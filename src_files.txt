

--- FILE: src/components/battle/LiveGameListModal.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/LiveGameListModal.tsx
// ==========================================

import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { X, Eye, Swords, Clock, User, ChevronDown, ChevronUp, Target } from 'lucide-react';
import { LiveMatch } from '../../types';
import { GameIcon } from '../common/GameIcon';

interface Props { onClose: () => void; onSpectate: (match: LiveMatch) => void; }

export const LiveGameListModal: React.FC<Props> = ({ onClose, onSpectate }) => {
  const { gameState, heroes } = useGameStore();
  const matches = gameState.liveMatches;

  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
  const [selectedMatchId, setSelectedMatchId] = useState<string | null>(null);

  useEffect(() => {
    const handleResize = () => {
      const mobile = window.innerWidth <= 768;
      setIsMobile(mobile);
      if (!mobile && !selectedMatchId && matches.length > 0) {
        setSelectedMatchId(matches[0].id);
      }
    };
    window.addEventListener('resize', handleResize);
    if (!isMobile && matches.length > 0 && !selectedMatchId) {
      setSelectedMatchId(matches[0].id);
    }
    return () => window.removeEventListener('resize', handleResize);
  }, [isMobile, matches, selectedMatchId]);

  const getHeroName = (id: string) => heroes.find(h => h.id === id)?.name || id;

  const formatDuration = (seconds: number) => {
    const totalSeconds = Math.floor(seconds); 
    const m = Math.floor(totalSeconds / 60);
    const s = totalSeconds % 60;
    return `${m}ë¶„ ${String(s).padStart(2, '0')}ì´ˆ`;
  };

  const MatchListItem = ({ match, isSelected, onClick }: { match: LiveMatch, isSelected: boolean, onClick: () => void }) => (
    <div 
      onClick={onClick}
      style={{ 
        padding: '12px 15px', 
        borderBottom: '1px solid #2c2c2f', 
        cursor: 'pointer',
        background: isSelected ? '#2a2a2e' : '#1c1c1f',
        borderLeft: isSelected ? '4px solid #58a6ff' : '4px solid transparent',
        transition: 'background 0.2s'
      }}
    >
      <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '4px', fontSize: '11px', color: '#888' }}>
        <span style={{ fontWeight:'bold', color:'#ccc' }}>{match.avgTier}</span>
        <span style={{ display:'flex', alignItems:'center', gap:'4px', fontFamily:'monospace' }}>
          <Clock size={10}/> {formatDuration(match.currentDuration)}
        </span>
      </div>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <div style={{ display:'flex', gap:'8px', alignItems:'center', width:'40%' }}>
          <span style={{ color: '#58a6ff', fontSize: '16px', fontWeight:'900' }}>{match.score.blue}</span>
          <span style={{ fontSize:'10px', color:'#58a6ff55', fontWeight:'bold' }}>BLUE</span>
        </div>
        <div style={{ fontSize: '11px', color: '#555', fontWeight:'bold' }}>VS</div>
        <div style={{ display:'flex', gap:'8px', alignItems:'center', width:'40%', justifyContent:'flex-end' }}>
          <span style={{ fontSize:'10px', color:'#e8405755', fontWeight:'bold' }}>RED</span>
          <span style={{ color: '#e84057', fontSize: '16px', fontWeight:'900' }}>{match.score.red}</span>
        </div>
      </div>
      {isMobile && (
        <div style={{ textAlign:'center', marginTop:'-5px', opacity:0.5 }}>
          {isSelected ? <ChevronUp size={14}/> : <ChevronDown size={14}/>}
        </div>
      )}
    </div>
  );

  const MatchDetailView = ({ match }: { match: LiveMatch | undefined }) => {
    if (!match) {
        return (
            <div style={{ padding: '50px', textAlign: 'center', color: '#666', fontSize:'13px' }}>
                ì„ íƒëœ ê²Œì„ì´ ì¢…ë£Œë˜ì—ˆê±°ë‚˜ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
            </div>
        );
    }

    return (
      <div style={{ background: '#0d1117', height:'100%', display:'flex', flexDirection:'column' }}>
        <div style={{ padding: '15px', textAlign: 'center', background: '#161b22', borderBottom: '1px solid #333', flexShrink:0 }}>
          <button 
            onClick={() => onSpectate(match)}
            style={{ 
              padding: '10px 40px', borderRadius: '8px', 
              background: '#238636', color: '#fff', border: 'none', 
              fontSize: '14px', fontWeight: 'bold', cursor: 'pointer',
              display: 'inline-flex', alignItems: 'center', gap: '8px',
              boxShadow: '0 4px 15px rgba(35,134,54,0.3)',
              transition: '0.2s'
            }}
          >
            <Eye size={18} /> ì‹¤ì‹œê°„ ê´€ì „ ì…ì¥
          </button>
        </div>

        <div style={{ padding: '15px', overflowY:'auto', flex:1 }}>
          <div style={{ display: 'grid', gridTemplateColumns: isMobile ? '1fr' : '1fr 1fr', gap: '15px' }}>
            <div>
              <h4 style={{ color: '#58a6ff', margin: '0 0 10px 0', fontSize:'12px', borderBottom: '2px solid #58a6ff', paddingBottom:'6px', display:'flex', justifyContent:'space-between' }}>
                <span>BLUE TEAM (ë‹¨í…Œ)</span>
                <span style={{ color:'#fff' }}>{match.score.blue}</span>
              </h4>
              {match.blueTeam && match.blueTeam.map((p, i) => (
                <PlayerCard key={i} p={p} color="#58a6ff" heroName={getHeroName(p.heroId)} />
              ))}
            </div>

            <div style={{ marginTop: isMobile ? '20px' : '0' }}>
              <h4 style={{ color: '#e84057', margin: '0 0 10px 0', fontSize:'12px', borderBottom: '2px solid #e84057', paddingBottom:'6px', textAlign: isMobile ? 'left' : 'right', display:'flex', flexDirection: isMobile ? 'row' : 'row-reverse', justifyContent:'space-between' }}>
                <span>RED TEAM (ì´ì¦ˆë§ˆí•œ)</span>
                <span style={{ color:'#fff' }}>{match.score.red}</span>
              </h4>
              {match.redTeam && match.redTeam.map((p, i) => (
                <PlayerCard key={i} p={p} color="#e84057" heroName={getHeroName(p.heroId)} alignRight={!isMobile} />
              ))}
            </div>
          </div>
        </div>
      </div>
    );
  };

  return (
    <div style={{
      position: 'fixed', top: 0, left: 0, width: '100%', height: '100%',
      backgroundColor: 'rgba(0,0,0,0.85)', zIndex: 9000,
      backdropFilter: 'blur(5px)',
      display: 'flex', justifyContent: 'center', 
      alignItems: 'center',
      padding: isMobile ? '0' : '40px'
    }}>

      <div className="panel" style={{ 
        width: isMobile ? '100%' : '1100px', 
        height: isMobile ? '100%' : '85vh', 
        background: '#1c1c1f', 
        border: isMobile ? 'none' : '1px solid #30363d', 
        display: 'flex', flexDirection: 'column', 
        borderRadius: isMobile ? '0' : '16px',
        boxShadow: '0 20px 60px rgba(0,0,0,0.9)',
        overflow: 'hidden'
      }}>

        <div style={{ 
          padding: '15px 20px', borderBottom: '1px solid #333', 
          display: 'flex', justifyContent: 'space-between', alignItems: 'center', 
          background:'#252528', zIndex: 50 
        }}>
          <h3 style={{ margin: 0, color:'#fff', display:'flex', alignItems:'center', gap:'10px', fontSize:'16px' }}>
            <Swords size={20} color="#f1c40f"/> ì§„í–‰ ì¤‘ì¸ ê²Œì„ ({matches.length})
          </h3>
          <button onClick={onClose} style={{ background:'none', border:'none', color:'#ccc', cursor:'pointer' }}><X size={24}/></button>
        </div>

        {isMobile ? (
          <div style={{ flex: 1, overflowY:'auto' }}>
            {matches.map(match => (
              <div key={match.id}>
                <MatchListItem 
                  match={match} 
                  isSelected={selectedMatchId === match.id} 
                  onClick={() => setSelectedMatchId(selectedMatchId === match.id ? null : match.id)} 
                />
                {selectedMatchId === match.id && (
                  <div style={{ height:'500px', borderBottom:'1px solid #333' }}>
                    <MatchDetailView match={match} />
                  </div>
                )}
              </div>
            ))}
            {matches.length === 0 && <div style={{padding:'40px', textAlign:'center', color:'#555'}}>ì§„í–‰ ì¤‘ì¸ ê²Œì„ì´ ì—†ìŠµë‹ˆë‹¤.</div>}
          </div>
        ) : (
          <div style={{ flex: 1, display: 'flex', overflow: 'hidden' }}>
            <div style={{ width: '300px', borderRight: '1px solid #333', overflowY: 'auto', background: '#161b22' }}>
              {matches.map(match => (
                <MatchListItem 
                  key={match.id} 
                  match={match} 
                  isSelected={selectedMatchId === match.id} 
                  onClick={() => setSelectedMatchId(match.id)} 
                />
              ))}
            </div>
            <div style={{ flex: 1, overflow: 'hidden' }}>
              <MatchDetailView match={matches.find(m => m.id === selectedMatchId)} />
            </div>
          </div>
        )}

      </div>
    </div>
  );
};

// [ìˆ˜ì •] PlayerCard: KDA, ê³¨ë“œ, CS, ë”œëŸ‰ í‘œì‹œ
const PlayerCard = ({ p, color, heroName, alignRight = false }: any) => {
  const isDead = p.currentHp <= 0;

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: alignRight ? 'row-reverse' : 'row',
      alignItems: 'center', 
      justifyContent: 'space-between',
      padding: '8px 12px', 
      marginBottom: '6px', 
      background: '#1c1c1f', 
      borderRadius: '6px', 
      borderLeft: alignRight ? 'none' : `3px solid ${color}`,
      borderRight: alignRight ? `3px solid ${color}` : 'none',
      boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
      opacity: isDead ? 0.6 : 1,
      filter: isDead ? 'grayscale(0.8)' : 'none'
    }}>
      {/* 1. ì˜ì›… ì •ë³´ */}
      <div style={{ display: 'flex', alignItems: 'center', gap: '10px', flexDirection: alignRight ? 'row-reverse' : 'row' }}>
        <div style={{ position:'relative' }}>
          <GameIcon id={p.heroId} size={38} shape="rounded" border={`1px solid ${color}44`} />
          <div style={{ position:'absolute', bottom:-3, right:-3, background:'#0d1117', color:'#fff', fontSize:'10px', fontWeight:'bold', padding:'0 3px', borderRadius:'3px', border:'1px solid #333' }}>
            {p.level}
          </div>
        </div>

        <div style={{ textAlign: alignRight ? 'right' : 'left' }}>
          <div style={{ color: '#fff', fontWeight:'bold', fontSize:'13px', lineHeight:'1.2' }}>{heroName}</div>
          <div style={{ color: '#8b949e', fontSize:'11px', display:'flex', alignItems:'center', gap:'3px', justifyContent: alignRight ? 'flex-end' : 'flex-start' }}>
            <User size={10}/> {p.name}
          </div>
        </div>
      </div>

      {/* 2. ìƒì„¸ ìŠ¤íƒ¯ (KDA / ê³¨ë“œ / CS / ë”œëŸ‰) */}
      <div style={{ textAlign: alignRight ? 'left' : 'right', display:'flex', flexDirection:'column', alignItems: alignRight ? 'flex-start' : 'flex-end', gap:'2px' }}>

        {/* KDA */}
        <div style={{ color: '#fff', fontWeight:'bold', fontSize:'13px', fontFamily:'monospace', letterSpacing:'-0.5px' }}>
          {p.kills}/<span style={{color:'#da3633'}}>{p.deaths}</span>/{p.assists}
        </div>

        {/* ê³¨ë“œ & CS */}
        <div style={{ fontSize: '10px', fontWeight:'bold', display:'flex', gap:'6px' }}>
          <span style={{ color: '#e89d40' }}>{(p.gold / 1000).toFixed(1)}k</span>
          <span style={{ color: '#444' }}>|</span>
          <span style={{ color: '#ccc' }}>{p.cs} CS</span>
        </div>

        {/* ë”œëŸ‰ (ë¹¨ê°„ìƒ‰) */}
        <div style={{ fontSize: '9px', fontWeight:'bold', color: '#ff6b6b', display:'flex', alignItems:'center', gap:'3px' }}>
          <Swords size={9}/> {(p.totalDamageDealt || 0).toLocaleString()}
        </div>

      </div>
    </div>
  );
};

--- FILE: src/components/battle/spectate/SmallComponents.tsx ---
// === FILE: /src/components/battle/spectate/SmallComponents.tsx ===

// ==========================================
// FILE PATH: /src/components/battle/spectate/SmallComponents.tsx
// ==========================================
import React from 'react';
import { X, Ban, Skull, Eye } from 'lucide-react'; 
import { GameIcon } from '../../common/GameIcon';

export const SpeedButton = ({ label, speed, currentSpeed, setSpeed }: any) => (
  <button 
    onClick={() => setSpeed(speed)} 
    style={{ 
      flex: 1, padding: '4px 0', 
      background: currentSpeed === speed ? '#58a6ff' : '#1c1c1f', 
      border: `1px solid ${currentSpeed === speed ? '#58a6ff' : '#333'}`, 
      borderRadius: '4px', color: currentSpeed === speed ? '#000' : '#888', 
      fontSize: '10px', fontWeight: '800', cursor: 'pointer', height: '24px'
    }}
  >
    {label}
  </button>
);

export const BanCard = ({ heroId, heroes, onClick }: any) => {
  const isValid = heroId && typeof heroId === 'string' && heroId.length > 0;
  return (
    <div 
      onClick={() => isValid && onClick && onClick(heroId)} 
      style={{ position: 'relative', width: '22px', height: '22px', borderRadius: '3px', overflow: 'hidden', background:'#111', border:'1px solid #333', cursor: isValid ? 'pointer' : 'default' }}
    >
      {isValid ? (
        <>
          <div style={{ filter: 'grayscale(100%) brightness(0.5)' }}><GameIcon id={heroId} size={22} shape="square" /></div>
          <div style={{ position: 'absolute', top: '50%', left: '50%', width: '140%', height: '2px', backgroundColor: '#da3633', transform: 'translate(-50%, -50%) rotate(45deg)' }} />
        </>
      ) : <div style={{ width:'100%', height:'100%', display:'flex', alignItems:'center', justifyContent:'center' }}><Ban size={10} color="#333"/></div>}
    </div>
  );
};

export const NeutralObjBar = ({ obj, label, color, icon }: any) => {
  if (!obj) return null;
  const isAlive = obj.status === 'ALIVE';
  const percent = isAlive ? (obj.hp / obj.maxHp) * 100 : 0;
  return (
    <div style={{ flex: 1, background: '#121214', padding: '6px 10px', borderRadius: '4px', border: '1px solid #333' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '3px', fontSize: '9px', fontWeight: 'bold' }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '4px', color: color }}>{icon} {label}</div>
        <span style={{ color: isAlive ? '#fff' : '#666' }}>{isAlive ? `${Math.ceil(obj.hp).toLocaleString()}` : 'SPAWN'}</span>
      </div>
      <div style={{ width: '100%', height: '3px', background: '#000', borderRadius: '1px', overflow: 'hidden' }}>
         <div style={{ width: `${percent}%`, height: '100%', background: isAlive ? color : '#333', transition: 'width 0.3s' }} />
      </div>
    </div>
  );
};

export const ObjectStatBox = ({ stats, color, side }: any) => {
  if (!stats) return null;
  const hpPercent = (stats.nexusHp / stats.maxNexusHp) * 100;
  const TowerIndicator = ({ label, brokenCount }: any) => (
    <div style={{ display: 'flex', alignItems: 'center', gap: '4px', fontSize: '9px', color:'#555' }}>
      <span style={{ width:'18px' }}>{label}</span>
      <div style={{ display: 'flex', gap: '1px' }}>
        {[1, 2, 3].map(tier => (
          <div key={tier} style={{ width: '6px', height: '6px', borderRadius: '1px', background: tier <= brokenCount ? '#222' : color, opacity: tier <= brokenCount ? 0.2 : 1 }} />
        ))}
      </div>
    </div>
  );
  return (
    <div style={{ background: '#121214', border: `1px solid ${color}22`, borderRadius: '6px', padding: '8px', flex: 1 }}>
      <div style={{ display:'flex', justifyContent:'space-between', alignItems:'flex-start' }}>
        <div>
          <div style={{ fontSize:'9px', color: color, fontWeight:'900', marginBottom:'2px' }}>{side}</div>
          <TowerIndicator label="TOP" brokenCount={stats.towers?.top || 0} />
          <TowerIndicator label="MID" brokenCount={stats.towers?.mid || 0} />
          <TowerIndicator label="BOT" brokenCount={stats.towers?.bot || 0} />
        </div>
        <div style={{ display:'flex', flexDirection:'column', gap:'4px', marginTop:'15px' }}>
           <div style={{ display:'flex', alignItems:'center', gap:'4px', fontSize:'11px', color:'#ccc', fontWeight:'bold' }}><Skull size={10} color="#7ee787"/> {stats.colossus || 0}</div>
           <div style={{ display:'flex', alignItems:'center', gap:'4px', fontSize:'11px', color:'#ccc', fontWeight:'bold' }}><Eye size={10} color="#a371f7"/> {stats.watcher || 0}</div>
        </div>
        <div style={{ textAlign:'right' }}>
           <div style={{ fontSize:'8px', color:'#666' }}>NEXUS</div>
           <div style={{ fontSize:'12px', fontWeight:'900', color: hpPercent < 30 ? '#da3633' : '#fff' }}>{Math.max(0, Math.ceil(stats.nexusHp)).toLocaleString()}</div>
           <div style={{ width:'50px', height:'3px', background:'#222', borderRadius:'1px', marginTop:'2px', overflow:'hidden' }}>
              <div style={{ width:`${hpPercent}%`, height:'100%', background: hpPercent < 30 ? '#da3633' : color }} />
           </div>
        </div>
      </div>
    </div>
  );
};

export const PlayerCard = ({ p, isSelected, onClick, heroName, teamColor }: any) => {
  if (!p) return null;
  const currentHp = p.currentHp || 0;
  const maxHp = p.maxHp || 1;
  const hpPercent = (currentHp / maxHp) * 100;
  const isDead = currentHp <= 0;
  
  return (
    <div onClick={onClick} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '4px 8px', background: isSelected ? `${teamColor}15` : '#161b22', borderRadius: '4px', border: isSelected ? `1px solid ${teamColor}` : '1px solid #30363d', marginBottom: '4px', cursor: 'pointer', height: '34px', opacity: isDead ? 0.6 : 1, filter: isDead ? 'grayscale(0.8)' : 'none', position: 'relative', overflow:'hidden' }}>
      <div style={{ position: 'relative', display:'flex', alignItems:'center', gap:'8px' }}>
        <GameIcon id={p.heroId || ''} size={28} shape="rounded" />
        <div>
          <div style={{ fontSize: '11px', fontWeight: 'bold', color: '#fff' }}>{heroName}</div>
          <div style={{ fontSize: '9px', color: '#8b949e' }}>{p.name}</div>
        </div>
      </div>
      <div style={{ textAlign: 'right' }}>
        <div style={{ fontSize: '11px', fontWeight: 'bold', color: '#fff' }}>{p.kills}/{p.deaths}/{p.assists}</div>
        <div style={{ fontSize: '9px', color: '#8b949e' }}>{((p.gold||0)/1000).toFixed(1)}k | {p.cs||0}cs</div>
      </div>
      <div style={{ position: 'absolute', bottom: 0, left: 0, width: '100%', height: '2px', background: 'rgba(0,0,0,0.3)' }}>
        <div style={{ width: `${hpPercent}%`, height: '100%', background: hpPercent < 30 ? '#da3633' : teamColor }} />
      </div>
    </div>
  );
};

export const DraftScreen = ({ match, heroes, onClose }: { match: any, heroes: any[], onClose: () => void }) => {
  // [Safety] matchê°€ nullì¼ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ê¸°ë³¸ê°’ ì„¤ì •
  const safeMatch = match || {};
  const blueTeam = safeMatch.blueTeam || [];
  const redTeam = safeMatch.redTeam || [];
  
  // draft ê°ì²´ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ì ìœ¼ë¡œ 0ìœ¼ë¡œ ì²˜ë¦¬ (Crash ë°©ì§€)
  const timer = Math.ceil(safeMatch.draft?.timer || 0);
  const turn = safeMatch.draft?.turnIndex || 0;
  
  const isPickPhase = turn >= 10;
  const isBanPhase = turn < 10;

  // í˜„ì¬ í”½ ìˆœì„œ ê³„ì‚° (í•˜ì´ë¼ì´íŠ¸ìš©)
  const pickIndex = isPickPhase ? turn - 10 : -1;
  const currentPickTeam = pickIndex >= 0 && pickIndex % 2 === 0 ? 'BLUE' : 'RED';
  const currentPickSlot = pickIndex >= 0 ? Math.floor(pickIndex / 2) : -1;

  const DraftPlayerSlot = ({ player, index, side }: { player: any, index: number, side: 'BLUE' | 'RED' }) => {
    if (!player) return <div style={{ height:'50px' }}></div>; // í”Œë ˆì´ì–´ ë°ì´í„° ì—†ìœ¼ë©´ ë¹ˆ ê³µê°„

    const isPicking = isPickPhase && currentPickTeam === side && currentPickSlot === index;
    const isPicked = !!player.heroId; // ì´ë¯¸ í”½ì´ ë˜ì—ˆëŠ”ì§€

    return (
      <div style={{
        marginBottom:'8px', 
        display:'flex', gap:'10px', alignItems:'center', 
        flexDirection: side === 'RED' ? 'row-reverse' : 'row',
        opacity: isPicked ? 1 : 0.5, // í”½ ì „ì—ëŠ” ë°˜íˆ¬ëª…
        transition: '0.2s',
        transform: isPicking ? 'scale(1.05)' : 'scale(1)'
      }}>
        <div style={{
          border: isPicking ? `2px solid ${side === 'BLUE' ? '#58a6ff' : '#e84057'}` : '1px solid #333',
          borderRadius: '12px',
          boxShadow: isPicking ? `0 0 15px ${side === 'BLUE' ? '#58a6ff' : '#e84057'}44` : 'none',
          position: 'relative'
        }}>
          {/* ì˜ì›… IDê°€ ì—†ìœ¼ë©´ ë¬¼ìŒí‘œ ë Œë”ë§ (GameIcon ë‚´ë¶€ ì²˜ë¦¬) */}
          <GameIcon id={player.heroId || ''} size={50} shape="square"/>
          
          {/* í”½ ì¤‘ì¼ ë•Œ ë¡œë”© ì¸ë””ì¼€ì´í„° */}
          {isPicking && (
            <div style={{ position:'absolute', inset:0, border:'2px solid #fff', borderRadius:'10px', animation:'pulse 1s infinite' }} />
          )}
        </div>
        <div style={{ textAlign: side === 'RED' ? 'right' : 'left' }}>
          <div style={{ fontSize:'12px', fontWeight:'bold', color: isPicking ? '#fff' : '#aaa' }}>{player.name}</div>
          <div style={{ fontSize:'10px', color: '#666' }}>{player.lane}</div>
        </div>
      </div>
    );
  };

  return (
    <div style={{ height:'100%', display:'flex', flexDirection:'column', alignItems:'center', justifyContent:'center', background:'#0d1117' }}>
      <button onClick={onClose} style={{ position:'absolute', right:'20px', top:'20px', background:'none', border:'none', color:'#fff', cursor:'pointer' }}><X size={30}/></button>
      
      <div style={{ marginBottom:'40px', textAlign:'center' }}>
        <h2 style={{ color:'#fff', fontSize:'24px', margin:'0 0 10px 0' }}>DRAFT PHASE</h2>
        <div style={{ fontSize:'14px', color:'#888', marginBottom:'5px' }}>
            {isBanPhase ? 'â›” ì±”í”¼ì–¸ ê¸ˆì§€ ì§„í–‰ ì¤‘...' : 'âš”ï¸ ì±”í”¼ì–¸ ì„ íƒ ì§„í–‰ ì¤‘...'}
        </div>
        <div style={{ fontSize:'32px', fontWeight:'900', color: timer <= 5 ? '#da3633' : '#fff' }}>{timer}</div>
      </div>

      <div style={{ display:'flex', width:'90%', maxWidth:'800px', justifyContent:'space-between' }}>
        {/* BLUE TEAM */}
        <div style={{ width:'40%', color:'#58a6ff' }}>
          <h3 style={{ borderBottom:'1px solid #58a6ff44', paddingBottom:'10px', marginBottom:'15px', margin:0 }}>BLUE TEAM</h3>
          {blueTeam.map((p: any, i: number) => <DraftPlayerSlot key={i} player={p} index={i} side="BLUE" />)}
        </div>

        {/* RED TEAM */}
        <div style={{ width:'40%', color:'#e84057', textAlign:'right' }}>
          <h3 style={{ borderBottom:'1px solid #e8405744', paddingBottom:'10px', marginBottom:'15px', margin:0 }}>RED TEAM</h3>
          {redTeam.map((p: any, i: number) => <DraftPlayerSlot key={i} player={p} index={i} side="RED" />)}
        </div>
      </div>
    </div>
  );
};


--- FILE: src/components/battle/spectate/GlobalLogPanel.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/spectate/GlobalLogPanel.tsx
// ==========================================
import React, { useMemo, useRef, useEffect } from 'react';

export const GlobalLogPanel = ({ logs, gameSpeed, formatTime }: any) => {
  const scrollRef = useRef<HTMLDivElement>(null);

  const visibleLogs = useMemo(() => {
    // 1ë°°ì†ì¼ ë•ŒëŠ” ëª¨ë“  ë¡œê·¸ í‘œì‹œ, ë°°ì†ì¼ ë•ŒëŠ” ì¤‘ìš” ë¡œê·¸ë§Œ í‘œì‹œ (ì„±ëŠ¥ ìµœì í™”)
    const filtered = logs.filter((log: any) => {
      if (gameSpeed === 1) return true; 
      return log.type !== 'DEBUG';      
    });
    return [...filtered].reverse().slice(0, 150); 
  }, [logs, gameSpeed]); 

  // ìƒˆ ë¡œê·¸ ì˜¤ë©´ ìŠ¤í¬ë¡¤ ë§¨ ìœ„ë¡œ
  useEffect(() => {
    if (scrollRef.current) scrollRef.current.scrollTop = 0;
  }, [visibleLogs.length]); 

  return (
    <div ref={scrollRef} style={{ flex: 1, overflowY: 'auto', padding: '10px', background: '#050505', maxHeight: '400px', display:'flex', flexDirection:'column', gap:'6px' }}>
      {visibleLogs.map((log: any, i: number) => {
        let badgeColor = '#888'; let badgeText = 'INFO'; 
        if (log.type === 'KILL') { badgeColor = '#ff4d4d'; badgeText = 'KILL'; }
        else if (log.type === 'DEBUG') { badgeColor = '#333'; badgeText = 'BTL'; } 
        else if (log.type === 'TOWER') { badgeColor = '#e89d40'; badgeText = 'OBJ'; }
        else if (log.type === 'START') { badgeColor = '#f1c40f'; badgeText = 'SYS'; }
        else if (log.type === 'DODGE') { badgeColor = '#7ee787'; badgeText = 'MISS'; }

        return (
          <div key={i} style={{ display: 'flex', gap: '8px', padding: '2px 0', borderBottom: '1px solid #1a1a1c', alignItems: 'flex-start' }}>
            <span style={{ fontSize: '10px', color: '#555', fontFamily: 'monospace', minWidth: '40px' }}>{formatTime(log.time)}</span>
            <div style={{ flex: 1 }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                <span style={{ fontSize: '8px', fontWeight: '900', color: badgeColor, background: `${badgeColor}15`, padding: '0px 4px', borderRadius: '2px', border: `1px solid ${badgeColor}33`, minWidth:'28px', textAlign:'center' }}>{badgeText}</span>
                <span style={{ fontSize: log.type === 'DEBUG' ? '11px' : '12px', color: log.type === 'DEBUG' ? '#aaa' : '#fff', lineHeight: '1.4' }}>{log.message}</span>
              </div>
            </div>
          </div>
        );
      })}
    </div>
  );
};

--- FILE: src/components/battle/spectate/PersonalLogView.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/spectate/PersonalLogView.tsx
// ==========================================
import React, { useMemo, useRef, useEffect } from 'react';
import { Activity } from 'lucide-react';

export const PersonalLogView = ({ logs, heroName, summonerName, formatTime }: any) => {
  const scrollRef = useRef<HTMLDivElement>(null);

  const filteredLogs = useMemo(() => {
    return logs.filter((log: any) => 
      log.message.includes(heroName) || log.message.includes(summonerName)
    ).reverse().slice(0, 50); 
  }, [logs, heroName, summonerName]);

  useEffect(() => {
    if (scrollRef.current) scrollRef.current.scrollTop = 0;
  }, [filteredLogs.length]);

  return (
    <div style={{ width: '100%', maxWidth: '450px', background: '#08080a', borderRadius: '8px', border: '1px solid #222', marginTop: '15px', overflow: 'hidden' }}>
      <div style={{ padding: '8px 12px', background: '#121214', borderBottom: '1px solid #222', display: 'flex', alignItems: 'center', gap: '6px' }}>
        <Activity size={12} color="#58a6ff" />
        <span style={{ fontSize: '11px', color: '#fff', fontWeight: 'bold' }}>{heroName} í™œë™ ë‚´ì—­</span>
      </div>
      <div ref={scrollRef} style={{ height: '200px', overflowY: 'auto', padding: '8px' }}>
        {filteredLogs.length > 0 ? filteredLogs.map((log: any, i: number) => (
          <div key={i} style={{ fontSize: '11px', padding: '5px 0', borderBottom: '1px solid #1a1a1c', display: 'flex', gap: '8px' }}>
            <span style={{ color: '#555', fontFamily: 'monospace', flexShrink: 0 }}>{formatTime(log.time)}</span>
            <span style={{ color: log.type === 'KILL' ? '#ff4d4d' : '#ccc', lineHeight: '1.4' }}>{log.message}</span>
          </div>
        )) : (
          <div style={{ padding: '40px 0', textAlign: 'center', color: '#444', fontSize: '11px' }}>ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>
        )}
      </div>
    </div>
  );
};

--- FILE: src/components/battle/spectate/UserDetailView.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/spectate/UserDetailView.tsx
// ==========================================
import React from 'react';
import { X } from 'lucide-react';
import { GameIcon } from '../../common/GameIcon';

export const UserDetailView = ({ player, heroName, viewingItem, setViewingItem }: any) => {
  const hpPercent = (player.currentHp / player.maxHp) * 100;
  const mpPercent = (player.currentMp / player.maxMp) * 100 || 0;

  const items = Array.isArray(player.items) ? player.items : [];

  const StatBadge = ({ color, label, val }: any) => (
    <span style={{fontSize:'10px', color: color, background: `${color}11`, padding:'2px 4px', borderRadius:'3px', border:`1px solid ${color}33`}}>
      {label} +{val}
    </span>
  );

  return (
    <div style={{ padding:'20px', display:'flex', flexDirection:'column', alignItems:'center' }}>
      <div style={{ display:'flex', alignItems:'center', gap:'15px', width:'100%', maxWidth:'450px', marginBottom:'20px' }}>
        <GameIcon id={player.heroId} size={54} />
        <div style={{ flex:1 }}>
          <div style={{ fontWeight:'bold', fontSize:'18px', color:'#fff' }}>{heroName}</div>
          <div style={{ color:'#8b949e', fontSize:'12px' }}>{player.name} (Lv.{player.level})</div>
        </div>
        <div style={{ textAlign:'right', minWidth:'120px' }}>

          <div style={{ fontSize:'10px', color:'#2ecc71', fontWeight:'900', marginBottom:'4px' }}>
            HP {Math.ceil(player.currentHp)}/{player.maxHp}
          </div>
          <div style={{ width:'100%', height:'6px', background:'#1a1a1c', borderRadius:'3px', overflow:'hidden', border:'1px solid #333' }}>
            <div style={{ width:`${hpPercent}%`, height:'100%', background: hpPercent < 30 ? '#da3633' : '#2ecc71' }} />
          </div>

          <div style={{ fontSize:'10px', color:'#3498db', fontWeight:'900', marginBottom:'4px', marginTop:'6px' }}>
            MP {Math.ceil(player.currentMp)}/{player.maxMp}
          </div>
          <div style={{ width:'100%', height:'6px', background:'#1a1a1c', borderRadius:'3px', overflow:'hidden', border:'1px solid #333' }}>
            <div style={{ width:`${mpPercent}%`, height:'100%', background: '#3498db' }} />
          </div>

          <div style={{ color:'#f1c40f', fontWeight:'bold', fontSize:'12px', marginTop:'6px' }}>ğŸ’° {Math.floor(player.gold).toLocaleString()} G</div>
        </div>
      </div>

      {viewingItem && (
        <div style={{ width:'100%', maxWidth:'450px', background:'#161b22', border:'1px solid #30363d', borderRadius:'8px', padding:'12px', marginBottom:'15px', position:'relative' }}>
          <button onClick={() => setViewingItem(null)} style={{ position:'absolute', right:'8px', top:'8px', background:'none', border:'none', color:'#666', cursor:'pointer' }}><X size={14}/></button>
          <div style={{ display:'flex', gap:'12px', alignItems:'center', marginBottom:'10px' }}>
            <GameIcon id={viewingItem.id} size={36} shape="square" />
            <div>
              <div style={{ fontWeight:'bold', color:'#fff', fontSize:'14px' }}>{viewingItem.name}</div>
              <div style={{ color:'#f1c40f', fontSize:'11px', fontWeight:'bold' }}>{viewingItem.cost} Gold</div>
            </div>
          </div>
          <div style={{ display:'flex', flexWrap:'wrap', gap:'8px', marginBottom:'10px' }}>
             {viewingItem.ad > 0 && <StatBadge color="#ff6b6b" label="AD" val={viewingItem.ad} />}
             {viewingItem.ap > 0 && <StatBadge color="#a371f7" label="AP" val={viewingItem.ap} />}
             {viewingItem.hp > 0 && <StatBadge color="#7ee787" label="HP" val={viewingItem.hp} />}
             {viewingItem.armor > 0 && <StatBadge color="#58a6ff" label="DEF" val={viewingItem.armor} />}
             {viewingItem.crit > 0 && <StatBadge color="#e89d40" label="CRI" val={viewingItem.crit + '%'} />}
             {viewingItem.speed > 0 && <StatBadge color="#fff" label="SPD" val={viewingItem.speed} />}
          </div>
          <div style={{ fontSize:'11px', color:'#ccc' }}>{viewingItem.description || "ì„¤ëª…ì´ ì—†ìŠµë‹ˆë‹¤."}</div>
        </div>
      )}

      <div style={{ display:'flex', gap:'6px', justifyContent:'center', marginBottom:'20px' }}>
        {([0,1,2,3,4,5]).map(i => (
          <div key={i} onClick={() => items[i] && setViewingItem(items[i])} style={{ width:'42px', height:'42px', background:'#0d1117', border:'1px solid #333', borderRadius:'4px', cursor:'pointer', overflow:'hidden', display:'flex', alignItems:'center', justifyContent:'center' }}>
            {items[i] ? <GameIcon id={items[i].id} size={40} shape="square" /> : null}
          </div>
        ))}
      </div>
    </div>
  );
};

--- FILE: src/components/battle/spectate/DraftScreen.tsx ---
import React from 'react';
import { X, Shield, Swords, Zap, Crosshair, Skull } from 'lucide-react';
import { GameIcon } from '../../common/GameIcon';
import { SpeedButton, BanCard } from './SpectateUI';

export const DraftScreen: React.FC<any> = ({ match, heroes, onClose, setSpeed, gameState, onBanClick }) => {
  const { blueTeam, redTeam, draft, bans } = match;
  const timer = Math.ceil(draft?.timer || 0);
  const turn = draft?.turnIndex || 0;
  const isBanPhase = turn < 10;

  // ë°´ ëª©ë¡ ì±„ìš°ê¸°
  const fillBans = (arr: string[]) => {
    const res = [...(arr || [])];
    while(res.length < 5) res.push('');
    return res;
  };
  const blueBans = fillBans(bans?.blue);
  const redBans = fillBans(bans?.red);

  // í”½ ìˆœì„œ (ìŠ¤ë„¤ì´í¬)
  const PICK_ORDER = [
    {team: 0, slot: 0}, {team: 1, slot: 0}, {team: 1, slot: 1}, {team: 0, slot: 1}, 
    {team: 0, slot: 2}, {team: 1, slot: 2}, {team: 1, slot: 3}, {team: 0, slot: 3}, 
    {team: 0, slot: 4}, {team: 1, slot: 4}
  ];

  let activeTeam = -1; 
  let activeSlot = -1; 

  if (!isBanPhase && (turn - 10) < PICK_ORDER.length) {
    const order = PICK_ORDER[turn - 10];
    activeTeam = order.team;
    activeSlot = order.slot;
  }

  const activeBanSlot = isBanPhase ? Math.floor(turn / 2) : -1;
  const activeBanTeam = isBanPhase ? (turn % 2) : -1;
  const getHeroName = (id: string) => heroes.find((h: any) => h.id === id)?.name || '';

  // [í•µì‹¬] ê²Œì„ ì»¨ì…‰ì— ë§ëŠ” í¬ì§€ì…˜ ëª…ì¹­ ë° ì•„ì´ì½˜ ë³€í™˜
  const getRoleDisplay = (lane: string) => {
    switch(lane) {
      case 'TOP': return { label: 'ì§‘í–‰ê´€', icon: <Shield size={10}/>, color: '#e74c3c' };
      case 'JUNGLE': return { label: 'ì¶”ì ì', icon: <Swords size={10}/>, color: '#2ecc71' };
      case 'MID': return { label: 'ì„ ì§€ì', icon: <Zap size={10}/>, color: '#3498db' };
      case 'BOT': return { label: 'ì‹ ì‚´ì', icon: <Crosshair size={10}/>, color: '#f1c40f' };
      default: return { label: 'ìˆ˜í˜¸ê¸°ì‚¬', icon: <Skull size={10}/>, color: '#9b59b6' };
    }
  };

  // ëª¨ë°”ì¼ ìµœì í™” í”½ ìŠ¬ë¡¯
  const PickSlot = ({ player, side, isActive }: any) => {
    const roleInfo = getRoleDisplay(player.lane);
    const borderColor = side === 'BLUE' ? '#58a6ff' : '#e84057';
    
    return (
      <div style={{ 
        display:'flex', alignItems:'center', gap:'8px', 
        background: isActive ? '#1f242e' : '#161b22', 
        border: isActive ? `1px solid ${borderColor}` : '1px solid #333',
        padding:'6px', borderRadius:'6px', 
        height: '48px', overflow:'hidden', position:'relative',
        marginBottom: '6px'
      }}>
        {/* ì˜ì›… ì•„ì´ì½˜ */}
        <div style={{ position:'relative', width:'36px', height:'36px', flexShrink:0 }}>
          {player.heroId ? (
            <GameIcon id={player.heroId} size={36} shape="rounded" />
          ) : (
            <div style={{ width:'100%', height:'100%', background:'#222', borderRadius:'8px', border:'1px dashed #444' }} />
          )}
          {isActive && (
            <div style={{ position:'absolute', inset:0, border:`2px solid ${borderColor}`, borderRadius:'8px', animation:'pulse 1s infinite' }} />
          )}
        </div>

        {/* ì •ë³´ í…ìŠ¤íŠ¸ */}
        <div style={{ flex:1, minWidth:0, display:'flex', flexDirection:'column', justifyContent:'center' }}>
          {/* ì˜ì›… ì´ë¦„ / ìƒíƒœ */}
          <div style={{ fontSize:'12px', fontWeight:'bold', color: player.heroId ? '#fff' : '#666', whiteSpace:'nowrap', overflow:'hidden', textOverflow:'ellipsis' }}>
            {player.heroId ? getHeroName(player.heroId) : (isActive ? 'ì„ íƒ ì¤‘...' : 'ëŒ€ê¸° ì¤‘')}
          </div>
          
          {/* ìœ ì € ë‹‰ë„¤ì„ (ìš”ì²­í•˜ì‹  ë¶€ë¶„) */}
          <div style={{ fontSize:'10px', color:'#ccc', whiteSpace:'nowrap', overflow:'hidden', textOverflow:'ellipsis', marginTop:'1px' }}>
            {player.name}
          </div>

          {/* í¬ì§€ì…˜ (ê²Œì„ ì»¨ì…‰ ì ìš©) */}
          <div style={{ fontSize:'9px', color: roleInfo.color, display:'flex', alignItems:'center', gap:'3px', marginTop:'2px', fontWeight:'bold' }}>
            {roleInfo.icon} {roleInfo.label}
          </div>
        </div>
      </div>
    );
  };

  return (
    <div style={{ 
      position: 'fixed', inset: 0, background: '#0f0f0f', zIndex: 10000,
      display: 'flex', flexDirection: 'column'
    }}>
      
      {/* 1. ìƒë‹¨ ì»¨íŠ¸ë¡¤ & íƒ€ì´ë¨¸ */}
      <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', padding:'10px', background:'#1a1a1a', borderBottom:'1px solid #333' }}>
        <div style={{ display:'flex', gap:'4px' }}>
           {[1, 10, 60].map(s => <SpeedButton key={s} label={`${s}x`} speed={s} currentSpeed={gameState.gameSpeed} setSpeed={setSpeed} />)}
        </div>
        <div style={{ textAlign:'center' }}>
          <div style={{ fontSize:'24px', fontWeight:'900', color: timer <= 5 ? '#da3633' : '#fff' }}>{timer}</div>
          <div style={{ fontSize:'10px', color: isBanPhase ? '#e84057' : '#58a6ff', fontWeight:'bold' }}>
            {isBanPhase ? 'ê¸ˆì§€ ë‹¨ê³„ (BAN)' : 'ì„ íƒ ë‹¨ê³„ (PICK)'}
          </div>
        </div>
        <button onClick={onClose} style={{ background:'none', border:'none', color:'#888', cursor:'pointer' }}><X size={24}/></button>
      </div>

      {/* 2. ë°´ ì¹´ë“œ ì˜ì—­ */}
      <div style={{ display:'flex', justifyContent:'space-between', padding:'10px 15px', background:'#1a1a1a', borderBottom:'1px solid #333' }}>
        <div style={{ display:'flex', gap:'4px' }}>
          {blueBans.map((id, i) => (
            <BanCard key={i} heroId={id} heroes={heroes} isActive={isBanPhase && activeBanTeam === 0 && activeBanSlot === i} onClick={onBanClick} />
          ))}
        </div>
        <div style={{ display:'flex', gap:'4px' }}>
          {redBans.map((id, i) => (
            <BanCard key={i} heroId={id} heroes={heroes} isActive={isBanPhase && activeBanTeam === 1 && activeBanSlot === i} onClick={onBanClick} />
          ))}
        </div>
      </div>

      {/* 3. í”½ ë¦¬ìŠ¤íŠ¸ (ì¢Œìš° 2ë¶„í• , ìŠ¤í¬ë¡¤ ê°€ëŠ¥) */}
      <div style={{ flex: 1, overflowY:'auto', padding:'10px', display:'flex', gap:'10px' }}>
        {/* BLUE TEAM */}
        <div style={{ flex: 1, display:'flex', flexDirection:'column' }}>
          <div style={{ textAlign:'center', fontSize:'12px', fontWeight:'bold', color:'#58a6ff', marginBottom:'8px', borderBottom:'2px solid #58a6ff', paddingBottom:'4px' }}>BLUE TEAM</div>
          {blueTeam.map((p:any, i:number) => (
            <PickSlot key={i} player={p} side="BLUE" isActive={!isBanPhase && activeTeam === 0 && activeSlot === i} />
          ))}
        </div>

        {/* RED TEAM */}
        <div style={{ flex: 1, display:'flex', flexDirection:'column' }}>
          <div style={{ textAlign:'center', fontSize:'12px', fontWeight:'bold', color:'#e84057', marginBottom:'8px', borderBottom:'2px solid #e84057', paddingBottom:'4px' }}>RED TEAM</div>
          {redTeam.map((p:any, i:number) => (
            <PickSlot key={i} player={p} side="RED" isActive={!isBanPhase && activeTeam === 1 && activeSlot === i} />
          ))}
        </div>
      </div>

      <style>{`
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
      `}</style>
    </div>
  );
};


--- FILE: src/components/battle/spectate/SpectateMap.tsx ---
import React from 'react';
import { useGameStore } from '../../../store/useGameStore';

export const SpectateMap: React.FC = () => {
  const { gameState } = useGameStore();
  
  // ì—…ë¡œë“œëœ ë§µ ì´ë¯¸ì§€ê°€ ìˆëŠ”ì§€ í™•ì¸ ('map_bg' í‚¤ ì‚¬ìš©)
  const mapImage = gameState.customImages?.['map_bg'];

  return (
    <div style={{
      position: 'absolute',
      inset: 0,
      background: '#0a0f0a', // ê¸°ë³¸ ë°°ê²½ìƒ‰ (ì´ë¯¸ì§€ ì—†ì„ ë•Œ)
      overflow: 'hidden',
      zIndex: 0
    }}>
      {/* 1. ë§µ ë°°ê²½ ì´ë¯¸ì§€ ë ˆì´ì–´ */}
      {mapImage ? (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundImage: `url(${mapImage})`,
          backgroundSize: '100% 100%', // ë§µì„ ê½‰ ì±„ì›€
          backgroundPosition: 'center',
          backgroundRepeat: 'no-repeat',
          opacity: 0.8, // ìœ ë‹› ì‹œì¸ì„±ì„ ìœ„í•´ ì•½ê°„ ì–´ë‘¡ê²Œ
          filter: 'contrast(1.1) saturate(1.1)' // ê²Œì„ ëŠë‚Œ ë³´ì •
        }} />
      ) : (
        /* ì´ë¯¸ì§€ê°€ ì—†ì„ ë•Œ ë³´ì—¬ì¤„ ê¸°ë³¸ ê²©ì íŒ¨í„´ */
        <div style={{
          width: '100%', height: '100%',
          backgroundImage: 'linear-gradient(#1a1a1c 1px, transparent 1px), linear-gradient(90deg, #1a1a1c 1px, transparent 1px)',
          backgroundSize: '5% 5%',
          opacity: 0.3
        }} />
      )}

      {/* 2. ë¼ì¸ ê°€ì´ë“œ (ì´ë¯¸ì§€ê°€ ìˆì–´ë„ í¬ë¯¸í•˜ê²Œ í‘œì‹œí•˜ì—¬ ê²½ë¡œ í™•ì¸) */}
      <svg width="100%" height="100%" viewBox="0 0 100 100" style={{ position: 'absolute', top: 0, left: 0, opacity: mapImage ? 0.15 : 0.4, pointerEvents:'none' }}>
        <defs>
          <linearGradient id="riverGrad" x1="0%" y1="100%" x2="100%" y2="0%">
            <stop offset="0%" stopColor="#3498db" stopOpacity="0" />
            <stop offset="50%" stopColor="#3498db" stopOpacity="0.5" />
            <stop offset="100%" stopColor="#3498db" stopOpacity="0" />
          </linearGradient>
        </defs>
        
        {/* ê°• (River) */}
        <line x1="0" y1="100" x2="100" y2="0" stroke="url(#riverGrad)" strokeWidth="8" />

        {/* ë¼ì¸ ê²½ë¡œ */}
        <g stroke="rgba(255,255,255,0.3)" strokeWidth="0.5" fill="none" strokeDasharray="2,2">
          {/* TOP */}
          <path d="M 5 95 L 5 20 Q 5 5 20 5 L 95 5" />
          {/* MID */}
          <line x1="5" y1="95" x2="95" y2="5" /> 
          {/* BOT */}
          <path d="M 5 95 L 80 95 Q 95 95 95 80 L 95 5" />
        </g>

        {/* ë³¸ì§„ êµ¬ì—­ í‘œì‹œ */}
        <circle cx="5" cy="95" r="3" fill="#58a6ff" fillOpacity="0.2" />
        <circle cx="95" cy="5" r="3" fill="#e84057" fillOpacity="0.2" />
      </svg>
    </div>
  );
};


--- FILE: src/components/battle/spectate/SpectateUI.tsx ---
import React from 'react';
import { GameIcon } from '../../common/GameIcon';
import { Ban, Skull, Eye, Shield, Sword, Target, Zap, Crosshair } from 'lucide-react';

export const SpeedButton = ({ label, speed, currentSpeed, setSpeed }: any) => (
  <button 
    onClick={() => setSpeed(speed)} 
    style={{ 
      flex: 1, padding: '6px 0', 
      background: currentSpeed === speed ? '#00b894' : '#2d3436', 
      border: `1px solid ${currentSpeed === speed ? '#00b894' : '#444'}`, 
      borderRadius: '4px', color: '#fff', 
      fontSize: '10px', fontWeight: 'bold', cursor: 'pointer', height: '28px'
    }}
  >
    {label}
  </button>
);

export const BanCard = ({ heroId, heroes, onClick }: any) => {
  return (
    <div 
      onClick={() => heroId && onClick && onClick(heroId)}
      style={{ 
        width: '30px', height: '30px', borderRadius: '4px', overflow: 'hidden', 
        background:'#1e1e1e', border: '1px solid #444', position:'relative',
        display:'flex', alignItems:'center', justifyContent:'center',
        flexShrink: 0
      }}
    >
      {heroId ? (
        <>
          <div style={{ filter: 'grayscale(100%) opacity(0.7)' }}><GameIcon id={heroId} size={30} shape="square" /></div>
          <div style={{ position: 'absolute', width: '140%', height: '2px', backgroundColor: '#d63031', transform: 'rotate(45deg)' }} />
        </>
      ) : <Ban size={12} color="#444"/>}
    </div>
  );
};

const RoleIcon = ({ lane }: { lane: string }) => {
  switch(lane) {
    case 'TOP': return <Shield size={9} color="#e74c3c"/>;
    case 'JUNGLE': return <Sword size={9} color="#2ecc71"/>;
    case 'MID': return <Zap size={9} color="#3498db"/>;
    case 'BOT': return <Crosshair size={9} color="#f1c40f"/>;
    default: return <Skull size={9} color="#9b59b6"/>;
  }
};

export const PlayerCard = ({ p, isSelected, onClick, heroName, teamColor }: any) => {
  if (!p) return null;

  const isDead = p.respawnTimer > 0;
  const kda = `${p.kills}/${p.deaths}/${p.assists}`;
  const gold = `${(p.gold / 1000).toFixed(1)}k`;
  const dmg = p.totalDamageDealt > 1000 
    ? `${(p.totalDamageDealt / 1000).toFixed(1)}k` 
    : p.totalDamageDealt;

  return (
    <div onClick={onClick} style={{ 
      display: 'flex', alignItems: 'center', 
      background: '#1e1e1e', 
      borderRadius: '4px', 
      border: isSelected ? `1px solid ${teamColor}` : '1px solid #333',
      borderLeft: `3px solid ${teamColor}`, 
      marginBottom: '6px', 
      padding: '4px 6px',
      cursor: 'pointer', 
      minHeight: '56px', 
      flexShrink: 0,
      opacity: isDead ? 0.5 : 1,
      position: 'relative',
      overflow: 'hidden',
      boxShadow: '0 2px 4px rgba(0,0,0,0.3)'
    }}>
      <div style={{ position:'relative', marginRight:'8px', flexShrink: 0 }}>
        <GameIcon id={p.heroId} size={42} shape="rounded" />
        <div style={{ position:'absolute', bottom:-2, right:-2, background:'#000', color:'#fff', fontSize:'10px', fontWeight:'bold', padding:'0 3px', borderRadius:'3px', border:'1px solid #555' }}>
          {p.level}
        </div>
      </div>

      <div style={{ flex: 1, display:'flex', flexDirection:'column', justifyContent:'center', minWidth: 0, gap:'1px' }}>
        <div style={{ fontSize: '12px', fontWeight: 'bold', color: '#fff', whiteSpace:'nowrap', overflow:'hidden', textOverflow:'ellipsis' }}>
          {heroName}
        </div>
        <div style={{ fontSize: '10px', color: '#ccc', whiteSpace:'nowrap', overflow:'hidden', textOverflow:'ellipsis' }}>
          {p.name}
        </div>
        <div style={{ display:'flex', alignItems:'center', gap:'2px', fontSize:'9px', color:'#888', fontWeight:'bold' }}>
          <RoleIcon lane={p.lane} /> {p.lane}
        </div>
      </div>

      <div style={{ textAlign: 'right', marginLeft:'4px', display:'flex', flexDirection:'column', justifyContent:'center', minWidth:'55px', gap:'1px' }}>
        <div style={{ fontSize: '11px', color: '#fff', fontWeight:'bold', letterSpacing:'-0.5px' }}>
          {kda}
        </div>
        <div style={{ fontSize: '10px', color: '#e89d40', fontWeight:'bold' }}>
          {gold}
        </div>
        <div style={{ display:'flex', alignItems:'center', justifyContent:'flex-end', gap:'4px', fontSize:'9px', color:'#aaa', marginTop:'2px' }}>
          <div style={{ display:'flex', alignItems:'center', gap:'1px' }} title="CS">
            <Target size={8} color="#ccc"/> {p.cs}
          </div>
          <div style={{ display:'flex', alignItems:'center', gap:'1px' }} title="ë”œëŸ‰">
            <Sword size={8} color="#ff7675"/> {dmg}
          </div>
        </div>
      </div>

      {isDead && (
        <div style={{ position:'absolute', inset:0, background:'rgba(0,0,0,0.6)', display:'flex', alignItems:'center', justifyContent:'center', zIndex:10 }}>
          <span style={{ color:'#ff7675', fontWeight:'900', fontSize:'18px', textShadow:'0 0 3px #000' }}>{Math.ceil(p.respawnTimer)}</span>
        </div>
      )}
      
      <div style={{ position:'absolute', bottom:0, left:0, width:'100%', height:'2px', background:'#333' }}>
        <div style={{ width: `${(p.currentHp/p.maxHp)*100}%`, height:'100%', background: teamColor }} />
      </div>
    </div>
  );
};

export const ObjectStatBox = ({ stats, color, godName }: any) => {
  if (!stats) return null;
  const hpPercent = (stats.nexusHp / stats.maxNexusHp) * 100;
  
  // [ìˆ˜ì •] íƒ€ì›Œ í‘œì‹œ ìˆœì„œ ë³€ê²½: [3ì°¨] [2ì°¨] [1ì°¨] ìˆœì„œë¡œ ë°°ì¹˜
  const TowerLane = ({ label, brokenCount }: { label: string, brokenCount: number }) => (
    <div style={{ display:'flex', alignItems:'center', gap:'2px', fontSize:'9px', color:'#888', marginBottom:'2px' }}>
      <span style={{ width:'20px', fontWeight:'bold' }}>{label}</span>
      {/* 3ì°¨ -> 2ì°¨ -> 1ì°¨ ìˆœì„œë¡œ ë Œë”ë§ (ì•ˆìª½ë¶€í„° ë°”ê¹¥ìª½ìœ¼ë¡œ) */}
      {[3, 2, 1].map(tier => {
        const isAlive = brokenCount < tier;
        return (
          <div key={tier} style={{
            width: '8px', height: '8px', borderRadius: '2px',
            background: isAlive ? color : '#222',
            border: isAlive ? 'none' : '1px solid #444',
            opacity: isAlive ? 1 : 0.5
          }} title={`${tier}ì°¨ íƒ€ì›Œ ${isAlive ? 'ìƒì¡´' : 'íŒŒê´´ë¨'}`} />
        );
      })}
    </div>
  );

  return (
    <div style={{ background: '#1e1e1e', border: `1px solid ${color}44`, borderRadius: '4px', padding: '8px', flex: 1 }}>
      <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:'4px' }}>
        <span style={{ color: color, fontWeight:'bold', fontSize:'11px', whiteSpace:'nowrap' }}>
          {godName}ì˜ ìˆ˜í˜¸ì
        </span>
        <span style={{ color: '#fff', fontSize:'10px', fontWeight:'bold' }}>
          {Math.ceil(stats.nexusHp).toLocaleString()}
        </span>
      </div>
      
      <div style={{ width:'100%', height:'4px', background:'#333', borderRadius:'2px', overflow:'hidden', marginBottom:'8px' }}>
         <div style={{ width:`${hpPercent}%`, height:'100%', background: color }} />
      </div>

      <div style={{ display:'flex', justifyContent:'space-between' }}>
        <div style={{ display:'flex', flexDirection:'column' }}>
          <TowerLane label="TOP" brokenCount={stats.towers?.top || 0} />
          <TowerLane label="MID" brokenCount={stats.towers?.mid || 0} />
          <TowerLane label="BOT" brokenCount={stats.towers?.bot || 0} />
        </div>

        <div style={{ display:'flex', flexDirection:'column', alignItems:'flex-end', justifyContent:'center', gap:'4px' }}>
          <div style={{ display:'flex', alignItems:'center', gap:'4px', fontSize:'10px', color:'#ccc' }} title="ì²˜ì¹˜í•œ ê±°ì‹ ë³‘">
            <Skull size={10} color="#7ee787"/> {stats.colossus}
          </div>
          <div style={{ display:'flex', alignItems:'center', gap:'4px', fontSize:'10px', color:'#ccc' }} title="ì²˜ì¹˜í•œ ì£¼ì‹œì">
            <Eye size={10} color="#a371f7"/> {stats.watcher}
          </div>
        </div>
      </div>
    </div>
  );
};

export const NeutralObjPanel = ({ colossus, watcher }: any) => {
  const ObjItem = ({ obj, name, color }: any) => {
    if(!obj) return null;
    const isAlive = obj.status === 'ALIVE';
    return (
      <div style={{ flex:1, background: isAlive ? `${color}22` : '#1e1e1e', padding:'6px', borderRadius:'4px', border: `1px solid ${isAlive ? color : '#333'}`, display:'flex', justifyContent:'space-between', alignItems:'center' }}>
        <span style={{ color: isAlive ? '#fff' : '#777', fontWeight:'bold', fontSize:'11px' }}>{name}</span>
        <span style={{ color: isAlive ? color : '#555', fontSize:'10px', fontWeight:'bold' }}>
          {isAlive ? 'ALIVE' : 'DEAD'}
        </span>
      </div>
    );
  };
  return (
    <div style={{ display:'flex', gap:'6px', padding:'8px 10px', background:'#121212', borderTop:'1px solid #222', flexShrink: 0 }}>
      <ObjItem obj={colossus} name="ê±°ì‹ ë³‘" color="#7ee787" />
      <ObjItem obj={watcher} name="ì£¼ì‹œì" color="#a371f7" />
    </div>
  );
};


--- FILE: src/components/battle/spectate/map/MapConstants.ts ---
// ==========================================
// FILE PATH: /src/components/battle/spectate/map/MapConstants.ts
// ==========================================

export const TOWER_COORDS = {
  BLUE: {
    TOP: [
      {x: 8, y: 35}, 
      {x: 8, y: 55}, 
      {x: 10, y: 75}
    ],
    MID: [
      {x: 40, y: 60}, 
      {x: 30, y: 70}, 
      {x: 22, y: 78}
    ],
    BOT: [
      {x: 75, y: 92}, 
      {x: 50, y: 90}, 
      {x: 25, y: 88}
    ],
    NEXUS: {x: 12, y: 88}
  },
  RED: {
    // [ì›ë³µ] íƒ€ì›Œ ì¢Œí‘œë¥¼ ì›ë˜ëŒ€ë¡œ ë˜ëŒë¦½ë‹ˆë‹¤.
    TOP: [
      {x: 45, y: 10}, 
      {x: 65, y: 12}, 
      {x: 80, y: 15}
    ],
    MID: [
      {x: 60, y: 40}, 
      {x: 70, y: 30}, 
      {x: 78, y: 22}
    ],
    BOT: [
      {x: 92, y: 65}, 
      {x: 92, y: 45}, 
      {x: 88, y: 25}
    ],
    NEXUS: {x: 88, y: 12}
  }
};


--- FILE: src/components/battle/spectate/map/MapObjects.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/spectate/map/MapObjects.tsx
// ==========================================
import React from 'react';
import { Skull, Zap, Shield } from 'lucide-react';
import { POI } from '../../../../engine/data/MapData';
import { TOWER_COORDS } from './MapConstants';

// --- íƒ€ì›Œ ë Œë”ë§ ---
export const TowerRender = ({ side, lane, tier, stats }: any) => {
  const isBlue = side === 'BLUE';
  const teamStats = isBlue ? stats.blue : stats.red;
  const brokenCount = teamStats.towers[lane.toLowerCase()];
  const isBroken = brokenCount >= tier;

  // [UI ì¶”ê°€] í˜„ì¬ í™œì„± íƒ€ì›Œì¸ ê²½ìš° ì²´ë ¥ë°” í‘œì‹œ
  const isActive = brokenCount === tier - 1;
  const currentHp = teamStats.laneHealth ? teamStats.laneHealth[lane.toLowerCase()] : 0;
  
  // ìµœëŒ€ ì²´ë ¥ì€ fieldSettingsì—ì„œ ê°€ì ¸ì™€ì•¼ ì •í™•í•˜ì§€ë§Œ, ì¼ë‹¨ Tierë³„ ì¶”ì •ì¹˜ ì‚¬ìš©
  const maxHpMap = { 1: 10000, 2: 15000, 3: 20000 };
  const maxHp = (maxHpMap as any)[tier] || 10000;
  const hpPercent = isActive ? (currentHp / maxHp) * 100 : 0;

  const laneCoords = isBlue ? TOWER_COORDS.BLUE : TOWER_COORDS.RED;
  const pos = (laneCoords as any)[lane][tier - 1];
  const color = isBlue ? '#58a6ff' : '#e84057';

  if (isBroken) {
    return (
      <div style={{
        position: 'absolute', left: `${pos.x}%`, top: `${pos.y}%`,
        transform: 'translate(-50%, -50%)',
        width: '12px', height: '12px',
        background: 'rgba(0,0,0,0.5)', border: '1px dashed #555', borderRadius: '50%',
        zIndex: 2, display: 'flex', alignItems: 'center', justifyContent: 'center'
      }}>
        <div style={{width:'4px', height:'4px', background:'#333', borderRadius:'50%'}}/>
      </div>
    );
  }

  return (
    <div style={{
      position: 'absolute', left: `${pos.x}%`, top: `${pos.y}%`,
      transform: 'translate(-50%, -50%)',
      display: 'flex', flexDirection: 'column', alignItems: 'center', zIndex: 5
    }}>
      <div style={{
        width: '18px', height: '18px', background: '#161b22', border: `2px solid ${color}`,
        borderRadius: '4px', display: 'flex', alignItems: 'center', justifyContent: 'center',
        boxShadow: `0 0 8px ${color}66`
      }}>
        <Shield size={10} color={color} fill={color} />
      </div>
      
      {/* ì²´ë ¥ë°” (í™œì„± íƒ€ì›Œë§Œ í‘œì‹œ) */}
      {isActive && (
        <div style={{ width: '24px', height: '3px', background: '#000', marginTop: '2px', borderRadius: '2px', overflow: 'hidden' }}>
            <div style={{ width: `${Math.max(0, hpPercent)}%`, height: '100%', background: hpPercent < 30 ? '#da3633' : color, transition:'width 0.2s' }} />
        </div>
      )}
    </div>
  );
};

// --- ë„¥ì„œìŠ¤ ë Œë”ë§ ---
export const NexusRender = ({ side, stats }: any) => {
  const isBlue = side === 'BLUE';
  const pos = isBlue ? TOWER_COORDS.BLUE.NEXUS : TOWER_COORDS.RED.NEXUS;
  const teamStats = isBlue ? stats.blue : stats.red;
  const color = isBlue ? '#58a6ff' : '#e84057';
  
  const currentHp = Math.max(0, teamStats.nexusHp);
  const maxHp = Math.max(1, teamStats.maxNexusHp);
  const hpPercent = (currentHp / maxHp) * 100;

  return (
    <div style={{
      position: 'absolute', left: `${pos.x}%`, top: `${pos.y}%`,
      transform: 'translate(-50%, -50%)', zIndex: 6,
      display: 'flex', flexDirection: 'column', alignItems: 'center'
    }}>
      <div style={{
        width: '36px', height: '36px', background: '#161b22', border: `3px solid ${color}`,
        borderRadius: '50%', display: 'flex', alignItems: 'center', justifyContent: 'center',
        boxShadow: `0 0 20px ${color}44`, position: 'relative'
      }}>
        <Zap size={18} color={color} fill={color} />
        {hpPercent <= 0 && (
           <div style={{ position:'absolute', inset:0, background:'#000000aa', borderRadius:'50%', display:'flex', alignItems:'center', justifyContent:'center' }}>
             <Skull size={20} color="#fff"/>
           </div>
        )}
      </div>
      <div style={{ marginTop:'4px', width:'50px', height:'5px', background:'#111', borderRadius:'3px', border:'1px solid #333', overflow:'hidden' }}>
         <div style={{ width: `${hpPercent}%`, height:'100%', background: hpPercent < 30 ? '#da3633' : color, transition: 'width 0.2s' }}/>
      </div>
      <span style={{ fontSize:'9px', fontWeight:'900', color:'#fff', textShadow:'0 0 2px #000', marginTop:'1px' }}>
        {Math.ceil(hpPercent)}%
      </span>
    </div>
  );
};

// --- ëª¬ìŠ¤í„°(ê±°ì‹ ë³‘/ì£¼ì‹œì) ë Œë”ë§ ---
export const MonsterRender = ({ type, objectives }: { type: 'colossus' | 'watcher', objectives: any }) => {
  if (!objectives || !objectives[type]) return null;
  const obj = objectives[type];
  
  if (obj.status !== 'ALIVE') return null;

  const pos = type === 'colossus' ? POI.BARON : POI.DRAGON;
  const color = type === 'colossus' ? '#a658ff' : '#e67e22'; 
  const icon = type === 'colossus' ? <Skull size={16} color="#fff"/> : <Zap size={16} color="#fff"/>;
  const hpPercent = (obj.hp / obj.maxHp) * 100;

  return (
    <div style={{
      position: 'absolute', left: `${pos.x}%`, top: `${pos.y}%`,
      transform: 'translate(-50%, -50%)', zIndex: 7,
      display: 'flex', flexDirection: 'column', alignItems: 'center'
    }}>
      <div style={{
        width: '32px', height: '32px', background: color, borderRadius: '50%',
        border: '3px solid #fff', display: 'flex', alignItems: 'center', justifyContent: 'center',
        boxShadow: `0 0 15px ${color}`
      }}>
        {icon}
      </div>
      <div style={{ 
        width:'40px', height:'5px', background:'#000', marginTop:'-10px', 
        borderRadius:'2px', overflow:'hidden', border:'1px solid #fff', zIndex:8 
      }}>
         <div style={{ width: `${hpPercent}%`, height:'100%', background: '#fff' }}/>
      </div>
      <span style={{ 
        marginTop:'2px', fontSize:'9px', fontWeight:'900', color:'#fff', 
        textShadow:'0 0 3px #000', background:'rgba(0,0,0,0.5)', padding:'0 4px', borderRadius:'4px'
      }}>
        {type === 'colossus' ? 'ê±°ì‹ ë³‘' : 'ì£¼ì‹œì'}
      </span>
    </div>
  );
};


--- FILE: src/components/battle/spectate/map/UnitRender.tsx ---
import React from 'react';
import { GameIcon } from '../../../common/GameIcon';
import { Plane, Skull } from 'lucide-react';

export const UnitRender = ({ player, isBlue, isSelected, onClick }: any) => {
  const isDead = player.respawnTimer > 0;
  
  // ê·€í™˜ ì²´í¬
  const recallTime = (player as any).currentRecallTime || 0;
  const isRecalling = recallTime > 0 && !isDead;
  const remainingRecall = Math.max(0, 4.0 - recallTime).toFixed(1);

  // ì‚¬ë§ íƒ€ì´ë¨¸ (ì˜¬ë¦¼ ì²˜ë¦¬)
  const deathTimer = Math.ceil(player.respawnTimer);

  return (
    <div 
      id={`unit-${player.heroId}`}
      onClick={onClick}
      style={{
        position: 'absolute',
        left: `${player.x}%`, 
        top: `${player.y}%`,
        // ì‚¬ë§ ì‹œì—ëŠ” ìœ„ì¹˜ê°€ ê³ ì •ë˜ì–´ì•¼ í•˜ë¯€ë¡œ transition ë” (ë–¨ë¦¼ ë°©ì§€)
        transition: (isDead || isRecalling) ? 'none' : 'left 0.5s linear, top 0.5s linear',
        
        width: '32px', height: '32px', 
        zIndex: isDead ? 5 : 10, // ì£½ì€ ìœ ë‹›ì€ ì‚° ìœ ë‹›ë³´ë‹¤ ì•„ë˜ì—
        cursor: 'pointer',
        transform: 'translate(-50%, -50%)',
        opacity: isDead ? 0.6 : 1, // ë°˜íˆ¬ëª…
        filter: isDead ? 'grayscale(100%) brightness(0.7)' : 'none'
      }}
    >
      {/* 1. ê·€í™˜ ì¸ë””ì¼€ì´í„° (íŒŒë‘) */}
      {isRecalling && (
        <div style={{
          position: 'absolute', top: -25, left: '50%', transform: 'translateX(-50%)',
          background: 'rgba(52, 152, 219, 0.9)', color: '#fff',
          padding: '2px 6px', borderRadius: '10px',
          fontSize: '9px', fontWeight: 'bold', whiteSpace: 'nowrap',
          display: 'flex', alignItems: 'center', gap: '2px',
          border: '1px solid #fff', zIndex: 20, boxShadow: '0 0 10px #3498db'
        }}>
          <Plane size={8} style={{ transform:'rotate(-45deg)' }}/> 
          <span>{remainingRecall}s</span>
        </div>
      )}

      {/* 2. ì‚¬ë§ ì¸ë””ì¼€ì´í„° (ë¹¨ê°•) - ì—¬ê¸°ê°€ í•µì‹¬! */}
      {isDead && (
        <div style={{
          position: 'absolute', top: -28, left: '50%', transform: 'translateX(-50%)',
          background: 'rgba(218, 54, 51, 0.9)', color: '#fff',
          padding: '2px 8px', borderRadius: '12px',
          fontSize: '11px', fontWeight: '900', whiteSpace: 'nowrap',
          display: 'flex', alignItems: 'center', gap: '4px',
          border: '1px solid #fff', zIndex: 20, boxShadow: '0 0 10px #da3633'
        }}>
          <Skull size={10} /> 
          <span>{deathTimer}s</span>
        </div>
      )}

      {/* ìœ ë‹› ë³¸ì²´ */}
      <div style={{
        width: '100%', height: '100%',
        borderRadius: '50%',
        border: isRecalling ? '2px solid #3498db' : (isDead ? '2px solid #555' : `2px solid ${isBlue ? '#58a6ff' : '#e84057'}`),
        background: '#161b22',
        overflow: 'hidden',
        boxShadow: isRecalling ? '0 0 15px #3498db' : (isSelected ? '0 0 0 2px white' : 'none'),
        boxSizing: 'border-box'
      }}>
         <GameIcon id={player.heroId} size="100%" shape="circle" border="none" />
      </div>

      {/* ë ˆë²¨ ë±ƒì§€ */}
      <div style={{ 
        position: 'absolute', top: -5, right: -5, 
        background: '#000', color: '#fff', 
        fontSize: '9px', fontWeight: 'bold',
        padding: '1px 4px', borderRadius: '4px', 
        border: '1px solid #555', zIndex: 2 
      }}>
        {player.level}
      </div>

      {/* ì²´ë ¥ë°” (ì£½ìœ¼ë©´ ìˆ¨ê¹€) */}
      {!isDead && (
        <div style={{ 
          position: 'absolute', bottom: -6, left: '50%', transform: 'translateX(-50%)', 
          width: '36px', height: '5px', 
          background: '#222', border: '1px solid #000', borderRadius: '2px', overflow: 'hidden'
        }}>
           <div style={{ 
             width: `${(player.currentHp / player.maxHp) * 100}%`, 
             height: '100%', 
             background: isBlue ? '#58a6ff' : '#e84057',
             transition: 'width 0.2s'
           }} />
        </div>
      )}
    </div>
  );
};


--- FILE: src/components/battle/spectate/map/objects/JungleRender.tsx ---
import React from 'react';
import { JungleMob } from '../../../../../../types';

export const JungleRender = ({ mobs }: { mobs?: JungleMob[] }) => {
  if (!mobs) return null;

  return (
    <>
      {mobs.map((mob) => {
        if (!mob.isAlive) return null;

        const color = mob.type === 'GOLEM' ? '#d35400' : '#7f8c8d';
        const size = mob.type === 'GOLEM' ? 14 : 10;

        return (
          <div
            key={mob.id}
            style={{
              position: 'absolute',
              left: `${mob.x}%`,
              top: `${mob.y}%`,
              width: `${size}px`,
              height: `${size}px`,
              backgroundColor: '#161b22',
              border: `2px solid ${color}`,
              borderRadius: '50%',
              transform: 'translate(-50%, -50%)',
              zIndex: 3,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: '8px',
              color: color,
              fontWeight: 'bold',
              pointerEvents: 'none'
            }}
          >
            {mob.type[0]}
          </div>
        );
      })}
    </>
  );
};


--- FILE: src/components/battle/spectate/map/objects/MinionRender.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/spectate/map/objects/MinionRender.tsx
// ==========================================
import React from 'react';
import { Minion } from '../../../../../../types';
import { Skull } from 'lucide-react';

export const MinionRender = ({ minions }: { minions?: Minion[] }) => {
  if (!minions) return null;

  return (
    <>
      {minions.map((m) => {
        const isBlue = m.team === 'BLUE';
        const color = isBlue ? '#58a6ff' : '#e84057';
        
        // [ìˆ˜ì •] ê±°ì‹ ë³‘ ë Œë”ë§ (ì²´ë ¥ë°” ì¶”ê°€)
        if (m.type === 'SUMMONED_COLOSSUS') {
            const hpPercent = (m.hp / m.maxHp) * 100;
            return (
                <div
                    key={m.id}
                    id={`minion-${m.id}`}
                    style={{
                        position: 'absolute',
                        left: `${m.x}%`,
                        top: `${m.y}%`,
                        transform: 'translate(-50%, -50%)',
                        zIndex: 15,
                        display: 'flex', flexDirection: 'column', alignItems: 'center',
                        transition: 'none'
                    }}
                >
                    {/* ì²´ë ¥ë°” */}
                    <div style={{ width: '40px', height: '6px', background: '#000', borderRadius: '3px', marginBottom: '4px', border: '1px solid #fff', overflow:'hidden' }}>
                        <div style={{ width: `${hpPercent}%`, height: '100%', background: '#a658ff', transition: 'width 0.2s' }} />
                    </div>

                    {/* ë³¸ì²´ ì•„ì´ì½˜ */}
                    <div style={{
                        width: '28px',
                        height: '28px',
                        backgroundColor: isBlue ? '#a658ff' : '#ff5858', 
                        borderRadius: '50%',
                        border: '2px solid #fff',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        boxShadow: '0 0 15px #a658ff'
                    }}>
                        <Skull size={18} color="#fff" />
                    </div>
                </div>
            );
        }

        // ì¼ë°˜ ë¯¸ë‹ˆì–¸
        const size = m.type === 'SIEGE' ? 14 : (m.type === 'MELEE' ? 10 : 8);
        const shape = m.type === 'RANGED' ? '50%' : '3px';
        const border = m.type === 'SIEGE' ? '2px solid #fff' : '1px solid #000';

        return (
          <div
            key={m.id}
            id={`minion-${m.id}`}
            style={{
              position: 'absolute',
              left: `${m.x}%`,
              top: `${m.y}%`,
              width: `${size}px`,
              height: `${size}px`,
              backgroundColor: color,
              borderRadius: shape,
              border: border,
              transform: 'translate(-50%, -50%)',
              zIndex: 4,
              boxShadow: m.type === 'SIEGE' ? '0 0 5px rgba(255,255,255,0.5)' : 'none',
              pointerEvents: 'none',
              transition: 'none' 
            }}
          />
        );
      })}
    </>
  );
};


--- FILE: src/components/battle/spectate/map/objects/ProjectileRender.tsx ---
import React from 'react';
import { Projectile } from '../../../../../../types';

export const ProjectileRender = ({ projectiles }: { projectiles?: Projectile[] }) => {
  if (!projectiles) return null;

  return (
    <>
      {projectiles.map((p) => (
        <div
          key={p.id}
          style={{
            position: 'absolute',
            left: `${p.x}%`,
            top: `${p.y}%`,
            width: '6px',
            height: '6px',
            backgroundColor: '#f1c40f',
            borderRadius: '50%',
            boxShadow: '0 0 4px #f1c40f',
            transform: 'translate(-50%, -50%)',
            zIndex: 20,
            pointerEvents: 'none'
          }}
        />
      ))}
    </>
  );
};


--- FILE: src/components/battle/spectate/views/SpectateHeader.tsx ---
import React from 'react';
import { X, Play, Pause } from 'lucide-react';
import { SpeedButton } from '../SpectateUI';

interface Props {
  score: { blue: number; red: number };
  timeStr: string;
  isGameEnded: boolean;
  isPlaying: boolean;
  gameSpeed: number;
  onTogglePlay: () => void;
  onSetSpeed: (s: number) => void;
  onClose: () => void;
  isMobile: boolean;
  mobileTab: 'LIST' | 'MAP';
  setMobileTab: (t: 'LIST' | 'MAP') => void;
}

export const SpectateHeader: React.FC<Props> = ({ 
  score, timeStr, isGameEnded, isPlaying, gameSpeed, 
  onTogglePlay, onSetSpeed, onClose, isMobile, mobileTab, setMobileTab 
}) => {
  return (
    <div style={{ flexShrink: 0, background: '#1a1a1a', borderBottom: '1px solid #333', padding: '10px' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom:'8px' }}>
        <div style={{ display:'flex', gap:'20px', alignItems:'center', flex:1, justifyContent:'center' }}>
            <span style={{ color: '#58a6ff', fontWeight: '900', fontSize:'22px', minWidth:'30px', textAlign:'right' }}>{score.blue}</span>
            <div style={{ background:'#000', padding:'4px 12px', borderRadius:'20px', border:'1px solid #444', color:'#fff', fontSize:'14px', fontFamily:'monospace', fontWeight:'bold' }}>
              {isGameEnded ? 'END' : timeStr}
            </div>
            <span style={{ color: '#e84057', fontWeight: '900', fontSize:'22px', minWidth:'30px', textAlign:'left' }}>{score.red}</span>
        </div>
        <button onClick={onClose} style={{ position:'absolute', right:'10px', top:'10px', background:'none', border:'none', color:'#888', cursor:'pointer' }}><X size={24}/></button>
      </div>
      
      <div style={{ display:'flex', justifyContent:'center', gap:'8px' }}>
          <button onClick={onTogglePlay} style={{ width:'50px', height:'30px', borderRadius:'4px', background: isPlaying ? '#ff7675' : '#55efc4', color:'#000', border:'none', cursor:'pointer', display:'flex', alignItems:'center', justifyContent:'center' }}>
            {isPlaying ? <Pause size={16}/> : <Play size={16}/>}
          </button>
          {[1, 10, 60].map(s => <SpeedButton key={s} label={`${s}ë°°`} speed={s} currentSpeed={gameSpeed} setSpeed={onSetSpeed} />)}
      </div>
      
      {isMobile && (
        <div style={{ display:'flex', marginTop:'10px', borderTop:'1px solid #333', paddingTop:'8px' }}>
          <button onClick={()=>setMobileTab('LIST')} style={{ flex:1, padding:'8px', background: mobileTab==='LIST'?'#333':'transparent', border:'none', color: mobileTab==='LIST'?'#fff':'#777', fontWeight:'bold', borderBottom: mobileTab==='LIST'?'2px solid #fff':'none' }}>ğŸ“‹ ì„ ìˆ˜ ì •ë³´</button>
          <button onClick={()=>setMobileTab('MAP')} style={{ flex:1, padding:'8px', background: mobileTab==='MAP'?'#333':'transparent', border:'none', color: mobileTab==='MAP'?'#fff':'#777', fontWeight:'bold', borderBottom: mobileTab==='MAP'?'2px solid #fff':'none' }}>ğŸ—ºï¸ ì‹¤ì‹œê°„ ë§µ</button>
        </div>
      )}
    </div>
  );
};


--- FILE: src/components/battle/spectate/views/SpectateListView.tsx ---
import React from 'react';
import { BanCard, PlayerCard, ObjectStatBox, NeutralObjPanel } from '../SpectateUI';
import { ChevronLeft, Terminal } from 'lucide-react';
import { GlobalLogPanel } from '../GlobalLogPanel';
import { UserDetailView } from '../UserDetailView';
import { PersonalLogView } from '../PersonalLogView';
import { LiveMatch, Hero } from '../../../../../types';

interface Props {
  match: LiveMatch;
  heroes: Hero[];
  isMobile: boolean;
  mobileTab: 'LIST' | 'MAP';
  selectedHeroId: string | null;
  onSelectHero: (id: string | null) => void;
  gameSpeed: number;
  formatTime: (s: number) => string;
  getHeroName: (id: string) => string;
}

export const SpectateListView: React.FC<Props> = ({
  match, heroes, isMobile, mobileTab, selectedHeroId, onSelectHero, gameSpeed, formatTime, getHeroName
}) => {
  const [viewingItem, setViewingItem] = React.useState<any>(null);
  const selectedPlayer = selectedHeroId ? [...match.blueTeam, ...match.redTeam].find(p => p.heroId === selectedHeroId) : null;

  return (
    <div style={{ 
      background: '#121212', 
      display: (isMobile && mobileTab !== 'LIST') ? 'none' : 'block',
      paddingBottom: '50px',
      width: '100%',
      overflowX: 'hidden'
    }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', padding: '8px 10px', borderBottom: '1px solid #222', background:'#1a1a1a' }}>
           <div style={{ display: 'flex', gap: '4px' }}>{(match.bans.blue || []).map((id:string, i:number) => <BanCard key={i} heroId={id} heroes={heroes} />)}</div>
           <div style={{ display: 'flex', gap: '4px' }}>{(match.bans.red || []).map((id:string, i:number) => <BanCard key={i} heroId={id} heroes={heroes} />)}</div>
        </div>

        <div style={{ padding: '8px', display:'flex', gap:'6px', alignItems:'flex-start' }}>
           <div style={{ flex:1, display:'flex', flexDirection:'column', gap:'4px', minWidth:0 }}>
             <div style={{ fontSize:'11px', fontWeight:'bold', color:'#58a6ff', textAlign:'center', marginBottom:'2px' }}>BLUE TEAM</div>
             {match.blueTeam.map((p:any, i:number) => <PlayerCard key={i} p={p} isSelected={selectedHeroId === p.heroId} onClick={() => onSelectHero(p.heroId)} heroName={getHeroName(p.heroId)} teamColor="#58a6ff" />)}
           </div>

           <div style={{ flex:1, display:'flex', flexDirection:'column', gap:'4px', minWidth:0 }}>
             <div style={{ fontSize:'11px', fontWeight:'bold', color:'#e84057', textAlign:'center', marginBottom:'2px' }}>RED TEAM</div>
             {match.redTeam.map((p:any, i:number) => <PlayerCard key={i} p={p} isSelected={selectedHeroId === p.heroId} onClick={() => onSelectHero(p.heroId)} heroName={getHeroName(p.heroId)} teamColor="#e84057" />)}
           </div>
        </div>

        <div style={{ padding:'0 8px 20px 8px' }}>
            <div style={{ padding:'8px 0', display:'flex', gap:'6px' }}>
               <ObjectStatBox stats={match.stats.blue} color="#58a6ff" side="BLUE" godName="ë‹¨í…Œ" />
               <ObjectStatBox stats={match.stats.red} color="#e84057" side="RED" godName="ì´ì¦ˆë§ˆí•œ" />
            </div>
            <NeutralObjPanel colossus={match.objectives?.colossus} watcher={match.objectives?.watcher} />
            
            <div style={{ height:'300px', border:'1px solid #333', marginTop:'10px', borderRadius:'8px', overflow:'hidden', display:'flex', flexDirection:'column' }}>
                {selectedPlayer ? (
                    <div style={{ height:'100%', overflowY:'auto' }}>
                        <div onClick={() => { onSelectHero(null); setViewingItem(null); }} style={{ padding:'8px', background:'#222', textAlign:'center', cursor:'pointer', fontSize:'12px', color:'#ccc', borderBottom:'1px solid #333' }}><ChevronLeft size={12}/> ëª©ë¡ìœ¼ë¡œ ëŒì•„ê°€ê¸°</div>
                        <UserDetailView player={selectedPlayer} heroName={getHeroName(selectedPlayer.heroId)} viewingItem={viewingItem} setViewingItem={setViewingItem} />
                        <PersonalLogView logs={match.logs} heroName={getHeroName(selectedPlayer.heroId)} summonerName={selectedPlayer.name} formatTime={formatTime} />
                    </div>
                ) : (
                    <>
                       <div style={{ padding:'8px', background:'#161b22', fontSize:'11px', color:'#888', display:'flex', gap:'6px', borderBottom:'1px solid #222' }}><Terminal size={12}/> ì‹¤ì‹œê°„ ë¡œê·¸</div>
                       <GlobalLogPanel logs={match.logs} gameSpeed={gameSpeed} formatTime={formatTime} />
                    </>
                )}
            </div>
        </div>
    </div>
  );
};


--- FILE: src/components/battle/spectate/views/SpectateMapView.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/spectate/views/SpectateMapView.tsx
// ==========================================
import React, { useEffect, useRef } from 'react';
import { SpectateMap } from '../../SpectateMap';
import { TowerRender, NexusRender, MonsterRender } from '../map/MapObjects';
import { UnitRender } from '../map/UnitRender';
import { MinionRender } from '../map/objects/MinionRender';
import { JungleRender } from '../map/objects/JungleRender';
import { ProjectileRender } from '../map/objects/ProjectileRender';
import { LiveMatch } from '../../../../../types';

interface Props {
  match: LiveMatch;
  isMobile: boolean;
  mobileTab: 'LIST' | 'MAP';
  selectedHeroId: string | null;
  onSelectHero: (id: string) => void;
  setMobileTab: (t: 'LIST' | 'MAP') => void;
}

export const SpectateMapView: React.FC<Props> = ({ 
  match, isMobile, mobileTab, selectedHeroId, onSelectHero, setMobileTab 
}) => {
  
  const visualRef = useRef<Record<string, {x: number, y: number}>>({});
  const requestRef = useRef<number>();

  useEffect(() => {
    const animate = () => {
      // ì˜ì›… ì´ë™ ë³´ê°„
      const allPlayers = [...match.blueTeam, ...match.redTeam];
      allPlayers.forEach(p => {
        updateElementPos(`unit-${p.heroId}`, p.x, p.y, 'HERO'); 
      });

      // ë¯¸ë‹ˆì–¸ ì´ë™ ë³´ê°„
      if (match.minions) {
        match.minions.forEach(m => {
          updateElementPos(`minion-${m.id}`, m.x, m.y, 'MINION');
        });
      }

      requestRef.current = requestAnimationFrame(animate);
    };

    const updateElementPos = (elementId: string, targetX: number, targetY: number, type: 'HERO' | 'MINION') => {
      const el = document.getElementById(elementId);
      if (!el) return;

      let current = visualRef.current[elementId];
      if (!current) {
        current = { x: targetX, y: targetY };
        visualRef.current[elementId] = current;
      }

      const dx = targetX - current.x;
      const dy = targetY - current.y;
      const dist = Math.sqrt(dx*dx + dy*dy);

      if (dist > 20) {
        current.x = targetX;
        current.y = targetY;
      } else if (dist > 0.01) {
        let speed = type === 'HERO' ? Math.max(0.05, dist * 0.1) : Math.max(0.025, dist * 0.05);
        if (dist <= speed) {
            current.x = targetX;
            current.y = targetY;
        } else {
            current.x += (dx / dist) * speed;
            current.y += (dy / dist) * speed;
        }
      }

      el.style.left = `${current.x}%`;
      el.style.top = `${current.y}%`;
      el.style.zIndex = `${Math.floor(current.y)}`;
    };

    requestRef.current = requestAnimationFrame(animate);
    return () => { if(requestRef.current) cancelAnimationFrame(requestRef.current); };
  }, [match]); 

  // ëª¨ë°”ì¼ íƒ­ ì œì–´ (ë¦¬ìŠ¤íŠ¸ ë³´ê¸°ì¼ ë• ìˆ¨ê¹€)
  if (isMobile && mobileTab !== 'MAP') return null;

  return (
    <div style={{ 
        width: '100%',
        height: '100%',
        display: 'flex', 
        alignItems: 'center', 
        justifyContent: 'center',
        background: '#050505',
        overflow: 'hidden',
        position: 'relative'
    }}>
      {/* 
         [í¬ê¸° ê³ ì • ë˜í¼]
         ëª¨ë°”ì¼ ì„¸ë¡œ: ê°€ë¡œ 100% ì±„ì›€
         PC/ê°€ë¡œëª¨ë“œ: ë†’ì´ 100% ì±„ìš°ê³  ê°€ë¡œ ë¹„ìœ¨ ë§ì¶¤
      */}
      <div style={{
          position: 'relative',
          width: '100%',
          maxWidth: '100vh', // ê°€ë¡œê°€ ë„ˆë¬´ ê¸¸ì–´ì§€ëŠ” ê²ƒ ë°©ì§€ (ì •ì‚¬ê°í˜• ìœ ì§€)
          aspectRatio: '1/1', // ìµœì‹  ë¸Œë¼ìš°ì € ì§€ì›
          margin: '0 auto'
      }}>
        {/* [í˜¸í™˜ì„± ë˜í¼] aspectRatio ë¯¸ì§€ì› ë¸Œë¼ìš°ì € ëŒ€ë¹„ ë° ë ˆì´ì•„ì›ƒ ê°•ì œ */}
        <div style={{
            width: '100%',
            paddingBottom: '100%', // 1:1 ë¹„ìœ¨ ê°•ì œ (Width ê¸°ì¤€ Height ì„¤ì •)
            position: 'relative',
            background: '#161b22',
            border: '1px solid #333',
            boxShadow: '0 0 50px rgba(0,0,0,0.5)',
            overflow: 'hidden' // ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ëŠ” ìœ ë‹› ìˆ¨ê¹€
        }}>
            {/* ì‹¤ì œ ë§µ ì»¨í…ì¸  (Absoluteë¡œ ê½‰ ì±„ì›€) */}
            <div style={{ position: 'absolute', inset: 0 }}>
                <SpectateMap />
                
                <JungleRender mobs={match.jungleMobs} />

                {['TOP', 'MID', 'BOT'].map(lane => (
                [1, 2, 3].map(tier => (
                    <React.Fragment key={`${lane}-${tier}`}>
                    <TowerRender side="BLUE" lane={lane} tier={tier} stats={match.stats} />
                    <TowerRender side="RED" lane={lane} tier={tier} stats={match.stats} />
                    </React.Fragment>
                ))
                ))}
                <NexusRender side="BLUE" stats={match.stats} />
                <NexusRender side="RED" stats={match.stats} />
                
                <MonsterRender type="colossus" objectives={match.objectives} />
                <MonsterRender type="watcher" objectives={match.objectives} />

                <MinionRender minions={match.minions} />

                {[...match.blueTeam, ...match.redTeam].map(p => (
                <UnitRender 
                    key={p.heroId} 
                    player={p} 
                    isBlue={match.blueTeam.includes(p)} 
                    isSelected={selectedHeroId === p.heroId} 
                    onClick={() => { onSelectHero(p.heroId); if(isMobile) setMobileTab('LIST'); }} 
                />
                ))}

                <ProjectileRender projectiles={match.projectiles} />
            </div>
        </div>
      </div>
    </div>
  );
};


--- FILE: src/components/battle/spectate/InGameScreen.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/spectate/InGameScreen.tsx
// ==========================================
import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../../store/useGameStore';
import { SpectateHeader } from './views/SpectateHeader';
import { SpectateMapView } from './views/SpectateMapView';
import { SpectateListView } from './views/SpectateListView';

export const InGameScreen: React.FC<any> = ({ match: initialMatch, onClose }) => {
  const match = useGameStore(state => state.gameState.liveMatches.find(m => m.id === initialMatch.id));
  const { heroes, gameState, setSpeed, togglePlay } = useGameStore();

  const [selectedHeroId, setSelectedHeroId] = useState<string | null>(null);
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
  const [mobileTab, setMobileTab] = useState<'LIST' | 'MAP'>('LIST');

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    setSpeed(1); // ê´€ì „ ì‹œì‘ ì‹œ 1ë°°ì†ìœ¼ë¡œ ì´ˆê¸°í™”
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  if (!match) return <div style={{color:'white', padding:50, textAlign:'center'}}>ê²Œì„ ì¢…ë£Œë¨</div>;

  const isGameEnded = match.stats.blue.nexusHp <= 0 || match.stats.red.nexusHp <= 0;
  
  const formatTime = (s: number) => {
    const m = Math.floor(s / 60);
    const sec = Math.floor(s % 60);
    return `${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
  };

  const getHeroName = (id: string) => heroes.find((h:any) => h.id === id)?.name || id;

  return (
    <div style={{ 
      position: 'fixed', inset: 0, background: '#0f0f0f', zIndex: 10000,
      display: 'flex', flexDirection: 'column'
    }}>
      
      {/* 1. ìƒë‹¨ë°” ëª¨ë“ˆ */}
      <SpectateHeader 
        score={match.score}
        timeStr={isGameEnded ? 'END' : formatTime(match.currentDuration)}
        isGameEnded={isGameEnded}
        isPlaying={gameState.isPlaying}
        gameSpeed={gameState.gameSpeed}
        onTogglePlay={togglePlay}
        onSetSpeed={setSpeed}
        onClose={onClose}
        isMobile={isMobile}
        mobileTab={mobileTab}
        setMobileTab={setMobileTab}
      />

      {/* 2. ë©”ì¸ ì»¨í…ì¸  */}
      <div style={{ flex: 1, overflowY: 'auto', WebkitOverflowScrolling: 'touch' }}>
        
        {/* [MAP] ë§µ ë·° ëª¨ë“ˆ */}
        <SpectateMapView 
          match={match}
          isMobile={isMobile}
          mobileTab={mobileTab}
          selectedHeroId={selectedHeroId}
          onSelectHero={setSelectedHeroId}
          setMobileTab={setMobileTab}
        />

        {/* [LIST] ë¦¬ìŠ¤íŠ¸ ë·° ëª¨ë“ˆ */}
        <SpectateListView 
          match={match}
          heroes={heroes}
          isMobile={isMobile}
          mobileTab={mobileTab}
          selectedHeroId={selectedHeroId}
          onSelectHero={setSelectedHeroId}
          gameSpeed={gameState.gameSpeed}
          formatTime={formatTime}
          getHeroName={getHeroName}
        />

      </div>
    </div>
  );
};


--- FILE: src/components/battle/SpectateModal.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/SpectateModal.tsx
// ==========================================
import React, { Component, ErrorInfo, useState } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { DraftScreen } from './spectate/DraftScreen';
import { InGameScreen } from './spectate/InGameScreen';
import { AlertTriangle } from 'lucide-react';
import { Hero } from '../../types';

// ì—ëŸ¬ ë°”ìš´ë”ë¦¬ (ê·¸ëŒ€ë¡œ ìœ ì§€)
class ErrorBoundary extends Component<{ children: React.ReactNode }, { hasError: boolean, errorMsg: string }> {
  constructor(props: any) { super(props); this.state = { hasError: false, errorMsg: "" }; }
  static getDerivedStateFromError(error: any) { return { hasError: true, errorMsg: error.toString() }; }
  render() {
    if (this.state.hasError) {
      return (
        <div style={{ padding: '40px', color: '#ff6b6b', textAlign: 'center', background:'#111', height:'100%', display:'flex', flexDirection:'column', justifyContent:'center', alignItems:'center' }}>
          <AlertTriangle size={40} style={{ marginBottom: '20px' }} />
          <h3>í™”ë©´ ë¡œë“œ ì‹¤íŒ¨</h3>
          <p style={{ fontSize: '12px', color: '#888' }}>{this.state.errorMsg}</p>
          <button onClick={() => window.location.reload()} style={{ marginTop:'20px', padding:'10px', cursor:'pointer' }}>ìƒˆë¡œê³ ì¹¨</button>
        </div>
      );
    }
    return this.props.children;
  }
}

// ë©”ì¸ ì»¨í…ì¸  ë¶„ê¸° ì²˜ë¦¬
const SpectateContent: React.FC<any> = ({ match: initialMatch, onClose }) => {
  // Store êµ¬ë… (ì‹¤ì‹œê°„ ë°ì´í„°)
  const match = useGameStore(state => state.gameState.liveMatches.find(m => m.id === initialMatch.id));
  const { heroes, setSpeed, gameState } = useGameStore();

  const [viewingBanHero, setViewingBanHero] = useState<Hero | null>(null);

  if (!match) {
    return (
      <div style={{color:'white', padding:'20px', textAlign:'center', display:'flex', flexDirection:'column', height:'100%', justifyContent:'center', alignItems:'center'}}>
        <h3 style={{marginBottom:'20px'}}>ê²Œì„ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.</h3>
        <button onClick={onClose} style={{padding:'10px 30px', cursor:'pointer', background:'#333', color:'#fff', border:'1px solid #555', borderRadius:'8px'}}>ë‚˜ê°€ê¸°</button>
      </div>
    );
  }

  // ë°´í”½ í™”ë©´
  if (match.status === 'DRAFTING' && (match.draft?.turnIndex || 0) < 20) {
    return (
      <DraftScreen 
        match={match} heroes={heroes} onClose={onClose} 
        setSpeed={setSpeed} gameState={gameState}
        onBanClick={setViewingBanHero}
      />
    );
  }

  // ì¸ê²Œì„ í™”ë©´
  return <InGameScreen match={match} onClose={onClose} />;
};

export const SpectateModal: React.FC<any> = (props) => {
  return (
    <div style={{ position: 'fixed', inset: 0, background: '#050505', zIndex: 30000 }}>
      <ErrorBoundary>
        <SpectateContent {...props} />
      </ErrorBoundary>
    </div>
  );
};

--- FILE: src/components/battle/BattleDashboard.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/BattleDashboard.tsx
// ==========================================

import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { Sword, Shield, Settings } from 'lucide-react';

// [ì¤‘ìš”] ìƒˆë¡œ ìƒì„±í•œ ëª¨ë“ˆ íŒŒì¼ë“¤ import
import { SiegeSettingsPanel } from './dashboard/SiegeSettingsPanel';
import { MinionCard } from './dashboard/MinionCard'; // (GodPanel ë‚´ë¶€ì—ì„œ ì‚¬ìš©ë¨, ì—¬ê¸°ì„œ ì§ì ‘ ì“°ì§„ ì•ŠìŒ)
import { GodPanel } from './dashboard/GodPanel';
import { GlobalBattleStats } from './dashboard/GlobalBattleStats';

export const BattleDashboard: React.FC = () => {
  const { gameState, updateBattleSettings } = useGameStore();
  const { battleSettings, godStats } = gameState;

  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  if (!battleSettings) return <div className="panel">ì‹œìŠ¤í…œ ë¡œë”© ì¤‘...</div>;

  const handleGodChange = (god: 'izman' | 'dante', field: string, value: any) => {
    updateBattleSettings({ [god]: { ...battleSettings[god], [field]: value } });
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '25px', paddingBottom: '80px' }}>
      
      {/* í—¤ë” ì˜ì—­ */}
      <div style={{ display: 'flex', alignItems: 'center', gap: '12px', padding: isMobile ? '0 5px' : '0' }}>
        <div style={{ background: '#58a6ff22', padding: '10px', borderRadius: '12px', border: '1px solid #58a6ff44' }}>
          <Settings size={24} color="#58a6ff" />
        </div>
        <div>
          <h2 style={{ margin: 0, fontSize: isMobile ? '18px' : '22px', fontWeight: '800', letterSpacing: '-0.5px', color:'#fff' }}>ì „ì¥ ì˜¤ë²„ë¼ì´ë“œ</h2>
          <p style={{ margin: 0, fontSize: isMobile ? '11px' : '13px', color: '#8b949e' }}>
            ì§„ì˜ë³„ ë°¸ëŸ°ìŠ¤ ë° í•˜ìˆ˜ì¸ ìŠ¤í™ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ì œì–´í•©ë‹ˆë‹¤.
          </p>
        </div>
      </div>

      {/* ì „ì²´ í†µê³„ */}
      <GlobalBattleStats stats={godStats} isMobile={isMobile} />

      {/* [í™•ì¸] ê³µì„± ì„¤ì • íŒ¨ë„ - í†µê³„ ë°”ë¡œ ì•„ë˜ì— ë°°ì¹˜ */}
      <SiegeSettingsPanel />

      {/* ì–‘ ì§„ì˜ íŒ¨ë„ */}
      <div style={{ display: 'grid', gridTemplateColumns: isMobile ? '1fr' : '1fr 1fr', gap: '25px' }}>
        <GodPanel 
          side="RED" settings={battleSettings.izman} stats={godStats}
          color="#ff4d4d" glowColor="rgba(255, 77, 77, 0.1)"
          onChange={(field: string, val: any) => handleGodChange('izman', field, val)}
          icon={<Sword size={20} />} isMobile={isMobile}
        />
        <GodPanel 
          side="BLUE" settings={battleSettings.dante} stats={godStats}
          color="#4d94ff" glowColor="rgba(77, 148, 255, 0.1)"
          onChange={(field: string, val: any) => handleGodChange('dante', field, val)}
          icon={<Shield size={20} />} isMobile={isMobile}
        />
      </div>
    </div>
  );
};


--- FILE: src/components/battle/BattlefieldPatchModal.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/BattlefieldPatchModal.tsx
// ==========================================

import React, { useState } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { X, Save, Sliders, Zap, Shield, Sword, Heart, Coins, Layers, Star } from 'lucide-react';
// [ëª¨ë“ˆí™”] ë¶„ë¦¬ëœ ì…ë ¥ ì»´í¬ë„ŒíŠ¸ ì„í¬íŠ¸
import { RangeInput, TimeInput } from './ui/PatchInputs';

interface Props {
  targetKey: string;
  title: string;
  color: string;
  onClose: () => void;
}

export const BattlefieldPatchModal: React.FC<Props> = ({ targetKey, title, color, onClose }) => {
  const { gameState, updateFieldSettings } = useGameStore();

  // ì¤‘ì²©ëœ í‚¤(towers.t1) ì²˜ë¦¬ ë¡œì§
  const getInitialSettings = () => {
    if (targetKey.startsWith('towers.')) {
        const subKey = targetKey.split('.')[1];
        return (gameState.fieldSettings.towers as any)[subKey];
    }
    return (gameState.fieldSettings as any)[targetKey];
  };

  const [localSettings, setLocalSettings] = useState({ ...getInitialSettings() });

  const handleChange = (field: string, value: any) => {
    setLocalSettings((prev: any) => ({ ...prev, [field]: value }));
  };

  const handleSave = () => {
    if (targetKey.startsWith('towers.')) {
        const subKey = targetKey.split('.')[1];
        updateFieldSettings({
            towers: {
                ...gameState.fieldSettings.towers,
                [subKey]: localSettings
            }
        });
    } else {
        updateFieldSettings({ [targetKey]: localSettings });
    }
    alert(`[${title}] íŒ¨ì¹˜ê°€ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.`);
    onClose();
  };

  const renderInputs = () => {
    // 1. í¬íƒ‘ ì„¤ì • (í‹°ì–´ë³„ ê³µí†µ)
    if (targetKey.startsWith('towers.')) {
        return (
            <>
                <RangeInput label="ìµœëŒ€ ì²´ë ¥" icon={<Heart size={14}/>} value={localSettings.hp} onChange={(v) => handleChange('hp', v)} min={1000} max={50000} step={100} unit=" HP" color={color} />
                <RangeInput label="ë°©ì–´ë ¥" icon={<Shield size={14}/>} value={localSettings.armor} onChange={(v) => handleChange('armor', v)} min={0} max={500} step={5} unit=" DEF" color={color} />
                <RangeInput label="ê³µê²©ë ¥" icon={<Sword size={14}/>} value={localSettings.atk} onChange={(v) => handleChange('atk', v)} min={0} max={1000} step={10} unit=" DMG" color={color} />
                <RangeInput label="íŒŒê´´ ë³´ìƒ" icon={<Coins size={14}/>} value={localSettings.rewardGold} onChange={(v) => handleChange('rewardGold', v)} min={0} max={2000} step={10} unit=" G" color={color} />
            </>
        );
    }

    // 2. ì˜¤ë¸Œì íŠ¸ë³„ ì„¤ì •
    switch(targetKey) {
      case 'jungle':
        return (
          <>
            <TimeInput label="ìµœì´ˆ ìƒì„± ì‹œê°„" value={localSettings.initialSpawnTime} onChange={(v) => handleChange('initialSpawnTime', v)} color={color} />
            <TimeInput label="ë¦¬ì   ì£¼ê¸°" value={localSettings.respawnTime} onChange={(v) => handleChange('respawnTime', v)} color={color} />
            <div style={{borderTop:'1px dashed #444', margin:'15px 0'}}></div>
            <RangeInput label="ìƒíƒœê³„ ë°€ë„" icon={<Layers size={14}/>} value={localSettings.density} onChange={(v) => handleChange('density', v)} min={0} max={500} step={1} unit="%" color={color} />
            <RangeInput label="ìì› í’ìš”ë„" icon={<Zap size={14}/>} value={localSettings.yield} onChange={(v) => handleChange('yield', v)} min={0} max={500} step={1} unit="%" color={color} />
            <RangeInput label="ì²˜ì¹˜ ê³¨ë“œ" icon={<Coins size={14}/>} value={localSettings.gold} onChange={(v) => handleChange('gold', v)} min={1} max={500} step={1} unit=" G" color={color} />
            <RangeInput label="ì²˜ì¹˜ ê²½í—˜ì¹˜" icon={<Star size={14}/>} value={localSettings.xp} onChange={(v) => handleChange('xp', v)} min={1} max={1000} step={1} unit=" XP" color={color} />
            <RangeInput label="ê³µê²©ë ¥" icon={<Sword size={14}/>} value={localSettings.attack} onChange={(v) => handleChange('attack', v)} min={0} max={1000} step={1} unit=" DMG" color={color} />
            <RangeInput label="ë°©ì–´ë ¥" icon={<Shield size={14}/>} value={localSettings.defense} onChange={(v) => handleChange('defense', v)} min={0} max={500} step={1} unit=" DEF" color={color} />
          </>
        );
      case 'colossus':
        return (
          <>
            <TimeInput label="ìµœì´ˆ ì¶œí˜„ ì‹œê°„" value={localSettings.initialSpawnTime} onChange={(v) => handleChange('initialSpawnTime', v)} color={color} />
            <TimeInput label="ë¦¬ì   ì£¼ê¸°" value={localSettings.respawnTime} onChange={(v) => handleChange('respawnTime', v)} color={color} />
            <div style={{borderTop:'1px dashed #444', margin:'15px 0'}}></div>
            <RangeInput label="ìµœëŒ€ ì²´ë ¥" icon={<Heart size={14}/>} value={localSettings.hp} onChange={(v) => handleChange('hp', v)} min={1000} max={100000} step={500} unit=" HP" color={color} />
            <RangeInput label="ë°©ì–´ë ¥" icon={<Shield size={14}/>} value={localSettings.armor} onChange={(v) => handleChange('armor', v)} min={0} max={500} step={5} unit=" DEF" color={color} />
            <RangeInput label="ê³µê²©ë ¥" icon={<Sword size={14}/>} value={localSettings.attack} onChange={(v) => handleChange('attack', v)} min={1} max={1000} step={10} unit=" DMG" color={color} />
            <RangeInput label="ì²˜ì¹˜ ë³´ìƒ" icon={<Coins size={14}/>} value={localSettings.rewardGold} onChange={(v) => handleChange('rewardGold', v)} min={0} max={5000} step={50} unit=" G" color={color} />
          </>
        );
      case 'watcher':
        return (
          <>
            <TimeInput label="ìµœì´ˆ ì¶œí˜„ ì‹œê°„" value={localSettings.initialSpawnTime} onChange={(v) => handleChange('initialSpawnTime', v)} color={color} />
            <TimeInput label="ë¦¬ì   ì£¼ê¸°" value={localSettings.respawnTime} onChange={(v) => handleChange('respawnTime', v)} color={color} />
            <div style={{borderTop:'1px dashed #444', margin:'15px 0'}}></div>
            <RangeInput label="ìµœëŒ€ ì²´ë ¥" icon={<Heart size={14}/>} value={localSettings.hp} onChange={(v) => handleChange('hp', v)} min={1000} max={100000} step={500} unit=" HP" color={color} />
            <RangeInput label="ë°©ì–´ë ¥" icon={<Shield size={14}/>} value={localSettings.armor} onChange={(v) => handleChange('armor', v)} min={0} max={500} step={5} unit=" DEF" color={color} />
            <div style={{ marginBottom:'25px' }}>
              <div style={{ fontSize:'13px', color:'#ccc', marginBottom:'10px', display:'flex', gap:'6px' }}><Zap size={14}/> ë²„í”„ ì¢…ë¥˜</div>
              <select 
                value={localSettings.buffType} 
                onChange={(e) => handleChange('buffType', e.target.value)}
                style={{ width:'100%', padding:'12px', background:'#0d1117', border:`1px solid ${color}`, color:'#fff', borderRadius:'8px', outline:'none', fontSize:'14px' }}
              >
                <option value="COMBAT">âš”ï¸ ì „íˆ¬ë ¥ ê°•í™”</option>
                <option value="GOLD">ğŸ’° í™©ê¸ˆì˜ ì†</option>
              </select>
            </div>
            <RangeInput label="ë²„í”„ ìˆ˜ì¹˜" icon={<Zap size={14}/>} value={localSettings.buffAmount} onChange={(v) => handleChange('buffAmount', v)} min={1} max={200} step={1} unit="%" color={color} />
            <TimeInput label="ë²„í”„ ì§€ì† ì‹œê°„" value={localSettings.buffDuration} onChange={(v) => handleChange('buffDuration', v)} color={color} />
          </>
        );
      default: return null;
    }
  };

  return (
    <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.85)', zIndex: 9999, display: 'flex', justifyContent: 'center', alignItems: 'center', backdropFilter:'blur(5px)', padding:'20px' }}>
      <div style={{ width: '100%', maxWidth: '450px', background: '#161b22', border: '1px solid #30363d', borderRadius: '16px', overflow: 'hidden', boxShadow: '0 20px 60px rgba(0,0,0,0.8)', display:'flex', flexDirection:'column', maxHeight:'90vh' }}>
        <div style={{ padding: '15px 20px', background: '#21262d', borderBottom: '1px solid #30363d', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <h3 style={{ margin: 0, color: color, display: 'flex', alignItems: 'center', gap: '8px', fontSize: '16px' }}>
            <Sliders size={18}/> {title} ì¡°ì •
          </h3>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#888', cursor: 'pointer' }}><X size={24}/></button>
        </div>
        <div style={{ padding: '20px', overflowY:'auto', flex:1 }}>
          {renderInputs()}
        </div>
        <div style={{ padding: '15px', borderTop: '1px solid #30363d', display: 'flex', justifyContent: 'flex-end', background:'#0d1117' }}>
          <button onClick={handleSave} style={{ width:'100%', background: '#238636', color: '#fff', border: 'none', padding: '14px', borderRadius: '8px', fontWeight: 'bold', fontSize:'15px', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent:'center', gap: '6px' }}>
            <Save size={18}/> íŒ¨ì¹˜ ì ìš©
          </button>
        </div>
      </div>
    </div>
  );
};


--- FILE: src/components/battle/BattlefieldTab.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/BattlefieldTab.tsx
// ==========================================

import React, { useState, useRef } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { Skull, Ghost, Shield, Zap, Info, Move } from 'lucide-react';
import { BattlefieldPatchModal } from './BattlefieldPatchModal';
import { SpectateMap } from './spectate/SpectateMap'; 
import { MapObjectIcon } from './ui/MapObjectIcon';
import { JunglePatchModal } from './jungle/JunglePatchModal';
import { JungleCampType } from '../../types/jungle';

export const BattlefieldTab: React.FC = () => {
  const { gameState, updateObjectPosition } = useGameStore();
  const positions = gameState.fieldSettings.positions;

  // [ëª¨ë‹¬ ìƒíƒœ]
  const [editingTarget, setEditingTarget] = useState<{ key: string, title: string, color: string } | null>(null);
  const [jungleModal, setJungleModal] = useState<JungleCampType | null>(null);

  // [ë“œë˜ê·¸ ìƒíƒœ]
  const [isDragging, setIsDragging] = useState<string | null>(null);
  const [dragPos, setDragPos] = useState({ x: 0, y: 0 });
  const longPressTimer = useRef<NodeJS.Timeout | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  // ë“œë˜ê·¸ ì¢…ë£Œ (ì €ì¥)
  const handlePointerUp = () => {
    if (longPressTimer.current) clearTimeout(longPressTimer.current);
    if (isDragging) {
        updateObjectPosition(isDragging, dragPos.x, dragPos.y);
        setIsDragging(null);
    }
  };

  // ë“œë˜ê·¸ ì¤‘ ì´ë™
  const handlePointerMove = (e: React.PointerEvent) => {
    if (isDragging && containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        const x = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
        const y = Math.max(0, Math.min(100, ((e.clientY - rect.top) / rect.height) * 100));
        setDragPos({ x, y });
    }
  };

  // [í•µì‹¬] ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ ë˜í¼
  const DraggableObject = ({ objKey, x, y, icon, color, size, label, title, isJungle = false, jungleType }: any) => {
    const isTarget = isDragging === objKey;
    const displayX = isTarget ? dragPos.x : x;
    const displayY = isTarget ? dragPos.y : y;

    const handleDown = (e: React.PointerEvent) => {
        // í…ìŠ¤íŠ¸ ì„ íƒ ë°©ì§€ ë° ì´ë²¤íŠ¸ ì „íŒŒ ì°¨ë‹¨
        e.preventDefault(); 
        
        longPressTimer.current = setTimeout(() => {
            setIsDragging(objKey);
            setDragPos({ x, y });
        }, 300); // 0.3ì´ˆ ê¾¹ ëˆ„ë¥´ë©´ ë“œë˜ê·¸ ì‹œì‘
    };

    const handleClick = () => {
        if (!isTarget) {
            if (isJungle && jungleType) {
                setJungleModal(jungleType);
            } else {
                // [ë²„ê·¸ ìˆ˜ì •] í¬íƒ‘ ê°œë³„ í‚¤(towers.blue.mid.0)ë¥¼ ê³µí†µ ì„¤ì • í‚¤(towers.t1)ë¡œ ë³€í™˜
                let settingKey = objKey;
                
                if (objKey.startsWith('towers.')) {
                    if (objKey.includes('nexus')) {
                        settingKey = 'towers.nexus';
                    } else {
                        // ì˜ˆ: towers.blue.mid.0 -> parts[3]ì´ ì¸ë±ìŠ¤(0, 1, 2)
                        const parts = objKey.split('.');
                        const tierIdx = parseInt(parts[3]); 
                        // ì¸ë±ìŠ¤ 0 -> t1, 1 -> t2, 2 -> t3
                        settingKey = `towers.t${tierIdx + 1}`;
                    }
                }
                
                // ë³€í™˜ëœ í‚¤ë¡œ ëª¨ë‹¬ ì—´ê¸° (ì´ì œ ê°’ì´ ì •ìƒì ìœ¼ë¡œ ëœ¹ë‹ˆë‹¤)
                setEditingTarget({ key: settingKey, title, color });
            }
        }
    };

    return (
        <div onPointerDown={handleDown} style={{ position:'absolute', left:0, top:0, width:'100%', height:'100%', pointerEvents:'none' }}>
            <div style={{ pointerEvents:'auto' }}>
                <MapObjectIcon 
                    x={displayX} y={displayY} 
                    size={size} color={isTarget ? '#fff' : color} 
                    icon={isTarget ? <Move size={20}/> : icon} 
                    label={isTarget ? 'ì´ë™ ì¤‘...' : label}
                    onClick={handleClick}
                />
            </div>
        </div>
    );
  };

  const renderTowers = (side: 'blue' | 'red') => {
    const isBlue = side === 'blue';
    const color = isBlue ? '#58a6ff' : '#e84057';
    const coords = positions.towers[side];

    return (
      <>
        {(['top', 'mid', 'bot'] as const).map(lane => (
          coords[lane].map((pos: any, index: number) => {
            const tier = index + 1; 
            const showLabel = isBlue && lane === 'top' ? `${tier}ì°¨` : undefined;
            return (
              <DraggableObject 
                key={`towers.${side}.${lane}.${index}`}
                objKey={`towers.${side}.${lane}.${index}`}
                x={pos.x} y={pos.y} size={24} color={color} 
                icon={<Shield size={12}/>} label={showLabel}
                title={`${tier}ì°¨ í¬íƒ‘ (${lane.toUpperCase()})`}
              />
            );
          })
        ))}
        {/* ë„¥ì„œìŠ¤ */}
        <DraggableObject 
            key={`towers.${side}.nexus`}
            objKey={`towers.${side}.nexus`}
            x={coords.nexus.x} y={coords.nexus.y} size={36} color={color} 
            icon={<Shield size={18}/>} label={isBlue ? "ìˆ˜í˜¸ì" : undefined}
            title="ìˆ˜í˜¸ì (ë„¥ì„œìŠ¤)"
        />
      </>
    );
  };

  const jungleTypes: JungleCampType[] = ['TOP_BLUE', 'BOT_BLUE', 'TOP_RED', 'BOT_RED'];

  return (
    <div style={{ height: 'calc(100vh - 200px)', minHeight: '600px', display: 'flex', flexDirection: 'column', background: '#0d1117' }}
         onPointerUp={handlePointerUp} // ë“œë˜ê·¸ í•´ì œ (í™”ë©´ ì „ì²´ ê°ì§€)
    >
      <div style={{ padding: '15px 20px', background: '#161b22', borderBottom: '1px solid #30363d', display: 'flex', alignItems: 'center', gap: '10px' }}>
        <Info size={18} color="#58a6ff" />
        <div style={{ fontSize: '13px', color: '#ccc' }}>
          <strong style={{ color: '#fff' }}>ì „ì¥ ì—ë””í„°:</strong> ì•„ì´ì½˜ì„ <strong style={{color:'#f1c40f'}}>ê¸¸ê²Œ ëˆŒëŸ¬</strong> ìœ„ì¹˜ ì´ë™, í´ë¦­í•˜ì—¬ ìŠ¤íƒ¯/ëª¬ìŠ¤í„°ë¥¼ ì„¤ì •í•˜ì„¸ìš”.
        </div>
      </div>

      <div style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '20px', overflow: 'hidden' }}>
        <div 
            ref={containerRef}
            onPointerMove={handlePointerMove}
            style={{ 
              position: 'relative', width: '100%', maxWidth: '700px', aspectRatio: '1/1',
              border: '1px solid #30363d', borderRadius: '12px', overflow: 'hidden',
              boxShadow: '0 0 50px rgba(0,0,0,0.5)', touchAction: 'none' 
            }}
        >
          <SpectateMap />

          {/* íƒ€ì›Œ */}
          {renderTowers('blue')}
          {renderTowers('red')}

          {/* ê±°ì‹ ë³‘ & ì£¼ì‹œì */}
          <DraggableObject objKey="colossus" x={positions.colossus.x} y={positions.colossus.y} size={40} color="#a658ff" label="ê±°ì‹ ë³‘" title="ê±°ì‹ ë³‘" icon={<Skull/>} />
          <DraggableObject objKey="watcher" x={positions.watcher.x} y={positions.watcher.y} size={40} color="#e67e22" label="ì£¼ì‹œì" title="ì£¼ì‹œì" icon={<Zap/>} />

          {/* ì •ê¸€ 4ê³³ */}
          {positions.jungle.map((pos, idx) => (
             <DraggableObject 
                key={`jungle.${idx}`} 
                objKey={`jungle.${idx}`} 
                x={pos.x} y={pos.y} 
                size={28} color="#2ecc71" icon={<Ghost/>} 
                label={idx < 2 ? (idx === 0 ? "ì‹¬ì—°(Top)" : "ì‹¬ì—°(Bot)") : undefined}
                title="ì •ê¸€ ìº í”„"
                isJungle={true}
                jungleType={jungleTypes[idx]}
             />
          ))}

        </div>
      </div>

      {editingTarget && (
        <BattlefieldPatchModal 
          targetKey={editingTarget.key} 
          title={editingTarget.title} 
          color={editingTarget.color} 
          onClose={() => setEditingTarget(null)} 
        />
      )}

      {jungleModal && (
        <JunglePatchModal 
            campType={jungleModal} 
            onClose={() => setJungleModal(null)} 
        />
      )}
    </div>
  );
};


--- FILE: src/components/battle/SpectateMap.tsx ---
import React from 'react';
import { useGameStore } from '../../store/useGameStore';

export const SpectateMap: React.FC = () => {
  const { gameState } = useGameStore();
  
  // ì—…ë¡œë“œëœ ë§µ ì´ë¯¸ì§€ê°€ ìˆëŠ”ì§€ í™•ì¸ ('map_bg' í‚¤ ì‚¬ìš©)
  const mapImage = gameState.customImages?.['map_bg'];

  return (
    <div style={{
      position: 'absolute',
      inset: 0,
      background: '#0a0f0a', // ê¸°ë³¸ ë°°ê²½ìƒ‰ (ì´ë¯¸ì§€ ì—†ì„ ë•Œ)
      overflow: 'hidden',
      zIndex: 0
    }}>
      {/* 1. ë§µ ë°°ê²½ ì´ë¯¸ì§€ ë ˆì´ì–´ */}
      {mapImage ? (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundImage: `url(${mapImage})`,
          backgroundSize: '100% 100%', // ë§µì„ ê½‰ ì±„ì›€
          backgroundPosition: 'center',
          backgroundRepeat: 'no-repeat',
          opacity: 0.8, // ìœ ë‹› ì‹œì¸ì„±ì„ ìœ„í•´ ì•½ê°„ ì–´ë‘¡ê²Œ
          filter: 'contrast(1.1) saturate(1.1)' // ê²Œì„ ëŠë‚Œ ë³´ì •
        }} />
      ) : (
        /* ì´ë¯¸ì§€ê°€ ì—†ì„ ë•Œ ë³´ì—¬ì¤„ ê¸°ë³¸ ê²©ì íŒ¨í„´ */
        <div style={{
          width: '100%', height: '100%',
          backgroundImage: 'linear-gradient(#1a1a1c 1px, transparent 1px), linear-gradient(90deg, #1a1a1c 1px, transparent 1px)',
          backgroundSize: '5% 5%',
          opacity: 0.3
        }} />
      )}

      {/* 2. ë¼ì¸ ê°€ì´ë“œ (ì´ë¯¸ì§€ê°€ ìˆì–´ë„ í¬ë¯¸í•˜ê²Œ í‘œì‹œí•˜ì—¬ ê²½ë¡œ í™•ì¸) */}
      <svg width="100%" height="100%" viewBox="0 0 100 100" style={{ position: 'absolute', top: 0, left: 0, opacity: mapImage ? 0.15 : 0.4, pointerEvents:'none' }}>
        <defs>
          <linearGradient id="riverGrad" x1="0%" y1="100%" x2="100%" y2="0%">
            <stop offset="0%" stopColor="#3498db" stopOpacity="0" />
            <stop offset="50%" stopColor="#3498db" stopOpacity="0.5" />
            <stop offset="100%" stopColor="#3498db" stopOpacity="0" />
          </linearGradient>
        </defs>
        
        {/* ê°• (River) */}
        <line x1="0" y1="100" x2="100" y2="0" stroke="url(#riverGrad)" strokeWidth="8" />

        {/* ë¼ì¸ ê²½ë¡œ */}
        <g stroke="rgba(255,255,255,0.3)" strokeWidth="0.5" fill="none" strokeDasharray="2,2">
          {/* TOP */}
          <path d="M 5 95 L 5 20 Q 5 5 20 5 L 95 5" />
          {/* MID */}
          <line x1="5" y1="95" x2="95" y2="5" /> 
          {/* BOT */}
          <path d="M 5 95 L 80 95 Q 95 95 95 80 L 95 5" />
        </g>

        {/* ë³¸ì§„ êµ¬ì—­ í‘œì‹œ */}
        <circle cx="5" cy="95" r="3" fill="#58a6ff" fillOpacity="0.2" />
        <circle cx="95" cy="5" r="3" fill="#e84057" fillOpacity="0.2" />
      </svg>
    </div>
  );
};


--- FILE: src/components/battle/dashboard/GlobalBattleStats.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/dashboard/GlobalBattleStats.tsx
// ==========================================
import React from 'react';
import { Activity } from 'lucide-react';

const StatBox = ({ label, value, color, align }: any) => (
  <div style={{ textAlign: align || 'left' }}>
    <div style={{ fontSize: '10px', color: '#8b949e', marginBottom: '2px' }}>{label}</div>
    <div style={{ fontSize: '16px', fontWeight: 'bold', color: color || '#fff', fontFamily: 'JetBrains Mono' }}>{value}</div>
  </div>
);

export const GlobalBattleStats = ({ stats, isMobile }: any) => {
  const total = stats.totalMatches || 1;
  const redWinRate = ((stats.izmanWins / total) * 100).toFixed(1);
  const blueWinRate = ((stats.danteWins / total) * 100).toFixed(1);
  return (
    <div style={{ background: '#161b22', padding: '20px', borderRadius: '16px', border: '1px solid #30363d', boxShadow: '0 10px 30px -10px rgba(0,0,0,0.5)' }}>
      <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:'15px', fontSize:'12px', color:'#8b949e', fontWeight:'bold' }}>
        <div style={{ display:'flex', alignItems:'center', gap:'6px' }}><Activity size={14}/> ì‹œë®¬ë ˆì´ì…˜ ì§‘ê³„</div>
        <div>ì´ {total.toLocaleString()} ë§¤ì¹˜ ë¶„ì„ë¨</div>
      </div>
      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '8px' }}>
        <span style={{ color: '#ff4d4d', fontWeight: '900', fontSize: '18px' }}>{redWinRate}%</span>
        <span style={{ color: '#555', fontSize: '12px', fontWeight: 'bold' }}>WIN RATE</span>
        <span style={{ color: '#4d94ff', fontWeight: '900', fontSize: '18px' }}>{blueWinRate}%</span>
      </div>
      <div style={{ width: '100%', height: '12px', background: '#21262d', borderRadius: '6px', overflow: 'hidden', display: 'flex', marginBottom:'20px' }}>
        <div style={{ width: `${redWinRate}%`, background: 'linear-gradient(90deg, #8a1c1c, #ff4d4d)', height: '100%' }}></div>
        <div style={{ width: '2px', background: '#000' }}></div>
        <div style={{ flex: 1, background: 'linear-gradient(90deg, #4d94ff, #1c4b8a)', height: '100%' }}></div>
      </div>
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1px 1fr', gap: '10px', alignItems: 'center' }}>
        <div style={{ display: 'flex', justifyContent: 'space-around' }}>
          <StatBox label="í‰ê·  KDA" value={stats.izmanAvgKills} color="#ff4d4d" align="center" />
          <StatBox label="ìŠ¹ë¦¬" value={stats.izmanWins} color="#ff4d4d" align="center" />
        </div>
        <div style={{ width: '1px', height: '30px', background: '#30363d' }}></div>
        <div style={{ display: 'flex', justifyContent: 'space-around' }}>
          <StatBox label="ìŠ¹ë¦¬" value={stats.danteWins} color="#4d94ff" align="center" />
          <StatBox label="í‰ê·  KDA" value={stats.danteAvgKills} color="#4d94ff" align="center" />
        </div>
      </div>
    </div>
  );
};


--- FILE: src/components/battle/dashboard/GodPanel.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/dashboard/GodPanel.tsx
// ==========================================
import React, { useState } from 'react';
import { useGameStore } from '../../../store/useGameStore';
import { GameIcon } from '../../common/GameIcon';
import { Crown, Camera, Crosshair, Shield, Heart, Monitor, Users } from 'lucide-react';
import { MinionCard } from './MinionCard';

const CustomSlider = ({ label, icon, value, min, max, step, onChange, color, suffix }: any) => (
  <div>
    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
      <div style={{ display: 'flex', alignItems: 'center', gap: '8px', color: '#ccc', fontSize: '12px', fontWeight:'bold' }}>{icon} {label}</div>
      <span style={{ color: color, fontFamily: 'JetBrains Mono', fontWeight: '800', fontSize: '14px', background:`${color}11`, padding:'2px 6px', borderRadius:'4px' }}>
        {suffix === 'x' ? 'x' : ''}{value.toLocaleString()}{suffix !== 'x' ? suffix : ''}
      </span>
    </div>
    <div style={{ position: 'relative', display: 'flex', alignItems: 'center' }}>
      <input type="range" min={min} max={max} step={step} value={value} onChange={(e)=>onChange(parseFloat(e.target.value))} style={{ width: '100%', accentColor: color, height: '6px', cursor: 'pointer', background: '#1c1c1f', borderRadius: '3px', outline: 'none' }} />
    </div>
  </div>
);

const SectionLabel = ({ icon, label, color }: any) => (
  <div style={{ display: 'flex', alignItems: 'center', gap: '6px', fontSize: '10px', fontWeight: '800', color: color, letterSpacing: '1px' }}>
    {icon} {label}
  </div>
);

const TechInput = ({ label, value, onChange, icon, unit }: any) => (
  <div style={{ background: '#0d1117', borderRadius: '12px', border: '1px solid #30363d', padding: '12px 15px', display: 'flex', flexDirection: 'column', gap: '6px', transition: 'all 0.2s' }}
  onMouseEnter={e => e.currentTarget.style.borderColor = '#58a6ff'} onMouseLeave={e => e.currentTarget.style.borderColor = '#30363d'}>
    <div style={{ display: 'flex', alignItems: 'center', gap: '6px', fontSize: '11px', color: '#8b949e', fontWeight:'600' }}>{icon} {label}</div>
    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
      <input type="number" value={value} onChange={(e)=>onChange(Number(e.target.value))} style={{ background: 'none', border: 'none', color: '#fff', fontSize: '18px', fontWeight: '800', outline: 'none', width: '100%', fontFamily: 'JetBrains Mono' }} />
      {unit && <span style={{ fontSize: '10px', color: '#555', fontWeight: 'bold' }}>{unit}</span>}
    </div>
  </div>
);

export const GodPanel = ({ side, settings, color, glowColor, onChange, icon }: any) => {
  const isRed = side === 'RED';
  const { setCustomImage } = useGameStore();
  const godId = isRed ? 'god_izman' : 'god_dante';
  const [isCrownHover, setIsCrownHover] = useState(false);

  const handleUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if(file) {
        const reader = new FileReader();
        reader.onloadend = () => { if(typeof reader.result === 'string') setCustomImage(godId, reader.result); };
        reader.readAsDataURL(file);
    }
  };

  return (
    <div style={{ background: 'linear-gradient(145deg, #121418 0%, #0d1117 100%)', borderRadius: '24px', border: `1px solid ${isRed ? '#4a1e1e' : '#1e3a5f'}`, boxShadow: `0 20px 40px rgba(0,0,0,0.3), inset 0 0 60px ${glowColor}`, overflow: 'hidden' }}>
      <div style={{ padding: '25px', borderBottom: `1px solid ${color}22`, display: 'flex', justifyContent: 'space-between', alignItems: 'center', background: `linear-gradient(90deg, ${color}11, transparent)` }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '20px' }}>
          <div style={{ position: 'relative' }}>
            <GameIcon id={godId} size={64} fallback={icon} border={`2px solid ${color}44`} shape="rounded" />
          </div>
          <div>
            <div style={{ display:'flex', alignItems:'center', gap:'8px', marginBottom:'4px' }}>
              <span style={{ fontSize: '10px', fontWeight: '900', color: '#fff', background: color, padding:'2px 8px', borderRadius:'10px' }}>
                {side} FACTION
              </span>
            </div>
            <h3 style={{ margin: 0, fontSize: '24px', fontWeight: '900', color: '#fff', letterSpacing:'-0.5px' }}>{settings.name}</h3>
          </div>
        </div>
        <div onMouseEnter={() => setIsCrownHover(true)} onMouseLeave={() => setIsCrownHover(false)} style={{ position: 'relative' }}>
          <label style={{ cursor: 'pointer', display:'flex', alignItems:'center', justifyContent:'center' }}>
            {isCrownHover && <span style={{ position: 'absolute', right: '45px', fontSize: '11px', color: color, fontWeight: 'bold', whiteSpace: 'nowrap', background: '#161b22', padding: '4px 8px', borderRadius: '4px', border: `1px solid ${color}44` }}>ì‚¬ì§„ ë³€ê²½</span>}
            <Crown size={32} color={color} style={{ opacity: isCrownHover ? 1 : 0.3, transform: isCrownHover ? 'scale(1.1) rotate(15deg)' : 'rotate(15deg)', transition: 'all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275)' }} />
            <div style={{ position: 'absolute', bottom: -2, right: -2, background: '#161b22', borderRadius: '50%', padding: '3px', border: `1px solid ${color}44`, opacity: isCrownHover ? 1 : 0.5 }}><Camera size={10} color={color}/></div>
            <input type="file" style={{display:'none'}} accept="image/*" onChange={handleUpload}/>
          </label>
        </div>
      </div>
      <div style={{ padding: '25px', display: 'flex', flexDirection: 'column', gap: '30px' }}>
        <div style={{ display: 'flex', flexDirection: 'column', gap: '20px' }}>
          <CustomSlider label="ì „íˆ¬ ê³µê²©ë ¥ ë³´ì •" icon={<Crosshair size={14}/>} value={settings.atkRatio} min={0.5} max={2.0} step={0.01} onChange={(v: number)=>onChange('atkRatio', v)} color={color} suffix="x" />
          <CustomSlider label="ë°©ì–´/ì²´ë ¥ íš¨ìœ¨" icon={<Shield size={14}/>} value={settings.defRatio} min={0.5} max={2.0} step={0.01} onChange={(v: number)=>onChange('defRatio', v)} color={color} suffix="x" />
          <CustomSlider label="ë„¥ì„œìŠ¤ ìµœëŒ€ ë‚´êµ¬ë„" icon={<Heart size={14}/>} value={settings.hpRatio} min={5000} max={50000} step={1000} onChange={(v: number)=>onChange('hpRatio', v)} color={color} />
        </div>
        <div style={{ height: '1px', background: '#30363d' }} />
        <div>
          <SectionLabel icon={<Monitor size={12}/>} label="STRUCTURAL INTEGRITY" color="#8b949e" />
          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px', marginTop:'10px' }}>
            <TechInput label="ìˆ˜í˜¸ì ìƒëª…ë ¥" value={settings.guardianHp} onChange={(v: number)=>onChange('guardianHp', v)} icon={<Crown size={14} color={color}/>} unit="HP" />
            <TechInput label="ë°©ì–´ íƒ€ì›Œ ìœ„ë ¥" value={settings.towerAtk} onChange={(v: number)=>onChange('towerAtk', v)} icon={<Crosshair size={14} color={color}/>} unit="DMG" />
          </div>
        </div>
        <div>
          <SectionLabel icon={<Users size={12}/>} label="MINION WAVES" color="#8b949e" />
          <div style={{ marginTop:'10px' }}>
            {settings.minions && (
              <>
                <MinionCard type="melee" data={settings.minions.melee} color={color} onChange={(t: string, f: string, v: number) => onChange('minions', { ...settings.minions, [t]: { ...settings.minions[t], [f]: v } })} />
                <MinionCard type="ranged" data={settings.minions.ranged} color={color} onChange={(t: string, f: string, v: number) => onChange('minions', { ...settings.minions, [t]: { ...settings.minions[t], [f]: v } })} />
                <MinionCard type="siege" data={settings.minions.siege} color={color} onChange={(t: string, f: string, v: number) => onChange('minions', { ...settings.minions, [t]: { ...settings.minions[t], [f]: v } })} />
              </>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};


--- FILE: src/components/battle/dashboard/MinionCard.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/dashboard/MinionCard.tsx
// ==========================================
import React from 'react';
import { Sword, Shield, Heart, Zap, Crosshair, Coins } from 'lucide-react';

const MiniInput = ({ label, icon, value, onChange }: any) => (
  <div style={{ background: '#0d1117', border: '1px solid #30363d', borderRadius: '4px', padding: '4px 8px', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
    <div style={{ display: 'flex', alignItems: 'center', gap: '4px', fontSize: '10px', color: '#888' }}>{icon} {label}</div>
    <input type="number" value={value} onChange={(e) => onChange(Number(e.target.value))} style={{ width: '40px', background: 'transparent', border: 'none', color: '#fff', fontSize: '11px', fontWeight: 'bold', textAlign: 'right', outline: 'none', padding: 0 }} />
  </div>
);

export const MinionCard = ({ type, data, onChange, color }: any) => {
  let typeIcon = <Sword size={14} />;
  let typeLabel = "ê·¼ê±°ë¦¬";
  if (type === 'ranged') { typeIcon = <Crosshair size={14}/>; typeLabel = "ì›ê±°ë¦¬"; }
  if (type === 'siege') { typeIcon = <Shield size={14}/>; typeLabel = "ê³µì„±"; }

  return (
    <div style={{ background: 'rgba(0,0,0,0.3)', border: `1px solid ${color}33`, borderRadius: '8px', padding: '10px', marginBottom: '10px' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px', borderBottom:`1px dashed ${color}33`, paddingBottom:'5px' }}>
        <div style={{ fontWeight: 'bold', color: color, fontSize: '13px', display:'flex', alignItems:'center', gap:'6px' }}>{typeIcon} {data.label}</div>
        <span style={{ fontSize: '10px', color: '#666', background:'rgba(255,255,255,0.05)', padding:'2px 6px', borderRadius:'4px' }}>{typeLabel} TYPE</span>
      </div>
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '8px', marginBottom:'8px' }}>
        <MiniInput label="ì²´ë ¥" icon={<Heart size={10} color="#2ecc71"/>} value={data.hp} onChange={(v:number) => onChange(type, 'hp', v)} />
        <MiniInput label="ë°©ì–´" icon={<Shield size={10} color="#3498db"/>} value={data.def} onChange={(v:number) => onChange(type, 'def', v)} />
        <MiniInput label="ê³µê²©" icon={<Sword size={10} color="#e74c3c"/>} value={data.atk} onChange={(v:number) => onChange(type, 'atk', v)} />
      </div>
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
        <MiniInput label="ê³¨ë“œ" icon={<Coins size={10} color="#f1c40f"/>} value={data.gold} onChange={(v:number) => onChange(type, 'gold', v)} />
        <MiniInput label="ê²½í—˜ì¹˜" icon={<Zap size={10} color="#9b59b6"/>} value={data.xp} onChange={(v:number) => onChange(type, 'xp', v)} />
      </div>
    </div>
  );
};


--- FILE: src/components/battle/dashboard/SiegeSettingsPanel.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/dashboard/SiegeSettingsPanel.tsx
// ==========================================
import React from 'react';
import { Hammer, Target, Skull } from 'lucide-react';
import { useGameStore } from '../../../store/useGameStore';

export const SiegeSettingsPanel: React.FC = () => {
  const { gameState, updateBattleSettings } = useGameStore();
  
  // [ìˆ˜ì •] ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ë¹ˆ ê°ì²´ë¡œ ì²˜ë¦¬í•˜ê³  ì•„ë˜ì—ì„œ ê°œë³„ì ìœ¼ë¡œ ê¸°ë³¸ê°’ í• ë‹¹
  const rawSiege = gameState.battleSettings.siege || {};

  // [ì•ˆì „ì¥ì¹˜] ê°’ì´ ì—†ê±°ë‚˜ NaNì´ë©´ ê¸°ë³¸ê°’ ì‚¬ìš© (?? ì—°ì‚°ì í™œìš©)
  const siege = {
    minionDmg: rawSiege.minionDmg ?? 1.0,
    cannonDmg: rawSiege.cannonDmg ?? 1.0,
    superDmg: rawSiege.superDmg ?? 1.0,
    
    dmgToHero: rawSiege.dmgToHero ?? 1.0,
    dmgToT1: rawSiege.dmgToT1 ?? 0.3,
    dmgToT2: rawSiege.dmgToT2 ?? 0.25,
    dmgToT3: rawSiege.dmgToT3 ?? 0.2,
    dmgToNexus: rawSiege.dmgToNexus ?? 0.1,

    colossusToHero: rawSiege.colossusToHero ?? 1.0,
    colossusToT1: rawSiege.colossusToT1 ?? 0.4,
    colossusToT2: rawSiege.colossusToT2 ?? 0.35,
    colossusToT3: rawSiege.colossusToT3 ?? 0.3,
    colossusToNexus: rawSiege.colossusToNexus ?? 0.15
  };

  const handleChange = (field: string, value: number) => {
    // ê¸°ì¡´ ê°’ ìœ ì§€í•˜ë©´ì„œ ì—…ë°ì´íŠ¸
    updateBattleSettings({ 
        siege: { ...siege, [field]: value } 
    } as any);
  };

  const CustomSlider = ({ label, value, onChange, max = 2 }: { label: string, value: number, onChange: (v: number) => void, max?: number }) => {
    // í•œë²ˆ ë” ì•ˆì „ì¥ì¹˜: valueê°€ ìˆ«ìê°€ ì•„ë‹ˆë©´ 0 ì²˜ë¦¬
    const safeValue = isNaN(value) ? 0 : value;
    
    return (
      <div style={{ marginBottom: '15px' }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '6px', fontSize: '11px', color: '#ccc' }}>
          <span>{label}</span>
          <span style={{ fontWeight: 'bold', color: '#f1c40f', fontFamily: 'monospace' }}>{(safeValue * 100).toFixed(0)}%</span>
        </div>
        <input 
          type="range" min={0} max={max} step={0.05} 
          value={safeValue} onChange={(e) => onChange(parseFloat(e.target.value))} 
          style={{ width: '100%', accentColor: '#f1c40f', height: '6px', cursor: 'pointer', background: '#30363d', borderRadius: '3px' }} 
        />
      </div>
    );
  };

  return (
    <div style={{ background: '#1c1c1f', padding: '20px', borderRadius: '16px', border: '1px solid #30363d', marginTop: '20px' }}>
      <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '20px', color: '#fff', fontSize: '14px', fontWeight: 'bold', borderBottom:'1px solid #333', paddingBottom:'10px' }}>
        <Hammer size={16} color="#f1c40f" />
        <span>ê³µì„±/í•˜ìˆ˜ì¸ ìƒì„¸ ë°ë¯¸ì§€ ì„¤ì •</span>
      </div>
      
      {/* 1. ê³µê²©ì íƒ€ì… */}
      <div style={{ marginBottom:'25px' }}>
        <div style={{ fontSize:'12px', color:'#58a6ff', fontWeight:'bold', marginBottom:'10px' }}>[ê³µê²©ì] í•˜ìˆ˜ì¸ ì¢…ë¥˜ë³„ ê¸°ë³¸ íŒŒì›Œ</div>
        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '20px' }}>
            <CustomSlider label="ì¼ë°˜ ë¯¸ë‹ˆì–¸" value={siege.minionDmg} onChange={(v) => handleChange('minionDmg', v)} />
            <CustomSlider label="ëŒ€í¬ ë¯¸ë‹ˆì–¸" value={siege.cannonDmg} onChange={(v) => handleChange('cannonDmg', v)} />
            <CustomSlider label="ê±°ì‹ ë³‘ (ì†Œí™˜)" value={siege.superDmg} onChange={(v) => handleChange('superDmg', v)} />
        </div>
      </div>

      {/* 2. ì¼ë°˜ ë¯¸ë‹ˆì–¸ ëŒ€ìƒ ê³„ìˆ˜ */}
      <div style={{ marginBottom:'25px' }}>
        <div style={{ fontSize:'12px', color:'#da3633', fontWeight:'bold', marginBottom:'10px', display:'flex', gap:'5px', alignItems:'center' }}>
            <Target size={12}/> [ë¯¸ë‹ˆì–¸] ëŒ€ìƒë³„ ë°ë¯¸ì§€ ë¹„ìœ¨
        </div>
        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr 1fr 1fr', gap: '15px' }}>
            <CustomSlider label="vs ì˜ì›…" value={siege.dmgToHero} onChange={(v) => handleChange('dmgToHero', v)} />
            <CustomSlider label="vs 1ì°¨" value={siege.dmgToT1} onChange={(v) => handleChange('dmgToT1', v)} />
            <CustomSlider label="vs 2ì°¨" value={siege.dmgToT2} onChange={(v) => handleChange('dmgToT2', v)} />
            <CustomSlider label="vs 3ì°¨" value={siege.dmgToT3} onChange={(v) => handleChange('dmgToT3', v)} />
            <CustomSlider label="vs ìˆ˜í˜¸ì" value={siege.dmgToNexus} onChange={(v) => handleChange('dmgToNexus', v)} />
        </div>
      </div>

      {/* 3. ê±°ì‹ ë³‘ ì „ìš© ëŒ€ìƒ ê³„ìˆ˜ */}
      <div>
        <div style={{ fontSize:'12px', color:'#9b59b6', fontWeight:'bold', marginBottom:'10px', display:'flex', gap:'5px', alignItems:'center' }}>
            <Skull size={12}/> [ê±°ì‹ ë³‘] ëŒ€ìƒë³„ ë°ë¯¸ì§€ ë¹„ìœ¨
        </div>
        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr 1fr 1fr', gap: '15px' }}>
            <CustomSlider label="vs ì˜ì›…" value={siege.colossusToHero} onChange={(v) => handleChange('colossusToHero', v)} />
            <CustomSlider label="vs 1ì°¨" value={siege.colossusToT1} onChange={(v) => handleChange('colossusToT1', v)} />
            <CustomSlider label="vs 2ì°¨" value={siege.colossusToT2} onChange={(v) => handleChange('colossusToT2', v)} />
            <CustomSlider label="vs 3ì°¨" value={siege.colossusToT3} onChange={(v) => handleChange('colossusToT3', v)} />
            <CustomSlider label="vs ìˆ˜í˜¸ì" value={siege.colossusToNexus} onChange={(v) => handleChange('colossusToNexus', v)} />
        </div>
      </div>
      
      <div style={{ fontSize: '11px', color: '#8b949e', marginTop: '15px', textAlign:'center' }}>
        * ìµœì¢… ë°ë¯¸ì§€ = (ê³µê²©ë ¥) Ã— (ê³µê²©ì ê³„ìˆ˜) Ã— (ëŒ€ìƒ ê³„ìˆ˜)
      </div>
    </div>
  );
};


--- FILE: src/components/battle/jungle/DraggableMob.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/jungle/DraggableMob.tsx
// ==========================================
import React, { useRef } from 'react';
import { JungleSpot } from './JungleSpot';

interface Props {
  spotId: string;
  x: number;
  y: number;
  name: string;
  isBuff: boolean;
  isSelected: boolean;
  isDragging: boolean;
  dragPos: { x: number, y: number };
  onSelect: () => void;
  onDragStart: (spotId: string, clientX: number, clientY: number) => void;
}

export const DraggableMob: React.FC<Props> = ({ 
  spotId, x, y, name, isBuff, isSelected, isDragging, dragPos, onSelect, onDragStart 
}) => {
  const longPressTimer = useRef<NodeJS.Timeout | null>(null);
  const isMoved = useRef(false);

  // í˜„ì¬ í‘œì‹œë  ìœ„ì¹˜ (ë“œë˜ê·¸ ì¤‘ì´ë©´ dragPos, ì•„ë‹ˆë©´ ì›ë˜ ì¢Œí‘œ)
  const displayX = isDragging ? dragPos.x : x;
  const displayY = isDragging ? dragPos.y : y;

  const handlePointerDown = (e: React.PointerEvent) => {
    // ì´ë²¤íŠ¸ ë²„ë¸”ë§ ë§‰ì•„ì„œ ë§µ ìŠ¤í¬ë¡¤ê³¼ ê°„ì„­ ë°©ì§€
    e.stopPropagation();
    e.currentTarget.setPointerCapture(e.pointerId);
    
    isMoved.current = false;

    // 0.2ì´ˆ ì´ìƒ ëˆ„ë¥´ë©´ ë“œë˜ê·¸ ì‹œì‘ìœ¼ë¡œ ê°„ì£¼
    longPressTimer.current = setTimeout(() => {
      onDragStart(spotId, e.clientX, e.clientY);
    }, 200);
  };

  const handlePointerUp = (e: React.PointerEvent) => {
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current);
      longPressTimer.current = null;
      
      // ë“œë˜ê·¸ê°€ ì‹œì‘ë˜ì§€ ì•Šì•˜ê³ , ì›€ì§ì´ì§€ ì•Šì•˜ë‹¤ë©´ 'í´ë¦­(ì„ íƒ)'ìœ¼ë¡œ ê°„ì£¼
      if (!isDragging && !isMoved.current) {
        onSelect();
      }
    }
    e.currentTarget.releasePointerCapture(e.pointerId);
  };

  const handlePointerMove = () => {
    // ì•„ì£¼ ë¯¸ì„¸í•œ ì›€ì§ì„ì€ ë¬´ì‹œí•˜ë„ë¡ í•  ìˆ˜ ìˆìœ¼ë‚˜, ì—¬ê¸°ì„  ë‹¨ìˆœí™”
    isMoved.current = true;
  };

  return (
    <div
      onPointerDown={handlePointerDown}
      onPointerUp={handlePointerUp}
      onPointerMove={handlePointerMove}
      style={{
        position: 'absolute',
        left: `${displayX}%`,
        top: `${displayY}%`,
        transform: 'translate(-50%, -50%)',
        zIndex: isDragging ? 100 : 10,
        // ë“œë˜ê·¸ ì¤‘ì´ ì•„ë‹ˆë©´ ìŠ¤í¬ë¡¤ í—ˆìš©, ëª¹ ìì²´ëŠ” í„°ì¹˜ ì•¡ì…˜ ë§‰ìŒ
        touchAction: 'none', 
        cursor: isDragging ? 'grabbing' : 'pointer'
      }}
    >
      <JungleSpot 
        x={0} y={0} // ì¢Œí‘œëŠ” ìƒìœ„ divê°€ ì œì–´í•¨
        name={name}
        isBuff={isBuff}
        isSelected={isSelected}
        onClick={() => {}} // Pointer ì´ë²¤íŠ¸ë¡œ í†µí•© ì²˜ë¦¬í•˜ë¯€ë¡œ ë¹ˆ í•¨ìˆ˜
      />
      {isDragging && (
        <div style={{
          position:'absolute', top:'-30px', left:'50%', transform:'translateX(-50%)',
          background:'#58a6ff', color:'#000', fontSize:'10px', fontWeight:'bold',
          padding:'2px 6px', borderRadius:'4px', whiteSpace:'nowrap', pointerEvents:'none'
        }}>
          ì´ë™ ì¤‘
        </div>
      )}
    </div>
  );
};


--- FILE: src/components/battle/jungle/JungleCampMap.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/jungle/JungleCampMap.tsx
// ==========================================
import React, { useRef } from 'react';
import { JungleCampConfig } from '../../../types/jungle';
import { JungleSpot } from './JungleSpot';
import { useGameStore } from '../../../store/useGameStore';

interface Props {
  config: JungleCampConfig;
  selectedSpotId: string | null;
  onSelectSpot: (spotId: string) => void;
  onDragStart: (spotId: string, x: number, y: number) => void;
  dragTargetId: string | null;
  dragPos: { x: number, y: number };
}

// ì¹´ë©”ë¼ ì¤‘ì‹¬ì  (ë°°ê²½ ì´ë¯¸ì§€ ìœ„ì¹˜ ë§ì¶¤)
const CAMP_CENTERS: Record<string, {x: number, y: number}> = {
  'TOP_BLUE': { x: 22, y: 38 },
  'BOT_BLUE': { x: 38, y: 77 },
  'TOP_RED':  { x: 63, y: 22 },
  'BOT_RED':  { x: 77, y: 62 }  
};

export const JungleCampMap: React.FC<Props> = ({ config, selectedSpotId, onSelectSpot, onDragStart, dragTargetId, dragPos }) => {
  const { gameState } = useGameStore();
  const mapImage = gameState.customImages?.['map_bg'];
  const center = CAMP_CENTERS[config.id] || { x: 50, y: 50 };

  const containerRef = useRef<HTMLDivElement>(null);
  const longPressTimer = useRef<NodeJS.Timeout | null>(null);
  const startTouchPos = useRef<{x: number, y: number} | null>(null);

  // [ìˆ˜ì •] ë“œë˜ê·¸ ì‹œì‘ ë¡œì§ ê°•í™”
  const handleSpotDown = (spotId: string, e: React.PointerEvent | React.TouchEvent) => {
    // ì´ë²¤íŠ¸ ì „íŒŒ ë°©ì§€ (ìƒìœ„ ìŠ¤í¬ë¡¤ ë§‰ê¸°)
    e.stopPropagation();
    
    let clientX, clientY;
    if ('touches' in e) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else {
        clientX = (e as React.PointerEvent).clientX;
        clientY = (e as React.PointerEvent).clientY;
    }

    startTouchPos.current = { x: clientX, y: clientY };

    if (longPressTimer.current) clearTimeout(longPressTimer.current);

    // 0.2ì´ˆ ê¾¹ ëˆ„ë¥´ë©´ ë“œë˜ê·¸ ì‹œì‘ (ì‹œê°„ ì•½ê°„ ëŠ˜ë ¤ì„œ ì˜¤ë™ì‘ ë°©ì§€)
    longPressTimer.current = setTimeout(() => {
        // ë“œë˜ê·¸ ì‹œì‘ ì‹œ í˜„ì¬ ì¢Œí‘œë¡œ ì´ˆê¸°í™”
        if (containerRef.current) {
            const rect = containerRef.current.getBoundingClientRect();
            const x = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
            const y = Math.max(0, Math.min(100, ((clientY - rect.top) / rect.height) * 100));
            onDragStart(spotId, x, y);
        }
        startTouchPos.current = null; // ë“œë˜ê·¸ ëª¨ë“œ ì§„ì… ì™„ë£Œ
    }, 200); 
  };

  // [ìˆ˜ì •] í„°ì¹˜ ì´ë™ ì¤‘ ë¡œì§ (ë¯¼ê°ë„ ì™„í™”)
  const handleMove = (clientX: number, clientY: number) => {
    // 1. ë¡±í”„ë ˆìŠ¤ ëŒ€ê¸° ì¤‘ì¼ ë•Œ (ì•„ì§ ë“œë˜ê·¸ ì‹œì‘ ì•ˆí•¨)
    if (longPressTimer.current && startTouchPos.current) {
        const moveDist = Math.sqrt(
            Math.pow(clientX - startTouchPos.current.x, 2) + 
            Math.pow(clientY - startTouchPos.current.y, 2)
        );
        // 15px ì´ìƒ ì›€ì§ì´ë©´ 'ìŠ¤í¬ë¡¤' ì˜ë„ë¡œ ê°„ì£¼í•˜ê³  íƒ€ì´ë¨¸ ì·¨ì†Œ
        if (moveDist > 15) { 
            clearTimeout(longPressTimer.current);
            longPressTimer.current = null;
            startTouchPos.current = null;
        }
        return;
    }

    // 2. ì´ë¯¸ ë“œë˜ê·¸ ì¤‘ì¼ ë•Œ (ì¢Œí‘œ ì—…ë°ì´íŠ¸)
    if (dragTargetId && containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        // ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šê²Œ í´ë¨í•‘ (5% ~ 95%)
        const x = Math.max(5, Math.min(95, ((clientX - rect.left) / rect.width) * 100));
        const y = Math.max(5, Math.min(95, ((clientY - rect.top) / rect.height) * 100));
        
        // onDragStartë¥¼ ì¬í™œìš©í•˜ì—¬ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ìƒìœ„ ì»´í¬ë„ŒíŠ¸ state ê°±ì‹ )
        onDragStart(dragTargetId, x, y);
    }
  };

  const onPointerMove = (e: React.PointerEvent) => {
      e.preventDefault();
      handleMove(e.clientX, e.clientY);
  };
  
  const onTouchMove = (e: React.TouchEvent) => {
      // í„°ì¹˜ ìŠ¤í¬ë¡¤ ë°©ì§€ (ë“œë˜ê·¸ ì¤‘ì¼ ë•Œë§Œ)
      if (dragTargetId) e.preventDefault();
      handleMove(e.touches[0].clientX, e.touches[0].clientY);
  };

  const handleEnd = () => {
    if (longPressTimer.current) {
        clearTimeout(longPressTimer.current);
        longPressTimer.current = null;
    }
    startTouchPos.current = null;
    // ë“œë˜ê·¸ ì¢…ë£Œ ì²˜ë¦¬ëŠ” ìƒìœ„ ì»´í¬ë„ŒíŠ¸(JunglePatchModal)ì˜ onPointerUpì—ì„œ ìˆ˜í–‰ë¨
  };

  return (
    <div 
      ref={containerRef}
      onPointerMove={onPointerMove}
      onTouchMove={onTouchMove}
      onPointerUp={handleEnd}
      onPointerLeave={handleEnd}
      onTouchEnd={handleEnd}
      onContextMenu={(e) => e.preventDefault()}
      style={{ 
        position: 'relative', width: '100%', height: '100%', 
        background: '#15191f', 
        border: '2px solid #30363d', borderRadius: '12px',
        overflow: 'hidden', boxShadow: 'inset 0 0 30px rgba(0,0,0,0.8)',
        touchAction: 'none', // ë§µ ë‚´ë¶€ì—ì„œëŠ” ë¸Œë¼ìš°ì € ìŠ¤í¬ë¡¤ ë¹„í™œì„±í™” (ë“œë˜ê·¸ ìš°ì„ )
        userSelect: 'none',
        WebkitUserSelect: 'none'
      }}
    >
      {mapImage ? (
        <div style={{
          position: 'absolute', inset: 0,
          backgroundImage: `url(${mapImage})`,
          backgroundSize: '160%', 
          backgroundPosition: `${center.x}% ${center.y}%`,
          opacity: 0.9, 
          filter: 'contrast(1.15) brightness(0.9)', 
          zIndex: 0, pointerEvents: 'none'
        }} />
      ) : (
        <div style={{ position: 'absolute', inset: 0, background: '#222', zIndex: 0 }} />
      )}

      <div style={{ position: 'absolute', top: 10, left: 10, fontSize: '12px', fontWeight: 'bold', color: '#fff', background:'rgba(0,0,0,0.7)', padding:'4px 10px', borderRadius:'6px', zIndex: 5, pointerEvents: 'none' }}>
        {config.name}
      </div>

      <div style={{ position: 'relative', width: '100%', height: '100%', zIndex: 10 }}>
        {config.monsters.map((mob) => {
            const isDragging = dragTargetId === mob.spotId;
            const displayX = isDragging ? dragPos.x : mob.x;
            const displayY = isDragging ? dragPos.y : mob.y;

            return (
              <div 
                key={mob.spotId}
                style={{ 
                    position: 'absolute', 
                    left: `${displayX}%`, top: `${displayY}%`, 
                    transform: 'translate(-50%, -50%)', 
                    zIndex: isDragging ? 100 : 10, // ë“œë˜ê·¸ ì¤‘ì¸ ê±´ ìµœìƒìœ„ë¡œ
                    cursor: 'grab',
                    touchAction: 'none'
                }}
                onPointerDown={(e) => handleSpotDown(mob.spotId, e)}
                onClick={(e) => { e.stopPropagation(); onSelectSpot(mob.spotId); }}
              >
                <JungleSpot 
                    x={0} y={0} // CSS left/topìœ¼ë¡œ ì œì–´í•˜ë¯€ë¡œ 0
                    name={mob.stats.name}
                    isBuff={mob.stats.isBuffMob}
                    isSelected={selectedSpotId === mob.spotId}
                    onClick={() => {}} // ìœ„ìª½ onClickì—ì„œ ì²˜ë¦¬
                />
              </div>
            );
        })}
      </div>
    </div>
  );
};


--- FILE: src/components/battle/jungle/JungleMapArea.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/jungle/JungleMapArea.tsx
// ==========================================
import React, { useRef, useState } from 'react';
import { JungleCampConfig } from '../../../types/jungle';
import { DraggableMob } from './DraggableMob';
import { useGameStore } from '../../../store/useGameStore';

interface Props {
  config: JungleCampConfig;
  selectedSpotId: string | null;
  onSelectSpot: (spotId: string) => void;
  onUpdatePos: (spotId: string, x: number, y: number) => void;
  isMobile: boolean;
}

// ë‘¥ì§€ë³„ ì¹´ë©”ë¼ ì¤‘ì‹¬ì  (ì´ë¯¸ì§€ ë§¤ì¹­ìš©)
const CAMP_CENTERS: Record<string, {x: number, y: number}> = {
  'TOP_BLUE': { x: 22, y: 38 },
  'BOT_BLUE': { x: 38, y: 77 },
  'TOP_RED':  { x: 63, y: 22 },
  'BOT_RED':  { x: 77, y: 62 }  
};

export const JungleMapArea: React.FC<Props> = ({ config, selectedSpotId, onSelectSpot, onUpdatePos, isMobile }) => {
  const { gameState } = useGameStore();
  const mapImage = gameState.customImages?.['map_bg'];
  const center = CAMP_CENTERS[config.id] || { x: 50, y: 50 };

  const containerRef = useRef<HTMLDivElement>(null);
  
  // ë“œë˜ê·¸ ìƒíƒœ ê´€ë¦¬ (ìƒìœ„ì—ì„œ ë¶„ë¦¬ë¨)
  const [dragTargetId, setDragTargetId] = useState<string | null>(null);
  const [dragPos, setDragPos] = useState({ x: 0, y: 0 });

  const handleDragStart = (spotId: string, clientX: number, clientY: number) => {
    setDragTargetId(spotId);
    updateDragPos(clientX, clientY);
  };

  const updateDragPos = (clientX: number, clientY: number) => {
    if (containerRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      // ì¢Œí‘œ ë³€í™˜ (0~100%)
      const x = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
      const y = Math.max(0, Math.min(100, ((clientY - rect.top) / rect.height) * 100));
      setDragPos({ x, y });
    }
  };

  const handlePointerMove = (e: React.PointerEvent) => {
    if (dragTargetId) {
      e.preventDefault(); // ë“œë˜ê·¸ ì¤‘ì—ëŠ” ìŠ¤í¬ë¡¤ ë°©ì§€
      updateDragPos(e.clientX, e.clientY);
    }
  };

  const handlePointerUp = () => {
    if (dragTargetId) {
      onUpdatePos(dragTargetId, dragPos.x, dragPos.y);
      setDragTargetId(null);
    }
  };

  return (
    <div 
      ref={containerRef}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      onPointerLeave={handlePointerUp}
      style={{ 
        position: 'relative', width: '100%', height: '100%', 
        background: '#15191f', 
        overflow: 'hidden', // ë‚´ë¶€ ìš”ì†Œê°€ íŠ€ì–´ë‚˜ì˜¤ì§€ ì•Šê²Œ
        touchAction: dragTargetId ? 'none' : 'pan-y', // ë“œë˜ê·¸ ì¤‘ì—” ìŠ¤í¬ë¡¤ ë§‰ê³ , í‰ì†Œì—” í—ˆìš©
        userSelect: 'none'
      }}
    >
      {/* ë§µ ë°°ê²½ */}
      {mapImage ? (
        <div style={{
          position: 'absolute', inset: 0,
          backgroundImage: `url(${mapImage})`,
          backgroundSize: '160%', 
          backgroundPosition: `${center.x}% ${center.y}%`,
          opacity: 0.9, 
          filter: 'contrast(1.15) brightness(0.9)', 
          zIndex: 0, pointerEvents: 'none'
        }} />
      ) : (
        <div style={{ position: 'absolute', inset: 0, background: '#222', zIndex: 0 }} />
      )}

      {/* ì•ˆë‚´ ë¬¸êµ¬ */}
      <div style={{ position: 'absolute', bottom: 10, left: '50%', transform: 'translateX(-50%)', 
        fontSize: '11px', fontWeight: 'bold', color: '#888', background:'rgba(0,0,0,0.8)', 
        padding:'4px 12px', borderRadius:'12px', zIndex: 5, pointerEvents: 'none', whiteSpace:'nowrap' 
      }}>
        {dragTargetId ? 'ì›í•˜ëŠ” ìœ„ì¹˜ì— ë†“ìœ¼ì„¸ìš”' : 'ê¾¹ ëˆŒëŸ¬ì„œ ì´ë™ / í„°ì¹˜í•˜ì—¬ ì„ íƒ'}
      </div>

      {/* ëª¬ìŠ¤í„°ë“¤ */}
      {config.monsters.map((mob) => (
        <DraggableMob
          key={mob.spotId}
          spotId={mob.spotId}
          x={mob.x}
          y={mob.y}
          name={mob.stats.name}
          isBuff={mob.stats.isBuffMob}
          isSelected={selectedSpotId === mob.spotId}
          isDragging={dragTargetId === mob.spotId}
          dragPos={dragPos}
          onSelect={() => onSelectSpot(mob.spotId)}
          onDragStart={handleDragStart}
        />
      ))}
    </div>
  );
};


--- FILE: src/components/battle/jungle/JunglePatchModal.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/jungle/JunglePatchModal.tsx
// ==========================================
import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../../store/useGameStore';
import { JungleCampType, JungleCampConfig, JungleMonsterStats } from '../../../types/jungle';
import { DEFAULT_JUNGLE_CONFIG } from '../../../data/jungle/jungleDefaults';
import { X, Save, RotateCcw } from 'lucide-react';
import { MonsterEditor } from './MonsterEditor';
import { JungleMapArea } from './JungleMapArea'; // ë¶„ë¦¬ëœ ëª¨ë“ˆ

interface Props { campType: JungleCampType; onClose: () => void; }

export const JunglePatchModal: React.FC<Props> = ({ campType, onClose }) => {
  const { gameState, updateFieldSettings } = useGameStore();
  
  const currentJungle = gameState.fieldSettings.jungle as any;
  const currentCamp = currentJungle?.camps?.[campType] || DEFAULT_JUNGLE_CONFIG.camps[campType];

  const [campConfig, setCampConfig] = useState<JungleCampConfig>(JSON.parse(JSON.stringify(currentCamp)));
  const [selectedSpotId, setSelectedSpotId] = useState<string | null>(campConfig.monsters[0]?.spotId || null);
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const selectedMonster = campConfig.monsters.find(m => m.spotId === selectedSpotId);

  const handleMonsterChange = (field: keyof JungleMonsterStats, value: any) => {
    if (!selectedSpotId) return;
    setCampConfig(prev => ({
      ...prev,
      monsters: prev.monsters.map(m => m.spotId === selectedSpotId ? { ...m, stats: { ...m.stats, [field]: value } } : m)
    }));
  };

  const handlePosUpdate = (spotId: string, x: number, y: number) => {
    setCampConfig(prev => ({
        ...prev,
        monsters: prev.monsters.map(m => m.spotId === spotId ? { ...m, x, y } : m)
    }));
    // ìœ„ì¹˜ ì´ë™ ì‹œ í•´ë‹¹ ëª¹ ìë™ ì„ íƒ
    setSelectedSpotId(spotId);
  };

  const handleSave = () => {
    const newJungleSettings = {
        ...currentJungle,
        camps: { ...(currentJungle.camps || DEFAULT_JUNGLE_CONFIG.camps), [campType]: campConfig }
    };
    updateFieldSettings({ jungle: newJungleSettings });
    // [ìˆ˜ì •] ì´ ë¶€ë¶„ì˜ ì—­ìŠ¬ë˜ì‹œê°€ ì—ëŸ¬ ì›ì¸ì´ì—ˆìŠµë‹ˆë‹¤.
    alert(`${campConfig.name} ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);
    onClose();
  };

  const handleReset = () => {
    if(confirm('ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ìœ„ì¹˜ í¬í•¨)')) {
        const resetData = JSON.parse(JSON.stringify(DEFAULT_JUNGLE_CONFIG.camps[campType]));
        setCampConfig(resetData);
        setSelectedSpotId(resetData.monsters[0]?.spotId);
    }
  };

  return (
    <div 
        style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.95)', zIndex: 9999, display: 'flex', justifyContent: 'center', alignItems: 'center', backdropFilter:'blur(5px)', padding: isMobile ? '0' : '20px' }}
        onContextMenu={(e) => e.preventDefault()}
    >
      <div style={{ 
          width: '100%', maxWidth: '900px', height: isMobile ? '100vh' : '700px', 
          background: '#161b22', border: isMobile ? 'none' : '1px solid #30363d', 
          borderRadius: isMobile ? '0' : '16px', overflow: 'hidden', display:'flex', flexDirection:'column', boxShadow: '0 20px 60px rgba(0,0,0,0.8)' 
      }}>
        
        {/* í—¤ë” */}
        <div style={{ padding: '15px 20px', background: '#21262d', borderBottom: '1px solid #30363d', display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexShrink: 0 }}>
          <h3 style={{ margin: 0, color: '#2ecc71', fontSize: '16px', display:'flex', alignItems:'center', gap:'8px' }}>
            ğŸŒ² {isMobile ? campConfig.name.split('(')[0] : campConfig.name}
          </h3>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#888', cursor: 'pointer', padding:'5px' }}><X size={24}/></button>
        </div>

        {/* ë°”ë”” (ë§µ + ì—ë””í„°) */}
        <div style={{ flex: 1, overflowY: 'auto', WebkitOverflowScrolling: 'touch', display: 'flex', flexDirection: isMobile ? 'column' : 'row' }}>
            
            {/* 1. ë§µ ì˜ì—­ (ëª¨ë“ˆí™”ë¨) */}
            <div style={{ 
                flex: isMobile ? 'none' : 1, 
                height: isMobile ? '45vh' : 'auto',
                borderRight: isMobile ? 'none' : '1px solid #30363d', borderBottom: isMobile ? '1px solid #30363d' : 'none',
                background:'#0d1117', position: 'relative'
            }}>
              <JungleMapArea 
                config={campConfig}
                selectedSpotId={selectedSpotId}
                onSelectSpot={setSelectedSpotId}
                onUpdatePos={handlePosUpdate}
                isMobile={isMobile}
              />
            </div>

            {/* 2. ì—ë””í„° ì˜ì—­ */}
            <div style={{ flex: isMobile ? 'none' : 1, background: '#161b22', minHeight: isMobile ? 'auto' : '100%', paddingBottom: isMobile ? '80px' : '0' }}>
              {selectedMonster ? (
                <MonsterEditor key={selectedSpotId} stats={selectedMonster.stats} onChange={handleMonsterChange} />
              ) : (
                <div style={{ padding:'40px', color:'#555', textAlign:'center' }}>ì„ íƒëœ ëª¬ìŠ¤í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>
              )}
            </div>

        </div>

        {/* í‘¸í„° */}
        <div style={{ padding: '15px', borderTop: '1px solid #30363d', display: 'flex', gap:'10px', flexShrink: 0, background:'#161b22' }}>
          <button onClick={handleReset} style={{ flex:1, background: '#3f1515', color: '#ff6b6b', border: '1px solid #5a1e1e', padding: '12px', borderRadius: '8px', fontWeight: 'bold', cursor: 'pointer', display:'flex', justifyContent:'center', alignItems:'center', gap:'6px', fontSize:'14px' }}>
            <RotateCcw size={16}/> ì´ˆê¸°í™”
          </button>
          <button onClick={handleSave} style={{ flex:2, background: '#238636', color: '#fff', border: 'none', padding: '12px', borderRadius: '8px', fontWeight: 'bold', cursor: 'pointer', display:'flex', justifyContent:'center', alignItems:'center', gap:'6px', fontSize:'14px' }}>
            <Save size={16}/> ì €ì¥
          </button>
        </div>

      </div>
    </div>
  );
};


--- FILE: src/components/battle/jungle/JungleSpot.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/jungle/JungleSpot.tsx
// ==========================================
import React from 'react';
import { Skull, Star } from 'lucide-react';

interface Props {
  x: number; // ì‚¬ìš© ì•ˆ í•¨ (ìƒìœ„ì—ì„œ ì œì–´)
  y: number; // ì‚¬ìš© ì•ˆ í•¨
  isSelected: boolean;
  isBuff: boolean;
  name: string;
  onClick: () => void;
}

export const JungleSpot: React.FC<Props> = ({ isSelected, isBuff, name, onClick }) => {
  return (
    <div 
      onClick={(e) => { e.stopPropagation(); onClick(); }}
      style={{
        cursor: 'pointer',
        display: 'flex', flexDirection: 'column', alignItems: 'center',
        // [ì¤‘ìš”] í„°ì¹˜ ì˜ì—­ì„ í™•ì‹¤íˆ í™•ë³´
        padding: '10px' 
      }}
    >
      <div style={{
        width: isBuff ? '36px' : '28px', 
        height: isBuff ? '36px' : '28px',
        borderRadius: '50%',
        background: isSelected ? '#fff' : '#161b22',
        border: isSelected ? '2px solid #58a6ff' : (isBuff ? '2px solid #f1c40f' : '2px solid #8b949e'),
        display: 'flex', alignItems: 'center', justifyContent: 'center',
        boxShadow: isSelected ? '0 0 15px #58a6ff' : '0 0 5px rgba(0,0,0,0.5)',
        transition: 'transform 0.1s',
        transform: isSelected ? 'scale(1.1)' : 'scale(1)'
      }}>
        {isBuff ? <Star size={18} color={isSelected ? '#58a6ff' : '#f1c40f'} /> : <Skull size={14} color={isSelected ? '#58a6ff' : '#8b949e'} />}
      </div>
      <div style={{
        marginTop: '2px', fontSize: '9px', fontWeight: 'bold',
        color: isSelected ? '#58a6ff' : '#ccc',
        background: 'rgba(0,0,0,0.7)', padding: '2px 6px', borderRadius: '4px',
        whiteSpace: 'nowrap', pointerEvents: 'none'
      }}>
        {name}
      </div>
    </div>
  );
};


--- FILE: src/components/battle/jungle/MonsterEditor.tsx ---
// ==========================================
// FILE PATH: /src/components/battle/jungle/MonsterEditor.tsx
// ==========================================
import React from 'react';
import { JungleMonsterStats, BuffType } from '../../../types/jungle';
import { Sword, Shield, Heart, Coins, Clock, Zap, Type, Plus, Trash2, TrendingUp } from 'lucide-react';
import { RangeInput } from '../ui/PatchInputs';

interface Props {
  stats: JungleMonsterStats;
  onChange: (field: keyof JungleMonsterStats, value: any) => void;
}

export const MonsterEditor: React.FC<Props> = ({ stats, onChange }) => {
  
  // ë²„í”„ ì¶”ê°€
  const addBuff = () => {
    const newBuffs = [...(stats.buffs || []), { type: 'ATK' as BuffType, value: 10 }];
    onChange('buffs', newBuffs);
  };

  // ë²„í”„ ì‚­ì œ
  const removeBuff = (index: number) => {
    const newBuffs = [...(stats.buffs || [])];
    newBuffs.splice(index, 1);
    onChange('buffs', newBuffs);
  };

  // ë²„í”„ ìˆ˜ì •
  const updateBuff = (index: number, field: 'type' | 'value', val: any) => {
    const newBuffs = [...(stats.buffs || [])];
    newBuffs[index] = { ...newBuffs[index], [field]: val };
    onChange('buffs', newBuffs);
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '20px', padding: '20px 15px' }}>
      
      {/* 1. ê¸°ë³¸ ì •ë³´ */}
      <div style={{ background: '#1f242e', padding: '15px', borderRadius: '8px', border: '1px solid #30363d' }}>
        <div style={{ marginBottom: '15px' }}>
          <label style={{ fontSize: '11px', color: '#8b949e', marginBottom: '6px', display: 'flex', alignItems:'center', gap:'4px' }}>
            <Type size={12}/> ëª¬ìŠ¤í„° ì´ë¦„
          </label>
          <input 
            type="text" value={stats.name} 
            onChange={(e) => onChange('name', e.target.value)}
            style={{ width: '100%', background: '#0d1117', border: '1px solid #444', color: '#fff', padding: '10px', borderRadius: '6px', fontWeight: 'bold', fontSize:'14px', boxSizing:'border-box' }}
          />
        </div>

        <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: stats.isBuffMob ? '15px' : '0' }}>
          <input 
            type="checkbox" checked={stats.isBuffMob} 
            onChange={(e) => onChange('isBuffMob', e.target.checked)}
            id="buffCheck"
            style={{ width: '18px', height: '18px', cursor:'pointer', accentColor: '#f1c40f' }}
          />
          <label htmlFor="buffCheck" style={{ flex: 1, cursor:'pointer' }}>
            <div style={{ fontSize: '13px', fontWeight: 'bold', color: stats.isBuffMob ? '#f1c40f' : '#ccc' }}>ë²„í”„ ëª¬ìŠ¤í„° ì—¬ë¶€</div>
            <div style={{ fontSize: '11px', color: '#666' }}>ì²´í¬ ì‹œ ì²˜ì¹˜ìì—ê²Œ íŠ¹ë³„ íš¨ê³¼ ë¶€ì—¬</div>
          </label>
        </div>

        {/* [ìˆ˜ì •] ë‹¤ì¤‘ ë²„í”„ ë¦¬ìŠ¤íŠ¸ UI */}
        {stats.isBuffMob && (
          <div style={{ animation: 'fadeIn 0.2s', background: '#2d2b18', padding:'10px', borderRadius:'6px', border:'1px solid #f1c40f' }}>
            <div style={{ fontSize:'12px', fontWeight:'bold', color:'#f1c40f', marginBottom:'10px', display:'flex', justifyContent:'space-between', alignItems:'center' }}>
                <span>ë¶€ì—¬í•  ë²„í”„ ëª©ë¡ ({stats.buffs?.length || 0})</span>
                <button onClick={addBuff} style={{ background:'#f1c40f', color:'#000', border:'none', borderRadius:'4px', padding:'4px 8px', fontSize:'11px', fontWeight:'bold', cursor:'pointer', display:'flex', alignItems:'center', gap:'4px' }}>
                    <Plus size={12}/> ì¶”ê°€
                </button>
            </div>

            {(!stats.buffs || stats.buffs.length === 0) && (
                <div style={{ fontSize:'11px', color:'#aaa', textAlign:'center', padding:'10px' }}>ë²„í”„ë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”.</div>
            )}

            {stats.buffs?.map((buff, idx) => (
                <div key={idx} style={{ marginBottom:'10px', paddingBottom:'10px', borderBottom: idx < stats.buffs.length-1 ? '1px dashed #555' : 'none' }}>
                    <div style={{ display:'flex', gap:'5px', marginBottom:'5px' }}>
                        <select 
                            value={buff.type}
                            onChange={(e) => updateBuff(idx, 'type', e.target.value)}
                            style={{ flex:1, background: '#161b22', border: '1px solid #f1c40f', color: '#fff', padding: '6px', borderRadius: '4px', fontSize:'11px' }}
                        >
                            <option value="ATK">âš”ï¸ ê³µê²©ë ¥</option>
                            <option value="DEF">ğŸ›¡ï¸ ë°©ì–´ë ¥</option>
                            <option value="SPEED">ğŸ’¨ ì´ë™ì†ë„</option>
                            <option value="REGEN">ğŸ’– ì¬ìƒ</option>
                            <option value="HASSTE">âš¡ ìŠ¤í‚¬ê°€ì†</option>
                            <option value="GOLD">ğŸ’° ê³¨ë“œ</option>
                        </select>
                        <button onClick={() => removeBuff(idx)} style={{ background:'#3f1515', border:'1px solid #5a1e1e', color:'#ff6b6b', borderRadius:'4px', padding:'6px', cursor:'pointer' }}>
                            <Trash2 size={12}/>
                        </button>
                    </div>
                    <RangeInput 
                      label="ìˆ˜ì¹˜" icon={<TrendingUp size={10}/>} 
                      value={buff.value} onChange={(v) => updateBuff(idx, 'value', v)} 
                      min={1} max={100} step={1} unit={buff.type === 'HASSTE' ? '' : '%'} color="#f1c40f" 
                    />
                </div>
            ))}
          </div>
        )}
      </div>

      {/* 2. ì „íˆ¬ ìŠ¤íƒ¯ */}
      <div style={{ background: '#1f242e', padding: '15px', borderRadius: '8px', border: '1px solid #30363d' }}>
        <h4 style={{ margin:'0 0 15px 0', fontSize:'12px', color:'#ccc' }}>ê¸°ë³¸ ëŠ¥ë ¥ì¹˜</h4>
        <RangeInput label="ì²´ë ¥" icon={<Heart size={12}/>} value={stats.hp} onChange={(v) => onChange('hp', v)} min={100} max={20000} step={100} unit="" color="#2ecc71" />
        <RangeInput label="ê³µê²©ë ¥" icon={<Sword size={12}/>} value={stats.atk} onChange={(v) => onChange('atk', v)} min={0} max={1000} step={10} unit="" color="#e74c3c" />
        <RangeInput label="ë°©ì–´ë ¥" icon={<Shield size={12}/>} value={stats.def} onChange={(v) => onChange('def', v)} min={0} max={300} step={5} unit="" color="#3498db" />
      </div>

      {/* 3. ë³´ìƒ */}
      <div style={{ background: '#1f242e', padding: '15px', borderRadius: '8px', border: '1px solid #30363d' }}>
        <h4 style={{ margin:'0 0 15px 0', fontSize:'12px', color:'#e89d40' }}>ë³´ìƒ ë° ìƒì„±</h4>
        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '15px' }}>
          <RangeInput label="ê³¨ë“œ" icon={<Coins size={12}/>} value={stats.gold} onChange={(v) => onChange('gold', v)} min={0} max={1000} step={10} unit=" G" color="#f1c40f" />
          <RangeInput label="ê²½í—˜ì¹˜" icon={<Zap size={12}/>} value={stats.xp} onChange={(v) => onChange('xp', v)} min={0} max={1000} step={10} unit=" XP" color="#9b59b6" />
        </div>
        <div style={{ marginTop: '10px' }}>
          <RangeInput label="ë¦¬ì   ì‹œê°„" icon={<Clock size={12}/>} value={stats.respawnTime} onChange={(v) => onChange('respawnTime', v)} min={10} max={600} step={10} unit=" ì´ˆ" color="#ccc" />
        </div>
      </div>

      <style>{`
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }
      `}</style>
    </div>
  );
};


--- FILE: src/components/battle/ui/MapObjectIcon.tsx ---
import React from 'react';

interface Props {
  x: number;
  y: number;
  icon: React.ReactElement;
  color: string;
  size: number;
  label?: string;
  onClick: () => void;
}

export const MapObjectIcon: React.FC<Props> = ({ x, y, icon, color, size, label, onClick }) => {
  return (
    <div 
      onClick={onClick}
      style={{
        position: 'absolute', left: `${x}%`, top: `${y}%`,
        transform: 'translate(-50%, -50%)',
        display: 'flex', flexDirection: 'column', alignItems: 'center',
        cursor: 'pointer', zIndex: 10
      }}
      className="map-obj-hover"
    >
      <div style={{
        width: size, height: size, borderRadius: '50%',
        background: '#161b22', border: `2px solid ${color}`,
        display: 'flex', alignItems: 'center', justifyContent: 'center',
        boxShadow: `0 0 10px ${color}66`,
        transition: 'all 0.2s'
      }}>
        {React.cloneElement(icon, { size: size/1.8, color })}
      </div>
      {label && (
        <span style={{ 
          marginTop: '4px', fontSize: '10px', fontWeight: 'bold', 
          color: '#fff', background: 'rgba(0,0,0,0.6)', 
          padding: '1px 6px', borderRadius: '4px', whiteSpace: 'nowrap'
        }}>
          {label}
        </span>
      )}
      <style>{`
        .map-obj-hover:hover > div { transform: scale(1.2); background: #fff !important; }
        .map-obj-hover:hover span { background: #58a6ff !important; }
      `}</style>
    </div>
  );
};


--- FILE: src/components/battle/ui/PatchInputs.tsx ---
import React from 'react';
import { Clock } from 'lucide-react';

interface RangeProps {
  label: string;
  icon?: React.ReactNode;
  value: number;
  onChange: (val: number) => void;
  min: number; max: number; step?: number;
  unit?: string;
  color?: string;
}

export const RangeInput: React.FC<RangeProps> = ({ label, icon, value, onChange, min, max, step = 1, unit = '', color = '#58a6ff' }) => (
  <div style={{ marginBottom: '25px' }}>
    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '12px', fontSize: '13px', color: '#ccc' }}>
      <div style={{ display:'flex', alignItems:'center', gap:'6px' }}>{icon} {label}</div>
      <span style={{ fontWeight: 'bold', color: color, fontFamily:'monospace', fontSize:'15px' }}>
        {value?.toLocaleString()}{unit}
      </span>
    </div>
    <div style={{ padding: '0 5px' }}>
      <input 
        type="range" min={min} max={max} step={step} 
        value={value || 0} 
        onChange={(e) => onChange(Number(e.target.value))} 
        style={{ width:'100%', accentColor: color, cursor:'pointer' }}
      />
    </div>
  </div>
);

export const TimeInput: React.FC<Omit<RangeProps, 'icon' | 'unit'>> = ({ label, value, onChange, min = 0, max = 3600, step = 10, color = '#ccc' }) => (
  <div style={{ marginBottom: '25px' }}>
    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '12px', fontSize: '13px', color: '#ccc' }}>
      <div style={{ display:'flex', alignItems:'center', gap:'6px' }}><Clock size={14}/> {label}</div>
      <span style={{ fontWeight: 'bold', color: color, fontFamily:'monospace', fontSize:'15px' }}>
        {Math.floor(value / 60)}ë¶„ {value % 60}ì´ˆ
      </span>
    </div>
    <input 
      type="range" min={min} max={max} step={step} 
      value={value || 0} 
      onChange={(e) => onChange(Number(e.target.value))} 
      style={{ width:'100%', accentColor: color, cursor:'pointer' }}
    />
  </div>
);


--- FILE: src/components/common/DevTools.tsx ---
// src/components/common/DevTools.tsx
import React from 'react';
import { useGameStore } from '../../store/useGameStore';
import { Trash2 } from 'lucide-react';

export const DevTools = () => {
  const { resetHeroStats } = useGameStore();

  const handleReset = () => {
    if (window.confirm('ëª¨ë“  ì±”í”¼ì–¸ì˜ ëˆ„ì  í†µê³„(ìŠ¹ë¥ , KDA, íŒìˆ˜)ë¥¼ 0ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\n*í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ê²Œì„ì—ëŠ” ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŠµë‹ˆë‹¤.')) {
      resetHeroStats();
      alert('í†µê³„ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ì œ ìƒˆë¡œìš´ ê²Œì„ ê²°ê³¼ê°€ ì¦‰ì‹œ ìŠ¹ë¥ ì— ë°˜ì˜ë©ë‹ˆë‹¤.');
    }
  };

  return (
    <div style={{
      position: 'fixed',
      bottom: '20px',
      right: '20px',
      zIndex: 9999
    }}>
      <button 
        onClick={handleReset}
        style={{
          background: '#e74c3c',
          color: 'white',
          border: 'none',
          padding: '10px 15px',
          borderRadius: '8px',
          cursor: 'pointer',
          boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
          display: 'flex',
          alignItems: 'center',
          gap: '8px',
          fontSize: '13px',
          fontWeight: 'bold'
        }}
      >
        <Trash2 size={16} />
        í†µê³„ ì´ˆê¸°í™”
      </button>
    </div>
  );
};

--- FILE: src/components/common/SaveLoadModal.tsx ---
import React, { useState, useEffect } from 'react';
import { X, Save, Upload, Download } from 'lucide-react';
import { useGameStore } from '../../store/useGameStore';
import { saveToSlot, loadFromSlot, getSlotsMeta, exportSaveFile, importSaveFile, SaveMeta } from '../../engine/SaveLoadSystem';

interface Props { onClose: () => void; }

export const SaveLoadModal: React.FC<Props> = ({ onClose }) => {
  const { heroes } = useGameStore();
  const [slots, setSlots] = useState<Record<string, SaveMeta>>({});
  const [refreshKey, setRefreshKey] = useState(0); 

  useEffect(() => {
    setSlots(getSlotsMeta());
  }, [refreshKey]);

  const handleSave = (slotId: string) => {
    if (saveToSlot(slotId)) {
      alert("ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!");
      setSlots(getSlotsMeta());
    }
  };

  const handleLoad = (slotId: string) => {
    if (!slots[slotId]) return;

    if (confirm("ì •ë§ ì´ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì‹œê² ìŠµë‹ˆê¹Œ?\ní˜„ì¬ ì§„í–‰ ìƒí™©ì€ ë®ì–´ì”Œì›Œì§‘ë‹ˆë‹¤.")) {
      const success = loadFromSlot(slotId, heroes);
      if (success) {
        alert("ë¡œë“œ ì™„ë£Œ!");
        onClose();
        window.location.reload();
      } else {
        alert("ë¡œë“œ ì‹¤íŒ¨! ë°ì´í„°ê°€ ì†ìƒë˜ì—ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
      }
    }
  };

  const handleFileImport = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    if (confirm("íŒŒì¼ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì‹œê² ìŠµë‹ˆê¹Œ?")) {
      const success = await importSaveFile(file, heroes);
      if (success) {
        alert("íŒŒì¼ ë¡œë“œ ì™„ë£Œ!");
        onClose();
        window.location.reload();
      }
    }
    e.target.value = ''; 
  };

  const SlotItem = ({ id, name, color }: { id: string, name: string, color: string }) => {
    const info = slots[id];
    return (
      <div style={{ background: '#21262d', padding: '15px', borderRadius: '8px', marginBottom: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', border: `1px solid ${color}` }}>
        <div>
          <div style={{ fontWeight: 'bold', color: color, marginBottom: '4px' }}>{name}</div>
          {info ? (
            <div style={{ fontSize: '13px', color: '#ccc' }}>
              <div>Day {info.day} â€¢ ìœ ì € {info.totalUsers}ëª…</div>
              <div style={{ fontSize: '11px', color: '#777' }}>{new Date(info.timestamp).toLocaleString()}</div>
            </div>
          ) : (
            <div style={{ fontSize: '13px', color: '#555' }}>ë¹„ì–´ ìˆìŒ</div>
          )}
        </div>
        <div style={{ display: 'flex', gap: '8px' }}>
          {id !== 'auto' && (
            <button onClick={() => handleSave(id)} style={{ padding: '8px 12px', background: '#238636', border: 'none', borderRadius: '6px', color: '#fff', cursor: 'pointer', fontWeight: 'bold' }}>
              ì €ì¥
            </button>
          )}
          <button 
            onClick={() => handleLoad(id)} 
            disabled={!info}
            style={{ padding: '8px 12px', background: info ? '#1f6feb' : '#333', border: 'none', borderRadius: '6px', color: '#fff', cursor: info ? 'pointer' : 'default', fontWeight: 'bold', opacity: info ? 1 : 0.5 }}
          >
            ë¡œë“œ
          </button>
        </div>
      </div>
    );
  };

  return (
    <div style={{ position: 'fixed', top: 0, left: 0, width: '100%', height: '100%', background: 'rgba(0,0,0,0.8)', display: 'flex', justifyContent: 'center', alignItems: 'center', zIndex: 9999 }}>
      <div className="panel" style={{ width: '500px', background: '#161b22', border: '1px solid #333' }}>

        <div style={{ padding: '15px', borderBottom: '1px solid #333', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <h3 style={{ margin: 0, display:'flex', alignItems:'center', gap:'8px' }}><Save size={18}/> ì €ì¥ / ë¶ˆëŸ¬ì˜¤ê¸°</h3>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#fff', cursor: 'pointer' }}><X /></button>
        </div>

        <div style={{ padding: '20px' }}>
          <SlotItem id="auto" name="ğŸ”„ ìë™ ì €ì¥ (Auto Save)" color="#e89d40" />
          <div style={{ height: '1px', background: '#333', margin: '15px 0' }}></div>
          <SlotItem id="slot1" name="ğŸ“ ì €ì¥ ìŠ¬ë¡¯ 1" color="#58a6ff" />
          <SlotItem id="slot2" name="ğŸ“ ì €ì¥ ìŠ¬ë¡¯ 2" color="#58a6ff" />
          <SlotItem id="slot3" name="ğŸ“ ì €ì¥ ìŠ¬ë¡¯ 3" color="#58a6ff" />

          <div style={{ marginTop: '20px', paddingTop: '15px', borderTop: '1px dashed #333', display: 'flex', justifyContent: 'space-between' }}>
            <button onClick={exportSaveFile} style={{ background: 'none', border: 'none', color: '#8b949e', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '5px', fontSize: '12px' }}>
              <Download size={14}/> PC íŒŒì¼ë¡œ ë°±ì—…
            </button>
            <label style={{ cursor: 'pointer', color: '#8b949e', display: 'flex', alignItems: 'center', gap: '5px', fontSize: '12px' }}>
              <Upload size={14}/> PC íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°
              <input type="file" style={{ display: 'none' }} accept=".json" onChange={handleFileImport} />
            </label>
          </div>
        </div>

      </div>
    </div>
  );
};


--- FILE: src/components/common/StatCard.tsx ---
import React, { useState, useEffect } from 'react';
import { LucideIcon } from 'lucide-react';

interface Props {
  title: string;
  value: string | number;
  icon: LucideIcon;
  color?: string;
}

export const StatCard: React.FC<Props> = ({ title, value, icon: Icon, color = "#58a6ff" }) => {
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return (
    <div className="stat-card-mini" style={{ 
      display: 'flex', 
      flexDirection: 'column', // ì•„ì´ì½˜ê³¼ í…ìŠ¤íŠ¸ë¥¼ ìœ„ì•„ë˜ë¡œ ë°°ì¹˜
      alignItems: 'center', 
      justifyContent: 'center',
      padding: isMobile ? '8px 4px' : '16px', 
      background: '#161b22',
      border: '1px solid #30363d',
      borderRadius: '8px',
      flex: 1,
      minWidth: 0, // ì¢ì€ í™”ë©´ì—ì„œ ì°Œê·¸ëŸ¬ì§ ë°©ì§€
    }}>
      {/* ì•„ì´ì½˜ - í¬ê¸° ì¶•ì†Œ */}
      <div style={{ 
        color: color,
        marginBottom: isMobile ? '4px' : '8px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        opacity: 0.9
      }}>
        <Icon size={isMobile ? 16 : 22} />
      </div>

      <div style={{ textAlign: 'center', width: '100%' }}>
        {/* ìˆ˜ì¹˜ - ê°€ë…ì„± í™•ë³´ */}
        <div className="text-mono" style={{ 
          fontSize: isMobile ? '13px' : '18px', 
          fontWeight: '800',
          color: '#fff',
          whiteSpace: 'nowrap',
          overflow: 'hidden',
          textOverflow: 'ellipsis'
        }}>
          {value}
        </div>
        {/* ì œëª© - ì•„ì£¼ ì‘ê²Œ í‘œì‹œ */}
        <div style={{ 
          fontSize: isMobile ? '8px' : '11px', 
          color: '#8b949e',
          marginTop: '1px',
          whiteSpace: 'nowrap'
        }}>
          {isMobile ? title.replace(' ', '') : title}
        </div>
      </div>
    </div>
  );
};

--- FILE: src/components/common/CrashScreen.tsx ---
import React from 'react';
import { AlertTriangle, RefreshCw, Trash2, Copy, Bug } from 'lucide-react';

interface Props {
  error: Error | null;
  resetErrorBoundary: () => void;
}

export const CrashScreen: React.FC<Props> = ({ error, resetErrorBoundary }) => {
  const handleCopy = () => {
    if (error) {
      // [ìˆ˜ì •] ë¬¸ë²• ì˜¤ë¥˜ ìˆ˜ì •
      navigator.clipboard.writeText(`Message: ${error.message}\nStack: ${error.stack}`);
      alert("ì˜¤ë¥˜ ë‚´ìš©ì´ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.");
    }
  };

  const handleHardReset = () => {
    if (confirm("ì •ë§ ëª¨ë“  ë°ì´í„°ë¥¼ ì‚­ì œí•˜ê³  ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ë³µêµ¬ ë¶ˆê°€)")) {
      localStorage.clear();
      // IndexedDB ì‚­ì œ
      const req = indexedDB.deleteDatabase('GodsWar_DB_V1');
      req.onsuccess = () => window.location.reload();
      req.onerror = () => window.location.reload();
      req.onblocked = () => window.location.reload();
    }
  };

  return (
    <div style={{
      position: 'fixed', inset: 0, zIndex: 99999,
      background: '#0f1115', color: '#fff',
      display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
      padding: '20px', fontFamily: 'sans-serif'
    }}>
      <div style={{
        maxWidth: '800px', width: '100%',
        background: '#161b22', border: '1px solid #da3633', borderRadius: '12px',
        padding: '30px', boxShadow: '0 20px 50px rgba(0,0,0,0.8)'
      }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '15px', marginBottom: '20px', borderBottom: '1px solid #da3633', paddingBottom: '15px' }}>
          <div style={{ background: '#da3633', padding: '10px', borderRadius: '50%' }}>
            <Bug size={32} color="#fff" />
          </div>
          <div>
            <h2 style={{ margin: 0, fontSize: '24px', fontWeight: 'bold', color: '#da3633' }}>
              ì‹œìŠ¤í…œ ì¹˜ëª…ì  ì˜¤ë¥˜ ë°œìƒ
            </h2>
            <p style={{ margin: '5px 0 0 0', color: '#8b949e', fontSize: '14px' }}>
              ê²Œì„ ì—”ì§„ì´ ì•ˆì „ì„ ìœ„í•´ ì‹¤í–‰ì„ ì¤‘ë‹¨í–ˆìŠµë‹ˆë‹¤.
            </p>
          </div>
        </div>

        <div style={{ marginBottom: '15px' }}>
          <label style={{ fontSize: '12px', fontWeight: 'bold', color: '#da3633' }}>ERROR MESSAGE:</label>
          <div style={{ background: '#0d1117', padding: '12px', borderRadius: '6px', border: '1px solid #30363d', color: '#fff', fontWeight: 'bold', marginTop: '5px' }}>
            {error?.message || "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜"}
          </div>
        </div>

        <div style={{ marginBottom: '25px' }}>
          <label style={{ fontSize: '12px', fontWeight: 'bold', color: '#8b949e' }}>STACK TRACE:</label>
          <pre style={{ 
            background: '#0d1117', padding: '15px', borderRadius: '6px', border: '1px solid #30363d', 
            color: '#ccc', fontSize: '11px', overflow: 'auto', maxHeight: '200px', marginTop: '5px',
            fontFamily: 'Consolas, monospace', whiteSpace: 'pre-wrap' 
          }}>
            {error?.stack || "ìŠ¤íƒ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤."}
          </pre>
        </div>

        <div style={{ display: 'flex', gap: '10px', justifyContent: 'flex-end' }}>
          <button onClick={handleCopy} style={{ display:'flex', alignItems:'center', gap:'6px', padding: '10px 15px', background: '#21262d', border: '1px solid #30363d', color: '#ccc', borderRadius: '6px', cursor: 'pointer' }}>
            <Copy size={16} /> ì˜¤ë¥˜ ë³µì‚¬
          </button>
          <button onClick={() => window.location.reload()} style={{ display:'flex', alignItems:'center', gap:'6px', padding: '10px 15px', background: '#238636', border: 'none', color: '#fff', borderRadius: '6px', cursor: 'pointer', fontWeight: 'bold' }}>
            <RefreshCw size={16} /> ì¬ì‹œì‘ (ìƒˆë¡œê³ ì¹¨)
          </button>
          <button onClick={handleHardReset} style={{ display:'flex', alignItems:'center', gap:'6px', padding: '10px 15px', background: '#3f1515', border: '1px solid #da3633', color: '#da3633', borderRadius: '6px', cursor: 'pointer', fontWeight: 'bold' }}>
            <Trash2 size={16} /> ë°ì´í„° ì´ˆê¸°í™” (ë¹„ìƒìš©)
          </button>
        </div>
      </div>
    </div>
  );
};


--- FILE: src/components/common/GameIcon.tsx ---
// ==========================================
// FILE PATH: /src/components/common/GameIcon.tsx
// ==========================================

import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';

interface Props {
  id: string; 
  size?: string | number;
  fallback?: React.ReactNode;
  shape?: 'square' | 'circle' | 'rounded';
  border?: string;
}

export const GameIcon: React.FC<Props> = ({ id, size = 40, fallback, shape = 'rounded', border = '1px solid #333' }) => {
  const customImages = useGameStore(state => state.gameState.customImages);
  
  // ì´ë¯¸ì§€ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
  const imageUrl = customImages?.[id];
  const [hasError, setHasError] = useState(false);

  // IDê°€ ë°”ë€Œë©´ ì—ëŸ¬ ìƒíƒœ ì´ˆê¸°í™” (ìƒˆë¡œìš´ ì´ë¯¸ì§€ëŠ” ë‹¤ì‹œ ì‹œë„í•´ë´ì•¼ í•˜ë¯€ë¡œ)
  useEffect(() => {
    setHasError(false);
  }, [id, imageUrl]);

  const style: React.CSSProperties = {
    width: typeof size === 'number' ? `${size}px` : size,
    height: typeof size === 'number' ? `${size}px` : size,
    borderRadius: shape === 'circle' ? '50%' : shape === 'rounded' ? '12px' : '0',
    overflow: 'hidden',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    background: '#1c1c1f', // ì´ë¯¸ì§€ê°€ ë¡œë”©ë˜ê¸° ì „ ë³´ì—¬ì¤„ ë°°ê²½ìƒ‰
    border: border,
    flexShrink: 0,
    position: 'relative',
  };

  // 1. ì´ë¯¸ì§€ê°€ ìˆê³ , ì—ëŸ¬ê°€ ë‚˜ì§€ ì•Šì€ ê²½ìš° -> ì´ë¯¸ì§€ ë Œë”ë§
  if (imageUrl && !hasError) {
    return (
      <div style={style}>
        <img 
          src={imageUrl} 
          alt={id}
          loading="lazy"
          decoding="async"
          style={{ 
            width: '100%', 
            height: '100%', 
            objectFit: 'cover', 
            display: 'block'
          }}
          onError={(e) => {
            console.warn(`ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨: ${id}`);
            e.currentTarget.style.display = 'none'; // ê¹¨ì§„ ì´ë¯¸ì§€ ìˆ¨ê¹€
            setHasError(true); // ì—ëŸ¬ ìƒíƒœë¡œ ì „í™˜í•˜ì—¬ Fallback í‘œì‹œ
          }}
        />
        {/* ë¡œë”© ì¤‘ ê¹œë¹¡ì„ ë°©ì§€ë¥¼ ìœ„í•´ ë’¤ì— Fallbackì„ ê¹”ì•„ë‘  */}
        <div style={{ position: 'absolute', inset:0, zIndex: -1, display:'flex', alignItems:'center', justifyContent:'center', opacity: 0.3 }}>
           {fallback || <div style={{width:'50%', height:'50%', background:'#555', borderRadius:'50%'}}/>}
        </div>
      </div>
    );
  }

  // 2. ì´ë¯¸ì§€ê°€ ì—†ê±°ë‚˜ ì—ëŸ¬ê°€ ë‚œ ê²½ìš° -> Fallback ë Œë”ë§
  return (
    <div style={style}>
      {fallback || (
        // ê¸°ë³¸ Fallback: ì˜ì›…/ì•„ì´í…œ IDì˜ ì²« ê¸€ì í‘œì‹œ
        <span style={{ fontSize: '12px', color: '#666', fontWeight:'bold', textTransform:'uppercase' }}>
          {id.split('_')[1]?.substring(0, 2) || '??'}
        </span>
      )} 
    </div>
  );
};


--- FILE: src/components/common/SystemMenu.tsx ---
import React, { useState } from 'react';
import { Save, Disc, AlertTriangle, X } from 'lucide-react';
import { OptionTab } from '../system/OptionTab';
import { SaveLoadTab } from '../system/SaveLoadTab';

interface Props { onClose: () => void; }

export const SystemMenu: React.FC<Props> = ({ onClose }) => {
  const [activeTab, setActiveTab] = useState<'SAVE' | 'LOAD' | 'OPTION'>('SAVE');

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };

  return (
    <div 
      onClick={handleBackdropClick} 
      style={{
        position: 'fixed', top: 0, left: 0, width: '100%', height: '100%',
        backgroundColor: 'rgba(0,0,0,0.85)', display: 'flex', justifyContent: 'center', alignItems: 'center', zIndex: 9999,
        backdropFilter: 'blur(5px)',
        padding: '10px' 
      }}
    >
      <div className="panel" style={{ 
        width: '100%', maxWidth: '450px', maxHeight: '90vh',
        background: '#1c1c1f', border: '1px solid #30363d', 
        display:'flex', flexDirection:'column', padding:0,
        overflow: 'hidden', borderRadius: '12px'
      }}>

        <div style={{ 
          padding: '15px 20px', borderBottom: '1px solid #333', 
          display: 'flex', justifyContent: 'space-between', alignItems: 'center', 
          background: '#252528', flexShrink: 0 
        }}>
          <h3 style={{ margin: 0, color: '#fff', fontSize: '16px' }}>ì‹œìŠ¤í…œ ë©”ë‰´</h3>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#fff', cursor: 'pointer', padding:'5px' }}>
            <X size={24} />
          </button>
        </div>

        <div style={{ display: 'flex', background: '#161b22', borderBottom: '1px solid #333', flexShrink: 0 }}>
          {([
            { id: 'SAVE', label: 'ì €ì¥', icon: Save },
            { id: 'LOAD', label: 'ë¶ˆëŸ¬ì˜¤ê¸°', icon: Disc },
            { id: 'OPTION', label: 'ì˜µì…˜', icon: AlertTriangle }
          ] as const).map(t => (
            <button
              key={t.id}
              onClick={() => setActiveTab(t.id)}
              style={{
                flex: 1, padding: '15px', background: 'none', border: 'none',
                borderBottom: activeTab === t.id ? '2px solid #58a6ff' : '2px solid transparent',
                color: activeTab === t.id ? '#fff' : '#777', fontWeight: 'bold', cursor: 'pointer',
                display:'flex', alignItems:'center', justifyContent:'center', gap:'8px'
              }}
            >
              <t.icon size={16} /> {t.label}
            </button>
          ))}
        </div>

        <div style={{ flex: 1, overflowY: 'auto', padding: '20px' }}>
          {activeTab === 'SAVE' && <SaveLoadTab mode="SAVE" />}
          {activeTab === 'LOAD' && <SaveLoadTab mode="LOAD" />}
          {activeTab === 'OPTION' && <OptionTab />}
        </div>

      </div>
    </div>
  );
};


--- FILE: src/components/community/CommunityBoard.tsx ---
import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { Star, ThumbsUp } from 'lucide-react';
import { Post } from '../../types';

export const CommunityBoard: React.FC = () => {
  const { communityPosts, openPost } = useGameStore();
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  const [tab, setTab] = useState<'all' | 'best'>('all');
  const [page, setPage] = useState(1);

  const POSTS_PER_PAGE = isMobile ? 15 : 20;

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const handleTabChange = (newTab: 'all' | 'best') => {
    setTab(newTab);
    setPage(1);
  };

  const filteredPosts = tab === 'best' 
    ? communityPosts.filter(p => p.isBest || p.upvotes >= 10) 
    : communityPosts;

  const totalPages = Math.ceil(filteredPosts.length / POSTS_PER_PAGE);
  const startIndex = (page - 1) * POSTS_PER_PAGE;
  const currentPosts = filteredPosts.slice(startIndex, startIndex + POSTS_PER_PAGE);

  const getCategoryColor = (cat: string) => {
    switch (cat) {
      case 'ê³µëµ': return '#58a6ff'; 
      case 'ë¶„ì„': return '#58a6ff';
      case 'ì§•ì§•': return '#e84057'; 
      case 'ìœ ë¨¸': return '#f1c40f'; 
      case 'ìë‘': return '#2ecc71';
      default: return '#8b949e';     
    }
  };

  // [ìˆ˜ì •ë¨] post íƒ€ì… ëª…ì‹œ
  const MobilePostItem = ({ post }: { post: Post }) => (
    <div 
      onClick={() => openPost(post)}
      style={{ 
        padding: '12px 15px', 
        borderBottom: '1px solid #2c2c2f', 
        background: post.isBest ? 'rgba(232, 64, 87, 0.05)' : '#1c1c1f',
        cursor: 'pointer'
      }}
    >
      <div style={{ display: 'flex', alignItems: 'center', marginBottom: '6px', lineHeight: '1.4' }}>
        {post.isBest && (
          <span style={{ fontSize:'10px', background:'#e84057', color:'#fff', padding:'1px 4px', borderRadius:'3px', marginRight:'6px', flexShrink:0 }}>
            BEST
          </span>
        )}
        <span style={{ 
          color: '#e6edf3', 
          fontSize: '15px', 
          fontWeight: post.isBest ? 'bold' : 'normal',
          overflow: 'hidden', textOverflow: 'ellipsis', display: '-webkit-box', WebkitLineClamp: 1, WebkitBoxOrient: 'vertical'
        }}>
          {post.title}
        </span>
        {post.comments > 0 && (
          <span style={{ color:'#58a6ff', fontSize:'13px', marginLeft:'6px', fontWeight:'bold', flexShrink:0 }}>
            [{post.comments}]
          </span>
        )}
      </div>

      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', fontSize: '12px', color: '#8b949e' }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
          <span style={{ color: getCategoryColor(post.category), fontWeight:'bold' }}>{post.category}</span>
          <span style={{ width:'1px', height:'10px', background:'#444' }}></span>
          <span>{post.author}</span>
          <span style={{ width:'1px', height:'10px', background:'#444' }}></span>
          <span>{post.displayTime}</span>
        </div>

        {post.upvotes > 0 && (
          <div style={{ display: 'flex', alignItems: 'center', gap: '4px', color: post.upvotes >= 10 ? '#e84057' : '#8b949e' }}>
            <ThumbsUp size={12} />
            <span>{post.upvotes}</span>
          </div>
        )}
      </div>
    </div>
  );

  return (
    <div className="panel" style={{ 
      height: isMobile ? '80vh' : '700px', 
      position: 'relative', zIndex: 10,
      background: '#1c1c1f', border: '1px solid #30363d', 
      display:'flex', flexDirection:'column', padding: 0, overflow:'hidden'
    }}>
      <div style={{ padding: '12px 15px', borderBottom: '1px solid #333', background: '#252528', display:'flex', justifyContent:'space-between', alignItems:'center', flexShrink: 0 }}>
        <h3 style={{ margin: 0, color:'#fff', fontSize: '16px', fontWeight: '800' }}>ì˜¤ë¼í´ ììœ ê²Œì‹œíŒ</h3>
        <div style={{ display:'flex', background:'#161b22', borderRadius:'6px', padding:'3px' }}>
          <button onClick={() => handleTabChange('all')} style={{ padding: '6px 12px', border: 'none', borderRadius: '4px', cursor: 'pointer', fontWeight: 'bold', fontSize:'12px', background: tab === 'all' ? '#30363d' : 'transparent', color: tab === 'all' ? '#fff' : '#666' }}>ì „ì²´</button>
          <button onClick={() => handleTabChange('best')} style={{ padding: '6px 12px', border: 'none', borderRadius: '4px', cursor: 'pointer', fontWeight: 'bold', fontSize:'12px', background: tab === 'best' ? '#e84057' : 'transparent', color: tab === 'best' ? '#fff' : '#666', display:'flex', alignItems:'center', gap:'4px' }}><Star size={12}/> ë…ê¸€</button>
        </div>
      </div>

      <div style={{ flex: 1, overflowY: 'auto', background: '#161b22' }}>
        {isMobile ? (
          <div>{currentPosts.map((post) => <MobilePostItem key={post.id} post={post} />)}</div>
        ) : (
          <table style={{ width: '100%', borderCollapse: 'collapse', fontSize:'13px', tableLayout:'fixed' }}>
            <thead>
              <tr style={{ background:'#161b22', color:'#8b949e', height:'35px', borderBottom:'1px solid #333' }}>
                <th style={{ width:'50px', textAlign:'center' }}>ë²ˆí˜¸</th>
                <th style={{ width:'60px', textAlign:'center' }}>íƒ­</th>
                <th style={{ textAlign:'left', paddingLeft:'10px' }}>ì œëª©</th>
                <th style={{ width:'100px', textAlign:'center' }}>ê¸€ì“´ì´</th>
                <th style={{ width:'70px', textAlign:'center' }}>ì‹œê°„</th>
                <th style={{ width:'50px', textAlign:'center' }}>ì¡°íšŒ</th>
                <th style={{ width:'50px', textAlign:'center' }}>ì¶”ì²œ</th>
              </tr>
            </thead>
            <tbody>
              {currentPosts.map((post, idx) => (
                <tr key={post.id} onClick={() => openPost(post)} style={{ borderBottom:'1px solid #252528', cursor:'pointer', height:'36px', background: post.isBest ? 'rgba(232, 64, 87, 0.05)' : 'transparent' }} onMouseEnter={e => e.currentTarget.style.backgroundColor = '#222'} onMouseLeave={e => e.currentTarget.style.backgroundColor = post.isBest ? 'rgba(232, 64, 87, 0.05)' : 'transparent'}>
                  <td style={{ textAlign:'center', color:'#555' }}>{filteredPosts.length - (startIndex + idx)}</td>
                  <td style={{ textAlign:'center', color: getCategoryColor(post.category) }}>{post.category}</td>
                  <td style={{ padding:'0 10px', overflow:'hidden', whiteSpace:'nowrap', textOverflow:'ellipsis' }}>
                    <span style={{ color: post.isBest ? '#fff' : '#ddd', fontWeight: post.isBest ? 'bold' : 'normal' }}>{post.title}</span>
                    {post.comments > 0 && <span style={{ color:'#58a6ff', fontSize:'11px', marginLeft:'6px', fontWeight:'bold' }}>[{post.comments}]</span>}
                  </td>
                  <td style={{ textAlign:'center', color:'#888', overflow:'hidden', whiteSpace:'nowrap', textOverflow:'ellipsis' }}>{post.author}</td>
                  <td style={{ textAlign:'center', color:'#666' }}>{post.displayTime}</td>
                  <td style={{ textAlign:'center', color:'#666' }}>{post.views}</td>
                  <td style={{ textAlign:'center', color: post.upvotes > 0 ? '#e84057' : '#666' }}>{post.upvotes}</td>
                </tr>
              ))}
            </tbody>
          </table>
        )}
        {currentPosts.length === 0 && <div style={{ textAlign:'center', padding:'40px', color:'#555', fontSize:'13px' }}>ê²Œì‹œê¸€ì´ ì—†ìŠµë‹ˆë‹¤.</div>}
      </div>

      <div style={{ padding: '12px', borderTop: '1px solid #333', display: 'flex', justifyContent: 'center', gap: '10px', background: '#161b22', flexShrink: 0 }}>
        <button disabled={page === 1} onClick={() => setPage(p => Math.max(1, p - 1))} className="btn" style={{ background:'#333', color:'#fff', padding:'6px 12px', opacity: page===1?0.5:1, fontSize:'12px' }}>ì´ì „</button>
        <span style={{ display:'flex', alignItems:'center', color:'#fff', padding:'0 10px', fontSize:'13px', fontFamily:'monospace' }}>{page} / {totalPages || 1}</span>
        <button disabled={page >= totalPages} onClick={() => setPage(p => Math.min(totalPages, p + 1))} className="btn" style={{ background:'#333', color:'#fff', padding:'6px 12px', opacity: page>=totalPages?0.5:1, fontSize:'12px' }}>ë‹¤ìŒ</button>
      </div>
    </div>
  );
};


--- FILE: src/components/community/PostDetailModal.tsx ---
// ==========================================
// FILE PATH: /src/components/community/PostDetailModal.tsx
// ==========================================

import React, { useState, useEffect } from 'react';
import { Post, UserProfile } from '../../types';
import { useGameStore } from '../../store/useGameStore';
// [ê²½ë¡œ ìˆ˜ì •ë¨] system í´ë” ì¶”ê°€
import { findUserProfileByName } from '../../engine/system/UserManager';
import { X, MessageSquare, ThumbsUp, ThumbsDown, User, Clock, Eye } from 'lucide-react';

interface Props {
  post: Post;
  onClose: () => void;
  onUserClick: (user: UserProfile) => void;
}

const getTierColor = (tier: string) => {
  if (tier.includes('ì²œìƒê³„') || tier.includes('ì±Œë¦°ì €')) return '#00bfff';
  if (tier.includes('ë§ˆìŠ¤í„°')) return '#9b59b6';
  if (tier.includes('ì—ì´ìŠ¤')) return '#e74c3c';
  if (tier.includes('ì¡°ì»¤')) return '#2ecc71';
  if (tier.includes('ê³¨ë“œ')) return '#f1c40f';
  if (tier.includes('ì‹¤ë²„')) return '#95a5a6';
  if (tier.includes('ë¸Œë¡ ì¦ˆ')) return '#d35400';
  return '#7f8c8d';
};

export const PostDetailModal: React.FC<Props> = ({ post, onClose, onUserClick }) => {
  const { gameState } = useGameStore();
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  useEffect(() => {
    document.body.style.overflow = 'hidden';
    return () => { document.body.style.overflow = 'unset'; };
  }, []);

  const handleAuthorClick = () => {
    const userProfile = findUserProfileByName(post.author, gameState.tierConfig);
    if (userProfile) {
      onUserClick(userProfile);
    } else {
      alert("í•´ë‹¹ ìœ ì € ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }
  };

  const overlayStyle: React.CSSProperties = isMobile ? {
    position: 'fixed', inset: 0, zIndex: 20000, 
    backgroundColor: '#0f1115',
    overflowY: 'auto', WebkitOverflowScrolling: 'touch',
    display: 'block'
  } : {
    position: 'fixed', top: 0, left: 0, width: '100%', height: '100%',
    backgroundColor: 'rgba(0,0,0,0.85)', display: 'flex', justifyContent: 'center', alignItems: 'center', 
    zIndex: 20000, backdropFilter: 'blur(3px)'
  };

  const panelStyle: React.CSSProperties = isMobile ? {
    width: '100%', minHeight: '100%', 
    background: '#1c1c1f', display: 'flex', flexDirection: 'column',
    boxSizing: 'border-box'
  } : {
    width: '100%', maxWidth: '700px', height:'85vh', 
    background: '#1c1c1f', border: '1px solid #30363d', 
    display:'flex', flexDirection:'column', borderRadius: '12px', overflow: 'hidden',
    boxShadow: '0 50px 100px -20px rgba(0,0,0,0.7)'
  };

  return (
    <div style={overlayStyle}>
      <div style={panelStyle}>
        {/* í—¤ë” */}
        <div style={{ 
          padding: '15px 20px', borderBottom: '1px solid #30363d', 
          display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start',
          background: '#252528',
          position: isMobile ? 'sticky' : 'relative', top: 0, zIndex: 50
        }}>
          <div style={{ flex: 1, paddingRight: '10px' }}>
            <div style={{ display:'flex', alignItems:'center', gap:'8px', marginBottom: '6px' }}>
              <span style={{ fontSize: '11px', color: '#58a6ff', border:'1px solid #58a6ff', padding:'1px 4px', borderRadius:'3px' }}>
                {post.category}
              </span>
              {post.isBest && <span style={{ fontSize: '11px', background: '#e84057', color: '#fff', padding:'1px 4px', borderRadius:'3px' }}>ë…ê¸€</span>}
            </div>
            <h2 style={{ margin: 0, fontSize: '18px', color: '#fff', lineHeight:'1.4', wordBreak:'keep-all' }}>{post.title}</h2>

            <div style={{ marginTop: '10px', fontSize: '12px', color: '#8b949e', display:'flex', flexWrap:'wrap', alignItems:'center', gap:'10px' }}>
              <div 
                onClick={handleAuthorClick}
                style={{ 
                  display:'flex', alignItems:'center', gap:'4px', cursor:'pointer', 
                  color: '#ccc', fontWeight:'bold', 
                  background: '#30363d', padding: '4px 8px', borderRadius: '4px',
                  border: '1px solid #444'
                }}
              >
                <User size={12} />
                {post.author} 
                <span style={{color: getTierColor(post.authorTier), fontWeight:'bold', fontSize:'11px'}}>
                  ({post.authorTier})
                </span>
              </div>
              <span style={{ display:'flex', alignItems:'center', gap:'4px' }}><Clock size={12}/> {post.displayTime}</span>
              <span style={{ display:'flex', alignItems:'center', gap:'4px' }}><Eye size={12}/> {post.views}</span>
            </div>
          </div>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#fff', cursor: 'pointer', padding:'5px' }}>
            <X size={24} />
          </button>
        </div>

        {/* ë³¸ë¬¸ */}
        <div style={{ 
          padding: '25px 20px', 
          color: '#e6edf3', fontSize: '15px', lineHeight: '1.7', 
          flex: 1, 
          overflowY: isMobile ? 'visible' : 'auto', 
          whiteSpace: 'pre-wrap',
          minHeight: '200px'
        }}>
          {post.content}
          <div style={{ marginTop:'50px', display:'flex', justifyContent:'center', gap:'15px' }}>
            <button style={{ 
              background:'#21262d', border:'1px solid #30363d', color:'#fff', 
              padding:'10px 20px', borderRadius:'30px', 
              display:'flex', alignItems:'center', gap:'8px', cursor:'pointer',
              fontSize:'14px', fontWeight:'bold'
            }}>
              <ThumbsUp size={18} color="#e89d40" /> 
              <span>{post.upvotes}</span>
            </button>
            <button style={{ 
              background:'#21262d', border:'1px solid #30363d', color:'#8b949e', 
              padding:'10px 20px', borderRadius:'30px', 
              display:'flex', alignItems:'center', gap:'8px', cursor:'pointer',
              fontSize:'14px', fontWeight:'bold'
            }}>
              <ThumbsDown size={18} /> 
              <span>{post.downvotes || 0}</span>
            </button>
          </div>
        </div>

        {/* ëŒ“ê¸€ì°½ */}
        <div style={{ background: '#161b22', borderTop: '1px solid #30363d', flexShrink: 0 }}>
          <div style={{ padding: '15px 20px', display:'flex', alignItems:'center', gap:'6px', color:'#fff', borderBottom:'1px solid #30363d', background:'#252528' }}>
            <MessageSquare size={16} /> ëŒ“ê¸€ <span style={{color:'#58a6ff', fontWeight:'bold'}}>{post.commentList?.length || 0}</span>
          </div>
          <div style={{ 
            maxHeight: isMobile ? 'none' : '300px', 
            overflowY: isMobile ? 'visible' : 'auto',
            paddingBottom: isMobile ? '50px' : '0' 
          }}>
            <div style={{ display:'flex', flexDirection:'column' }}>
              {post.commentList && post.commentList.map((comment) => (
                <div key={comment.id} style={{ padding: '15px 20px', borderBottom: '1px solid #2c2c2f' }}>
                  <div style={{ display:'flex', justifyContent:'space-between', marginBottom:'6px' }}>
                    <span style={{ fontWeight:'bold', fontSize:'13px', color:'#ccc', display:'flex', alignItems:'center', gap:'6px' }}>
                      {comment.author} 
                      <span style={{ fontSize:'10px', color: getTierColor(comment.authorTier), background:'#0d1117', padding:'1px 4px', borderRadius:'3px', border:'1px solid #333', fontWeight:'bold' }}>
                        {comment.authorTier}
                      </span>
                    </span>
                    <span style={{ fontSize:'11px', color:'#555' }}>{comment.timestamp}</span>
                  </div>
                  <div style={{ fontSize:'13px', color:'#aaa', lineHeight:'1.4' }}>{comment.content}</div>
                </div>
              ))}
              {(!post.commentList || post.commentList.length === 0) && (
                <div style={{ color:'#555', fontSize:'13px', textAlign:'center', padding:'40px 20px' }}>
                  ì•„ì§ ì‘ì„±ëœ ëŒ“ê¸€ì´ ì—†ìŠµë‹ˆë‹¤.
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

--- FILE: src/components/dashboard/GameStats.tsx ---
// ==========================================
// FILE PATH: /src/components/dashboard/GameStats.tsx
// ==========================================

import React from 'react';
import { useGameStore } from '../../store/useGameStore';
import { StatCard } from '../common/StatCard';
import { Users, Activity, Smile, Frown, Meh, Monitor } from 'lucide-react';

interface Props {
  isMobile: boolean;
  onOpenGameList: () => void;
}

export const GameStats: React.FC<Props> = ({ isMobile, onOpenGameList }) => {
  const { gameState } = useGameStore();

  // ë¯¼ì‹¬ ìƒíƒœì— ë”°ë¥¸ UI ì†ì„± ë°˜í™˜
  const getSentimentInfo = (value: number) => {
    if (value >= 70) return { icon: Smile, color: '#2ecc71', label: 'ì¶•ì œ' }; // ë†’ìŒ: ì´ˆë¡
    if (value >= 40) return { icon: Meh, color: '#f1c40f', label: 'ë³´í†µ' };   // ì¤‘ê°„: ë…¸ë‘
    return { icon: Frown, color: '#e74c3c', label: 'í­ë™' };                  // ë‚®ìŒ: ë¹¨ê°•
  };

  const sentiment = gameState.userSentiment || 60;
  const sentInfo = getSentimentInfo(sentiment);

  return (
    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: isMobile ? '6px' : '15px', marginBottom: '20px' }}>

      <StatCard 
        title="ê°€ì…ì" 
        value={(gameState.totalUsers ?? 0).toLocaleString()} 
        icon={Users} 
        color="#fff" 
      />

      <StatCard 
        title="CCU" 
        value={(gameState.ccu ?? 0).toLocaleString()} 
        icon={Activity} 
        color="#58a6ff" 
      />

      {/* ë™ì  ë¯¼ì‹¬ ì¹´ë“œ */}
      <StatCard 
        title={`ë¯¼ì‹¬ (${sentInfo.label})`} 
        value={sentiment.toFixed(1)} 
        icon={sentInfo.icon} 
        color={sentInfo.color} 
      />

      <div onClick={onOpenGameList} style={{ cursor: 'pointer' }}>
        <StatCard 
          title="ì§„í–‰ì¤‘" 
          value={gameState.liveMatches?.length ?? 0} 
          icon={Monitor} 
          color="#9b59b6" 
        />
      </div>
    </div>
  );
};

--- FILE: src/components/hero/CustomizeHeroModal.tsx ---
// ==========================================
// FILE PATH: /src/components/hero/CustomizeHeroModal.tsx
// ==========================================

import React, { useState, useRef } from 'react';
import { Hero } from '../../types';
import { useGameStore } from '../../store/useGameStore';
import { X, Save, Camera, Image as ImageIcon, Upload, Trash2 } from 'lucide-react';
import { GameIcon } from '../common/GameIcon';

interface Props {
  hero: Hero;
  onClose: () => void;
}

export const CustomizeHeroModal: React.FC<Props> = ({ hero, onClose }) => {
  const { updateHero, setCustomImage, removeCustomImage } = useGameStore();

  // ìƒíƒœ ê´€ë¦¬: hero.conceptê°€ ìˆìœ¼ë©´ ê·¸ê±¸ ì“°ê³ , ì—†ìœ¼ë©´ ê¸°ë³¸ ë¬¸êµ¬
  const [name, setName] = useState(hero.name);
  const [concept, setConcept] = useState(hero.concept || "ìƒˆë¡œìš´ ì˜ì›…ì˜ íƒ„ìƒ");

  const profileRef = useRef<HTMLInputElement>(null);
  const bgRef = useRef<HTMLInputElement>(null);

  const handleSave = () => {
    // [í•µì‹¬ ìˆ˜ì •] concept í•„ë“œì— ì§ì ‘ ì €ì¥í•˜ì—¬ ì¦‰ì‹œ ë°˜ì˜ë˜ë„ë¡ í•¨
    updateHero(hero.id, { name, concept });
    alert('ì»¤ìŠ¤í„°ë§ˆì´ì§•ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
    onClose();
  };

  const handleUpload = (id: string, e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        if (typeof reader.result === 'string') setCustomImage(id, reader.result);
      };
      reader.readAsDataURL(file);
    }
  };

  return (
    <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.85)', zIndex: 9999, display: 'flex', justifyContent: 'center', alignItems: 'center', padding:'20px' }}>
      <div style={{ width: '100%', maxWidth: '400px', background: '#161b22', borderRadius: '16px', border: '1px solid #30363d', overflow: 'hidden' }}>

        {/* í—¤ë” */}
        <div style={{ padding: '15px 20px', borderBottom: '1px solid #333', display: 'flex', justifyContent: 'space-between', alignItems: 'center', background:'#21262d' }}>
          <h3 style={{ margin: 0, color: '#fff', fontSize:'16px' }}>ì˜ì›… ì»¤ìŠ¤í„°ë§ˆì´ì§•</h3>
          <button onClick={onClose} style={{ background:'none', border:'none', color:'#ccc', cursor:'pointer' }}><X size={20}/></button>
        </div>

        {/* ë°”ë”” */}
        <div style={{ padding: '20px', display:'flex', flexDirection:'column', gap:'20px' }}>

          {/* 1. ì‚¬ì§„ ë³€ê²½ ì˜ì—­ */}
          <div style={{ display:'flex', gap:'15px' }}>
            {/* í”„ë¡œí•„ ì‚¬ì§„ */}
            <div style={{ flex:1, display:'flex', flexDirection:'column', gap:'5px' }}>
                <div 
                onClick={() => profileRef.current?.click()}
                style={{ aspectRatio:'1/1', background:'#0d1117', border:'1px dashed #555', borderRadius:'12px', display:'flex', flexDirection:'column', alignItems:'center', justifyContent:'center', cursor:'pointer', color:'#888' }}
                >
                <GameIcon id={hero.id} size={50} shape="rounded" />
                <div style={{ fontSize:'11px', marginTop:'8px', display:'flex', alignItems:'center', gap:'4px' }}><Camera size={12}/> í”„ë¡œí•„</div>
                <input type="file" ref={profileRef} style={{ display: 'none' }} accept="image/*" onChange={(e) => handleUpload(hero.id, e)} />
                </div>
                <button onClick={() => removeCustomImage(hero.id)} style={{ fontSize:'10px', color:'#da3633', background:'none', border:'none', cursor:'pointer', display:'flex', justifyContent:'center', alignItems:'center', gap:'2px' }}>
                    <Trash2 size={10}/> ì´ˆê¸°í™”
                </button>
            </div>

            {/* ë°°ê²½ ì‚¬ì§„ */}
            <div style={{ flex:1, display:'flex', flexDirection:'column', gap:'5px' }}>
                <div 
                onClick={() => bgRef.current?.click()}
                style={{ aspectRatio:'1/1', background:'#0d1117', border:'1px dashed #555', borderRadius:'12px', display:'flex', flexDirection:'column', alignItems:'center', justifyContent:'center', cursor:'pointer', color:'#888' }}
                >
                <ImageIcon size={30} />
                <div style={{ fontSize:'11px', marginTop:'8px', display:'flex', alignItems:'center', gap:'4px' }}><Upload size={12}/> ë°°ê²½</div>
                <input type="file" ref={bgRef} style={{ display: 'none' }} accept="image/*" onChange={(e) => handleUpload(`${hero.id}_bg`, e)} />
                </div>
                <button onClick={() => removeCustomImage(`${hero.id}_bg`)} style={{ fontSize:'10px', color:'#da3633', background:'none', border:'none', cursor:'pointer', display:'flex', justifyContent:'center', alignItems:'center', gap:'2px' }}>
                    <Trash2 size={10}/> ì´ˆê¸°í™”
                </button>
            </div>
          </div>

          {/* 2. í…ìŠ¤íŠ¸ ë³€ê²½ ì˜ì—­ */}
          <div>
            <label style={{ fontSize:'12px', color:'#8b949e', marginBottom:'5px', display:'block' }}>ì˜ì›… ì´ë¦„</label>
            <input 
              type="text" value={name} onChange={(e) => setName(e.target.value)}
              style={{ width:'100%', padding:'12px', background:'#0d1117', border:'1px solid #30363d', color:'#fff', borderRadius:'8px', fontSize:'14px', fontWeight:'bold', boxSizing:'border-box' }}
            />
          </div>

          <div>
            <label style={{ fontSize:'12px', color:'#8b949e', marginBottom:'5px', display:'block' }}>ì»¨ì…‰ ë¬¸êµ¬ (ëŒ€ì‚¬)</label>
            <input 
              type="text" value={concept} onChange={(e) => setConcept(e.target.value)}
              style={{ width:'100%', padding:'12px', background:'#0d1117', border:'1px solid #30363d', color:'#fff', borderRadius:'8px', fontSize:'13px', fontStyle:'italic', boxSizing:'border-box' }}
            />
          </div>

        </div>

        {/* í‘¸í„° */}
        <div style={{ padding: '15px', borderTop: '1px solid #333', background:'#21262d' }}>
          <button onClick={handleSave} style={{ width:'100%', padding:'12px', background:'#238636', color:'#fff', border:'none', borderRadius:'8px', fontWeight:'bold', cursor:'pointer', display:'flex', justifyContent:'center', gap:'8px' }}>
            <Save size={16}/> ì €ì¥í•˜ê¸°
          </button>
        </div>

      </div>
    </div>
  );
};

--- FILE: src/components/hero/HeroDetailView.tsx ---
// ==========================================
// FILE PATH: /src/components/hero/HeroDetailView.tsx
// ==========================================

import React, { useState, useEffect, useMemo } from 'react';
import { Hero } from '../../types';
import { useGameStore } from '../../store/useGameStore';
import { ROLE_DATA } from '../../data/roles';
import { 
  X, Wrench, Edit, Swords, Shield, Zap, Target, Skull, Trophy, 
  Activity, BarChart2, Clock, Search, Heart, Footprints, Crosshair, Droplets, Flame, Trash
} from 'lucide-react'; // [ìˆ˜ì •] Trash ì•„ì´ì½˜ ì¶”ê°€
import { GameIcon } from '../common/GameIcon';
import { CustomizeHeroModal } from './CustomizeHeroModal';
import { HeroVsModal } from './HeroVsModal';

interface Props {
  hero: Hero;
  onBack: () => void;
  onPatch: () => void;
}

export const HeroDetailView: React.FC<Props> = ({ hero, onBack, onPatch }) => {
  // [ìˆ˜ì •] deleteHero ì¶”ê°€
  const { heroes, gameState, shopItems, deleteHero } = useGameStore();
  const [activeTab, setActiveTab] = useState<'SUMMARY' | 'COUNTER' | 'COMBAT' | 'BUILD'>('SUMMARY');
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
  const [showCustomize, setShowCustomize] = useState(false);

  const [selectedEnemy, setSelectedEnemy] = useState<Hero | null>(null);
  const [enemySearch, setEnemySearch] = useState('');

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const roleInfo = ROLE_DATA[hero.role];
  const bgId = `${hero.id}_bg`;
  const customBg = gameState.customImages?.[bgId];

  // ì˜ì›… ê³ ìœ  ëŒ€ì‚¬ í‘œì‹œ
  const displayConcept = hero.concept || roleInfo.concept;

  // [ì‹ ê·œ] ì˜ì›… ì‚­ì œ í•¸ë“¤ëŸ¬
  const handleDelete = () => {
    if (confirm(`ì •ë§ '${hero.name}' ì˜ì›…ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nì‚­ì œëœ ì˜ì›…ì€ ë³µêµ¬í•  ìˆ˜ ì—†ìœ¼ë©°, í†µê³„ ë°ì´í„°ë„ ì‚¬ë¼ì§‘ë‹ˆë‹¤.`)) {
      deleteHero(hero.id);
      onBack(); // ëª©ë¡ìœ¼ë¡œ ëŒì•„ê°€ê¸°
    }
  };

  // --- [ë°ì´í„° ê³„ì‚°] ---
  const totalMatches = Math.max(1, hero.record.totalMatches);
  const winRate = (hero.record.totalWins / totalMatches) * 100;

  const parseStat = (val: string) => parseFloat(val.replace(/,/g, '')) || 0;

  const dpm = parseStat(hero.avgDpm);
  const dpg = parseStat(hero.avgDpg);
  const gpm = parseStat(hero.avgGold);
  const cspm = parseStat(hero.avgCs);

  const avgKills = hero.record.totalKills / totalMatches;
  const avgDeaths = hero.record.totalDeaths / totalMatches;
  const avgAssists = hero.record.totalAssists / totalMatches;
  const survivalRate = Math.max(0, 100 - (avgDeaths * 10));
  const killParticipation = Math.min(100, ((avgKills + avgAssists) / (avgKills + avgDeaths + avgAssists + 5)) * 100);

  let objectDmgFactor = 0.2;
  if (hero.role === 'ì‹ ì‚´ì') objectDmgFactor = 0.5;
  if (hero.role === 'ì¶”ì ì') objectDmgFactor = 0.4;
  const objectDpm = dpm * objectDmgFactor;

  let ccScore = 0;
  ['q','w','e','r'].forEach(k => {
    const s = (hero.skills as any)[k];
    if (s.mechanic === 'STUN' || s.mechanic === 'HOOK') ccScore += 15;
    if (s.mechanic === 'GLOBAL') ccScore += 10;
  });
  ccScore += (avgAssists * 2);

  const enemyList = useMemo(() => {
    return heroes
      .filter(h => h.id !== hero.id && h.name.includes(enemySearch))
      .sort((a, b) => b.recentWinRate - a.recentWinRate);
  }, [heroes, hero.id, enemySearch]);

  const recommendedItems = useMemo(() => {
    const itemStats = gameState.itemStats;
    const isAD = hero.stats.ad > hero.stats.ap;
    const isTank = hero.role === 'ìˆ˜í˜¸ê¸°ì‚¬';

    const suitableItems = shopItems.filter(item => {
      if (item.type === 'POWER') return true;
      if (isTank) return item.type === 'ARMOR' || item.hp > 0;
      if (isAD) return item.ad > 0 || item.crit > 0 || item.speed > 0;
      return item.ap > 0; 
    });

    return suitableItems.map(item => {
      const stat = itemStats[item.id] || { totalWins: 0, totalPicks: 0 };
      const iWinRate = stat.totalPicks > 0 ? (stat.totalWins / stat.totalPicks) * 100 : 0;
      return { item, winRate: iWinRate, picks: stat.totalPicks };
    })
    .sort((a, b) => b.winRate - a.winRate)
    .slice(0, 6);
  }, [hero, shopItems, gameState.itemStats]);

  // --- [UI í—¬í¼] ---
  const getScoreColor = (score: number, standard: number) => {
    if (score >= standard * 1.1) return '#ff4d4d'; 
    if (score >= standard * 0.95) return '#2ecc71'; 
    return '#8b949e'; 
  };

  const getSmartSkillInfo = (skill: any) => {
    let desc = "ì ì—ê²Œ ê¸°ë³¸ í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤.";
    let tag = "ê³µê²©";
    let color = "#ccc";
    let icon = <Swords size={12}/>;

    switch (skill.mechanic) {
      case 'DAMAGE': desc = "ê°•ë ¥í•œ í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤."; tag = "í”¼í•´"; color = "#e74c3c"; break;
      case 'HEAL': desc = "ì²´ë ¥ì„ íšŒë³µì‹œí‚µë‹ˆë‹¤."; tag = "íšŒë³µ"; color = "#2ecc71"; icon = <Activity size={12}/>; break;
      case 'SHIELD': desc = "í”¼í•´ë¥¼ í¡ìˆ˜í•©ë‹ˆë‹¤."; tag = "ë³´í˜¸"; color = "#3498db"; icon = <Shield size={12}/>; break;
      case 'STUN': desc = "ì ì„ ê¸°ì ˆì‹œí‚µë‹ˆë‹¤."; tag = "ì œì–´"; color = "#f1c40f"; icon = <Zap size={12}/>; break;
      case 'HOOK': desc = "ì ì„ ëŒì–´ì˜µë‹ˆë‹¤."; tag = "ê·¸ë©"; color = "#9b59b6"; icon = <Target size={12}/>; break;
      case 'DASH': desc = "ë¹ ë¥´ê²Œ ì´ë™í•©ë‹ˆë‹¤."; tag = "ì´ë™"; color = "#95a5a6"; icon = <Activity size={12}/>; break;
      case 'STEALTH': desc = "ëª¨ìŠµì„ ê°ì¶¥ë‹ˆë‹¤."; tag = "ì€ì‹ "; color = "#7f8c8d"; break;
      case 'EXECUTE': desc = "ì¹˜ëª…ì ì¸ í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤."; tag = "ì²˜í˜•"; color = "#da3633"; icon = <Skull size={12}/>; break;
      case 'GLOBAL': desc = "ë§µ ì „ì²´ì— ì˜í–¥ì„ ì¤ë‹ˆë‹¤."; tag = "ê´‘ì—­"; color = "#e67e22"; icon = <Zap size={12}/>; break;
    }
    return { desc, tag, color, icon };
  };

  const StatRow = ({ label, value, subValue, color }: any) => (
    <div style={{ display:'flex', flexDirection:'column', justifyContent:'center', padding:'10px', background:'rgba(255,255,255,0.03)', borderRadius:'8px' }}>
      <span style={{ color:'#888', fontSize:'11px', marginBottom:'2px' }}>{label}</span>
      <div style={{ color: color || '#fff', fontWeight:'800', fontSize:'15px', fontFamily:'monospace' }}>{value}</div>
      {subValue && <div style={{ color:'#555', fontSize:'10px' }}>{subValue}</div>}
    </div>
  );

  const TabButton = ({ id, label, icon }: any) => (
    <button 
      onClick={() => setActiveTab(id)}
      style={{ 
        flex: 1, display:'flex', alignItems:'center', justifyContent:'center', gap:'4px',
        padding: '12px 0',
        background: activeTab === id ? 'rgba(88, 166, 255, 0.2)' : 'rgba(0,0,0,0.6)',
        border: 'none', borderBottom: activeTab === id ? '3px solid #58a6ff' : '3px solid transparent',
        color: activeTab === id ? '#58a6ff' : '#aaa', fontWeight:'bold', cursor:'pointer', transition:'0.2s',
        fontSize: '11px', whiteSpace: 'nowrap'
      }}
    >
      {React.cloneElement(icon, { size: 14 })} {label}
    </button>
  );

  const HeroSpecItem = ({ icon, label, value, color }: any) => (
    <div style={{ 
      display:'flex', alignItems:'center', justifyContent:'space-between',
      background:'#161b22', padding:'6px 10px', borderRadius:'6px', 
      border:'1px solid #30363d', minWidth:'80px'
    }}>
      <div style={{ display:'flex', alignItems:'center', gap:'6px' }}>
        {React.cloneElement(icon, { size: 12, color: color })}
        <span style={{ fontSize:'10px', color:'#aaa', fontWeight:'bold' }}>{label}</span>
      </div>
      <span style={{ fontSize:'12px', fontWeight:'900', color:'#fff', fontFamily:'monospace' }}>{value}</span>
    </div>
  );

  return (
    <div style={{ 
      position: 'fixed', inset: 0, zIndex: 9999,
      display: 'flex', justifyContent: 'center', alignItems: 'center',
      backgroundColor: 'rgba(0,0,0,0.85)', backdropFilter: 'blur(5px)'
    }}>

      <div style={{ 
        width: isMobile ? '100%' : '650px', 
        height: isMobile ? '100%' : '90vh',
        backgroundColor: '#0d1117', 
        display: 'flex', flexDirection: 'column', 
        overflow: 'hidden', position: 'relative',
        borderRadius: isMobile ? '0' : '16px',
        border: isMobile ? 'none' : '1px solid #30363d',
        boxShadow: '0 20px 60px rgba(0,0,0,0.8)'
      }}>

        {/* ë°°ê²½ ì´ë¯¸ì§€ */}
        <div style={{
          position: 'absolute', top: 0, left: 0, width: '100%', height: '100%',
          backgroundImage: customBg ? `url(${customBg})` : 'none',
          backgroundSize: 'cover', backgroundPosition: 'center top', zIndex: 0,
          opacity: 0.6, pointerEvents: 'none'
        }} />
        <div style={{
          position: 'absolute', top: 0, left: 0, width: '100%', height: '100%',
          background: 'linear-gradient(to bottom, rgba(13,17,23,0.2) 0%, rgba(13,17,23,0.9) 50%, #0d1117 100%)',
          zIndex: 1, pointerEvents: 'none'
        }} />

        {/* ë‹«ê¸° ë²„íŠ¼ */}
        <div style={{ padding: '15px 20px', position: 'relative', zIndex: 10, display: 'flex', justifyContent: 'flex-end' }}>
          <button onClick={onBack} style={{ background:'rgba(0,0,0,0.5)', border:'1px solid rgba(255,255,255,0.2)', color:'#fff', padding:'8px', borderRadius:'50%', cursor:'pointer', display:'flex', alignItems:'center', justifyContent:'center' }}>
            <X size={20}/>
          </button>
        </div>

        {/* ë©”ì¸ ìŠ¤í¬ë¡¤ ì˜ì—­ */}
        <div style={{ flex: 1, overflowY: 'auto', position: 'relative', zIndex: 10, scrollbarWidth:'none', paddingBottom:'50px' }}>

          {/* 1. í—¤ë” ì„¹ì…˜ */}
          <div style={{ padding: '0 20px 20px 20px', display: 'flex', flexDirection: 'row', gap: '20px', alignItems: 'center' }}>
            <div style={{ flexShrink: 0 }}>
              <GameIcon id={hero.id} size={isMobile ? 100 : 120} shape="rounded" border={`3px solid ${roleInfo.color}`} />
            </div>
            <div style={{ display:'flex', flexDirection:'column', gap:'4px', flex: 1 }}>
              <h1 style={{ margin: 0, fontSize: isMobile ? '24px' : '32px', fontWeight: '900', color: '#fff', textShadow: '0 2px 10px rgba(0,0,0,0.8)' }}>{hero.name}</h1>
              <div style={{ display:'flex', gap:'6px', alignItems:'center', marginTop:'4px' }}>
                <span style={{ fontSize: '11px', fontWeight: '800', color: '#000', background: roleInfo.color, padding:'2px 8px', borderRadius:'4px' }}>{hero.role}</span>
                <span style={{ fontSize: '11px', fontWeight: '800', color: roleInfo.color, border:`1px solid ${roleInfo.color}`, padding:'2px 8px', borderRadius:'4px' }}>{hero.tier}í‹°ì–´</span>
              </div>

              {/* ì˜ì›… ê³ ìœ  ëŒ€ì‚¬ */}
              <p style={{ 
                margin: '8px 0 10px 0', fontSize: '13px', color: '#e0e0e0', fontStyle: 'italic', opacity: 0.9, 
                borderLeft:`3px solid ${roleInfo.color}`, paddingLeft:'10px', lineHeight:'1.4', background:'rgba(0,0,0,0.3)', padding:'8px 10px', borderRadius:'0 6px 6px 0'
              }}>
                "{displayConcept}"
              </p>

              {/* [ìˆ˜ì •] ë²„íŠ¼ ê·¸ë£¹ (ì‚­ì œ ë²„íŠ¼ í¬í•¨) */}
              <div style={{ display: 'flex', gap: '8px' }}>
                <button onClick={onPatch} style={{ flex:1, background:'#238636', border:'none', color:'#fff', padding:'6px', borderRadius:'4px', fontWeight:'bold', fontSize:'12px', cursor:'pointer', display:'flex', alignItems:'center', justifyContent:'center', gap:'4px' }}>
                  <Wrench size={12}/> íŒ¨ì¹˜
                </button>
                <button onClick={() => setShowCustomize(true)} style={{ flex:1, background:'#1f6feb', border:'none', color:'#fff', padding:'6px', borderRadius:'4px', fontWeight:'bold', fontSize:'12px', cursor:'pointer', display:'flex', alignItems:'center', justifyContent:'center', gap:'4px' }}>
                  <Edit size={12}/> ì»¤ìŠ¤í…€
                </button>
                <button onClick={handleDelete} style={{ flex:1, background:'#3f1515', border:'1px solid #5a1e1e', color:'#ff6b6b', padding:'6px', borderRadius:'4px', fontWeight:'bold', fontSize:'12px', cursor:'pointer', display:'flex', alignItems:'center', justifyContent:'center', gap:'4px' }}>
                  <Trash size={12}/> ì‚­ì œ
                </button>
              </div>
            </div>
          </div>

          {/* 2. ìƒì„¸ ìŠ¤íƒ¯ ê·¸ë¦¬ë“œ (ëª¨ë“  ì •ë³´ í‘œì‹œ) */}
          <div style={{ padding: '0 20px 20px 20px' }}>
            <div style={{ 
              display: 'grid', 
              gridTemplateColumns: isMobile ? '1fr 1fr' : 'repeat(4, 1fr)', 
              gap: '6px' 
            }}>
              {/* Row 1: ê¸°ë³¸ ì²´ê¸‰ */}
              <HeroSpecItem label="HP" value={hero.stats.hp} icon={<Heart/>} color="#2ecc71" />
              <HeroSpecItem label="MP" value={hero.stats.mp || 300} icon={<Droplets/>} color="#3498db" />
              <HeroSpecItem label="AD" value={hero.stats.ad} icon={<Swords/>} color="#da3633" />
              <HeroSpecItem label="AP" value={hero.stats.ap} icon={<Zap/>} color="#9b59b6" />

              {/* Row 2: ë°©ì–´/ì´ë™ */}
              <HeroSpecItem label="DEF" value={hero.stats.armor} icon={<Shield/>} color="#58a6ff" />
              <HeroSpecItem label="SPD" value={hero.stats.speed} icon={<Footprints/>} color="#f1c40f" />
              <HeroSpecItem label="RNG" value={hero.stats.range} icon={<Crosshair/>} color="#ccc" />
              <HeroSpecItem label="CRI" value={`${hero.stats.crit}%`} icon={<Target/>} color="#e67e22" />

              {/* Row 3: ì¬ìƒ/ê´€í†µ/ê¸°ë³¸ê³µê²© */}
              <HeroSpecItem label="H.Reg" value={hero.stats.regen} icon={<Activity/>} color="#2ecc71" />
              <HeroSpecItem label="M.Reg" value={hero.stats.mpRegen || 5} icon={<Activity/>} color="#3498db" />
              <HeroSpecItem label="PEN" value={hero.stats.pen} icon={<Flame/>} color="#da3633" />
              <HeroSpecItem label="BASE" value={hero.stats.baseAtk} icon={<Swords/>} color="#777" />
            </div>
          </div>

          {/* íƒ­ ë©”ë‰´ */}
          <div style={{ display: 'flex', background: '#161b22', borderBottom: '1px solid #30363d', borderTop: '1px solid rgba(255,255,255,0.1)', position: 'sticky', top: 0, zIndex: 20 }}>
            <TabButton id="SUMMARY" label="ì¢…í•©ë¶„ì„" icon={<BarChart2/>} />
            <TabButton id="COUNTER" label="ìƒëŒ€ë¶„ì„" icon={<Swords/>} />
            <TabButton id="COMBAT" label="ì „íˆ¬ì„±ì¥" icon={<Activity/>} />
            <TabButton id="BUILD" label="ì•„ì´í…œ" icon={<Zap/>} />
          </div>

          {/* íƒ­ ì»¨í…ì¸  */}
          <div style={{ padding: '20px', minHeight: '400px', background: 'rgba(13, 17, 23, 0.95)' }}>

            {/* TAB 1: ì¢…í•© ë¶„ì„ */}
            {activeTab === 'SUMMARY' && (
              <div style={{ display: 'flex', flexDirection: 'column', gap: '15px' }}>
                <div style={{ background: '#1c1c1f', padding: '15px', borderRadius: '12px', border: '1px solid #333' }}>
                  <h3 style={{ margin:'0 0 12px 0', fontSize:'14px', color:'#f1c40f', display:'flex', gap:'6px', alignItems:'center' }}>
                    <Trophy size={14}/> ì‹œì¦Œ í¼í¬ë¨¼ìŠ¤
                  </h3>
                  <div style={{ display:'grid', gridTemplateColumns:'1fr 1fr 1fr 1fr', gap:'8px', textAlign:'center' }}>
                    <div style={{ display:'flex', flexDirection:'column', gap:'2px' }}>
                      <div style={{ fontSize:'10px', color:'#888' }}>ìŠ¹ë¥ </div>
                      <div style={{ fontSize:'15px', fontWeight:'900', color: getScoreColor(winRate, 50) }}>{winRate.toFixed(0)}%</div>
                    </div>
                    <div style={{ display:'flex', flexDirection:'column', gap:'2px', borderLeft:'1px solid #333' }}>
                      <div style={{ fontSize:'10px', color:'#888' }}>KDA</div>
                      <div style={{ fontSize:'15px', fontWeight:'900', color: getScoreColor(parseFloat(hero.kdaRatio), 3.0) }}>{hero.kdaRatio}</div>
                    </div>
                    <div style={{ display:'flex', flexDirection:'column', gap:'2px', borderLeft:'1px solid #333' }}>
                      <div style={{ fontSize:'10px', color:'#888' }}>í”½ë¥ </div>
                      <div style={{ fontSize:'15px', fontWeight:'900', color:'#fff' }}>{hero.pickRate.toFixed(0)}%</div>
                    </div>
                    <div style={{ display:'flex', flexDirection:'column', gap:'2px', borderLeft:'1px solid #333' }}>
                      <div style={{ fontSize:'10px', color:'#da3633' }}>ë°´ë¥ </div>
                      <div style={{ fontSize:'15px', fontWeight:'900', color:'#da3633' }}>{hero.banRate.toFixed(0)}%</div>
                    </div>
                  </div>
                </div>

                {/* ìŠ¤í‚¬ ì •ë³´ (ë§ˆë‚˜ ì†Œëª¨ í¬í•¨) */}
                <div style={{ background: '#1c1c1f', padding: '15px', borderRadius: '12px', border: '1px solid #333' }}>
                  <h3 style={{ margin:'0 0 12px 0', fontSize:'14px', color:'#fff', display:'flex', gap:'6px', alignItems:'center' }}>
                    <Zap size={14}/> ìŠ¤í‚¬ ì •ë³´
                  </h3>
                  <div style={{ display:'flex', flexDirection:'column', gap:'8px' }}>
                    {['passive', 'q', 'w', 'e', 'r'].map((key) => {
                      const skill = (hero.skills as any)[key];
                      const { desc, tag, color, icon } = getSmartSkillInfo(skill);
                      const cost = skill.cost ?? (key === 'r' ? 100 : 50);

                      return (
                        <div key={key} style={{ display:'flex', flexDirection:'column', background:'#252528', padding:'12px', borderRadius:'8px', borderLeft: key === 'r' ? '3px solid #f1c40f' : `3px solid ${color}`, gap:'6px' }}>
                          <div style={{ display:'flex', alignItems:'center', justifyContent:'space-between' }}>
                            <div style={{ display:'flex', alignItems:'center', gap:'8px' }}>
                              <div style={{ fontSize:'12px', fontWeight:'900', color: key==='r'?'#f1c40f':color, width:'20px', textAlign:'center', background:'#161b22', borderRadius:'4px' }}>
                                {key === 'passive' ? 'P' : key.toUpperCase()}
                              </div>
                              <div style={{ fontSize:'14px', color:'#fff', fontWeight:'bold' }}>{skill.name}</div>
                            </div>
                            <div style={{ display:'flex', gap:'6px' }}>
                                {key !== 'passive' && (
                                    <div style={{ fontSize:'10px', color:'#3498db', border:'1px solid #3498db44', padding:'1px 6px', borderRadius:'10px', background:'#3498db11', fontWeight:'bold' }}>
                                        {cost} MP
                                    </div>
                                )}
                                <div style={{ fontSize:'10px', color: color, border:`1px solid ${color}44`, padding:'1px 6px', borderRadius:'10px', display:'flex', alignItems:'center', gap:'3px', background:`${color}11` }}>
                                    {icon} {tag}
                                </div>
                            </div>
                          </div>

                          <div style={{ fontSize:'12px', color:'#ccc', paddingLeft:'28px', lineHeight:'1.4' }}>{desc}</div>

                          <div style={{ fontSize:'11px', color:'#666', paddingLeft:'28px', display:'flex', flexWrap:'wrap', gap:'6px', marginTop:'4px', borderTop:'1px dashed #333', paddingTop:'4px' }}>
                            <span style={{ color:'#888' }}>ìˆ˜ì¹˜:</span>
                            <span style={{ color:'#fff', fontWeight:'bold' }}>{skill.val}</span>
                            {skill.adRatio > 0 && <span style={{ color:'#e67e22' }}>(+{skill.adRatio} AD)</span>}
                            {skill.apRatio > 0 && <span style={{ color:'#9b59b6' }}>(+{skill.apRatio} AP)</span>}
                            {skill.cd > 0 && <span style={{ marginLeft:'auto', color:'#aaa', display:'flex', alignItems:'center', gap:'2px' }}><Clock size={10}/> {skill.cd}s</span>}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              </div>
            )}

            {/* TAB 2: ìƒëŒ€ ë¶„ì„ */}
            {activeTab === 'COUNTER' && (
              <div style={{ background: '#1c1c1f', padding: '15px', borderRadius: '12px', border: '1px solid #333', minHeight:'400px' }}>
                <div style={{ display:'flex', gap:'10px', marginBottom:'15px', background:'#252528', padding:'10px', borderRadius:'8px' }}>
                  <Search size={16} color="#888"/>
                  <input 
                    type="text" placeholder="ë¹„êµí•  ì˜ì›… ì´ë¦„ ê²€ìƒ‰..." value={enemySearch} onChange={(e) => setEnemySearch(e.target.value)}
                    style={{ background:'none', border:'none', color:'#fff', outline:'none', width:'100%', fontWeight:'bold', fontSize:'13px' }}
                  />
                </div>
                <div style={{ display:'flex', flexDirection:'column', gap:'8px' }}>
                  {enemyList.map(enemy => (
                    <div key={enemy.id} onClick={() => setSelectedEnemy(enemy)} style={{ display:'flex', alignItems:'center', gap:'12px', padding:'10px', background:'#252528', borderRadius:'8px', cursor:'pointer' }}>
                      <GameIcon id={enemy.id} size={36} shape="rounded" />
                      <div style={{ flex:1 }}>
                        <div style={{ fontWeight:'bold', color:'#fff', fontSize:'13px' }}>{enemy.name}</div>
                        <div style={{ fontSize:'11px', color:'#888' }}>{enemy.role}</div>
                      </div>
                      <div style={{ fontSize:'12px', fontWeight:'bold', color: enemy.recentWinRate >= 50 ? '#ff4d4d' : '#888' }}>
                        {enemy.recentWinRate.toFixed(1)}%
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* TAB 3: ì „íˆ¬ ì„±ì¥ */}
            {activeTab === 'COMBAT' && (
              <div style={{ display:'flex', flexDirection:'column', gap:'15px' }}>
                <div style={{ background: '#1c1c1f', padding: '15px', borderRadius: '12px', border: '1px solid #333' }}>
                  <h3 style={{ margin:'0 0 10px 0', fontSize:'14px', color:'#da3633' }}>ì „íˆ¬ íš¨ìœ¨ì„±</h3>
                  <div style={{ display:'grid', gridTemplateColumns:'1fr 1fr', gap:'8px' }}>
                    <StatRow label="DPM" value={Math.floor(dpm).toLocaleString()} color="#da3633" />
                    <StatRow label="DPG" value={Math.floor(dpg).toLocaleString()} color="#aaa" />
                    <StatRow label="í‚¬ ê´€ì—¬ìœ¨" value={`${killParticipation.toFixed(1)}%`} color="#e89d40" />
                    <StatRow label="ì˜¤ë¸Œì íŠ¸ ë”œ" value={Math.floor(objectDpm).toLocaleString()} color="#f1c40f" />
                    <StatRow label="CC ì ìˆ˜" value={ccScore.toFixed(0)} color="#3498db" />
                  </div>
                </div>

                <div style={{ background: '#1c1c1f', padding: '15px', borderRadius: '12px', border: '1px solid #333' }}>
                  <h3 style={{ margin:'0 0 10px 0', fontSize:'14px', color:'#2ecc71' }}>ì„±ì¥ ì§€í‘œ</h3>
                  <div style={{ display:'grid', gridTemplateColumns:'1fr 1fr', gap:'8px' }}>
                    <StatRow label="GPM" value={Math.floor(gpm).toLocaleString()} color="#f1c40f" />
                    <StatRow label="CSPM" value={cspm.toFixed(1)} color="#ccc" />
                    <StatRow label="ìƒì¡´ ì ìˆ˜" value={`${survivalRate.toFixed(0)}`} color={getScoreColor(survivalRate, 70)} />
                    <StatRow label="ê³¨ë“œ íš¨ìœ¨" value={`${((dpm/gpm)*100).toFixed(0)}%`} color="#aaa" />
                  </div>
                </div>
              </div>
            )}

            {/* TAB 4: ì•„ì´í…œ ë¹Œë“œ */}
            {activeTab === 'BUILD' && (
              <div style={{ background: '#1c1c1f', padding: '15px', borderRadius: '12px', border: '1px solid #333' }}>
                <h3 style={{ margin:'0 0 10px 0', fontSize:'14px', color:'#fff' }}>ì¶”ì²œ í•µì‹¬ ë¹Œë“œ</h3>
                <div style={{ display:'flex', flexDirection:'column', gap:'8px' }}>
                  {recommendedItems.map((data, idx) => (
                    <div key={idx} style={{ display:'flex', alignItems:'center', gap:'12px', padding:'10px', background:'#252528', borderRadius:'8px' }}>
                      <div style={{ fontSize:'13px', fontWeight:'bold', color: idx < 3 ? '#e89d40' : '#555', width:'15px' }}>{idx+1}</div>
                      <div style={{ width:'32px', height:'32px', background:'#161b22', borderRadius:'6px', display:'flex', alignItems:'center', justifyContent:'center', border:'1px solid #444' }}>
                        <Zap size={16} color={data.item.type === 'WEAPON' ? '#da3633' : '#3498db'} />
                      </div>
                      <div style={{ flex:1 }}>
                        <div style={{ fontSize:'13px', fontWeight:'bold', color:'#fff' }}>{data.item.name}</div>
                        <div style={{ fontSize:'11px', color:'#f1c40f' }}>{data.item.cost} G</div>
                      </div>
                      <div style={{ textAlign:'right' }}>
                        <div style={{ fontSize:'13px', fontWeight:'bold', color: data.winRate >= 50 ? '#ff4d4d' : '#fff' }}>{data.winRate.toFixed(1)}%</div>
                        <div style={{ fontSize:'10px', color:'#666' }}>ìŠ¹ë¥ </div>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

          </div>
        </div>

        {showCustomize && <CustomizeHeroModal hero={hero} onClose={() => setShowCustomize(false)} />}
        {selectedEnemy && <HeroVsModal myHero={hero} enemyHero={selectedEnemy} onClose={() => setSelectedEnemy(null)} />}

      </div>
    </div>
  );
};


--- FILE: src/components/hero/HeroListTable.tsx ---
// ==========================================
// FILE PATH: /src/components/hero/HeroListTable.tsx
// ==========================================

import React from 'react';
import { Hero, Tier } from '../../types';
import { Target, Swords, Coins, Skull, Shield } from 'lucide-react'; 
import { GameIcon } from '../common/GameIcon';

interface Props {
  heroes: Hero[];
  isMobile?: boolean;
  onHeroClick?: (hero: Hero) => void;
}

export const HeroListTable: React.FC<Props> = ({ heroes, isMobile = false, onHeroClick }) => {
  const sortedHeroes = [...heroes].sort((a, b) => (a.rank || 999) - (b.rank || 999));

  // [UI í—¬í¼] ìŠ¹ë¥  ìƒ‰ìƒ
  const getWinRateColor = (rate: number) => {
    if (rate >= 52) return '#ff4d4d'; // OP (Red)
    if (rate >= 50) return '#3fb950'; // Good (Green)
    return '#8b949e'; // Normal (Gray)
  };

  // [UI í—¬í¼] í‹°ì–´ë³„ ê³ ìœ  ìƒ‰ìƒ ë° ìŠ¤íƒ€ì¼ ë°˜í™˜
  const getTierStyle = (tier: Tier) => {
    switch (tier) {
      case 'OP': return { color: '#ff4d4d', border: '#ff4d4d', bg: 'rgba(255, 77, 77, 0.15)' }; // ë¹¨ê°•
      case '1': return { color: '#e89d40', border: '#e89d40', bg: 'rgba(232, 157, 64, 0.15)' }; // ì£¼í™©/ê³¨ë“œ
      case '2': return { color: '#58a6ff', border: '#58a6ff', bg: 'rgba(88, 166, 255, 0.15)' }; // íŒŒë‘
      case '3': return { color: '#2ecc71', border: '#2ecc71', bg: 'rgba(46, 204, 113, 0.15)' }; // ì´ˆë¡
      case '4': return { color: '#95a5a6', border: '#95a5a6', bg: 'rgba(149, 165, 166, 0.15)' }; // íšŒìƒ‰
      case '5': return { color: '#7f8c8d', border: '#7f8c8d', bg: 'rgba(127, 140, 141, 0.15)' }; // ë˜¥ìƒ‰
      default: return { color: '#8b949e', border: '#30363d', bg: '#21262d' };
    }
  };

  // [ëª¨ë°”ì¼] ì¹´ë“œí˜• ë¦¬ìŠ¤íŠ¸ ë·°
  if (isMobile) {
    return (
      <div style={{ overflowY: 'auto', flex: 1, padding: '10px', display: 'flex', flexDirection: 'column', gap: '8px', paddingBottom: '80px', scrollbarWidth:'none' }}>
        {sortedHeroes.map((hero) => {
          const tierStyle = getTierStyle(hero.tier);

          return (
            <div 
              key={hero.id} 
              onClick={() => onHeroClick && onHeroClick(hero)}
              style={{ 
                background: '#161b22', border: '1px solid #30363d', borderRadius: '10px', 
                padding: '12px', display: 'flex', flexDirection: 'column', gap: '10px',
                cursor: 'pointer', position: 'relative', overflow: 'hidden'
              }}
            >
              {/* 1. ìƒë‹¨: ê¸°ë³¸ ì •ë³´ */}
              <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                <div style={{ fontSize: '14px', fontWeight: '900', fontStyle: 'italic', color: hero.rank <= 3 ? '#e89d40' : '#555', width: '24px', textAlign: 'center' }}>{hero.rank}</div>
                <GameIcon id={hero.id} size={48} shape="rounded" border="1px solid #444" />
                <div style={{ flex: 1, minWidth: 0 }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                    <span style={{ fontWeight: 'bold', fontSize: '15px', color: '#fff', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>{hero.name}</span>
                    <span style={{ 
                      fontSize: '10px', fontWeight: '800', 
                      color: tierStyle.color, 
                      border: `1px solid ${tierStyle.border}`, 
                      background: tierStyle.bg,
                      padding: '1px 5px', borderRadius: '4px', height: 'fit-content' 
                    }}>
                      {hero.tier}í‹°ì–´
                    </span>
                  </div>
                  {/* [ìˆ˜ì •ë¨] ì—­í• êµ° ì˜†ì— KDA ì •ë³´ ì¶”ê°€ */}
                  <div style={{ fontSize: '11px', color: '#888', marginTop: '4px', display:'flex', alignItems:'center', gap:'6px' }}>
                    <span style={{ fontWeight:'bold', color:'#ccc' }}>{hero.role}</span>
                    <span style={{ width:'1px', height:'10px', background:'#444' }}></span>
                    <span style={{ fontFamily:'monospace', color:'#aaa' }}>{hero.avgKda}</span>
                  </div>
                </div>
                <div style={{ textAlign: 'right' }}>
                  <div style={{ fontSize: '16px', fontWeight: 'bold', color: getWinRateColor(hero.recentWinRate) }}>{hero.recentWinRate.toFixed(1)}%</div>
                  <div style={{ fontSize: '10px', color: '#666', marginTop:'2px' }}>í”½ {hero.pickRate.toFixed(0)}% <span style={{color:'#444'}}>|</span> ë°´ {hero.banRate.toFixed(0)}%</div>
                </div>
              </div>

              {/* 2. í•˜ë‹¨: ìƒì„¸ ìŠ¤íƒ¯ ê·¸ë¦¬ë“œ */}
              <div style={{ display: 'grid', gridTemplateColumns: '1.2fr 1fr 1fr 1fr', gap: '4px', background: '#0d1117', borderRadius: '6px', padding: '8px 4px' }}>
                <div style={{ textAlign: 'center', borderRight: '1px solid #222' }}>
                  <div style={{ fontSize: '9px', color: '#666', marginBottom: '1px', display:'flex', alignItems:'center', justifyContent:'center', gap:'3px' }}><Skull size={9}/> í‰ì </div>
                  <div style={{ fontSize: '11px', fontWeight: 'bold', color: parseFloat(hero.kdaRatio) >= 3 ? '#e89d40' : '#ccc' }}>{hero.kdaRatio}:1</div>
                </div>
                <div style={{ textAlign: 'center', borderRight: '1px solid #222' }}>
                  <div style={{ fontSize: '9px', color: '#666', marginBottom: '1px', display:'flex', alignItems:'center', justifyContent:'center', gap:'3px' }}><Swords size={9}/> DPM</div>
                  <div style={{ fontSize: '11px', fontWeight: 'bold', color: '#da3633' }}>{hero.avgDpm}</div>
                </div>
                <div style={{ textAlign: 'center', borderRight: '1px solid #222' }}>
                  <div style={{ fontSize: '9px', color: '#666', marginBottom: '1px', display:'flex', alignItems:'center', justifyContent:'center', gap:'3px' }}><Target size={9}/> CS</div>
                  <div style={{ fontSize: '11px', fontWeight: 'bold', color: '#ccc' }}>{hero.avgCs}</div>
                </div>
                <div style={{ textAlign: 'center' }}>
                  <div style={{ fontSize: '9px', color: '#666', marginBottom: '1px', display:'flex', alignItems:'center', justifyContent:'center', gap:'3px' }}><Coins size={9}/> GOLD</div>
                  <div style={{ fontSize: '11px', fontWeight: 'bold', color: '#f1c40f' }}>{Number(hero.avgGold.replace(/,/g, '')) >= 1000 ? (Number(hero.avgGold.replace(/,/g, ''))/1000).toFixed(1) + 'k' : hero.avgGold}</div>
                </div>
              </div>
            </div>
          );
        })}
      </div>
    );
  }

  // [ë°ìŠ¤í¬íƒ‘]
  return (
    <div style={{ overflowX: 'auto', flex: 1, overflowY: 'auto' }}>
      <div style={{ display: 'grid', gridTemplateColumns: '40px 140px 100px 120px 140px 100px 80px 1fr', padding: '12px', background: '#0d1117', borderBottom: '1px solid #30363d', fontSize: '11px', color: '#8b949e', fontWeight: 'bold', textAlign: 'center', position: 'sticky', top: 0, zIndex: 10 }}>
        <div>ìˆœìœ„</div>
        <div style={{ textAlign: 'left', paddingLeft: '10px' }}>ì±”í”¼ì–¸</div>
        <div>ìŠ¹ë¥ </div>
        <div>í”½ë¥  / ë°´ë¥ </div>
        <div>KDA (í‚¬/ëƒ/ì–´)</div>
        <div><Target size={10} style={{ display: 'inline' }} /> CS</div>
        <div><Swords size={10} style={{ display: 'inline' }} /> DPM</div>
        <div><Coins size={10} style={{ display: 'inline' }} /> GOLD</div>
      </div>

      <div className="hero-list-compact">
        {sortedHeroes.map((hero) => {
          const tierStyle = getTierStyle(hero.tier);
          return (
            <div 
              key={hero.id} 
              className="hero-row" 
              onClick={() => onHeroClick && onHeroClick(hero)} 
              style={{ display: 'grid', gridTemplateColumns: '40px 140px 100px 120px 140px 100px 80px 1fr', padding: '10px 12px', borderBottom: '1px solid #2c2c2f', alignItems: 'center', fontSize: '12px', color: '#ccc', textAlign: 'center', background: '#161b22', cursor: 'pointer' }}
            >
              <div style={{ fontWeight: '900', color: '#555', fontStyle: 'italic' }}>{hero.rank}</div>
              <div style={{ textAlign: 'left', paddingLeft: '10px', display: 'flex', alignItems: 'center', gap: '8px' }}>
                <GameIcon id={hero.id} size={32} fallback={<span style={{fontSize:'16px'}}>ğŸ§™â€â™‚ï¸</span>} />
                <div style={{ display: 'flex', flexDirection: 'column' }}>
                  <span style={{ fontWeight: 'bold', color: '#fff' }}>{hero.name}</span>
                  <span style={{ fontSize: '9px', fontWeight: '800', color: tierStyle.color, border: `1px solid ${tierStyle.border}`, background: tierStyle.bg, padding: '1px 4px', borderRadius: '3px', width: 'fit-content' }}>{hero.tier}í‹°ì–´</span>
                </div>
              </div>
              <div style={{ fontWeight: 'bold', color: getWinRateColor(hero.recentWinRate) }}>{hero.recentWinRate.toFixed(1)}%</div>
              <div style={{ fontSize: '11px', color: '#888' }}><span style={{ color: '#fff' }}>{hero.pickRate.toFixed(1)}%</span> <span style={{ color: '#444' }}>|</span> <span style={{ color: '#da3633' }}>{hero.banRate.toFixed(1)}%</span></div>
              <div><span style={{ color: '#fff', fontWeight: 'bold', fontSize: '11px' }}>{hero.avgKda}</span><span style={{ display:'block', fontSize:'10px', color:'#666' }}>({hero.kdaRatio}:1)</span></div>
              <div style={{ fontFamily: 'monospace', color: '#888' }}>{hero.avgCs}</div>
              <div style={{ fontFamily: 'monospace', color: '#da3633' }}>{hero.avgDpm}</div>
              <div style={{ fontFamily: 'monospace', color: '#f1c40f' }}>{hero.avgGold}</div>
            </div>
          );
        })}
      </div>
    </div>
  );
};


--- FILE: src/components/hero/HeroManagement.tsx ---
// ==========================================
// FILE PATH: /src/components/hero/HeroManagement.tsx
// ==========================================
import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { Edit3, Search, Plus, Trash2, Shield, Swords, Zap, Crosshair, Skull, Layers, Target } from 'lucide-react';
import { Hero, Role } from '../../types';
import { GameIcon } from '../common/GameIcon';

interface Props { onEditHero: (hero: Hero) => void; }

// ì—­í• êµ° ë°ì´í„° ë° ì•„ì´ì½˜ ë§¤í•‘ (ì›ë³¸ ìœ ì§€)
const ROLES: (Role | 'ALL')[] = ['ALL', 'ì§‘í–‰ê´€', 'ì¶”ì ì', 'ì„ ì§€ì', 'ì‹ ì‚´ì', 'ìˆ˜í˜¸ê¸°ì‚¬'];

const getRoleIcon = (role: string) => {
  switch(role) {
    case 'ALL': return <Layers size={14}/>;
    case 'ì§‘í–‰ê´€': return <Shield size={14}/>;
    case 'ì¶”ì ì': return <Swords size={14}/>;
    case 'ì„ ì§€ì': return <Zap size={14}/>;
    case 'ì‹ ì‚´ì': return <Crosshair size={14}/>;
    case 'ìˆ˜í˜¸ê¸°ì‚¬': return <Skull size={14}/>;
    default: return <Layers size={14}/>;
  }
};

const getRoleColor = (role: string) => {
  switch(role) {
    case 'ì§‘í–‰ê´€': return '#e74c3c';
    case 'ì¶”ì ì': return '#2ecc71';
    case 'ì„ ì§€ì': return '#3498db';
    case 'ì‹ ì‚´ì': return '#f1c40f';
    case 'ìˆ˜í˜¸ê¸°ì‚¬': return '#9b59b6';
    default: return '#8b949e';
  }
};

export const HeroManagement: React.FC<Props> = ({ onEditHero }) => {
  const { heroes, addHero, deleteHero } = useGameStore();
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedRole, setSelectedRole] = useState<Role | 'ALL'>('ALL');

  // ëª¨ë°”ì¼ ê°ì§€ ë¡œì§ (ì›ë³¸ ìœ ì§€)
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // í•„í„°ë§ ë¡œì§ (ì›ë³¸ ìœ ì§€)
  const filteredHeroes = heroes.filter(h => {
    const matchRole = selectedRole === 'ALL' || h.role === selectedRole;
    const matchSearch = h.name.includes(searchTerm) || h.role.includes(searchTerm);
    return matchRole && matchSearch;
  });

  // ì˜ì›… ìƒì„± ë¡œì§ (statsì— range ê¸°ë³¸ê°’ í¬í•¨í•˜ì—¬ ë¬´ê²°ì„± ìœ ì§€)
  const handleCreateHero = () => {
    const id = `h_custom_${Date.now()}`;
    const newHero: Hero = {
      id,
      name: "ì´ë¦„ ì—†ëŠ” ì˜ì›…",
      role: selectedRole === 'ALL' ? "ì§‘í–‰ê´€" : selectedRole,
      tier: "3",
      stats: { hp: 2000, ad: 60, ap: 0, armor: 30, crit: 0, range: 150, speed: 340, regen: 10, pen: 0, baseAtk: 60 },
      skills: {
        passive: { name: "ê¸°ë³¸ íŒ¨ì‹œë¸Œ", mechanic: "NONE", val: 0, adRatio: 0, apRatio: 0, cd: 0, isPassive: true },
        q: { name: "Q ìŠ¤í‚¬", mechanic: "DAMAGE", val: 100, adRatio: 1.0, apRatio: 0, cd: 8 },
        w: { name: "W ìŠ¤í‚¬", mechanic: "NONE", val: 0, adRatio: 0, apRatio: 0, cd: 12 },
        e: { name: "E ìŠ¤í‚¬", mechanic: "DASH", val: 50, adRatio: 0, apRatio: 0, cd: 15 },
        r: { name: "R ê¶ê·¹ê¸°", mechanic: "DAMAGE", val: 300, adRatio: 1.5, apRatio: 0, cd: 100 }
      },
      record: {
        totalMatches: 0, totalWins: 0, totalPicks: 0, totalBans: 0,
        totalKills: 0, totalDeaths: 0, totalAssists: 0,
        totalDamage: 0, totalDamageTaken: 0, totalCs: 0, totalGold: 0,
        recentResults: []
      },
      rank: 999, rankChange: 0, recentWinRate: 0, pickRate: 0, banRate: 0,
      avgKda: "0.0/0.0/0.0", kdaRatio: "0.00", avgDpm: "0", avgDpg: "0", avgCs: "0", avgGold: "0"
    };
    addHero(newHero);
    onEditHero(newHero);
  };

  const handleDelete = (e: React.MouseEvent, id: string, name: string) => {
    e.stopPropagation();
    if (confirm(`ì •ë§ '${name}' ì˜ì›…ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nì‚­ì œ í›„ ë˜ëŒë¦´ ìˆ˜ ì—†ìœ¼ë©°, í†µê³„ ë°ì´í„°ë„ ì‚¬ë¼ì§‘ë‹ˆë‹¤.`)) {
      deleteHero(id);
    }
  };

  return (
    <div style={{ background: '#161b22', padding: isMobile ? '15px' : '20px', borderRadius: '12px', border: '1px solid #30363d', minHeight:'80vh', display:'flex', flexDirection:'column' }}>

      {/* 1. í—¤ë” & ê²€ìƒ‰ì°½ (ì›ë³¸ ë””ìì¸ ìœ ì§€) */}
      <div style={{ display: 'flex', flexDirection: isMobile ? 'column' : 'row', justifyContent: 'space-between', alignItems: isMobile ? 'stretch' : 'center', marginBottom: '15px', gap: '10px' }}>
        <h3 style={{ margin:0, color:'#fff', display:'flex', alignItems:'center', gap:'8px' }}>
          ğŸ›¡ï¸ ì˜ì›… ë°ì´í„° ê´€ë¦¬
        </h3>

        <div style={{ display:'flex', gap:'10px' }}>
          <div style={{ flex:1, display: 'flex', alignItems: 'center', gap: '10px', background: '#0d1117', padding: '8px 15px', borderRadius: '8px', border: '1px solid #30363d' }}>
            <Search size={16} color="#888" />
            <input 
              type="text" 
              placeholder="ì˜ì›… ê²€ìƒ‰..." 
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              style={{ background: 'none', border: 'none', color: '#fff', outline: 'none', width: '100%', fontSize:'13px' }}
            />
          </div>
          <button 
            onClick={handleCreateHero}
            style={{ 
              background:'#238636', color:'#fff', display:'flex', alignItems:'center', gap:'6px', 
              fontSize:'13px', whiteSpace:'nowrap', padding:'8px 16px', border:'none', borderRadius:'8px', cursor:'pointer', fontWeight:'bold'
            }}
          >
            <Plus size={16}/> {isMobile ? '' : 'ìƒˆ ì˜ì›…'}
          </button>
        </div>
      </div>

      {/* 2. í¬ì§€ì…˜ í•„í„° (ì›ë³¸ ê°€ë¡œ ìŠ¤í¬ë¡¤ ë””ìì¸ ìœ ì§€) */}
      <div style={{ 
        display: 'flex', gap: '8px', overflowX: 'auto', paddingBottom: '10px', marginBottom: '10px',
        scrollbarWidth: 'none', msOverflowStyle: 'none' 
      }}>
        {ROLES.map(role => (
          <button
            key={role}
            onClick={() => setSelectedRole(role)}
            style={{
              padding: '8px 12px', borderRadius: '20px', border: selectedRole === role ? `1px solid ${getRoleColor(role)}` : '1px solid #30363d',
              background: selectedRole === role ? `${getRoleColor(role)}22` : '#0d1117',
              color: selectedRole === role ? getRoleColor(role) : '#8b949e',
              fontSize: '12px', fontWeight: 'bold', cursor: 'pointer', whiteSpace: 'nowrap',
              display: 'flex', alignItems: 'center', gap: '6px', flexShrink: 0
            }}
          >
            {getRoleIcon(role)} {role === 'ALL' ? 'ì „ì²´' : role}
          </button>
        ))}
      </div>

      {/* 3. ì˜ì›… ë¦¬ìŠ¤íŠ¸ (ì›ë³¸ ë””ìì¸ ìœ ì§€ + ì‚¬ê±°ë¦¬ ì •ë³´ë§Œ ì¶”ê°€) */}
      <div style={{ 
        display: 'grid', 
        gridTemplateColumns: isMobile ? '1fr' : 'repeat(auto-fill, minmax(240px, 1fr))', 
        gap: '10px', flex: 1, overflowY: 'auto', alignContent: 'start'
      }}>
        {filteredHeroes.map(hero => (
          <div key={hero.id} style={{ 
            background: '#0d1117', padding: '12px', borderRadius: '10px', border: '1px solid #30363d', 
            display: 'flex', alignItems: 'center', gap: '15px', position: 'relative'
          }}>

            <div onClick={() => onEditHero(hero)} style={{ cursor:'pointer' }}>
                <GameIcon id={hero.id} size={50} fallback={<span style={{fontSize:'24px'}}>ğŸ§™â€â™‚ï¸</span>} shape="rounded" border={`2px solid ${getRoleColor(hero.role)}44`}/>
            </div>

            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '2px' }} onClick={() => onEditHero(hero)}>
              <div style={{ display:'flex', alignItems:'center', gap:'6px' }}>
                <span style={{ fontSize: '10px', color: getRoleColor(hero.role), border: `1px solid ${getRoleColor(hero.role)}44`, padding:'1px 4px', borderRadius:'3px', fontWeight:'bold' }}>
                  {hero.role}
                </span>
                {hero.id.startsWith('h_custom') && (
                  <span style={{ fontSize:'9px', background:'#1f6feb', color:'#fff', padding:'1px 4px', borderRadius:'3px' }}>NEW</span>
                )}
              </div>
              <strong style={{ fontSize: '15px', color: '#fff', cursor:'pointer' }}>{hero.name}</strong>

              {/* [ì¶”ê°€] ì‚¬ê±°ë¦¬ ì •ë³´ ë° ê¸°ì¡´ ìŠ¹ë¥  ì •ë³´ ë¬´ê²°í•˜ê²Œ í‘œì‹œ */}
              <div style={{ fontSize: '11px', color: '#666', display:'flex', gap:'8px', marginTop:'2px' }}>
                <span style={{ display:'flex', alignItems:'center', gap:'3px' }}>
                    <Target size={10} color="#58a6ff"/> {hero.stats.range}
                </span>
                <span style={{ color:'#444' }}>|</span>
                <span>ìŠ¹ë¥  {hero.recentWinRate.toFixed(1)}%</span>
              </div>
            </div>

            <div style={{ display:'flex', flexDirection: isMobile ? 'row' : 'column', gap:'6px' }}>
              <button onClick={() => onEditHero(hero)} style={{ background: '#21262d', border: '1px solid #30363d', color: '#fff', padding: '8px', borderRadius: '6px', cursor: 'pointer' }}>
                <Edit3 size={16} />
              </button>

              <button onClick={(e) => handleDelete(e, hero.id, hero.name)} style={{ background: '#3f1515', border: '1px solid #5a1e1e', color: '#ff6b6b', padding: '8px', borderRadius: '6px', cursor: 'pointer' }}>
                <Trash2 size={16} />
              </button>
            </div>

          </div>
        ))}

        {filteredHeroes.length === 0 && (
          <div style={{ gridColumn: '1/-1', textAlign: 'center', padding: '40px', color: '#555' }}>
            í•´ë‹¹í•˜ëŠ” ì˜ì›…ì´ ì—†ìŠµë‹ˆë‹¤.
          </div>
        )}
      </div>

    </div>
  );
};

--- FILE: src/components/hero/HeroTable.tsx ---
// ==========================================
// FILE PATH: /src/components/hero/HeroTable.tsx
// ==========================================

import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { Hero } from '../../types';
import { 
  Swords, Shield, Zap, Crosshair, Skull, 
  Target, Coins, Trophy, Activity, AlertCircle 
} from 'lucide-react';

interface Props { onHeroClick: (hero: Hero) => void; }

// --- Helper Functions & Components ---

const RoleIcon = ({ role, size = 14, color = "#ccc" }: { role: string, size?: number, color?: string }) => {
  switch(role) {
    case 'ì§‘í–‰ê´€': return <Swords size={size} color={color} />;
    case 'ìˆ˜í˜¸ê¸°ì‚¬': return <Shield size={size} color={color} />;
    case 'ì„ ì§€ì': return <Zap size={size} color={color} />;
    case 'ì‹ ì‚´ì': return <Crosshair size={size} color={color} />;
    case 'ì¶”ì ì': return <Skull size={size} color={color} />;
    default: return <span>?</span>;
  }
};

const formatNumber = (numStr: string | number) => {
  if (!numStr) return '0';
  const num = typeof numStr === 'string' ? parseInt(numStr.replace(/,/g, '')) : numStr;
  if (isNaN(num)) return '0';
  return num.toLocaleString();
};

const getTierBg = (tier: string) => tier === 'OP' ? '#5383e8' : 'transparent';
const getTierBorder = (tier: string) => {
  if (tier === 'OP') return '#5383e8';
  if (tier === '1') return '#e84057';
  if (tier === '2') return '#e89d40';
  if (tier === '3') return '#59c7ba';
  return '#555';
};
const getTierColor = (tier: string) => {
  if (tier === 'OP') return '#5383e8';
  if (tier === '1') return '#e84057';
  if (tier === '2') return '#e89d40';
  if (tier === '3') return '#59c7ba';
  return '#888';
};
const getWinRateColor = (rate: number) => rate >= 52 ? '#5383e8' : rate <= 48 ? '#e84057' : '#fff';


// --- Main Component ---

export const HeroTable: React.FC<Props> = ({ onHeroClick }) => {
  const { heroes } = useGameStore();
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  if (!heroes || heroes.length === 0) {
    return (
      <div style={{ padding:'40px', textAlign:'center', color:'#666', background:'#1c1c1f', borderRadius:'8px' }}>
        <Activity size={32} style={{ marginBottom:'10px', opacity:0.5 }}/>
        <br/>ë°ì´í„°ë¥¼ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤...
      </div>
    );
  }

  // =========================================================
  // [Mobile View] ì¹´ë“œ ë¦¬ìŠ¤íŠ¸ í˜•íƒœ
  // =========================================================
  if (isMobile) {
    return (
      <div style={{ paddingBottom: '20px' }}>
        {heroes.map((hero) => (
          <div 
            key={hero.id}
            onClick={() => onHeroClick(hero)}
            style={{
              background: '#1c1c1f',
              border: '1px solid #333',
              borderRadius: '12px',
              padding: '15px',
              marginBottom: '12px',
              display: 'flex',
              flexDirection: 'column',
              gap: '12px',
              boxShadow: '0 4px 10px rgba(0,0,0,0.2)'
            }}
          >
            {/* ìƒë‹¨: ë­í¬ + ê¸°ë³¸ì •ë³´ + í‹°ì–´ */}
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                <div style={{ 
                  width: '36px', height: '36px', background: '#252528', borderRadius: '8px', 
                  display: 'flex', alignItems: 'center', justifyContent: 'center',
                  border: '1px solid #444', fontWeight: 'bold', color: '#fff'
                }}>
                  {hero.rank}
                </div>
                <div>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                    <span style={{ fontWeight: 'bold', fontSize: '16px', color: '#fff' }}>{hero.name}</span>
                    <span style={{ fontSize: '12px', color: '#888' }}>{hero.role}</span>
                  </div>
                  <div style={{ display:'flex', gap:'5px', fontSize:'11px', color:'#666', marginTop:'2px' }}>
                    <RoleIcon role={hero.role} size={12} color="#666" />
                    <span>{hero.skills?.passive?.name || 'ê¸°ë³¸ ê³µê²©'}</span>
                  </div>
                </div>
              </div>

              <div style={{ 
                padding: '4px 10px', borderRadius: '6px', fontSize: '12px', fontWeight: '800',
                background: getTierBg(hero.tier), 
                color: hero.tier === 'OP' ? '#fff' : getTierColor(hero.tier),
                border: `1px solid ${getTierBorder(hero.tier)}`
              }}>
                {hero.tier} í‹°ì–´
              </div>
            </div>

            {/* í•˜ë‹¨: ì£¼ìš” ìŠ¤íƒ¯ Grid */}
            <div style={{ 
              display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', 
              background: '#121212', borderRadius: '8px', padding: '10px', gap: '5px'
            }}>
              <div style={{ textAlign: 'center' }}>
                <div style={{ fontSize: '11px', color: '#666' }}>ìŠ¹ë¥ </div>
                <div style={{ fontWeight: 'bold', color: getWinRateColor(hero.recentWinRate || 0) }}>
                  {(hero.recentWinRate || 0).toFixed(1)}%
                </div>
              </div>
              <div style={{ textAlign: 'center', borderLeft: '1px solid #333', borderRight: '1px solid #333' }}>
                <div style={{ fontSize: '11px', color: '#666' }}>í”½ë¥ </div>
                <div style={{ fontWeight: 'bold', color: '#fff' }}>
                  {(hero.pickRate || 0).toFixed(1)}%
                </div>
              </div>
              <div style={{ textAlign: 'center' }}>
                <div style={{ fontSize: '11px', color: '#666' }}>KDA</div>
                <div style={{ fontWeight: 'bold', color: parseFloat(hero.kdaRatio) >= 4 ? '#5383e8' : '#ccc' }}>
                  {hero.kdaRatio}
                </div>
              </div>
            </div>

          </div>
        ))}
      </div>
    );
  }

  // =========================================================
  // [Desktop View] ê¸°ì¡´ í…Œì´ë¸” í˜•íƒœ
  // =========================================================
  return (
    <div className="panel" style={{ overflowX: 'auto', background: '#1c1c1f', border: '1px solid #2c2c2f', boxShadow: '0 4px 20px rgba(0,0,0,0.3)' }}>
      <h3 style={{ margin: '0', padding: '15px 20px', fontSize: '15px', color: '#fff', borderLeft: '4px solid #5383e8', background: '#252528', borderBottom: '1px solid #2c2c2f' }}>
        ğŸ“Š ì±”í”¼ì–¸ ë¶„ì„ (Ranked Statistics)
      </h3>
      <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '13px', whiteSpace: 'nowrap' }}>
        <thead>
          <tr style={{ color: '#9aa4af', borderBottom: '1px solid #2c2c2f', textAlign: 'right', height: '45px', background: '#1c1c1f' }}>
            <th style={{ width: '60px', textAlign: 'center' }}>ìˆœìœ„</th>
            <th style={{ textAlign: 'left', paddingLeft: '20px' }}>ì±”í”¼ì–¸</th>
            <th style={{ width: '100px' }}>ìŠ¹ë¥ </th>
            <th style={{ width: '140px' }}>í”½ë¥  / ë°´ë¥ </th>
            <th style={{ width: '200px' }}>KDA (í‰ì )</th>
            <th style={{ width: '160px' }}>CS / ê³¨ë“œ</th>
            <th style={{ width: '180px', paddingRight: '20px' }}>ê°€í•œ í”¼í•´ / ë°›ì€ í”¼í•´</th>
          </tr>
        </thead>
        <tbody>
          {heroes.map((hero) => (
            <tr 
              key={hero.id} 
              onClick={() => onHeroClick(hero)}
              style={{ borderBottom: '1px solid #2c2c2f', cursor: 'pointer', height: '50px', transition: 'background 0.1s' }}
              onMouseEnter={(e) => e.currentTarget.style.background = '#2a2a2e'}
              onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
            >
              <td style={{ textAlign: 'center', color: '#777' }}>
                <span style={{ fontSize: '14px', color: '#fff', fontWeight: 'bold', marginRight: '4px' }}>{hero.rank || '-'}</span>
              </td>

              <td style={{ textAlign: 'left', paddingLeft: '20px' }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                  <div style={{ width: '32px', height: '32px', background: '#333', borderRadius: '6px', display:'flex', alignItems:'center', justifyContent:'center', border: '1px solid #444' }}>
                     <RoleIcon role={hero.role} />
                  </div>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                    <span style={{ fontWeight: 'bold', fontSize: '14px', color: '#eee' }}>{hero.name}</span>
                    <span style={{ fontSize: '12px', color: '#666' }}>{hero.role}</span>
                    <span style={{ 
                      marginLeft: '6px', padding: '1px 6px', borderRadius: '3px', fontWeight: '800', fontSize: '10px',
                      background: getTierBg(hero.tier), color: '#fff', border: `1px solid ${getTierBorder(hero.tier)}`
                    }}>
                      {hero.tier || 'unranked'}
                    </span>
                  </div>
                </div>
              </td>

              <td style={{ textAlign: 'right', fontWeight: 'bold' }}>
                <span style={{ color: getWinRateColor(hero.recentWinRate || 0) }}>
                  {(hero.recentWinRate || 0).toFixed(2)}%
                </span>
              </td>

              <td style={{ textAlign: 'right' }}>
                <span style={{ color: '#ccc' }}>{(hero.pickRate || 0).toFixed(1)}%</span>
                <span style={{ color: '#555', margin: '0 6px' }}>/</span>
                <span style={{ color: '#e84057', fontSize: '12px' }}>{(hero.banRate || 0).toFixed(1)}%</span>
              </td>

              <td style={{ textAlign: 'right' }}>
                <span style={{ color: '#8b949e', fontSize: '12px', marginRight: '8px' }}>({hero.avgKda || '0/0/0'})</span>
                <span style={{ fontWeight: 'bold', color: parseFloat(hero.kdaRatio || '0') >= 4 ? '#5383e8' : '#fff' }}>
                  {hero.kdaRatio || '0.00'}:1
                </span>
              </td>

              <td style={{ textAlign: 'right' }}>
                <div style={{ display: 'inline-flex', alignItems: 'center', gap: '15px' }}>
                  <span style={{ color: '#aaa', fontSize: '12px', display: 'flex', alignItems: 'center', gap: '4px' }}>
                    <Target size={12}/> {hero.avgCs || 0}
                  </span>
                  <span style={{ color: '#e89d40', fontSize: '12px', display: 'flex', alignItems: 'center', gap: '4px' }}>
                    <Coins size={12}/> {formatNumber(hero.avgGold || '0')}
                  </span>
                </div>
              </td>

              <td style={{ textAlign: 'right', paddingRight: '20px' }}>
                <span style={{ color: '#e84057' }}>{formatNumber(hero.avgDpm || '0')}</span>
                <span style={{ color: '#555', margin: '0 6px' }}>/</span>
                <span style={{ color: '#8b949e' }}>{formatNumber(hero.avgDpg || '0')}</span>
              </td>

            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

--- FILE: src/components/hero/HeroVsModal.tsx ---
// ==========================================
// FILE PATH: /src/components/hero/HeroVsModal.tsx
// ==========================================

import React, { useMemo } from 'react';
import { Hero } from '../../types';
// â–¼ [ìˆ˜ì •] 'Trophy'ë¥¼ import ëª©ë¡ì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.
import { X, Swords, Skull, Target, Zap, Shield, TrendingUp, AlertTriangle, Trophy } from 'lucide-react';
import { GameIcon } from '../common/GameIcon';

interface Props {
  myHero: Hero;
  enemyHero: Hero;
  onClose: () => void;
}

export const HeroVsModal: React.FC<Props> = ({ myHero, enemyHero, onClose }) => {

  // --- [1. ì •ë°€ ìƒì„± ì‹œë®¬ë ˆì´ì…˜ ì—”ì§„] ---
  const analysis = useMemo(() => {
    let score = 0; // 0 ê¸°ì¤€, ì–‘ìˆ˜ë©´ myHero ìœ ë¦¬, ìŒìˆ˜ë©´ enemyHero ìœ ë¦¬

    // 1. ê¸°ë³¸ ì²´ê¸‰ ì°¨ì´ (ìŠ¹ë¥  ê¸°ë°˜)
    const myWin = myHero.recentWinRate;
    const enWin = enemyHero.recentWinRate;
    score += (myWin - enWin) * 1.5;

    // 2. ì—­í• êµ° ìƒì„± (ê°€ìœ„ë°”ìœ„ë³´ ë¡œì§)
    // ì¶”ì ì(ì•”ì‚´) > ì‹ ì‚´ì(ì›ë”œ) > ìˆ˜í˜¸ê¸°ì‚¬(íƒ±ì»¤) > ì¶”ì ì
    // ì„ ì§€ì(ë©”ì´ì§€) vs ì§‘í–‰ê´€(ë¸Œë£¨ì €) : ì†ì‹¸ì›€
    const roles = { my: myHero.role, en: enemyHero.role };

    if (roles.my === 'ì¶”ì ì' && (roles.en === 'ì‹ ì‚´ì' || roles.en === 'ì„ ì§€ì')) score += 10; // ì•”ì‚´ ì„±ê³µ
    if (roles.my === 'ì‹ ì‚´ì' && roles.en === 'ìˆ˜í˜¸ê¸°ì‚¬') score += 8; // ì¹´ì´íŒ… ìš°ìœ„
    if (roles.my === 'ìˆ˜í˜¸ê¸°ì‚¬' && roles.en === 'ì¶”ì ì') score += 10; // ë”œ ì•ˆë°•í˜
    if (roles.my === 'ì§‘í–‰ê´€' && roles.en === 'ì¶”ì ì') score += 5; // ì²´ê¸‰ ì°¨ì´

    // ë°˜ëŒ€ ê²½ìš° (íŒ¨ë„í‹°)
    if (roles.en === 'ì¶”ì ì' && (roles.my === 'ì‹ ì‚´ì' || roles.my === 'ì„ ì§€ì')) score -= 10;
    if (roles.en === 'ì‹ ì‚´ì' && roles.my === 'ìˆ˜í˜¸ê¸°ì‚¬') score -= 8;
    if (roles.en === 'ìˆ˜í˜¸ê¸°ì‚¬' && roles.my === 'ì¶”ì ì') score -= 10;

    // 3. ìŠ¤í‚¬ ë©”ì»¤ë‹ˆì¦˜ ìƒì„±
    const mySkills = Object.values(myHero.skills);
    const enSkills = Object.values(enemyHero.skills);

    const myCC = mySkills.filter(s => s.mechanic === 'STUN' || s.mechanic === 'HOOK').length;
    const enCC = enSkills.filter(s => s.mechanic === 'STUN' || s.mechanic === 'HOOK').length;
    const myDash = mySkills.filter(s => s.mechanic === 'DASH').length;
    const enDash = enSkills.filter(s => s.mechanic === 'DASH').length;

    // CCê¸°ê°€ ë§ìœ¼ë©´ ì´ë™ê¸° ì—†ëŠ” ì ì—ê²Œ ìœ ë¦¬
    if (myCC > 0 && enDash === 0) score += 5;
    if (enCC > 0 && myDash === 0) score -= 5;

    // 4. ìµœì¢… ìŠ¹ë¥  ë° ì§€í‘œ ì‚°ì¶œ
    // ìµœì†Œ 35%, ìµœëŒ€ 65%ë¡œ ë³´ì •
    const matchupWinRate = Math.min(65, Math.max(35, 50 + score));

    // ë¼ì¸ì „ í‚¬ í™•ë¥  (ìƒì„±ì´ ê·¹ë‹¨ì ì¼ìˆ˜ë¡ í‚¬ í™•ë¥  ë†’ìŒ)
    const laneKillRate = 50 + (score * 1.2);

    // 15ë¶„ ê³¨ë“œ ê²©ì°¨ ì˜ˆìƒ
    const goldDiff = Math.floor(score * 35);

    return { score, matchupWinRate, laneKillRate, goldDiff };
  }, [myHero, enemyHero]);


  // --- [2. ë‹¤ì±„ë¡œìš´ ë¶„ì„ ì½”ë©˜íŠ¸ ìƒì„±ê¸°] ---
  const getAnalystComment = () => {
    const { score, matchupWinRate } = analysis;
    const myName = myHero.name;
    const enName = enemyHero.name;

    // ìƒí™©ë³„ ë©˜íŠ¸ í’€ (Pool)
    const comments = {
      // ì••ë„ì  ìš°ìœ„ (ìŠ¹ë¥  60% ì´ìƒ)
      dominate: [
        `"${enName}" ì…ì¥ì—ì„œ ì¬ì•™ê³¼ë„ ê°™ì€ ë§¤ì¹˜ì—…ì…ë‹ˆë‹¤. ${myName}ì˜ ìŠ¤í‚¬ ì…‹ì´ ìƒëŒ€ë¥¼ ì™„ë²½í•˜ê²Œ ì¹´ìš´í„°ì¹©ë‹ˆë‹¤.`,
        `ë¼ì¸ì „ë¶€í„° í•œíƒ€ê¹Œì§€ ${myName}ê°€ ì£¼ë„ê¶Œì„ ì¥˜ ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•„ìŠ¹ ì¹´ë“œì…ë‹ˆë‹¤.`,
        `ë°ì´í„°ìƒ 7:3 ì •ë„ë¡œ ìœ ë¦¬í•©ë‹ˆë‹¤. ${enName}ì˜ ì§„ì…ì„ ${myName}ê°€ ì†ì‰½ê²Œ ë°›ì•„ì¹  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`,
        `ìƒëŒ€ëŠ” ë°´í”½ ë‹¨ê³„ì—ì„œ ì´ë¯¸ ì¡ŒìŠµë‹ˆë‹¤. ${myName}ì˜ ë”œì„ ë²„í‹¸ ìˆ˜ ì—†ëŠ” êµ¬ì¡°ì…ë‹ˆë‹¤.`
      ],
      // ì†Œí­ ìš°ìœ„ (52~59%)
      advantage: [
        `ê¸°ë¶„ ì¢‹ì€ ìƒì„±ì…ë‹ˆë‹¤. ì´ˆë°˜ êµì „ë§Œ ì¡°ì‹¬í•˜ë©´ ${myName}ì˜ ì„±ì¥ ê¸°ëŒ€ì¹˜ê°€ ë” ë†’ìŠµë‹ˆë‹¤.`,
        `${enName}ì˜ ì£¼ìš” ìŠ¤í‚¬ì´ ë¹ ì§€ëŠ” íƒ€ì´ë°ì„ ë…¸ë¦¬ë©´ í‚¬ê°ì„ ì‰½ê²Œ ì¡ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`,
        `í†µê³„ì ìœ¼ë¡œ ìœ ë¦¬í•˜ì§€ë§Œ ë°©ì‹¬ì€ ê¸ˆë¬¼ì…ë‹ˆë‹¤. ${myName}ì˜ ìœ ì§€ë ¥ì´ ìŠ¹íŒ¨ë¥¼ ê°€ë¥¼ ê²ƒì…ë‹ˆë‹¤.`,
        `ì¤‘ë°˜ íƒ€ì´ë°ë¶€í„° ${myName}ê°€ ì‚¬ì´ë“œ ì£¼ë„ê¶Œì„ ê°€ì ¸ì˜¤ê¸° í¸í•œ êµ¬ë„ì…ë‹ˆë‹¤.`
      ],
      // ì—„ëŒ€ì—„ (48~51%)
      even: [
        `ìˆœìˆ˜ í”¼ì§€ì»¬ ì‹¸ì›€ì…ë‹ˆë‹¤. ìŠ¤í‚¬ í•˜ë‚˜ ì°¨ì´ë¡œ ìŠ¹íŒ¨ê°€ ê°ˆë¦´ 'ì†ì‹¸ì›€' êµ¬ë„ì…ë‹ˆë‹¤.`,
        `ì •ê¸€ëŸ¬ì˜ ê°œì…ì´ ìŠ¹íŒ¨ë¥¼ ê°€ë¥¼ ê²ƒì…ë‹ˆë‹¤. ë¼ì¸ì „ë³´ë‹¤ëŠ” í•©ë¥˜ ì‹¸ì›€ì´ ì¤‘ìš”í•©ë‹ˆë‹¤.`,
        `ì„œë¡œ í‚¬ì„ ë‚´ê¸° í˜ë“  êµ¬ì¡°ì…ë‹ˆë‹¤. íŒŒë° ìœ„ì£¼ì˜ ì§€ë£¨í•œ ë¼ì¸ì „ì´ ì˜ˆìƒë©ë‹ˆë‹¤.`,
        `ëˆ„ê°€ ë” ì‹¤ìˆ˜ë¥¼ ëœ í•˜ëŠëƒì˜ ì‹¸ì›€ì…ë‹ˆë‹¤. ë°ì´í„°ìƒ ìŠ¹ë¥ ì€ ì •í™•íˆ ë°˜ë°˜ì…ë‹ˆë‹¤.`
      ],
      // ì†Œí­ ì—´ì„¸ (41~47%)
      disadvantage: [
        `ë‹¤ì†Œ ê»„ë„ëŸ¬ìš´ ìƒëŒ€ì…ë‹ˆë‹¤. ${enName}ì˜ ê²¬ì œë¥¼ ë²„í‹°ë©° í›„ë°˜ì„ ë„ëª¨í•´ì•¼ í•©ë‹ˆë‹¤.`,
        `ë§ë”œì€ í”¼í•˜ëŠ” ê²Œ ì¢‹ìŠµë‹ˆë‹¤. ì•„êµ°ì˜ ì§€ì› ì—†ì´ëŠ” ë¼ì¸ì „ ì£¼ë„ê¶Œì„ ì¡ê¸° í˜ë“­ë‹ˆë‹¤.`,
        `${enName}ì˜ ì„±ì¥ ì†ë„ê°€ ë” ë¹ ë¦…ë‹ˆë‹¤. ì´ˆë°˜ì— ë³€ìˆ˜ë¥¼ ë§Œë“¤ì§€ ì•Šìœ¼ë©´ ê²Œì„ì´ í˜ë“¤ì–´ì§‘ë‹ˆë‹¤.`,
        `ìƒì„±ìƒ ë¶ˆë¦¬í•˜ì§€ë§Œ ê·¹ë³µ ë¶ˆê°€ëŠ¥í•˜ì§„ ì•ŠìŠµë‹ˆë‹¤. ì•„ì´í…œìœ¼ë¡œ ì¹´ìš´í„° ì¹˜ëŠ” ê²ƒì„ ì¶”ì²œí•©ë‹ˆë‹¤.`
      ],
      // ì••ë„ì  ì—´ì„¸ (40% ì´í•˜)
      hardCounter: [
        `ë‹·ì§€ë¥¼ ì¶”ì²œí•©ë‹ˆë‹¤. ${myName}ë¡œëŠ” ${enName}ë¥¼ ì´ê¸°ê¸° ì •ë§ í˜ë“­ë‹ˆë‹¤.`,
        `"ì§€ì˜¥ì˜ ì¹´ìš´í„°" ë§¤ì¹˜ì—…ì…ë‹ˆë‹¤. ìˆ¨ë§Œ ì‰¬ì–´ë„ ë¼ì¸ì „ì´ í„°ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`,
        `${enName}ë¥¼ ë°´í•˜ì§€ ì•Šì€ ëŒ€ê°€ë¥¼ ì¹˜ë¥¼ ê²ƒì…ë‹ˆë‹¤. íƒ€ì›Œ í—ˆê¹…ì´ ìœ ì¼í•œ ì‚´ê¸¸ì…ë‹ˆë‹¤.`,
        `ì ˆëŒ€ 1:1ì„ ê±¸ì§€ ë§ˆì‹­ì‹œì˜¤. ëª¨ë“  ì§€í‘œê°€ ${enName}ì˜ ìŠ¹ë¦¬ë¥¼ ê°€ë¦¬í‚¤ê³  ìˆìŠµë‹ˆë‹¤.`
      ]
    };

    // ëœë¤ ì„ íƒ ë¡œì§
    const pick = (arr: string[]) => arr[Math.floor(Math.random() * arr.length)];

    if (matchupWinRate >= 60) return pick(comments.dominate);
    if (matchupWinRate >= 52) return pick(comments.advantage);
    if (matchupWinRate >= 48) return pick(comments.even);
    if (matchupWinRate >= 40) return pick(comments.disadvantage);
    return pick(comments.hardCounter);
  };

  const comment = useMemo(() => getAnalystComment(), [analysis]);


  // --- [3. UI ì»´í¬ë„ŒíŠ¸] ---
  const ComparisonRow = ({ label, icon, leftVal, rightVal, unit = '', inverse = false }: any) => {
    // ê°’ì´ ë” í° ìª½ì´ ì´ê¸°ëŠ”ì§€(true), ì‘ì€ ìª½ì´ ì´ê¸°ëŠ”ì§€(false)
    const isLeftWin = inverse ? leftVal <= rightVal : leftVal >= rightVal;
    const total = leftVal + rightVal;
    const leftP = total > 0 ? (leftVal / total) * 100 : 50;

    const winColor = '#58a6ff'; // Blue
    const loseColor = '#da3633'; // Red (ì )

    return (
      <div style={{ marginBottom: '15px' }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '12px', color: '#ccc', marginBottom: '6px', padding: '0 5px' }}>
          <span style={{ fontWeight: 'bold', color: isLeftWin ? winColor : '#888' }}>
            {leftVal.toLocaleString()}{unit}
          </span>
          <div style={{ display:'flex', alignItems:'center', gap:'4px', color:'#aaa', fontSize:'11px' }}>{icon} {label}</div>
          <span style={{ fontWeight: 'bold', color: !isLeftWin ? loseColor : '#888' }}>
            {rightVal.toLocaleString()}{unit}
          </span>
        </div>

        {/* ê·¸ë˜í”„ ë°” */}
        <div style={{ display: 'flex', height: '6px', background: '#222', borderRadius: '3px', overflow: 'hidden' }}>
          <div style={{ width: `${leftP}%`, background: isLeftWin ? winColor : '#444', transition:'1s' }} />
          <div style={{ width: '2px', background: '#000' }} />
          <div style={{ flex: 1, background: !isLeftWin ? loseColor : '#444', transition:'1s' }} />
        </div>
      </div>
    );
  };

  return (
    <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.85)', zIndex: 9999, display: 'flex', justifyContent: 'center', alignItems: 'center', padding: '15px', backdropFilter: 'blur(5px)' }}>
      <div style={{ width: '100%', maxWidth: '500px', background: '#161b22', borderRadius: '16px', border: '1px solid #30363d', overflow: 'hidden', display:'flex', flexDirection:'column', maxHeight:'85vh' }}>

        {/* í—¤ë” */}
        <div style={{ padding: '15px 20px', background: '#21262d', borderBottom: '1px solid #30363d', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <h3 style={{ margin: 0, color: '#fff', fontSize: '15px', display:'flex', alignItems:'center', gap:'8px', fontWeight:'bold' }}>
            <Swords size={16} color="#da3633"/> ìƒëŒ€ ì „ì  ì‹œë®¬ë ˆì´ì…˜
          </h3>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#ccc', cursor: 'pointer' }}><X size={20}/></button>
        </div>

        {/* VS ë°°ë„ˆ */}
        <div style={{ padding: '25px 20px', background: 'linear-gradient(135deg, rgba(88, 166, 255, 0.15) 0%, rgba(218, 54, 51, 0.15) 100%)', display: 'flex', justifyContent: 'space-between', alignItems: 'center', borderBottom:'1px solid #30363d' }}>
          {/* ë‚˜ (ì™¼ìª½) */}
          <div style={{ textAlign: 'center', width:'30%' }}>
            <div style={{ position:'relative', display:'inline-block' }}>
              <GameIcon id={myHero.id} size={60} shape="circle" border="3px solid #58a6ff" />
              <div style={{ position:'absolute', bottom:-5, left:'50%', transform:'translateX(-50%)', background:'#58a6ff', color:'#000', fontSize:'9px', fontWeight:'bold', padding:'1px 6px', borderRadius:'10px', whiteSpace:'nowrap' }}>ME</div>
            </div>
            <div style={{ marginTop: '8px', fontWeight: 'bold', color: '#fff', fontSize:'13px' }}>{myHero.name}</div>
          </div>

          <div style={{ textAlign: 'center', flex:1 }}>
            <div style={{ fontSize: '11px', color: '#aaa', marginBottom: '2px' }}>ìƒëŒ€ ìŠ¹ë¥  ì˜ˆì¸¡</div>
            <div style={{ fontSize: '28px', fontWeight: '900', color: analysis.matchupWinRate >= 50 ? '#58a6ff' : '#da3633', textShadow:'0 0 10px rgba(0,0,0,0.5)' }}>
              {analysis.matchupWinRate.toFixed(1)}%
            </div>
            <div style={{ fontSize:'10px', color: analysis.matchupWinRate >= 50 ? '#58a6ff' : '#da3633', fontWeight:'bold' }}>
              {analysis.matchupWinRate >= 50 ? 'ìœ ë¦¬í•¨' : 'ë¶ˆë¦¬í•¨'}
            </div>
          </div>

          {/* ì  (ì˜¤ë¥¸ìª½) */}
          <div style={{ textAlign: 'center', width:'30%' }}>
            <div style={{ position:'relative', display:'inline-block' }}>
              <GameIcon id={enemyHero.id} size={60} shape="circle" border="3px solid #da3633" />
              <div style={{ position:'absolute', bottom:-5, left:'50%', transform:'translateX(-50%)', background:'#da3633', color:'#fff', fontSize:'9px', fontWeight:'bold', padding:'1px 6px', borderRadius:'10px', whiteSpace:'nowrap' }}>ENEMY</div>
            </div>
            <div style={{ marginTop: '8px', fontWeight: 'bold', color: '#fff', fontSize:'13px' }}>{enemyHero.name}</div>
          </div>
        </div>

        {/* ë¶„ì„ ì»¨í…ì¸  (ìŠ¤í¬ë¡¤) */}
        <div style={{ padding: '20px', flex: 1, overflowY: 'auto', background:'#0d1117' }}>

          {/* ë¶„ì„ ì½”ë©˜íŠ¸ ë°•ìŠ¤ */}
          <div style={{ marginBottom:'25px', padding:'15px', background:'#1c1c1f', borderRadius:'8px', border:'1px solid #333', borderLeft:'4px solid #58a6ff' }}>
            <div style={{ fontSize:'12px', color:'#58a6ff', fontWeight:'bold', marginBottom:'6px', display:'flex', alignItems:'center', gap:'5px' }}>
              <TrendingUp size={14}/> ë¶„ì„ ì½”ë©˜íŠ¸
            </div>
            <div style={{ fontSize:'13px', color:'#eee', lineHeight:'1.5' }}>
              "{comment}"
            </div>
          </div>

          <h4 style={{ fontSize:'12px', color:'#888', margin:'0 0 15px 0' }}>ìƒì„¸ ì§€í‘œ ë¹„êµ</h4>

          <ComparisonRow 
            label="ë¼ì¸ì „ í‚¬ í™•ë¥ " icon={<Skull size={12}/>} 
            leftVal={analysis.laneKillRate} rightVal={100 - analysis.laneKillRate} unit="%"
          />
          <ComparisonRow 
            label="15ë¶„ ê³¨ë“œ ê²©ì°¨" icon={<Zap size={12}/>} 
            leftVal={analysis.goldDiff > 0 ? `+${analysis.goldDiff}` : 0} 
            rightVal={analysis.goldDiff < 0 ? `+${Math.abs(analysis.goldDiff)}` : 0} 
          />
          <ComparisonRow 
            label="ë¶„ë‹¹ ë°ë¯¸ì§€ (DPM)" icon={<Target size={12}/>} 
            leftVal={parseInt(myHero.avgDpm.replace(/,/g, ''))} 
            rightVal={parseInt(enemyHero.avgDpm.replace(/,/g, ''))} 
          />
          <ComparisonRow 
            label="KDA ë¹„ìœ¨" icon={<Trophy size={12}/>} 
            leftVal={parseFloat(myHero.kdaRatio)} 
            rightVal={parseFloat(enemyHero.kdaRatio)} 
          />

          <div style={{ marginTop:'20px', fontSize:'11px', color:'#555', textAlign:'center' }}>
            * ìœ„ ë°ì´í„°ëŠ” ìµœê·¼ {Math.max(myHero.record.totalMatches, 100)}ê²½ê¸° ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‹œë®¬ë ˆì´ì…˜ ë˜ì—ˆìŠµë‹ˆë‹¤.
          </div>
        </div>

      </div>
    </div>
  );
};

--- FILE: src/components/hero/LaneStatsView.tsx ---
// ==========================================
// FILE PATH: /src/components/hero/LaneStatsView.tsx
// ==========================================

import React, { useRef, useState, useMemo } from 'react';
import { Hero, Role } from '../../types';
import { ROLE_DATA } from '../../data/roles';
import { useGameStore } from '../../store/useGameStore';
import { Wrench, Camera, Image as ImageIcon, Target, Swords, Coins, Activity, TrendingUp, Skull } from 'lucide-react';
import { RolePatchModal } from './RolePatchModal'; 
import { GameIcon } from '../common/GameIcon';

interface Props {
  heroes: Hero[];
  selectedRole: Role;
  onSelectRole: (role: Role) => void;
  isMobile?: boolean;
  onHeroClick?: (hero: Hero) => void; // í´ë¦­ í•¸ë“¤ëŸ¬ ì¶”ê°€
}

const getRoleId = (role: Role) => {
  switch(role) {
    case 'ì§‘í–‰ê´€': return 'role_executor';
    case 'ì¶”ì ì': return 'role_tracker';
    case 'ì„ ì§€ì': return 'role_prophet';
    case 'ì‹ ì‚´ì': return 'role_slayer';
    case 'ìˆ˜í˜¸ê¸°ì‚¬': return 'role_guardian';
    default: return 'role_unknown';
  }
};

export const LaneStatsView: React.FC<Props> = ({ heroes, selectedRole, onSelectRole, isMobile = false, onHeroClick }) => {
  const { gameState, setCustomImage } = useGameStore();
  const [showPatchModal, setShowPatchModal] = useState(false);
  const [isHovered, setIsHovered] = useState(false);

  const roleInfo = ROLE_DATA[selectedRole];
  const roleId = getRoleId(selectedRole);
  const roleBgId = `${roleId}_bg`; 

  // [ìˆ˜ì •] ë°°ê²½ ì´ë¯¸ì§€ ë¡œë”© ë¡œì§ ê°•í™” (ë°°ê²½í‚¤ -> ì•„ì´ì½˜í‚¤ ìˆœì„œë¡œ í™•ì¸)
  const displayBg = gameState.customImages?.[roleBgId] || gameState.customImages?.[roleId];

  const iconInputRef = useRef<HTMLInputElement>(null);
  const bgInputRef = useRef<HTMLInputElement>(null);

  const s = gameState.roleSettings || {
    executor: { damage: 10, defense: 10 },
    tracker: { gold: 20, smiteChance: 1.5 },
    prophet: { cdrPerLevel: 2 },
    slayer: { structureDamage: 30 },
    guardian: { survivalRate: 20 }
  };

  const getDynamicTraitText = (role: Role) => {
    switch (role) {
      case 'ì§‘í–‰ê´€': return `ì£¼ë³€ì— ì•„êµ°ì´ ì—†ì„ ë•Œ(ì†”ë¡œ ë¼ì¸ì „ ì‹œ) í”¼í•´ëŸ‰ +${s.executor.damage}%, ë°©ì–´ë ¥ +${s.executor.defense}%.`;
      case 'ì¶”ì ì': return `ëª¬ìŠ¤í„°/ì˜¤ë¸Œì íŠ¸ ì²˜ì¹˜ ì‹œ ê³¨ë“œ íšë“ëŸ‰ +${s.tracker.gold}%. ë‹¤ë¥¸ ë¼ì¸ ê°œì…(ê°±í‚¹) ì‹œ ì„±ê³µë¥  ì¦ê°€. (ê°•íƒ€ í™•ë¥  ${s.tracker.smiteChance}ë°°)`;
      case 'ì„ ì§€ì': return `ë ˆë²¨ì´ ì˜¤ë¥¼ìˆ˜ë¡ ìŠ¤í‚¬ ê°€ì†(ì¿¨íƒ€ì„ ê°ì†Œ) íš¨ê³¼ê°€ ì¶”ê°€ë¡œ ë¶™ìŒ. (ë ˆë²¨ë‹¹ ìœ„ë ¥ +${s.prophet.cdrPerLevel}%)`;
      case 'ì‹ ì‚´ì': return `êµ¬ì¡°ë¬¼(íƒ€ì›Œ, ì–µì œê¸°, ìˆ˜í˜¸ì) ë° ê±°ì‹ ë³‘ì—ê²Œ ì…íˆëŠ” í”¼í•´ëŸ‰ +${s.slayer.structureDamage}%.`;
      case 'ìˆ˜í˜¸ê¸°ì‚¬': return `ê°™ì€ ë¼ì¸ì— ìˆëŠ” ì•„êµ°ì˜ ìƒì¡´ìœ¨ì„ ${s.guardian.survivalRate}% ì˜¬ë ¤ì¤Œ. (ìì‹ ì´ ëŒ€ì‹  ì£½ì„ í™•ë¥  ì¦ê°€)`;
      default: return '';
    }
  };

  const laneHeroes = heroes
    .filter(h => h.role === selectedRole)
    .sort((a, b) => b.recentWinRate - a.recentWinRate);

  const roleStats = useMemo(() => {
    if (laneHeroes.length === 0) return null;

    let totalWins = 0, totalMatches = 0;
    let totalK = 0, totalD = 0, totalA = 0;
    let totalGold = 0, totalCs = 0, totalDpm = 0;

    laneHeroes.forEach(h => {
        totalWins += h.record.totalWins;
        totalMatches += h.record.totalMatches;
        totalK += h.record.totalKills;
        totalD += h.record.totalDeaths;
        totalA += h.record.totalAssists;

        totalGold += parseInt(h.avgGold.replace(/,/g, '')) || 0;
        totalCs += parseFloat(h.avgCs) || 0;
        totalDpm += parseInt(h.avgDpm.replace(/,/g, '')) || 0;
    });

    const count = laneHeroes.length;
    const safeDiv = (a: number, b: number) => b === 0 ? 0 : a / b;

    return {
        avgWinRate: totalMatches > 0 ? (totalWins / totalMatches) * 100 : 0,
        avgKda: safeDiv(totalK + totalA, totalD).toFixed(2),
        avgGold: Math.round(totalGold / count).toLocaleString(),
        avgCs: (totalCs / count).toFixed(1),
        avgDpm: Math.round(totalDpm / count).toLocaleString(),
    };
  }, [laneHeroes]);

  const handleIconUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if(file) {
        const reader = new FileReader();
        reader.onloadend = () => { if(typeof reader.result === 'string') setCustomImage(roleId, reader.result); };
        reader.readAsDataURL(file);
    }
  };

  const handleBgUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if(file) {
        const reader = new FileReader();
        reader.onloadend = () => { if(typeof reader.result === 'string') setCustomImage(roleBgId, reader.result); };
        reader.readAsDataURL(file);
    }
  };

  const actionButtonStyle = {
    background: 'rgba(33, 38, 45, 0.8)', 
    border: '1px solid rgba(255,255,255,0.2)', 
    color: '#fff', 
    padding: '8px 12px', 
    borderRadius: '6px', 
    cursor: 'pointer', 
    fontWeight: 'bold' as const, 
    display: 'flex', alignItems: 'center', gap: '8px', 
    fontSize: '12px', whiteSpace: 'nowrap' as const, 
    backdropFilter: 'blur(4px)', width: '100%', justifyContent: 'center'
  };

  return (
    <div 
      key={selectedRole}
      style={{ 
        display: 'flex', flexDirection: 'column', height: '100%', 
        backgroundColor: '#0d1117',
        // [ìˆ˜ì •] ë°°ê²½ ì´ë¯¸ì§€ ì ìš© ë¶€ë¶„
        backgroundImage: displayBg ? `linear-gradient(to bottom, rgba(13,17,23,0.5), rgba(13,17,23,0.95)), url(${displayBg})` : 'none',
        backgroundSize: 'cover', backgroundPosition: 'center top', position: 'relative'
      }}
    >

      {/* 0. ìƒë‹¨ íƒ­ ë„¤ë¹„ê²Œì´ì…˜ */}
      <div style={{ 
        padding: '10px 15px', borderBottom: '1px solid rgba(255,255,255,0.1)', 
        background: 'rgba(22, 27, 34, 0.8)', backdropFilter: 'blur(10px)',
        display: 'flex', gap: '10px', overflowX: 'auto', whiteSpace: 'nowrap',
        flexShrink: 0, zIndex: 10
      }}>
        {Object.entries(ROLE_DATA).map(([key, info]) => {
          const role = key as Role;
          const isSelected = selectedRole === role;
          return (
            <button key={role} onClick={() => onSelectRole(role)}
              style={{ 
                flex: 1, minWidth: isMobile ? '70px' : '100px',
                background: isSelected ? info.color : 'rgba(255,255,255,0.05)', 
                color: isSelected ? '#000' : '#ccc',
                border: '1px solid', borderColor: isSelected ? info.color : 'transparent',
                borderRadius: '6px', padding: '10px 0', cursor: 'pointer',
                display: 'flex', alignItems: 'center', justifyContent:'center', gap: '6px',
                transition: '0.2s', fontWeight: '800', fontSize:'12px'
              }}
            >
              {React.createElement(info.icon, { size: 14 })} {role}
            </button>
          );
        })}
      </div>

      {/* 1. ì—­í• êµ° ì„¤ëª… í—¤ë” */}
      <div style={{ 
        padding: isMobile ? '15px' : '30px', 
        display: 'flex', flexDirection: isMobile ? 'column' : 'row', 
        gap: isMobile ? '15px' : '30px', alignItems: 'flex-start', 
        background: `linear-gradient(180deg, ${roleInfo.color}11 0%, transparent 100%)`,
        flexShrink: 0, position: 'relative'
      }}>

        <div style={{ display:'flex', gap:'20px', width: isMobile ? '100%' : 'auto', alignItems:'center' }}>
          <div style={{ position: 'relative' }} onMouseEnter={() => setIsHovered(true)} onMouseLeave={() => setIsHovered(false)}>
            <div onClick={() => iconInputRef.current?.click()} style={{ cursor: 'pointer', display: 'block' }}>
              <GameIcon id={roleId} size={isMobile ? 60 : 100} fallback={React.createElement(roleInfo.icon, { size: isMobile ? 30 : 50, color: roleInfo.color })} border={`2px solid ${roleInfo.color}`} shape="rounded" />
              <div style={{ position: 'absolute', inset: 0, borderRadius: '12px', background: 'rgba(0,0,0,0.5)', display: isHovered ? 'flex' : 'none', alignItems: 'center', justifyContent: 'center', transition: '0.2s' }}>
                <Camera size={24} color="#fff" />
              </div>
            </div>
          </div>
          {isMobile && (
             <div style={{ flex: 1 }}>
                <h2 style={{ margin: 0, color: '#fff', fontSize: '24px', fontWeight: '900', textShadow: '0 2px 10px rgba(0,0,0,0.8)' }}>{selectedRole}</h2>
                <span style={{ fontSize: '12px', color: roleInfo.color, fontWeight: 'bold', background: 'rgba(0,0,0,0.6)', padding: '2px 8px', borderRadius: '4px', border: `1px solid ${roleInfo.color}44` }}>{roleInfo.name}</span>
             </div>
          )}
        </div>

        <div style={{ flex: 1, width: '100%' }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
            <div style={{ flex: 1, marginRight: '20px' }}>
              {!isMobile && (
                <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '10px' }}>
                  <h2 style={{ margin: 0, color: '#fff', fontSize: '32px', fontWeight: '900', textShadow: '0 2px 10px rgba(0,0,0,0.8)' }}>{selectedRole}</h2>
                  <span style={{ fontSize: '16px', color: roleInfo.color, fontWeight: 'bold', background: 'rgba(0,0,0,0.6)', padding: '2px 8px', borderRadius: '4px', border: `1px solid ${roleInfo.color}44` }}>{roleInfo.name}</span>
                </div>
              )}
              <div style={{ fontSize: isMobile ? '13px' : '16px', color: '#fff', fontWeight: 'bold', marginBottom: '8px', fontStyle: 'italic', textShadow: '0 1px 3px rgba(0,0,0,0.8)' }}>"{roleInfo.concept}"</div>
              <div style={{ fontSize: '13px', color: '#eee', marginBottom: '15px', lineHeight: '1.5', textShadow: '0 1px 2px rgba(0,0,0,0.8)' }}>{roleInfo.desc}</div>
            </div>
            {!isMobile && (
              <div style={{ display: 'flex', flexDirection: 'column', gap: '8px', minWidth: '140px' }}>
                <button onClick={() => setShowPatchModal(true)} style={actionButtonStyle}><Wrench size={14}/> ë°¸ëŸ°ìŠ¤ íŒ¨ì¹˜</button>
                <button onClick={() => iconInputRef.current?.click()} style={actionButtonStyle}><Camera size={14}/> í”„ë¡œí•„ ë³€ê²½</button>
                <button onClick={() => bgInputRef.current?.click()} style={actionButtonStyle}><ImageIcon size={14}/> ë°°ê²½ ë³€ê²½</button>
              </div>
            )}
          </div>

          <div style={{ display: 'grid', gridTemplateColumns: isMobile ? '1fr' : '1fr 1fr', gap: '10px' }}>
            <div style={{ background: 'rgba(28, 28, 31, 0.7)', padding: '12px', borderRadius: '8px', border: '1px solid rgba(255,255,255,0.1)', backdropFilter:'blur(4px)' }}>
              <div style={{ fontSize: '11px', color: '#58a6ff', fontWeight: 'bold', marginBottom: '4px' }}>ê³ ìœ  íŠ¹ì„± : {roleInfo.traitName}</div>
              <div style={{ fontSize: '12px', color: '#fff', lineHeight: '1.4' }}>{getDynamicTraitText(selectedRole)}</div>
            </div>
            <div style={{ background: 'rgba(28, 28, 31, 0.7)', padding: '12px', borderRadius: '8px', border: '1px solid rgba(255,255,255,0.1)', backdropFilter:'blur(4px)' }}>
              <div style={{ fontSize: '11px', color: '#da3633', fontWeight: 'bold', marginBottom: '4px' }}>ì‹œë®¬ë ˆì´ì…˜ ë°˜ì˜</div>
              <div style={{ fontSize: '12px', color: '#ccc', lineHeight: '1.4' }}>{roleInfo.simEffect}</div>
            </div>
          </div>

          {isMobile && (
            <div style={{ marginTop: '15px', display: 'flex', gap: '8px' }}>
              <button onClick={() => setShowPatchModal(true)} style={{...actionButtonStyle, flex:1 }}><Wrench size={14}/> íŒ¨ì¹˜</button>
              <button onClick={() => iconInputRef.current?.click()} style={{...actionButtonStyle, flex:1 }}><Camera size={14}/> í”„ë¡œí•„</button>
              <button onClick={() => bgInputRef.current?.click()} style={{...actionButtonStyle, flex:1 }}><ImageIcon size={14}/> ë°°ê²½</button>
            </div>
          )}
        </div>
      </div>

      <input type="file" ref={iconInputRef} style={{ display: 'none' }} accept="image/*" onChange={handleIconUpload} />
      <input type="file" ref={bgInputRef} style={{ display: 'none' }} accept="image/*" onChange={handleBgUpload} />

      {roleStats && (
        <div style={{ background: 'rgba(18, 20, 24, 0.85)', borderBottom: '1px solid #30363d', borderTop: '1px solid rgba(255,255,255,0.1)', padding: '15px 20px', backdropFilter: 'blur(5px)', display: 'flex', flexDirection: isMobile ? 'column' : 'row', alignItems: 'center', justifyContent:'space-between', gap:'15px' }}>
          <div style={{ display:'flex', alignItems:'center', gap:'8px', color:'#fff', fontWeight:'bold', fontSize:'14px' }}>
            <Activity size={16} color={roleInfo.color}/> <span style={{ color: roleInfo.color }}>{selectedRole}</span> í†µê³„
          </div>
          <div style={{ display:'flex', gap: isMobile ? '10px' : '25px', flexWrap:'wrap', justifyContent: isMobile ? 'space-between' : 'flex-end', width:'100%' }}>
            <RoleStatItem label="í‰ê·  ìŠ¹ë¥ " value={`${roleStats.avgWinRate.toFixed(1)}%`} color={roleStats.avgWinRate >= 50 ? '#ff4d4d' : '#8b949e'} icon={<TrendingUp size={12}/>} />
            <RoleStatItem label="í‰ê·  KDA" value={`${roleStats.avgKda}:1`} color="#fff" icon={<Skull size={12}/>} />
            <RoleStatItem label="ë¶„ë‹¹ ê³¨ë“œ" value={roleStats.avgGold} color="#e89d40" icon={<Coins size={12}/>} />
            <RoleStatItem label="ë¶„ë‹¹ ë°ë¯¸ì§€" value={roleStats.avgDpm} color="#da3633" icon={<Swords size={12}/>} />
            <RoleStatItem label="í‰ê·  CS" value={roleStats.avgCs} color="#ccc" icon={<Target size={12}/>} />
          </div>
        </div>
      )}

      <div style={{ flex: 1, overflowY: 'auto', paddingBottom: '80px', background: 'rgba(13, 17, 23, 0.6)', backdropFilter: 'blur(3px)' }}>
        {isMobile ? (
          <div style={{ padding: '10px', display: 'flex', flexDirection: 'column', gap: '8px' }}>
            {laneHeroes.map((hero, idx) => (
              <div 
                key={hero.id} 
                onClick={() => onHeroClick && onHeroClick(hero)} // [ì¶”ê°€] í´ë¦­ ì—°ê²°
                style={{ background: 'rgba(22, 27, 34, 0.85)', border: '1px solid rgba(48, 54, 61, 0.8)', borderRadius: '12px', padding: '12px 15px', display: 'flex', alignItems: 'center', justifyContent: 'space-between', cursor: 'pointer' }}
              >
                <div style={{ display: 'flex', alignItems: 'center', gap: '15px', flex: 1 }}>
                  <div style={{ fontSize: '16px', fontWeight: '900', fontStyle: 'italic', color: idx < 3 ? '#e74c3c' : '#666', width: '20px', textAlign: 'center' }}>{idx + 1}</div>
                  <GameIcon id={hero.id} size={42} fallback={<span style={{fontSize:'22px'}}>ğŸ§™â€â™‚ï¸</span>} />
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '3px' }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                      <span style={{ fontWeight: 'bold', fontSize: '14px', color: '#fff' }}>{hero.name}</span>
                      <span className={`tier-badge tier-${hero.tier}`} style={{ fontSize: '9px', padding: '2px 5px', height: 'fit-content' }}>{hero.tier}í‹°ì–´</span>
                    </div>
                    <div style={{ fontSize: '11px', color: '#8b949e' }}>
                      <span style={{ color: hero.recentWinRate >= 50 ? '#ff4d4d' : '#8b949e', fontWeight: 'bold' }}>ìŠ¹ë¥  {hero.recentWinRate.toFixed(1)}%</span>
                      <span style={{ margin: '0 4px', opacity: 0.3 }}>â€¢</span>
                      <span>í”½ë¥  {hero.pickRate.toFixed(1)}%</span>
                    </div>
                  </div>
                </div>
                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-end', gap: '2px', minWidth: '80px' }}>
                  <div style={{ fontWeight: 'bold', fontSize: '12px', color: '#fff' }}>{hero.avgKda}</div>
                  <div style={{ fontSize: '10px', color: '#e89d40', fontWeight:'bold' }}>{hero.avgGold} G</div>
                  <div style={{ fontSize: '9px', color: '#888', display:'flex', gap:'6px', marginTop:'2px' }}>
                    <span>CS {hero.avgCs}</span>
                    <span style={{ color: '#da3633' }}>{hero.avgDpm}</span>
                  </div>
                </div>
              </div>
            ))}
            {laneHeroes.length === 0 && <div style={{ padding: '40px', textAlign: 'center', color: '#ccc' }}>ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>}
          </div>
        ) : (
          <>
            <div style={{ display: 'grid', gridTemplateColumns: '40px 140px 100px 120px 140px 100px 80px 1fr', padding: '10px 20px', background: 'rgba(28, 28, 31, 0.95)', fontSize: '11px', color: '#8b949e', fontWeight: 'bold', textAlign: 'center', borderBottom: '1px solid #30363d', position:'sticky', top:0 }}>
              <div>#</div>
              <div style={{ textAlign: 'left', paddingLeft: '10px' }}>ì±”í”¼ì–¸</div>
              <div>ìŠ¹ë¥ </div>
              <div>í”½ë¥  / ë°´ë¥ </div>
              <div>KDA (í‚¬/ëƒ/ì–´)</div>
              <div><Target size={10} style={{ display: 'inline' }} /> CS</div>
              <div><Swords size={10} style={{ display: 'inline' }} /> DPM</div>
              <div><Coins size={10} style={{ display: 'inline' }} /> GOLD</div>
            </div>
            <div>
              {laneHeroes.map((hero, idx) => (
                <div key={hero.id} onClick={() => onHeroClick && onHeroClick(hero)} style={{ display: 'grid', gridTemplateColumns: '40px 140px 100px 120px 140px 100px 80px 1fr', padding: '10px 20px', borderBottom: '1px solid rgba(255,255,255,0.05)', alignItems: 'center', fontSize: '12px', color: '#ccc', textAlign: 'center', background: 'rgba(22, 27, 34, 0.6)', cursor: 'pointer' }}>
                  <div style={{ fontWeight: 'bold', color: '#aaa' }}>{idx + 1}</div>
                  <div style={{ textAlign: 'left', paddingLeft: '10px', display: 'flex', alignItems: 'center', gap: '8px' }}>
                    <GameIcon id={hero.id} size={32} fallback={<span style={{fontSize:'16px'}}>ğŸ§™â€â™‚ï¸</span>} />
                    <div style={{ display: 'flex', flexDirection: 'column' }}>
                      <span style={{ fontWeight: 'bold', color: '#fff' }}>{hero.name}</span>
                      <span className={`tier-badge tier-${hero.tier}`} style={{ marginLeft: 0, width: 'fit-content' }}>{hero.tier}í‹°ì–´</span>
                    </div>
                  </div>
                  <div style={{ fontWeight: 'bold', color: hero.recentWinRate >= 50 ? '#ff4d4d' : '#4d94ff' }}>{hero.recentWinRate.toFixed(1)}%</div>
                  <div style={{ fontSize: '11px', color: '#ccc' }}>
                    <span style={{ color: '#fff' }}>{hero.pickRate.toFixed(1)}%</span> <span style={{ color: '#888' }}>|</span> <span style={{ color: '#da3633' }}>{hero.banRate.toFixed(1)}%</span>
                  </div>
                  <div>
                    <span style={{ color: '#fff', fontWeight: 'bold', fontSize: '11px' }}>{hero.avgKda}</span>
                    <span style={{ display:'block', fontSize:'10px', color:'#888' }}>({hero.kdaRatio}:1)</span>
                  </div>
                  <div style={{ fontFamily: 'monospace', color: '#ccc' }}>{hero.avgCs}</div>
                  <div style={{ fontFamily: 'monospace', color: '#da3633' }}>{hero.avgDpm}</div>
                  <div style={{ fontFamily: 'monospace', color: '#f1c40f' }}>{hero.avgGold}</div>
                </div>
              ))}
            </div>
          </>
        )}
      </div>

      {showPatchModal && <RolePatchModal role={selectedRole} onClose={() => setShowPatchModal(false)} />}
    </div>
  );
};

const RoleStatItem = ({ label, value, color, icon }: any) => (
  <div style={{ display:'flex', flexDirection:'column', alignItems:'flex-end' }}>
    <span style={{ fontSize:'10px', color:'#ccc', marginBottom:'2px', display:'flex', alignItems:'center', gap:'4px' }}>
      {icon} {label}
    </span>
    <span style={{ fontSize:'14px', fontWeight:'bold', color: color, fontFamily:'monospace' }}>
      {value}
    </span>
  </div>
);

--- FILE: src/components/hero/RolePatchModal.tsx ---
// ==========================================
// FILE PATH: /src/components/hero/RolePatchModal.tsx
// ==========================================

import React, { useState } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { Role, RoleSettings } from '../../types';
import { X, Save, Sliders } from 'lucide-react';

interface Props {
  role: Role;
  onClose: () => void;
}

export const RolePatchModal: React.FC<Props> = ({ role, onClose }) => {
  const { gameState, updateRoleSettings } = useGameStore();

  // ìŠ¤í† ì–´ì—ì„œ í˜„ì¬ ì„¤ì •ê°’ ê°€ì ¸ì˜¤ê¸° (ì—†ìœ¼ë©´ ê¸°ë³¸ê°’)
  // [ìˆ˜ì •] ì´ê³³ì—ì„œ ë¬¸ë²• ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì—ˆìŠµë‹ˆë‹¤. ê´„í˜¸ì™€ ì½¤ë§ˆë¥¼ ì •í™•íˆ í™•ì¸í•˜ì„¸ìš”.
  const initialSettings = gameState.roleSettings || {
    executor: { damage: 15, defense: 15 },
    tracker: { gold: 20, smiteChance: 1.5 },
    prophet: { cdrPerLevel: 2 },
    slayer: { structureDamage: 30 },
    guardian: { survivalRate: 20 }
  };

  const [settings, setSettings] = useState<RoleSettings>(initialSettings);

  // ê°’ ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleChange = (group: keyof RoleSettings, field: string, value: number) => {
    setSettings(prev => ({
      ...prev,
      [group]: { ...prev[group], [field]: value }
    }));
  };

  // ì €ì¥ í•¸ë“¤ëŸ¬
  const handleSave = () => {
    updateRoleSettings(settings);
    alert(`[${role}] ë°¸ëŸ°ìŠ¤ íŒ¨ì¹˜ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.\në‹¤ìŒ ì‹œë®¬ë ˆì´ì…˜ í‹±ë¶€í„° ì¦‰ì‹œ ì ìš©ë©ë‹ˆë‹¤.`);
    onClose();
  };

  // ìŠ¬ë¼ì´ë” ì»´í¬ë„ŒíŠ¸ (ë‚´ë¶€ ì •ì˜)
  const RangeInput = ({ label, value, onChange, unit, max, step = 1 }: any) => (
    <div style={{ marginBottom: '15px' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px', fontSize: '12px', color: '#ccc' }}>
        <span>{label}</span>
        <span style={{ fontWeight: 'bold', color: '#58a6ff', fontFamily:'monospace' }}>{value}{unit}</span>
      </div>
      <input 
        type="range" min={0} max={max} step={step} value={value} 
        onChange={(e) => onChange(Number(e.target.value))} 
        style={{ width: '100%', accentColor: '#58a6ff', height: '4px', cursor: 'pointer' }} 
      />
    </div>
  );

  // ì—­í• êµ°ë³„ë¡œ ë‹¤ë¥¸ ì…ë ¥ì°½ ë Œë”ë§
  const renderInputs = () => {
    switch(role) {
      case 'ì§‘í–‰ê´€':
        return (
          <>
            <div style={{fontSize:'12px', color:'#888', marginBottom:'15px'}}>
              * ê³ ë¦½(ì£¼ë³€ì— ì•„êµ° ì—†ìŒ) ìƒíƒœì¼ ë•Œ ì ìš©ë˜ëŠ” ë³´ë„ˆìŠ¤ì…ë‹ˆë‹¤.
            </div>
            <RangeInput 
              label="ì¶”ê°€ í”¼í•´ëŸ‰" 
              value={settings.executor.damage} 
              onChange={(v: number) => handleChange('executor', 'damage', v)} 
              unit="%" max={100} 
            />
            <RangeInput 
              label="ì¶”ê°€ ë°©ì–´ë ¥" 
              value={settings.executor.defense} 
              onChange={(v: number) => handleChange('executor', 'defense', v)} 
              unit="%" max={100} 
            />
          </>
        );
      case 'ì¶”ì ì':
        return (
          <>
            <div style={{fontSize:'12px', color:'#888', marginBottom:'15px'}}>
              * ì •ê¸€ëŸ¬ì˜ ì„±ì¥ ì†ë„ì™€ ì˜¤ë¸Œì íŠ¸ ì‹¸ì›€ ëŠ¥ë ¥ì„ ì¡°ì ˆí•©ë‹ˆë‹¤.
            </div>
            <RangeInput 
              label="ê³¨ë“œ íšë“ëŸ‰ ë³´ë„ˆìŠ¤" 
              value={settings.tracker.gold} 
              onChange={(v: number) => handleChange('tracker', 'gold', v)} 
              unit="%" max={200} 
            />
            <RangeInput 
              label="ê°•íƒ€ í™•ë¥  ë°°ìœ¨ (ê¸°ë³¸ 1.0)" 
              value={settings.tracker.smiteChance} 
              onChange={(v: number) => handleChange('tracker', 'smiteChance', v)} 
              unit="ë°°" max={5} step={0.1} 
            />
          </>
        );
      case 'ì„ ì§€ì':
        return (
          <>
            <div style={{fontSize:'12px', color:'#888', marginBottom:'15px'}}>
              * ë ˆë²¨ì´ ì˜¤ë¥¼ìˆ˜ë¡ ìŠ¤í‚¬ ì¿¨íƒ€ì„ì´ ì¤„ì–´ë“œëŠ” íš¨ê³¼ë¥¼ ë°ë¯¸ì§€ë¡œ í™˜ì‚°í•©ë‹ˆë‹¤.
            </div>
            <RangeInput 
              label="ë ˆë²¨ë‹¹ ìŠ¤í‚¬ ìœ„ë ¥ ì¦ê°€" 
              value={settings.prophet.cdrPerLevel} 
              onChange={(v: number) => handleChange('prophet', 'cdrPerLevel', v)} 
              unit="%" max={10} step={0.5} 
            />
            <div style={{fontSize:'11px', color:'#58a6ff', marginTop:'5px'}}>
              (ì˜ˆ: 3% ì„¤ì • ì‹œ, 16ë ˆë²¨ ë„ë‹¬í•˜ë©´ ë°ë¯¸ì§€ 48% ì¦ê°€)
            </div>
          </>
        );
      case 'ì‹ ì‚´ì':
        return (
          <>
             <div style={{fontSize:'12px', color:'#888', marginBottom:'15px'}}>
              * íƒ€ì›Œ ì² ê±° ë° ë„¥ì„œìŠ¤ íŒŒê´´ ëŠ¥ë ¥ì„ ì¡°ì ˆí•©ë‹ˆë‹¤.
            </div>
            <RangeInput 
              label="êµ¬ì¡°ë¬¼ ëŒ€ìƒ ì¶”ê°€ í”¼í•´" 
              value={settings.slayer.structureDamage} 
              onChange={(v: number) => handleChange('slayer', 'structureDamage', v)} 
              unit="%" max={300} 
            />
          </>
        );
      case 'ìˆ˜í˜¸ê¸°ì‚¬':
        return (
          <>
            <div style={{fontSize:'12px', color:'#888', marginBottom:'15px'}}>
              * ê°™ì€ ë¼ì¸ ì•„êµ°ì˜ ìƒì¡´ë ¥ì„ ë†’ì—¬ì¤ë‹ˆë‹¤.
            </div>
            <RangeInput 
              label="ì•„êµ° ìƒì¡´ìœ¨ ì¦ê°€ ë³´ì •" 
              value={settings.guardian.survivalRate} 
              onChange={(v: number) => handleChange('guardian', 'survivalRate', v)} 
              unit="%" max={80} 
            />
          </>
        );
      default: return null;
    }
  };

  return (
    <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.85)', zIndex: 9999, display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
      <div style={{ width: '90%', maxWidth: '400px', background: '#161b22', border: '1px solid #30363d', borderRadius: '12px', overflow: 'hidden', boxShadow: '0 20px 50px rgba(0,0,0,0.8)' }}>

        {/* í—¤ë” */}
        <div style={{ padding: '15px', background: '#21262d', borderBottom: '1px solid #30363d', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <h3 style={{ margin: 0, color: '#fff', display: 'flex', alignItems: 'center', gap: '8px', fontSize: '16px' }}>
            <Sliders size={18} color="#58a6ff"/> {role} ë°¸ëŸ°ìŠ¤ íŒ¨ì¹˜
          </h3>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#888', cursor: 'pointer' }}><X size={20}/></button>
        </div>

        {/* ë°”ë”” */}
        <div style={{ padding: '20px', display: 'flex', flexDirection: 'column', gap: '10px' }}>
          {renderInputs()}
        </div>

        {/* í‘¸í„° */}
        <div style={{ padding: '15px', borderTop: '1px solid #30363d', display: 'flex', justifyContent: 'flex-end', background:'#0d1117' }}>
          <button onClick={handleSave} style={{ background: '#238636', color: '#fff', border: 'none', padding: '10px 20px', borderRadius: '6px', fontWeight: 'bold', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '6px' }}>
            <Save size={16}/> íŒ¨ì¹˜ ì ìš©
          </button>
        </div>
      </div>
    </div>
  );
};

--- FILE: src/components/hero/patch/SkillEditor.tsx ---
// ==========================================
// FILE PATH: /src/components/hero/patch/SkillEditor.tsx
// ==========================================
import React, { useState } from 'react';
import { HeroSkillSet } from '../../../types';
import { Edit2, Check } from 'lucide-react';

const MECHANIC_UI_CONFIG: any = {
  DAMAGE: [
    { key: 'val', label: 'í”¼í•´ëŸ‰', max: 1000, step: 10 }, 
    { key: 'adRatio', label: 'ADê³„ìˆ˜', max: 2.5, step: 0.05, color: '#e67e22' }, 
    { key: 'apRatio', label: 'APê³„ìˆ˜', max: 3.0, step: 0.05, color: '#9b59b6' },
    { key: 'cost', label: 'ë§ˆë‚˜ ì†Œëª¨', max: 300, step: 5, color: '#3498db' },
    { key: 'cd', label: 'ì¿¨íƒ€ì„', max: 180, step: 1, color: '#bdc3c7' }
  ],
  HEAL: [
    { key: 'val', label: 'íšŒë³µëŸ‰', max: 800, step: 10, color: '#2ecc71' }, 
    { key: 'apRatio', label: 'APê³„ìˆ˜', max: 2.0, step: 0.05, color: '#9b59b6' },
    { key: 'cost', label: 'ë§ˆë‚˜ ì†Œëª¨', max: 300, step: 5, color: '#3498db' },
    { key: 'cd', label: 'ì¿¨íƒ€ì„', max: 180, step: 1, color: '#bdc3c7' }
  ],
  SHIELD: [
    { key: 'val', label: 'ë³´í˜¸ë§‰', max: 1000, step: 10, color: '#3498db' }, 
    { key: 'adRatio', label: 'ADê³„ìˆ˜', max: 1.5, step: 0.05, color: '#e67e22' }, 
    { key: 'duration', label: 'ì§€ì†ì‹œê°„', max: 8, step: 0.5 },
    { key: 'cost', label: 'ë§ˆë‚˜ ì†Œëª¨', max: 300, step: 5, color: '#3498db' },
    { key: 'cd', label: 'ì¿¨íƒ€ì„', max: 180, step: 1, color: '#bdc3c7' }
  ],
  HOOK: [
    { key: 'val', label: 'ê·¸ë©ê±°ë¦¬', max: 1200, step: 25, color: '#f1c40f' }, 
    { key: 'duration', label: 'ê¸°ì ˆì‹œê°„', max: 3, step: 0.1 },
    { key: 'cost', label: 'ë§ˆë‚˜ ì†Œëª¨', max: 300, step: 5, color: '#3498db' },
    { key: 'cd', label: 'ì¿¨íƒ€ì„', max: 180, step: 1, color: '#bdc3c7' }
  ],
  DASH: [
    { key: 'val', label: 'ì´ë™ê±°ë¦¬', max: 800, step: 10, color: '#9b59b6' }, 
    { key: 'duration', label: 'ì¤€ë¹„ì‹œê°„', max: 1.5, step: 0.05 },
    { key: 'cost', label: 'ë§ˆë‚˜ ì†Œëª¨', max: 300, step: 5, color: '#3498db' },
    { key: 'cd', label: 'ì¿¨íƒ€ì„', max: 180, step: 1, color: '#bdc3c7' }
  ],
  STUN: [
    { key: 'duration', label: 'ê¸°ì ˆì‹œê°„', max: 4, step: 0.1, color: '#e74c3c' }, 
    { key: 'val', label: 'ë²”ìœ„', max: 600, step: 10 },
    { key: 'cost', label: 'ë§ˆë‚˜ ì†Œëª¨', max: 300, step: 5, color: '#3498db' },
    { key: 'cd', label: 'ì¿¨íƒ€ì„', max: 180, step: 1, color: '#bdc3c7' }
  ],
  STEALTH: [
    { key: 'duration', label: 'ì§€ì†ì‹œê°„', max: 15, step: 0.5, color: '#95a5a6' }, 
    { key: 'val', label: 'ì´ì†ì¦ê°€', max: 80, step: 1 },
    { key: 'cost', label: 'ë§ˆë‚˜ ì†Œëª¨', max: 300, step: 5, color: '#3498db' },
    { key: 'cd', label: 'ì¿¨íƒ€ì„', max: 180, step: 1, color: '#bdc3c7' }
  ],
  EXECUTE: [
    { key: 'val', label: 'ê¸°ë³¸í”¼í•´', max: 1000, step: 10, color: '#da3633' },
    { key: 'adRatio', label: 'ADê³„ìˆ˜', max: 3.0, step: 0.1, color: '#e67e22' },
    { key: 'cost', label: 'ë§ˆë‚˜ ì†Œëª¨', max: 300, step: 5, color: '#3498db' },
    { key: 'cd', label: 'ì¿¨íƒ€ì„', max: 200, step: 1, color: '#bdc3c7' }
  ],
  GLOBAL: [
    { key: 'val', label: 'í”¼í•´/í', max: 1000, step: 10, color: '#f1c40f' },
    { key: 'apRatio', label: 'APê³„ìˆ˜', max: 3.0, step: 0.1, color: '#9b59b6' },
    { key: 'duration', label: 'ì§€ì†ì‹œê°„', max: 10, step: 0.5 },
    { key: 'cost', label: 'ë§ˆë‚˜ ì†Œëª¨', max: 300, step: 5, color: '#3498db' },
    { key: 'cd', label: 'ì¿¨íƒ€ì„', max: 300, step: 5, color: '#bdc3c7' }
  ]
};

interface Props {
  skills: HeroSkillSet;
  onChange: (key: string, field: string, value: any) => void;
}

export const SkillEditor: React.FC<Props> = ({ skills, onChange }) => {
  const [selectedKey, setSelectedKey] = useState<keyof HeroSkillSet>('passive');
  const [activeField, setActiveField] = useState<string | null>(null);
  const [isEditingName, setIsEditingName] = useState(false);

  if (!skills) {
    return <div style={{ color: '#fff', padding: '20px' }}>{"ìŠ¤í‚¬ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."}</div>;
  }

  const currentSkill = skills[selectedKey];
  const uiConfig = MECHANIC_UI_CONFIG[currentSkill.mechanic] || MECHANIC_UI_CONFIG.DAMAGE;

  const currentStatValue = activeField ? (currentSkill as any)[activeField] : 0;
  const currentConfig = activeField ? uiConfig.find((c: any) => c.key === activeField) : null;
  const currentMax = currentConfig?.max || 1000;
  const currentStep = currentConfig?.step || 1;
  const currentLabel = currentConfig?.label || '';

  return (
    <div className="skill-editor">
      <div style={{ display: 'flex', gap: '6px', marginBottom: '20px' }}>
        {(['passive', 'q', 'w', 'e', 'r'] as const).map(k => (
          <button 
            key={k} 
            onClick={() => {setSelectedKey(k); setActiveField(null);}} 
            style={{ 
              flex: 1, padding: '10px', 
              background: selectedKey === k ? '#30363d' : '#161b22', 
              border: '1px solid #30363d', borderRadius: '10px', 
              color: selectedKey === k ? '#fff' : '#8b949e', fontWeight: 'bold', cursor: 'pointer',
              transition: 'all 0.2s'
            }}
          >
            {k === 'passive' ? 'P' : k.toUpperCase()}
          </button>
        ))}
      </div>

      <div style={{ marginBottom: '15px', padding: '12px', background: '#161b22', borderRadius: '12px', border: '1px solid #30363d' }}>
        {isEditingName ? (
          <div style={{ display: 'flex', gap: '8px' }}>
            <input 
              value={currentSkill.name} 
              onChange={e => onChange(selectedKey, 'name', e.target.value)} 
              onBlur={() => setIsEditingName(false)} 
              autoFocus 
              style={{ background: '#000', border: '1px solid #58a6ff', color: '#fff', padding: '5px', flex: 1, outline: 'none', borderRadius:'4px' }} 
            />
            <Check size={16} color="#2ecc71" onClick={() => setIsEditingName(false)} style={{ cursor: 'pointer' }} />
          </div>
        ) : (
          <div onClick={() => setIsEditingName(true)} style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer' }}>
            <span style={{ fontSize: '10px', color: '#8b949e', fontWeight: 'bold' }}>{selectedKey.toUpperCase()}</span>
            <span style={{ fontWeight: 'bold', flex: 1, color: '#fff' }}>{currentSkill.name}</span>
            <Edit2 size={12} color="#58a6ff" />
          </div>
        )}
      </div>

      <select 
        value={currentSkill.mechanic} 
        onChange={e => onChange(selectedKey, 'mechanic', e.target.value)} 
        style={{ width: '100%', padding: '10px', background: '#161b22', border: '1px solid #30363d', color: '#fff', borderRadius: '10px', marginBottom: '15px', outline:'none', cursor:'pointer' }}
      >
        <option value="DAMAGE">âš”ï¸ í”¼í•´ (DAMAGE)</option>
        <option value="HEAL">ğŸ’š íšŒë³µ (HEAL)</option>
        <option value="SHIELD">ğŸ›¡ï¸ ë³´í˜¸ë§‰ (SHIELD)</option>
        <option value="HOOK">ğŸª ê·¸ë© (HOOK)</option>
        <option value="DASH">ğŸ’¨ ì´ë™ (DASH)</option>
        <option value="STUN">ğŸ’« ê¸°ì ˆ (STUN)</option>
        <option value="STEALTH">ğŸ‘» ì€ì‹  (STEALTH)</option>
        <option value="EXECUTE">ğŸ©¸ ì²˜í˜• (EXECUTE)</option>
        <option value="GLOBAL">ğŸŒ ê¸€ë¡œë²Œ (GLOBAL)</option>
      </select>

      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px', marginBottom: '15px' }}>
        {uiConfig.map((item: any) => (
          <div 
            key={item.key} 
            onClick={() => setActiveField(item.key)} 
            style={{ 
              background: '#161b22', 
              border: activeField === item.key ? '1px solid #58a6ff' : '1px solid #30363d', 
              borderRadius: '10px', padding: '10px', 
              textAlign: 'center', cursor: 'pointer',
              transition: 'all 0.2s'
            }}
          >
            <label style={{ display: 'block', fontSize: '10px', color: '#8b949e', marginBottom: '4px' }}>{item.label}</label>
            <div style={{ fontSize: '15px', fontWeight: 'bold', color: item.color || '#fff' }}>
              {(currentSkill as any)[item.key] ?? 0}
              {item.key === 'cd' ? 'ì´ˆ' : ''}
            </div>
          </div>
        ))}
      </div>

      {activeField && (
        <div style={{ background: '#161b22', padding: '15px', borderRadius: '12px', border: '1px solid #58a6ff44', animation: 'fadeIn 0.2s' }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '10px' }}>
            <span style={{ color: '#aaa', fontSize: '12px', fontWeight:'bold' }}>
              {currentLabel} ì¡°ì ˆ
            </span>
            <strong style={{ color: '#58a6ff', fontSize:'14px' }}>
              {currentStatValue}
            </strong>
          </div>
          <input 
            type="range" 
            min={0} 
            max={currentMax}
            step={currentStep}
            value={currentStatValue || 0} 
            onChange={e => onChange(selectedKey, activeField!, Number(e.target.value))}
            style={{ width: '100%', accentColor: '#58a6ff', height:'6px', cursor:'pointer' }}
          />
          <div style={{ display:'flex', justifyContent:'flex-end', gap:'10px', marginTop:'10px' }}>
             <button 
               onClick={() => onChange(selectedKey, activeField!, Math.max(0, Number(currentStatValue || 0) - currentStep))} 
               style={{background:'#30363d', border:'none', color:'#fff', padding:'5px 10px', borderRadius:'4px', cursor:'pointer'}}
             >
               -
             </button>
             <button 
               onClick={() => onChange(selectedKey, activeField!, Number(currentStatValue || 0) + currentStep)} 
               style={{background:'#30363d', border:'none', color:'#fff', padding:'5px 10px', borderRadius:'4px', cursor:'pointer'}}
             >
               +
             </button>
          </div>
        </div>
      )}
      <style>{`
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
      `}</style>
    </div>
  );
};

--- FILE: src/components/hero/patch/StatEditor.tsx ---
// ==========================================
// FILE PATH: /src/components/hero/patch/StatEditor.tsx
// ==========================================
import React, { useState } from 'react';
import { Sliders } from 'lucide-react';

// [ìˆ˜ì •] ìŠ¤íƒ¯ ì„¤ì • í™•ì¥ (ë§ˆë‚˜, ì¬ìƒ, ê´€í†µë ¥ ì¶”ê°€)
const STAT_CONFIG: any = {
  baseAtk: { min: 0, max: 200, step: 1, color: '#777', label: 'ê¸°ë³¸ ê³µê²©ë ¥', unit: '' },
  ad: { min: 0, max: 1000, step: 1, color: '#e67e22', label: 'ì¶”ê°€ AD (ê³„ìˆ˜ìš©)', unit: '' },
  ap: { min: 0, max: 1000, step: 1, color: '#9b59b6', label: 'ì£¼ë¬¸ë ¥(AP)', unit: '' },
  crit: { min: 0, max: 100, step: 1, color: '#e74c3c', label: 'ì¹˜ëª…íƒ€ìœ¨', unit: '%' },
  range: { min: 1, max: 1000, step: 5, color: '#ccc', label: 'ê³µê²© ì‚¬ê±°ë¦¬', unit: '' },
  pen: { min: 0, max: 100, step: 1, color: '#da3633', label: 'ë°©ì–´ ê´€í†µë ¥', unit: '' },

  hp: { min: 1, max: 5000, step: 10, color: '#2ecc71', label: 'ì²´ë ¥(HP)', unit: '' },
  mp: { min: 0, max: 2000, step: 10, color: '#3498db', label: 'ë§ˆë‚˜(MP)', unit: '' },
  regen: { min: 0, max: 100, step: 1, color: '#27ae60', label: 'ì²´ë ¥ ì¬ìƒ', unit: '/s' },
  mpRegen: { min: 0, max: 50, step: 1, color: '#2980b9', label: 'ë§ˆë‚˜ ì¬ìƒ', unit: '/s' },
  armor: { min: 0, max: 300, step: 1, color: '#3498db', label: 'ë°©ì–´ë ¥', unit: '' },
  speed: { min: 100, max: 600, step: 5, color: '#f1c40f', label: 'ì´ë™ ì†ë„', unit: '' }
};

interface Props {
  fields: string[];
  stats: any;
  onChange: (field: string, value: number) => void;
}

export const StatEditor: React.FC<Props> = ({ fields, stats, onChange }) => {
  const [activeField, setActiveField] = useState<string | null>(null);

  const currentStatValue = activeField ? stats[activeField] : 0;
  const currentConfig = activeField ? STAT_CONFIG[activeField] : null;

  const currentMax = currentConfig?.max || 1000;
  const currentStep = currentConfig?.step || 1;
  const currentLabel = currentConfig?.label || '';
  const currentUnit = currentConfig?.unit || '';
  const currentColor = currentConfig?.color || '#fff';

  return (
    <div className="stat-editor">

      {/* 1. ìŠ¤íƒ¯ ì¹´ë“œ ê·¸ë¦¬ë“œ */}
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '8px', marginBottom: '20px' }}>
        {fields.map(f => {
          const conf = STAT_CONFIG[f];
          if (!conf) return null;

          const isActive = activeField === f;
          const val = stats[f] !== undefined ? stats[f] : 0;

          return (
            <div 
              key={f} 
              onClick={() => setActiveField(f)}
              style={{ 
                background: isActive ? '#1f242e' : '#161b22', 
                border: isActive ? `2px solid ${conf.color}` : '1px solid #30363d', 
                borderRadius: '8px', padding: '10px 5px', 
                textAlign: 'center', cursor: 'pointer',
                transition: 'all 0.2s',
              }}
            >
              <div style={{ fontSize: '10px', color: isActive ? conf.color : '#8b949e', marginBottom: '2px', fontWeight:'bold', whiteSpace:'nowrap' }}>
                {conf.label}
              </div>
              <div style={{ fontSize: '14px', fontWeight: '800', color: conf.color }}>
                {val}<span style={{fontSize:'10px', marginLeft:'1px', color:'#666'}}>{conf.unit}</span>
              </div>
            </div>
          );
        })}
      </div>

      {/* 2. ìŠ¬ë¼ì´ë” íŒ¨ë„ */}
      {activeField && currentConfig && (
        <div style={{ 
          background: '#1c1c1f', padding: '20px', borderRadius: '16px', 
          border: `1px solid ${currentColor}`, boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
          animation: 'slideUp 0.2s ease-out'
        }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>
            <div style={{ display:'flex', alignItems:'center', gap:'8px' }}>
              <Sliders size={18} color={currentColor}/>
              <span style={{ color: '#fff', fontSize: '14px', fontWeight:'bold' }}>{currentLabel} ì¡°ì ˆ</span>
            </div>
            <div style={{ fontSize: '24px', fontWeight: '900', color: currentColor }}>
              {currentStatValue}<span style={{fontSize:'14px', color:'#555'}}>{currentUnit}</span>
            </div>
          </div>

          <input 
            type="range" 
            min={currentConfig.min} 
            max={currentMax} 
            step={currentStep}
            value={currentStatValue || 0} 
            onChange={e => onChange(activeField, Number(e.target.value))}
            style={{ width: '100%', accentColor: currentColor, height:'8px', cursor:'pointer', marginBottom:'15px' }}
          />

          <div style={{ display:'grid', gridTemplateColumns:'1fr 1fr 1fr 1fr', gap:'8px' }}>
             <AdjustBtn onClick={() => onChange(activeField, Math.max(currentConfig.min, (currentStatValue||0) - (currentStep*10)))} label={`-${currentStep*10}`} />
             <AdjustBtn onClick={() => onChange(activeField, Math.max(currentConfig.min, (currentStatValue||0) - currentStep))} label={`-${currentStep}`} />
             <AdjustBtn onClick={() => onChange(activeField, Math.min(currentMax, (currentStatValue||0) + currentStep))} label={`+${currentStep}`} />
             <AdjustBtn onClick={() => onChange(activeField, Math.min(currentMax, (currentStatValue||0) + (currentStep*10)))} label={`+${currentStep*10}`} />
          </div>
        </div>
      )}

      <style>{`
        @keyframes slideUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
      `}</style>
    </div>
  );
};

const AdjustBtn = ({ onClick, label }: any) => (
  <button 
    onClick={onClick} 
    style={{
      background:'#21262d', border:'1px solid #30363d', color:'#fff', 
      padding:'12px 0', borderRadius:'8px', cursor:'pointer', fontWeight:'bold',
      fontSize:'14px', transition:'0.1s'
    }}
  >
    {label}
  </button>
);

--- FILE: src/components/hero/HeroStatsView.tsx ---
// ==========================================
// FILE PATH: /src/components/hero/HeroStatsView.tsx
// ==========================================

import React, { useState, useEffect, useMemo } from 'react'; // useMemo ì¶”ê°€
import { useGameStore } from '../../store/useGameStore';
import { Award, LayoutGrid, List } from 'lucide-react';
import { Role, Hero } from '../../types';
import { HeroListTable } from './HeroListTable';
import { LaneStatsView } from './LaneStatsView';
import { HeroDetailView } from './HeroDetailView';
import { PatchModal } from './PatchModal';

export const HeroStatsView = () => {
  const { heroes } = useGameStore();
  const [mode, setMode] = useState<'HERO' | 'LANE'>('HERO');
  const [selectedRole, setSelectedRole] = useState<Role>('ì§‘í–‰ê´€');

  // [ìˆ˜ì • 1] ì˜ì›… ê°ì²´ ëŒ€ì‹  IDë¥¼ ì €ì¥í•˜ì—¬ í•­ìƒ ìµœì‹  ë°ì´í„°ë¥¼ ì°¸ì¡°í•˜ë„ë¡ ë³€ê²½
  const [viewingHeroId, setViewingHeroId] = useState<string | null>(null);
  const [showPatchModal, setShowPatchModal] = useState(false);

  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  // [ìˆ˜ì • 2] IDë¥¼ ê¸°ë°˜ìœ¼ë¡œ í˜„ì¬ ìµœì‹  ì˜ì›… ë°ì´í„° ì°¾ê¸°
  const viewingHero = useMemo(() => 
    heroes.find(h => h.id === viewingHeroId) || null, 
  [heroes, viewingHeroId]);

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // [ìˆ˜ì • 3] í•¸ë“¤ëŸ¬ê°€ IDë¥¼ ì €ì¥í•˜ë„ë¡ ë³€ê²½
  const handleHeroClick = (hero: Hero) => {
    setViewingHeroId(hero.id);
  };

  return (
    <div className="stats-container" style={{ 
      background: '#161b22', borderRadius: '12px', border: '1px solid #30363d', 
      minHeight: '600px', display: 'flex', flexDirection: 'column', overflow: 'hidden',
      position: 'relative'
    }}>

      {/* í—¤ë” ë° íƒ­ */}
      <div style={{ 
        padding: '12px 15px', borderBottom: '1px solid #30363d', 
        display: 'flex', alignItems: 'center', justifyContent: 'space-between',
        background:'#21262d', gap: '10px'
      }}>
        {/* ì œëª© */}
        <div style={{ display: 'flex', alignItems: 'center', gap: '6px', fontWeight: 'bold', fontSize: isMobile ? '14px' : '16px', color: '#fff', whiteSpace:'nowrap' }}>
          <Award size={isMobile ? 16 : 18} color="#58a6ff" />
          <span>ì‹œì¦Œ 1 ë°ì´í„°</span>
        </div>

        {/* íƒ­ ë²„íŠ¼ */}
        <div style={{ display:'flex', background:'#0d1117', padding:'3px', borderRadius:'6px', border:'1px solid #30363d' }}>
          <button 
            onClick={() => setMode('HERO')} 
            style={{ 
              display:'flex', alignItems:'center', justifyContent:'center', gap:'4px', 
              padding: isMobile ? '6px 10px' : '6px 14px', 
              borderRadius:'4px', border:'none', cursor:'pointer', fontWeight:'bold', fontSize: isMobile ? '11px' : '12px', 
              background: mode === 'HERO' ? '#58a6ff' : 'transparent', color: mode === 'HERO' ? '#000' : '#8b949e',
              transition: '0.2s', whiteSpace:'nowrap'
            }}
          >
            <List size={12}/> ì˜ì›…ë³„
          </button>
          <button 
            onClick={() => setMode('LANE')} 
            style={{ 
              display:'flex', alignItems:'center', justifyContent:'center', gap:'4px', 
              padding: isMobile ? '6px 10px' : '6px 14px', 
              borderRadius:'4px', border:'none', cursor:'pointer', fontWeight:'bold', fontSize: isMobile ? '11px' : '12px', 
              background: mode === 'LANE' ? '#58a6ff' : 'transparent', color: mode === 'LANE' ? '#000' : '#8b949e',
              transition: '0.2s', whiteSpace:'nowrap'
            }}
          >
            <LayoutGrid size={12}/> ë¼ì¸ë³„
          </button>
        </div>
      </div>

      {/* ë©”ì¸ ì»¨í…ì¸  */}
      <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
        {mode === 'HERO' ? (
          <HeroListTable 
            heroes={heroes} 
            isMobile={isMobile} 
            onHeroClick={handleHeroClick} 
          />
        ) : (
          <LaneStatsView 
            heroes={heroes} 
            selectedRole={selectedRole} 
            onSelectRole={setSelectedRole} 
            isMobile={isMobile}
            onHeroClick={handleHeroClick} 
          />
        )}
      </div>

      {/* ì˜ì›… ìƒì„¸ íŒì—… (viewingHeroëŠ” ì´ì œ í•­ìƒ ìµœì‹  ìƒíƒœì„) */}
      {viewingHero && (
        <HeroDetailView 
          hero={viewingHero} 
          onBack={() => setViewingHeroId(null)} 
          onPatch={() => setShowPatchModal(true)}
        />
      )}

      {/* íŒ¨ì¹˜ ëª¨ë‹¬ */}
      {showPatchModal && viewingHero && (
        <PatchModal 
          hero={viewingHero} 
          onClose={() => setShowPatchModal(false)} 
        />
      )}
    </div>
  );
};

--- FILE: src/components/hero/PatchModal.tsx ---
// ==========================================
// FILE PATH: /src/components/hero/PatchModal.tsx
// ==========================================

import React, { useState, useEffect } from 'react';
import { Hero, HeroStats, HeroSkillSet } from '../../types';
import { useGameStore } from '../../store/useGameStore';
import { X, Save, Sliders, Zap, Swords, Shield } from 'lucide-react';
import { GameIcon } from '../common/GameIcon';

import { SkillEditor } from './patch/SkillEditor';
import { StatEditor } from './patch/StatEditor';

interface Props { hero: Hero | null; onClose: () => void; }

export const PatchModal: React.FC<Props> = ({ hero, onClose }) => {
  const { updateHero } = useGameStore();
  const [activeTab, setActiveTab] = useState<'skill' | 'combat' | 'basic'>('skill');

  const [stats, setStats] = useState<HeroStats | null>(null);
  const [skills, setSkills] = useState<HeroSkillSet | null>(null);

  useEffect(() => {
    if (hero) {
      setStats(JSON.parse(JSON.stringify(hero.stats)));
      setSkills(JSON.parse(JSON.stringify(hero.skills)));
    }
  }, [hero]);

  if (!hero || !stats || !skills) return null;

  const handleSave = () => {
    const r = hero.record;
    
    // 1. ê³¼ê±° ê¸°ë¡ ì••ì¶• (Soft Reset) - ê¸°ì¡´ ë°ì´í„°ì˜ 20% ë¹„ì¤‘ë§Œ ë‚¨ê¹€
    const COMPRESSION_RATIO = 0.2; 
    const newTotalMatches = Math.max(100, Math.floor(r.totalMatches * COMPRESSION_RATIO));
    
    // ê¸°ì¡´ ìŠ¹ë¥  ìœ ì§€
    const winRate = r.totalMatches > 0 ? r.totalWins / r.totalMatches : 0.5;
    const newTotalWins = Math.floor(newTotalMatches * winRate);

    // 2. [í•µì‹¬ ìˆ˜ì •] ìµœê·¼ ì „ì (Trend)ì— ê°€ìƒ ë°ì´í„° ì£¼ì…
    // ë¹ˆ ë°°ì—´([])ë¡œ ë‘ë©´ ìŠ¹ë¥ ì´ 50%ë¡œ íŠ€ì–´ë²„ë¦¬ë¯€ë¡œ, ê¸°ì¡´ ìŠ¹ë¥  íŒ¨í„´ì„ ë°˜ì˜í•œ ë”ë¯¸ ë°ì´í„° 20ê°œë¥¼ ë„£ìŒ
    const newRecentResults: boolean[] = [];
    for (let i = 0; i < 20; i++) {
        // winRate í™•ë¥ ë¡œ ìŠ¹ë¦¬(true) ì£¼ì…
        newRecentResults.push(Math.random() < winRate);
    }

    const updatedRecord = {
        ...r,
        totalMatches: newTotalMatches,
        totalWins: newTotalWins,
        // í”½/ë°´ ë“± ê¸°íƒ€ í†µê³„ë„ ì••ì¶•
        totalPicks: Math.floor(r.totalPicks * COMPRESSION_RATIO),
        totalBans: Math.floor(r.totalBans * COMPRESSION_RATIO),
        totalDamage: r.totalDamage * COMPRESSION_RATIO,
        totalDamageTaken: r.totalDamageTaken * COMPRESSION_RATIO,
        totalCs: r.totalCs * COMPRESSION_RATIO,
        totalGold: r.totalGold * COMPRESSION_RATIO,
        totalKills: r.totalKills * COMPRESSION_RATIO,
        totalDeaths: r.totalDeaths * COMPRESSION_RATIO,
        totalAssists: r.totalAssists * COMPRESSION_RATIO,
        
        recentResults: newRecentResults
    };

    updateHero(hero.id, { stats, skills, record: updatedRecord });
    
    alert(`[${hero.name}] íŒ¨ì¹˜ ì™„ë£Œ!\ní†µê³„ê°€ ì†Œí”„íŠ¸ ë¦¬ì…‹ë˜ì–´ ìŠ¹ë¥  ë³€í™”ê°€ ì¦‰ê° ë°˜ì˜ë©ë‹ˆë‹¤.`);
    onClose();
  };

  const handleStatChange = (field: string, value: number) => {
    setStats(prev => prev ? ({ ...prev, [field]: value }) : null);
  };

  const handleSkillChange = (key: string, field: string, value: any) => {
    setSkills(prev => {
      if (!prev) return null;
      return {
        ...prev,
        [key]: { ...prev[key as keyof HeroSkillSet], [field]: value }
      };
    });
  };

  const TabButton = ({ id, label, icon }: any) => (
    <button 
      onClick={() => setActiveTab(id)} 
      style={{ 
        flex: 1, padding: '12px', background: activeTab === id ? '#1f242e' : 'transparent', 
        border: 'none', borderBottom: activeTab === id ? '2px solid #58a6ff' : '1px solid #30363d', 
        color: activeTab === id ? '#58a6ff' : '#8b949e', fontWeight: 'bold', cursor: 'pointer',
        display:'flex', alignItems:'center', justifyContent:'center', gap:'6px', fontSize:'13px',
        transition: '0.2s'
      }}
    >
      {icon} {label}
    </button>
  );

  return (
    <div className="modal-overlay" onClick={onClose} style={{ 
      position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.85)', 
      display: 'flex', justifyContent: 'center', alignItems: 'center', 
      zIndex: 9999, backdropFilter: 'blur(5px)', padding:'20px'
    }}>
      <div onClick={e => e.stopPropagation()} style={{ 
        width: '100%', maxWidth: '500px', maxHeight: '90vh', display: 'flex', flexDirection: 'column',
        background: '#161b22', borderRadius: '16px', border: '1px solid #30363d', 
        overflow: 'hidden', boxShadow: '0 20px 60px rgba(0,0,0,0.6)'
      }}>
        <div style={{ padding: '15px 20px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', background: '#21262d', borderBottom: '1px solid #30363d' }}>
          <div style={{ display: 'flex', alignItems: 'center', gap: '15px' }}>
            <GameIcon id={hero.id} size={44} shape="rounded" />
            <div>
              <div style={{ display:'flex', alignItems:'center', gap:'6px' }}>
                <h3 style={{ margin: 0, fontSize: '16px', color: '#fff' }}>{hero.name}</h3>
                <span style={{ fontSize:'10px', background:'#30363d', padding:'2px 6px', borderRadius:'4px', color:'#ccc' }}>{hero.role}</span>
              </div>
              <div style={{ fontSize: '12px', color: '#58a6ff', marginTop:'2px', display:'flex', alignItems:'center', gap:'4px' }}>
                <Sliders size={12}/> ë°¸ëŸ°ìŠ¤ ì¡°ì • ì¤‘...
              </div>
            </div>
          </div>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#888', cursor: 'pointer', padding:'5px' }}><X size={24}/></button>
        </div>
        <div style={{ display: 'flex', background: '#0d1117' }}>
          <TabButton id="skill" label="ìŠ¤í‚¬" icon={<Zap size={14}/>} />
          <TabButton id="combat" label="ì „íˆ¬" icon={<Swords size={14}/>} />
          <TabButton id="basic" label="ê¸°ë³¸" icon={<Shield size={14}/>} />
        </div>
        <div style={{ flex: 1, overflowY: 'auto', padding: '20px' }}>
          {activeTab === 'skill' && <SkillEditor skills={skills} onChange={handleSkillChange} />}
          {activeTab === 'combat' && <StatEditor fields={['baseAtk', 'ad', 'ap', 'crit', 'pen', 'range']} stats={stats} onChange={handleStatChange} />}
          {activeTab === 'basic' && <StatEditor fields={['hp', 'mp', 'armor', 'regen', 'mpRegen', 'speed']} stats={stats} onChange={handleStatChange} />}
        </div>
        <div style={{ padding: '15px 20px', background: '#21262d', borderTop: '1px solid #30363d' }}>
          <button onClick={handleSave} style={{ 
            width: '100%', padding: '12px', background: '#238636', border: 'none', 
            borderRadius: '8px', color: '#fff', fontWeight: 'bold', fontSize:'14px',
            cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px',
            boxShadow: '0 4px 12px rgba(35, 134, 54, 0.2)'
          }}>
            <Save size={18}/> íŒ¨ì¹˜ ì ìš© (í†µê³„ ë³´ì •ë¨)
          </button>
        </div>
      </div>
    </div>
  );
};


--- FILE: src/components/layout/Header.tsx ---
// ==========================================
// FILE PATH: /src/components/layout/Header.tsx
// ==========================================

import React from 'react';
import { useGameStore } from '../../store/useGameStore';
import { Settings, Save, Play, Pause } from 'lucide-react';

interface Props {
  isMobile: boolean;
  onOpenSystemMenu: () => void;
}

export const Header: React.FC<Props> = ({ isMobile, onOpenSystemMenu }) => {
  const { gameState, togglePlay, setSpeed } = useGameStore();

  // ì‹œê°„ í¬ë§·íŒ… (00:00:00)
  const formatTime = (h: number, m: number, s: number) => 
    `${String(h || 0).padStart(2, '0')}:${String(m || 0).padStart(2, '0')}:${String(Math.floor(s || 0)).padStart(2, '0')}`;

  // ë²„íŠ¼ ìŠ¤íƒ€ì¼ í—¬í¼
  const getBtnStyle = (speed: number) => ({
    padding: '6px 10px', 
    background: gameState.gameSpeed === speed ? '#58a6ff' : '#30363d',
    border: '1px solid #444', 
    borderRadius: '6px', 
    color: '#fff', 
    fontSize: '11px', 
    fontWeight: 'bold',
    cursor: 'pointer',
    minWidth: '40px'
  });

  return (
    <header style={{ 
      display: 'flex', flexDirection: isMobile ? 'column' : 'row', 
      justifyContent: 'space-between', alignItems: isMobile ? 'stretch' : 'center', 
      marginBottom: '20px', background: '#161b22', padding: '15px', 
      borderRadius: '12px', border: '1px solid #30363d', gap: isMobile ? '15px' : '0' 
    }}>
      {/* 1. ì™¼ìª½ ì„¹ì…˜: ì œëª© ë° ì‹œê°„ */}
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
        <div>
          <h1 style={{ margin: 0, fontSize: '20px', color: '#fff' }}>
            ORACLE <span style={{ fontSize:'12px', background:'#58a6ff', color:'#000', padding:'2px 6px', borderRadius:'4px', fontWeight:'bold'}}>PRO</span>
          </h1>
          <div style={{ display: 'flex', gap: '15px', marginTop: '5px', fontSize: '14px', color: '#8b949e' }}>
            <span>ğŸ“… S{gameState.season || 1}</span>
            <span>D{gameState.day || 1}</span>
            <span style={{ color: '#fff', fontWeight: 'bold', fontFamily: 'monospace' }}>
              â° {formatTime(gameState.hour, gameState.minute, gameState.second)}
            </span>
          </div>
        </div>
        {isMobile && (
          <button onClick={onOpenSystemMenu} style={{ background:'none', border:'none', color:'#8b949e' }}>
            <Settings size={24} />
          </button>
        )}
      </div>

      {/* 2. ì˜¤ë¥¸ìª½ ì„¹ì…˜: ë°°ì† ë° ì €ì¥ ì»¨íŠ¸ë¡¤ */}
      <div style={{ display: 'flex', gap: '10px', alignItems: 'center', justifyContent: isMobile ? 'space-between' : 'flex-end' }}>
        <div style={{ display:'flex', alignItems:'center', gap:'6px' }}>
          {!isMobile && (
            <button className="btn" onClick={onOpenSystemMenu} style={{ background: '#21262d', color: '#ccc', border:'1px solid #30363d', display:'flex', alignItems:'center', gap:'6px', padding: '8px 12px', marginRight:'10px' }}>
              <Save size={16}/> ì €ì¥/ë¡œë“œ
            </button>
          )}

          {/* ë°°ì† ë²„íŠ¼ë“¤ */}
          <button style={getBtnStyle(1)} onClick={() => setSpeed(1)}>1ë°°</button>
          <button style={getBtnStyle(3)} onClick={() => setSpeed(3)}>3ë°°</button>
          <button style={getBtnStyle(60)} onClick={() => setSpeed(60)}>1ë¶„</button>
          <button style={getBtnStyle(600)} onClick={() => setSpeed(600)}>10ë¶„</button>
          <button style={getBtnStyle(3600)} onClick={() => setSpeed(3600)}>1ì‹œê°„</button>
        </div>

        {/* ì¬ìƒ/ì •ì§€ ë²„íŠ¼ */}
        <button className="btn" onClick={togglePlay} style={{ background: gameState.isPlaying ? '#da3633' : '#238636', width: '80px', color:'white', fontWeight:'bold', display:'flex', alignItems:'center', justifyContent:'center', gap:'6px' }}>
          {gameState.isPlaying ? <><Pause size={16}/> ì •ì§€</> : <><Play size={16}/> ì¬ìƒ</>}
        </button>
      </div>
    </header>
  );
};

--- FILE: src/components/shop/ItemPatchModal.tsx ---
// ==========================================
// FILE PATH: /src/components/shop/ItemPatchModal.tsx
// ==========================================

import React, { useState, useEffect, useRef } from 'react';
import { Item } from '../../types';
import { useGameStore } from '../../store/useGameStore';
// [ìˆ˜ì •] Trash2 -> Trash ë¡œ ë³€ê²½ (í° í™”ë©´ í•´ê²°ì˜ í•µì‹¬)
import { X, Save, Trash, Sliders } from 'lucide-react';
import { GameIcon } from '../common/GameIcon';

interface Props {
  item?: Item | null;
  onClose: () => void;
}

// ì „ì²´ ìŠ¤íƒ¯ ì„¤ì • ì •ì˜
const ALL_STATS: Record<string, { label: string, color: string, max: number, step: number, unit: string }> = {
  ad: { label: 'ê³µê²©ë ¥ (AD)', color: '#e74c3c', max: 300, step: 1, unit: '' },
  ap: { label: 'ì£¼ë¬¸ë ¥ (AP)', color: '#9b59b6', max: 500, step: 1, unit: '' },
  crit: { label: 'ì¹˜ëª…íƒ€ (CRI)', color: '#e67e22', max: 100, step: 1, unit: '%' },
  pen: { label: 'ê´€í†µë ¥ (PEN)', color: '#da3633', max: 100, step: 1, unit: '' },

  hp: { label: 'ì²´ë ¥ (HP)', color: '#2ecc71', max: 2000, step: 10, unit: '' },
  armor: { label: 'ë°©ì–´ë ¥ (DEF)', color: '#3498db', max: 200, step: 1, unit: '' },
  regen: { label: 'ì²´ë ¥ ì¬ìƒ', color: '#27ae60', max: 100, step: 1, unit: '/s' },

  mp: { label: 'ë§ˆë‚˜ (MP)', color: '#3498db', max: 2000, step: 10, unit: '' },
  mpRegen: { label: 'ë§ˆë‚˜ ì¬ìƒ', color: '#2980b9', max: 50, step: 1, unit: '/s' },
  speed: { label: 'ì´ë™ì†ë„', color: '#f1c40f', max: 150, step: 1, unit: '' },
};

// ë¶„ë¥˜ë³„ í—ˆìš© ìŠ¤íƒ¯ ì •ì˜
const TYPE_ALLOWED_STATS: Record<string, string[]> = {
  WEAPON: ['ad', 'crit', 'pen', 'speed', 'hp'], 
  ARMOR: ['hp', 'armor', 'regen', 'mp'],        
  ARTIFACT: ['ap', 'mp', 'mpRegen', 'pen', 'hp'], 
  BOOTS: ['speed', 'armor', 'pen'],             
  ACCESSORY: Object.keys(ALL_STATS),            
  POWER: Object.keys(ALL_STATS),                
};

const DEFAULT_ITEM: Item = {
  id: '', name: '', cost: 1000,
  ad: 0, ap: 0, hp: 0, armor: 0, crit: 0, speed: 0,
  mp: 0, regen: 0, mpRegen: 0, pen: 0,
  type: 'WEAPON', description: ''
};

// ìŠ¤íƒ¯ ì—ë””í„° ì»´í¬ë„ŒíŠ¸
const StatEditor = ({ 
  statKey, data, activeStat, setActiveStat, handleChange 
}: { 
  statKey: string, 
  data: Item, 
  activeStat: string | null, 
  setActiveStat: (key: string | null) => void, 
  handleChange: (field: keyof Item, value: number) => void 
}) => {
  const config = ALL_STATS[statKey];
  const value = (data as any)[statKey] || 0;
  const isActive = activeStat === statKey;

  return (
    <div 
      onClick={() => setActiveStat(isActive ? null : statKey)}
      style={{
        background: isActive ? '#1f242e' : '#161b22',
        border: isActive ? `1px solid ${config.color}` : '1px solid #30363d',
        borderRadius: '10px', padding: '12px',
        cursor: 'pointer', transition: 'all 0.2s',
        display: 'flex', flexDirection: 'column', gap: '8px'
      }}
    >
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <span style={{ fontSize: '11px', color: isActive ? config.color : '#888', fontWeight: 'bold' }}>
          {config.label}
        </span>
        <span style={{ fontSize: '16px', fontWeight: '900', color: value > 0 ? config.color : '#555', fontFamily: 'monospace' }}>
          {value > 0 ? '+' : ''}{value}{config.unit}
        </span>
      </div>

      {isActive && (
        <div onClick={(e) => e.stopPropagation()} style={{ marginTop: '10px', animation: 'fadeIn 0.2s' }}>
          <input 
            type="range" min={0} max={config.max} step={config.step} value={value}
            onChange={(e) => handleChange(statKey as keyof Item, Number(e.target.value))}
            style={{ width: '100%', accentColor: config.color, height: '20px', cursor: 'pointer', marginBottom: '10px', touchAction: 'none' }}
          />
          <div style={{ display: 'flex', gap: '5px', justifyContent: 'flex-end' }}>
            <button onClick={() => handleChange(statKey as keyof Item, Math.max(0, value - (config.step*10)))} className="mini-btn">--</button>
            <button onClick={() => handleChange(statKey as keyof Item, Math.max(0, value - config.step))} className="mini-btn">-</button>
            <button onClick={() => handleChange(statKey as keyof Item, Math.min(config.max, value + config.step))} className="mini-btn">+</button>
            <button onClick={() => handleChange(statKey as keyof Item, Math.min(config.max, value + (config.step*10)))} className="mini-btn">++</button>
          </div>
        </div>
      )}
    </div>
  );
};

export const ItemPatchModal: React.FC<Props> = ({ item, onClose }) => {
  // deleteItemì„ ì•ˆì „í•˜ê²Œ ê°€ì ¸ì˜µë‹ˆë‹¤. (ì—†ìœ¼ë©´ undefined)
  const store = useGameStore();
  const { addItem, updateItem, setCustomImage, removeCustomImage } = store;
  // deleteItemì´ ì—†ì„ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ anyë¡œ ì²˜ë¦¬í•˜ê±°ë‚˜ ë°©ì–´ ì½”ë“œ ì‘ì„±
  const deleteItem = (store as any).deleteItem;

  const [data, setData] = useState<Item>(DEFAULT_ITEM);
  const [activeStat, setActiveStat] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    if (item) setData({ ...DEFAULT_ITEM, ...item });
    else setData({ ...DEFAULT_ITEM, id: `i_custom_${Date.now()}` });
  }, [item]);

  const handleSave = () => {
    if (!data.name) return alert('ì•„ì´í…œ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
    item ? updateItem(item.id, data) : addItem(data);
    onClose();
  };

  const handleDelete = () => {
    if (!item) return;
    if (!deleteItem) {
      alert("ì‚­ì œ ê¸°ëŠ¥ì´ ìŠ¤í† ì–´ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. (store/itemSlice.ts í™•ì¸)");
      return;
    }
    if (confirm(`ì •ë§ '${item.name}' ì•„ì´í…œì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
      deleteItem(item.id);
      onClose();
    }
  };

  const handleChange = (field: keyof Item, value: any) => {
    setData(prev => ({ ...prev, [field]: value }));
  };

  const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        if (typeof reader.result === 'string') setCustomImage(data.id, reader.result);
      };
      reader.readAsDataURL(file);
    }
  };

  const visibleStats = TYPE_ALLOWED_STATS[data.type] || Object.keys(ALL_STATS);

  return (
    <div style={{
      position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.85)', zIndex: 9999,
      display: 'flex', justifyContent: 'center', alignItems: 'center', backdropFilter: 'blur(5px)', padding: '15px'
    }}>
      <div style={{ 
        width: '100%', maxWidth: '500px', background: '#0d1117', border: '1px solid #30363d', 
        borderRadius: '16px', overflow: 'hidden', display: 'flex', flexDirection: 'column', maxHeight: '90vh',
        boxShadow: '0 20px 60px rgba(0,0,0,0.8)'
      }}>

        {/* 1. ìƒë‹¨ ì •ë³´ */}
        <div style={{ padding: '20px', borderBottom: '1px solid #30363d', background: '#161b22', display: 'flex', gap: '15px' }}>
          <div onClick={() => fileInputRef.current?.click()} className="group" style={{ position: 'relative', cursor: 'pointer', flexShrink: 0 }}>
            <GameIcon id={data.id} size={72} shape="rounded" border="2px solid #30363d" />
            <div style={{ position: 'absolute', inset: 0, background: 'rgba(0,0,0,0.6)', display: 'flex', alignItems: 'center', justifyContent: 'center', borderRadius: '12px', opacity: 0, transition: '0.2s', color: '#fff', fontSize: '10px', fontWeight: 'bold' }} className="hover-show">ë³€ê²½</div>
            <input type="file" ref={fileInputRef} style={{ display: 'none' }} accept="image/*" onChange={handleImageUpload} />
          </div>

          <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '8px' }}>
            <input 
              type="text" value={data.name} onChange={(e) => handleChange('name', e.target.value)}
              placeholder="ì•„ì´í…œ ì´ë¦„"
              style={{ background: 'transparent', border: 'none', borderBottom: '1px solid #30363d', color: '#fff', fontSize: '16px', fontWeight: 'bold', padding: '5px 0', width: '100%', outline: 'none' }}
            />
            <div style={{ display: 'flex', gap: '10px' }}>
              <div style={{ flex: 1 }}>
                <label style={{ fontSize: '10px', color: '#888' }}>ê°€ê²©</label>
                <input 
                  type="number" value={data.cost} onChange={(e) => handleChange('cost', Number(e.target.value))}
                  style={{ background: '#0d1117', border: '1px solid #30363d', color: '#f1c40f', borderRadius: '4px', width: '100%', padding: '6px', fontWeight: 'bold', fontSize: '13px' }}
                />
              </div>
              <div style={{ flex: 1 }}>
                <label style={{ fontSize: '10px', color: '#888' }}>ë¶„ë¥˜</label>
                <select 
                  value={data.type} onChange={(e) => handleChange('type', e.target.value)}
                  style={{ background: '#0d1117', border: '1px solid #30363d', color: '#ccc', borderRadius: '4px', width: '100%', padding: '6px', fontSize: '12px' }}
                >
                  <option value="WEAPON">âš”ï¸ ë¬´ê¸°</option>
                  <option value="ARMOR">ğŸ›¡ï¸ ë°©ì–´êµ¬</option>
                  <option value="ARTIFACT">ğŸ”® ë§ˆë„êµ¬</option>
                  <option value="BOOTS">ğŸ‘ ì‹ ë°œ</option>
                  <option value="ACCESSORY">ğŸ’ ì¥ì‹ êµ¬</option>
                  <option value="POWER">âš¡ ê¶ŒëŠ¥</option>
                </select>
              </div>
            </div>
          </div>
        </div>

        {/* 2. ìŠ¤íƒ¯ ì—ë””í„° */}
        <div style={{ flex: 1, overflowY: 'auto', padding: '20px' }}>
          <div style={{ marginBottom: '20px' }}>
            <textarea 
              value={data.description || ''} onChange={(e) => handleChange('description', e.target.value)}
              placeholder="ì„¤ëª…..." rows={2}
              style={{ width: '100%', background: '#161b22', border: '1px solid #30363d', borderRadius: '8px', padding: '10px', color: '#ccc', fontSize: '12px', resize: 'none', boxSizing: 'border-box' }}
            />
          </div>

          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px' }}>
            {visibleStats.map(key => (
              <StatEditor key={key} statKey={key} data={data} activeStat={activeStat} setActiveStat={setActiveStat} handleChange={handleChange} />
            ))}
          </div>

          <div style={{ marginTop: '20px', display: 'flex', justifyContent: 'center' }}>
            <button onClick={() => removeCustomImage(data.id)} style={{ background: 'none', border: 'none', color: '#666', fontSize: '11px', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '4px' }}>
                <Trash size={12}/> ì‚¬ì§„ ì´ˆê¸°í™”
            </button>
          </div>
        </div>

        {/* 3. í‘¸í„° (ì‚­ì œ ë²„íŠ¼ í¬í•¨) */}
        <div style={{ padding: '15px 20px', borderTop: '1px solid #30363d', background: '#161b22', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <div>
            {item && (
              <button 
                onClick={handleDelete}
                style={{ 
                  padding: '10px 16px', background: '#3f1515', border: '1px solid #5a1e1e', 
                  color: '#ff6b6b', borderRadius: '8px', cursor: 'pointer', 
                  fontWeight: 'bold', fontSize: '13px', display: 'flex', alignItems: 'center', gap: '6px' 
                }}
              >
                <Trash size={16}/> ì‚­ì œ
              </button>
            )}
          </div>

          <div style={{ display:'flex', gap:'10px' }}>
            <button onClick={onClose} style={{ padding: '10px 20px', background: 'transparent', border: '1px solid #30363d', color: '#ccc', borderRadius: '8px', cursor: 'pointer', fontWeight: 'bold', fontSize: '13px' }}>ì·¨ì†Œ</button>
            <button onClick={handleSave} style={{ padding: '10px 24px', background: '#238636', border: 'none', color: '#fff', borderRadius: '8px', cursor: 'pointer', fontWeight: 'bold', fontSize: '13px', display: 'flex', alignItems: 'center', gap: '6px' }}>
              <Save size={16}/> {item ? 'ìˆ˜ì •' : 'ìƒì„±'}
            </button>
          </div>
        </div>

      </div>
      <style>{`
        .hover-show:hover { opacity: 1 !important; }
        .mini-btn {
          background: #30363d; border: none; color: #fff; 
          padding: 4px 8px; border-radius: 4px; 
          cursor: pointer; display: flex; alignItems: center; justifyContent: center;
          font-size: 11px; font-weight: bold;
        }
        .mini-btn:hover { background: #444; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }
      `}</style>
    </div>
  );
};


--- FILE: src/components/shop/ItemStatsView.tsx ---
// ==========================================
// FILE PATH: /src/components/shop/ItemStatsView.tsx
// ==========================================

import React, { useState } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { Item } from '../../types';
import { Trophy, Target, Activity, ArrowUp, ArrowDown } from 'lucide-react';

export const ItemStatsView: React.FC = () => {
  const { shopItems, gameState } = useGameStore();

  // [ìˆ˜ì •] ê¸°ì¡´ ì„¸ì´ë¸Œ íŒŒì¼ì— itemStatsê°€ ì—†ì„ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ë¹ˆ ê°ì²´({}) í• ë‹¹
  const itemStats = gameState.itemStats || {};
  const godStats = gameState.godStats || { totalMatches: 0 };

  const [sortKey, setSortKey] = useState<'winRate' | 'pickRate' | 'kda'>('pickRate');

  // ì „ì²´ ê²Œì„ ìˆ˜ (í”½ë¥  ê³„ì‚°ìš©)
  const totalPlayerGames = Math.max(1, godStats.totalMatches * 10);

  // ë°ì´í„° ê°€ê³µ
  const statsList = shopItems.map(item => {
    // itemStatsê°€ ë¹„ì–´ìˆì–´ë„ ì•ˆì „í•˜ê²Œ ê¸°ë³¸ê°’ ì‚¬ìš©
    const stat = itemStats[item.id] || { totalPicks: 0, totalWins: 0, totalKills: 0, totalDeaths: 0, totalAssists: 0 };

    const pickRate = (stat.totalPicks / totalPlayerGames) * 100;
    const winRate = stat.totalPicks > 0 ? (stat.totalWins / stat.totalPicks) * 100 : 0;
    const kills = stat.totalPicks > 0 ? stat.totalKills / stat.totalPicks : 0;
    const deaths = stat.totalPicks > 0 ? stat.totalDeaths / stat.totalPicks : 0;
    const assists = stat.totalPicks > 0 ? stat.totalAssists / stat.totalPicks : 0;
    const kda = deaths === 0 ? (kills + assists) : (kills + assists) / deaths;

    return {
      ...item,
      stat,
      displayPickRate: pickRate,
      displayWinRate: winRate,
      displayKda: kda,
      avgKdaStr: `${kills.toFixed(1)} / ${deaths.toFixed(1)} / ${assists.toFixed(1)}`
    };
  });

  // ì •ë ¬
  const sortedList = [...statsList].sort((a, b) => {
    if (sortKey === 'winRate') return b.displayWinRate - a.displayWinRate;
    if (sortKey === 'kda') return b.displayKda - a.displayKda;
    return b.displayPickRate - a.displayPickRate; // default: pickRate
  });

  const getWinRateColor = (rate: number) => {
    if (rate >= 55) return '#ff4d4d'; // OP
    if (rate >= 50) return '#3fb950'; // Good
    return '#8b949e'; // Bad
  };

  return (
    <div style={{ padding: '0 5px' }}>
      {/* ì •ë ¬ ë²„íŠ¼ */}
      <div style={{ display: 'flex', gap: '10px', marginBottom: '15px', justifyContent: 'flex-end' }}>
        {[
          { key: 'pickRate', label: 'ì±„íƒë¥  ìˆœ' },
          { key: 'winRate', label: 'ìŠ¹ë¥  ìˆœ' },
          { key: 'kda', label: 'í‰ì (KDA) ìˆœ' }
        ].map((btn) => (
          <button
            key={btn.key}
            onClick={() => setSortKey(btn.key as any)}
            style={{
              background: sortKey === btn.key ? '#30363d' : 'transparent',
              color: sortKey === btn.key ? '#fff' : '#888',
              border: '1px solid #30363d', padding: '6px 12px', borderRadius: '6px', cursor: 'pointer', fontSize: '11px', fontWeight: 'bold',
              display:'flex', alignItems:'center', gap:'4px'
            }}
          >
            {btn.label} {sortKey === btn.key && <ArrowDown size={12}/>}
          </button>
        ))}
      </div>

      {/* í…Œì´ë¸” í—¤ë” */}
      <div style={{ display: 'grid', gridTemplateColumns: '2fr 1fr 1fr 1.5fr', padding: '10px', background: '#21262d', borderRadius: '8px 8px 0 0', fontSize: '11px', color: '#8b949e', fontWeight: 'bold' }}>
        <div>ì•„ì´í…œ ëª…</div>
        <div style={{ textAlign: 'center' }}>ì±„íƒë¥ </div>
        <div style={{ textAlign: 'center' }}>ìŠ¹ë¥ </div>
        <div style={{ textAlign: 'right', paddingRight:'10px' }}>í‰ê·  KDA</div>
      </div>

      {/* ë¦¬ìŠ¤íŠ¸ */}
      <div style={{ border: '1px solid #30363d', borderTop: 'none', borderRadius: '0 0 8px 8px', background: '#161b22' }}>
        {sortedList.map((item, idx) => (
          <div key={item.id} style={{ 
            display: 'grid', gridTemplateColumns: '2fr 1fr 1fr 1.5fr', 
            padding: '12px 10px', borderBottom: '1px solid #2c2c2f', alignItems: 'center' 
          }}>
            {/* 1. ì•„ì´í…œ ì •ë³´ */}
            <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
              <div style={{ fontSize: '12px', color: '#555', width: '20px', textAlign: 'center' }}>{idx + 1}</div>
              <div>
                <div style={{ color: item.type === 'POWER' ? '#9b59b6' : '#fff', fontWeight: 'bold', fontSize: '13px' }}>
                  {item.name}
                </div>
                <div style={{ fontSize: '10px', color: '#666' }}>{item.cost} G</div>
              </div>
            </div>

            {/* 2. ì±„íƒë¥  */}
            <div style={{ textAlign: 'center' }}>
              <div style={{ color: '#fff', fontSize: '13px', fontWeight: 'bold' }}>{item.displayPickRate.toFixed(1)}%</div>
              <div style={{ fontSize: '10px', color: '#555' }}>{item.stat.totalPicks.toLocaleString()}íšŒ</div>
            </div>

            {/* 3. ìŠ¹ë¥  */}
            <div style={{ textAlign: 'center' }}>
              <div style={{ color: getWinRateColor(item.displayWinRate), fontSize: '13px', fontWeight: 'bold' }}>
                {item.displayWinRate.toFixed(1)}%
              </div>
            </div>

            {/* 4. KDA */}
            <div style={{ textAlign: 'right', paddingRight:'10px' }}>
              <div style={{ color: item.displayKda >= 3 ? '#e89d40' : '#ccc', fontWeight: 'bold', fontSize: '13px' }}>
                {item.displayKda.toFixed(2)}:1
              </div>
              <div style={{ fontSize: '10px', color: '#666' }}>{item.avgKdaStr}</div>
            </div>
          </div>
        ))}

        {sortedList.length === 0 && (
          <div style={{ padding: '40px', textAlign: 'center', color: '#555' }}>ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>
        )}
      </div>
    </div>
  );
};

--- FILE: src/components/shop/ShopTab.tsx ---
// ==========================================
// FILE PATH: /src/components/shop/ShopTab.tsx
// ==========================================

import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { 
  Coins, Plus, Shield, Sword, Zap, Briefcase, 
  BarChart2, ShoppingCart, Search, ChevronRight, Footprints, Gem 
} from 'lucide-react'; // Trash ì œê±°ë¨
import { ItemStatsView } from './ItemStatsView'; 
import { ItemPatchModal } from './ItemPatchModal';
import { Item } from '../../types';
import { GameIcon } from '../common/GameIcon';

export const ShopTab: React.FC = () => {
  const { shopItems } = useGameStore();
  const [mode, setMode] = useState<'MANAGE' | 'STATS'>('MANAGE');
  const [filter, setFilter] = useState<string>('ALL');
  const [searchQuery, setSearchQuery] = useState('');
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingItem, setEditingItem] = useState<Item | null>(null);

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const filteredItems = shopItems.filter(i => {
    const matchFilter = filter === 'ALL' || i.type === filter;
    const matchSearch = i.name.toLowerCase().includes(searchQuery.toLowerCase());
    return matchFilter && matchSearch;
  });

  // ê°€ê²©ìˆœ ì •ë ¬
  filteredItems.sort((a, b) => a.cost - b.cost);

  const handleCreate = () => { setEditingItem(null); setIsModalOpen(true); };
  const handleEdit = (item: Item) => { setEditingItem(item); setIsModalOpen(true); };

  const getTypeIcon = (type: string) => {
    switch(type) {
      case 'WEAPON': return <Sword size={14} color="#e74c3c"/>;
      case 'ARMOR': return <Shield size={14} color="#2ecc71"/>;
      case 'ACCESSORY': return <Briefcase size={14} color="#f1c40f"/>;
      case 'POWER': return <Zap size={14} color="#9b59b6"/>;
      case 'BOOTS': return <Footprints size={14} color="#00b894"/>;
      case 'ARTIFACT': return <Gem size={14} color="#a29bfe"/>;
      default: return <Coins size={14} color="#888"/>;
    }
  };

  const StatBadge = ({ label, val, color }: { label: string, val?: number, color: string }) => {
    if (!val || val === 0) return null;
    return (
      <span style={{ 
        fontSize: '10px', fontWeight: 'bold', color: color, 
        background: `${color}11`, border: `1px solid ${color}44`, 
        padding: '1px 5px', borderRadius: '4px', whiteSpace: 'nowrap',
        display: 'inline-flex', alignItems: 'center', fontFamily: 'monospace'
      }}>
        {label} +{val}
      </span>
    );
  };

  const ItemStatsRenderer = ({ item }: { item: Item }) => (
    <div style={{ display: 'flex', gap: '4px', flexWrap: 'wrap' }}>
      <StatBadge label="AD" val={item.ad} color="#e74c3c" />
      <StatBadge label="AP" val={item.ap} color="#9b59b6" />
      <StatBadge label="HP" val={item.hp} color="#2ecc71" />
      <StatBadge label="DEF" val={item.armor} color="#3498db" />
      <StatBadge label="CRI" val={item.crit} color="#e67e22" />
      <StatBadge label="SPD" val={item.speed} color="#f1c40f" />
      <StatBadge label="MP" val={item.mp} color="#3498db" />
      <StatBadge label="PEN" val={item.pen} color="#da3633" />
      <StatBadge label="REG" val={item.regen} color="#27ae60" />
      <StatBadge label="M.REG" val={item.mpRegen} color="#2980b9" />
    </div>
  );

  const DesktopRow = ({ item, index }: { item: Item, index: number }) => (
    <div 
      onClick={() => handleEdit(item)}
      style={{ 
        // [ìˆ˜ì •] ê·¸ë¦¬ë“œ ì»¬ëŸ¼ì—ì„œ ì‚­ì œ ë²„íŠ¼ ê³µê°„ ì œê±° (80px -> ì œê±°)
        display: 'grid', gridTemplateColumns: '50px 250px 100px 1fr', 
        padding: '10px 15px', borderBottom: '1px solid #2c2c2f', 
        alignItems: 'center', background: '#161b22', cursor: 'pointer',
        transition: 'background 0.1s'
      }}
      onMouseEnter={e => e.currentTarget.style.background = '#21262d'}
      onMouseLeave={e => e.currentTarget.style.background = '#161b22'}
    >
      <div style={{ color: '#555', fontStyle: 'italic', fontWeight: 'bold', textAlign:'center' }}>{index + 1}</div>
      <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
        <GameIcon id={item.id} size={36} shape="rounded" border="1px solid #444" />
        <div>
          <div style={{ fontWeight: 'bold', color: item.type === 'POWER' ? '#9b59b6' : '#fff', fontSize: '13px' }}>{item.name}</div>
          <div style={{ fontSize: '11px', color: '#666', display:'flex', alignItems:'center', gap:'4px' }}>
            {getTypeIcon(item.type)} {item.type}
          </div>
        </div>
      </div>
      <div style={{ color: '#f1c40f', fontWeight: 'bold', fontSize: '13px', fontFamily: 'monospace' }}>
        {item.cost.toLocaleString()} G
      </div>
      <div><ItemStatsRenderer item={item} /></div>
      
      {/* [ìˆ˜ì •] ì‚­ì œ ë²„íŠ¼ ì œê±°ë¨ */}
    </div>
  );

  const MobileRow = ({ item, index }: { item: Item, index: number }) => (
    <div onClick={() => handleEdit(item)} style={{ display: 'flex', alignItems: 'center', gap: '12px', padding: '12px', borderBottom: '1px solid #2c2c2f', background: '#161b22', cursor: 'pointer' }}>
      <div style={{ fontSize: '12px', color: '#555', fontStyle: 'italic', width: '20px', textAlign:'center' }}>{index + 1}</div>
      <GameIcon id={item.id} size={42} shape="rounded" border="1px solid #444" />
      <div style={{ flex: 1, minWidth: 0 }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '4px' }}>
          <span style={{ fontWeight: 'bold', color: '#fff', fontSize: '14px' }}>{item.name}</span>
          <span style={{ color: '#f1c40f', fontWeight: 'bold', fontSize: '12px' }}>{item.cost.toLocaleString()}</span>
        </div>
        <ItemStatsRenderer item={item} />
      </div>
      <ChevronRight size={16} color="#444" />
      {/* [ìˆ˜ì •] ì‚­ì œ ë²„íŠ¼ ì œê±°ë¨ */}
    </div>
  );

  return (
    <div style={{ paddingBottom: '80px', display: 'flex', flexDirection: 'column', height: '100%' }}>
      <div style={{ background:'#161b22', borderRadius:'12px', border:'1px solid #30363d', padding: '12px 15px', marginBottom: '10px', display:'flex', flexDirection: isMobile ? 'column' : 'row', gap: isMobile ? '10px' : '15px', justifyContent:'space-between', alignItems: isMobile ? 'stretch' : 'center' }}>
        <div style={{ display:'flex', alignItems:'center', gap:'10px' }}>
            <Coins color="#f1c40f" size={20}/>
            <h2 style={{ margin:0, color:'#fff', fontSize: '16px', fontWeight:'800' }}>ì•„ì´í…œ ìƒì </h2>
        </div>
        <div style={{ display:'flex', background:'#0d1117', padding:'3px', borderRadius:'6px', border:'1px solid #30363d' }}>
            <button onClick={() => setMode('MANAGE')} style={{ flex:1, padding:'6px 12px', borderRadius:'4px', border:'none', background: mode === 'MANAGE' ? '#58a6ff' : 'transparent', color: mode === 'MANAGE' ? '#000' : '#8b949e', fontWeight:'bold', fontSize:'12px', cursor:'pointer', display:'flex', alignItems:'center', justifyContent:'center', gap:'6px' }}><ShoppingCart size={14}/> ê´€ë¦¬</button>
            <button onClick={() => setMode('STATS')} style={{ flex:1, padding:'6px 12px', borderRadius:'4px', border:'none', background: mode === 'STATS' ? '#58a6ff' : 'transparent', color: mode === 'STATS' ? '#000' : '#8b949e', fontWeight:'bold', fontSize:'12px', cursor:'pointer', display:'flex', alignItems:'center', justifyContent:'center', gap:'6px' }}><BarChart2 size={14}/> í†µê³„</button>
        </div>
      </div>

      {mode === 'STATS' && <ItemStatsView />}

      {mode === 'MANAGE' && (
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', background: '#1c1c1f', border: '1px solid #30363d', borderRadius: '12px', overflow: 'hidden' }}>
          <div style={{ padding: '10px 15px', borderBottom: '1px solid #30363d', display: 'flex', flexDirection: isMobile ? 'column' : 'row', gap: '10px', background: '#252528' }}>
            <div style={{ display: 'flex', gap: '5px', overflowX: 'auto', scrollbarWidth: 'none' }}>
              {['ALL', 'WEAPON', 'ARMOR', 'ARTIFACT', 'BOOTS', 'ACCESSORY', 'POWER'].map(f => (
                <button key={f} onClick={() => setFilter(f)} style={{ background: filter === f ? '#30363d' : 'transparent', color: filter === f ? '#fff' : '#888', border: '1px solid', borderColor: filter === f ? '#555' : 'transparent', padding: '4px 10px', borderRadius: '4px', cursor: 'pointer', fontWeight: 'bold', fontSize: '11px', whiteSpace: 'nowrap' }}>
                  {f === 'ALL' ? 'ì „ì²´' : f}
                </button>
              ))}
            </div>
            <div style={{ position: 'relative', flex: 1 }}>
              <Search size={14} color="#666" style={{ position: 'absolute', left: '10px', top: '50%', transform: 'translateY(-50%)' }} />
              <input type="text" placeholder="ì•„ì´í…œ ê²€ìƒ‰..." value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} style={{ width: '100%', background: '#161b22', border: '1px solid #444', borderRadius: '4px', padding: '6px 10px 6px 30px', color: '#fff', fontSize: '12px', outline: 'none', boxSizing: 'border-box' }} />
            </div>
            <button onClick={handleCreate} style={{ background: '#238636', border: '1px solid #2ea043', borderRadius: '4px', color: '#fff', fontSize: '12px', fontWeight: 'bold', padding: '6px 12px', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '4px', whiteSpace: 'nowrap', justifyContent:'center' }}><Plus size={14}/> ì‹ ê·œ ë“±ë¡</button>
          </div>

          <div style={{ flex: 1, overflowY: 'auto' }}>
            {!isMobile && (
              // [ìˆ˜ì •] í—¤ë” ê·¸ë¦¬ë“œ ì¡°ì • (80px ì‚­ì œ)
              <div style={{ display: 'grid', gridTemplateColumns: '50px 250px 100px 1fr', padding: '10px 15px', borderBottom: '1px solid #30363d', background: '#161b22', fontSize: '11px', fontWeight: 'bold', color: '#8b949e', position: 'sticky', top: 0 }}>
                <div style={{ textAlign:'center' }}>No.</div>
                <div>ì•„ì´í…œ ì •ë³´</div>
                <div>ê°€ê²©</div>
                <div>ëŠ¥ë ¥ì¹˜ (Stats)</div>
                {/* ê´€ë¦¬(ì‚­ì œ) íƒ­ í—¤ë” ì œê±°ë¨ */}
              </div>
            )}
            {filteredItems.length > 0 ? (
              filteredItems.map((item, idx) => (
                isMobile ? <MobileRow key={item.id} item={item} index={idx} /> : <DesktopRow key={item.id} item={item} index={idx} />
              ))
            ) : <div style={{ padding: '40px', textAlign: 'center', color: '#555', fontSize: '13px' }}>ê²€ìƒ‰ëœ ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤.</div>}
          </div>
        </div>
      )}

      {isModalOpen && <ItemPatchModal item={editingItem} onClose={() => setIsModalOpen(false)} />}
    </div>
  );
};


--- FILE: src/components/shop/ui/ShopItemRow.tsx ---
import React from 'react';
import { Item } from '../../../types';
import { GameIcon } from '../../common/GameIcon';
import { Sword, Shield, Coins, Zap, Briefcase, ChevronRight, Footprints, Gem } from 'lucide-react';

interface Props {
  item: Item;
  index: number;
  isMobile: boolean;
  onEdit: (item: Item) => void;
}

const getTypeIcon = (type: string) => {
  switch(type) {
    case 'WEAPON': return <Sword size={14} color="#e74c3c"/>;
    case 'ARMOR': return <Shield size={14} color="#2ecc71"/>;
    case 'ACCESSORY': return <Briefcase size={14} color="#f1c40f"/>;
    case 'POWER': return <Zap size={14} color="#9b59b6"/>;
    case 'BOOTS': return <Footprints size={14} color="#00b894"/>;
    case 'ARTIFACT': return <Gem size={14} color="#a29bfe"/>;
    default: return <Coins size={14} color="#888"/>;
  }
};

const StatBadge = ({ label, val, color }: { label: string, val?: number, color: string }) => {
  if (!val || val === 0) return null;
  return (
    <span style={{ fontSize: '10px', fontWeight: 'bold', color: color, background: \`\${color}11\`, border: \`1px solid \${color}44\`, padding: '1px 5px', borderRadius: '4px', whiteSpace: 'nowrap', display: 'inline-flex', alignItems: 'center', fontFamily: 'monospace' }}>
      {label} +{val}
    </span>
  );
};

const ItemStatsRenderer = ({ item }: { item: Item }) => (
  <div style={{ display: 'flex', gap: '4px', flexWrap: 'wrap' }}>
    <StatBadge label="AD" val={item.ad} color="#e74c3c" />
    <StatBadge label="AP" val={item.ap} color="#9b59b6" />
    <StatBadge label="HP" val={item.hp} color="#2ecc71" />
    <StatBadge label="DEF" val={item.armor} color="#3498db" />
    <StatBadge label="CRI" val={item.crit} color="#e67e22" />
    <StatBadge label="SPD" val={item.speed} color="#f1c40f" />
    <StatBadge label="MP" val={item.mp} color="#3498db" />
    <StatBadge label="PEN" val={item.pen} color="#da3633" />
    <StatBadge label="REG" val={item.regen} color="#27ae60" />
    <StatBadge label="M.REG" val={item.mpRegen} color="#2980b9" />
  </div>
);

export const ShopItemRow: React.FC<Props> = ({ item, index, isMobile, onEdit }) => {
  if (isMobile) {
    return (
      <div onClick={() => onEdit(item)} style={{ display: 'flex', alignItems: 'center', gap: '12px', padding: '12px', borderBottom: '1px solid #2c2c2f', background: '#161b22', cursor: 'pointer' }}>
        <div style={{ fontSize: '12px', color: '#555', fontStyle: 'italic', width: '20px', textAlign:'center' }}>{index + 1}</div>
        <GameIcon id={item.id} size={42} shape="rounded" border="1px solid #444" />
        <div style={{ flex: 1, minWidth: 0 }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '4px' }}>
            <span style={{ fontWeight: 'bold', color: '#fff', fontSize: '14px' }}>{item.name}</span>
            <span style={{ color: '#f1c40f', fontWeight: 'bold', fontSize: '12px' }}>{item.cost.toLocaleString()}</span>
          </div>
          <ItemStatsRenderer item={item} />
        </div>
        <ChevronRight size={16} color="#444" />
      </div>
    );
  }

  return (
    <div onClick={() => onEdit(item)} style={{ display: 'grid', gridTemplateColumns: '50px 250px 100px 1fr', padding: '10px 15px', borderBottom: '1px solid #2c2c2f', alignItems: 'center', background: '#161b22', cursor: 'pointer', transition: 'background 0.1s' }} onMouseEnter={e => e.currentTarget.style.background = '#21262d'} onMouseLeave={e => e.currentTarget.style.background = '#161b22'}>
      <div style={{ color: '#555', fontStyle: 'italic', fontWeight: 'bold', textAlign:'center' }}>{index + 1}</div>
      <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
        <GameIcon id={item.id} size={36} shape="rounded" border="1px solid #444" />
        <div>
          <div style={{ fontWeight: 'bold', color: item.type === 'POWER' ? '#9b59b6' : '#fff', fontSize: '13px' }}>{item.name}</div>
          <div style={{ fontSize: '11px', color: '#666', display:'flex', alignItems:'center', gap:'4px' }}>{getTypeIcon(item.type)} {item.type}</div>
        </div>
      </div>
      <div style={{ color: '#f1c40f', fontWeight: 'bold', fontSize: '13px', fontFamily: 'monospace' }}>{item.cost.toLocaleString()} G</div>
      <div><ItemStatsRenderer item={item} /></div>
    </div>
  );
};


--- FILE: src/components/system/SystemMenu.tsx ---
// ==========================================
// FILE PATH: /src/components/common/SystemMenu.tsx
// ==========================================

import React, { useState } from 'react';
import { Save, Disc, AlertTriangle, X } from 'lucide-react';

// ë¶„ë¦¬í•œ ì»´í¬ë„ŒíŠ¸ import
import { OptionTab } from '../system/OptionTab';
import { SaveLoadTab } from '../system/SaveLoadTab';

interface Props { onClose: () => void; }

export const SystemMenu: React.FC<Props> = ({ onClose }) => {
  const [activeTab, setActiveTab] = useState<'SAVE' | 'LOAD' | 'OPTION'>('SAVE');

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };

  return (
    <div 
      onClick={handleBackdropClick} 
      style={{
        position: 'fixed', top: 0, left: 0, width: '100%', height: '100%',
        backgroundColor: 'rgba(0,0,0,0.85)', display: 'flex', justifyContent: 'center', alignItems: 'center', zIndex: 9999,
        backdropFilter: 'blur(5px)',
        padding: '10px' 
      }}
    >
      <div className="panel" style={{ 
        width: '100%', maxWidth: '450px', maxHeight: '90vh',
        background: '#1c1c1f', border: '1px solid #30363d', 
        display:'flex', flexDirection:'column', padding:0,
        overflow: 'hidden', borderRadius: '12px'
      }}>

        {/* í—¤ë” */}
        <div style={{ 
          padding: '15px 20px', borderBottom: '1px solid #333', 
          display: 'flex', justifyContent: 'space-between', alignItems: 'center', 
          background: '#252528', flexShrink: 0 
        }}>
          <h3 style={{ margin: 0, color: '#fff', fontSize: '16px' }}>ì‹œìŠ¤í…œ ë©”ë‰´</h3>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#fff', cursor: 'pointer', padding:'5px' }}>
            <X size={24} />
          </button>
        </div>

        {/* íƒ­ ë²„íŠ¼ */}
        <div style={{ display: 'flex', background: '#161b22', borderBottom: '1px solid #333', flexShrink: 0 }}>
          {([
            { id: 'SAVE', label: 'ì €ì¥', icon: Save },
            { id: 'LOAD', label: 'ë¶ˆëŸ¬ì˜¤ê¸°', icon: Disc },
            { id: 'OPTION', label: 'ì˜µì…˜', icon: AlertTriangle }
          ] as const).map(t => (
            <button
              key={t.id}
              onClick={() => setActiveTab(t.id)}
              style={{
                flex: 1, padding: '15px', background: 'none', border: 'none',
                borderBottom: activeTab === t.id ? '2px solid #58a6ff' : '2px solid transparent',
                color: activeTab === t.id ? '#fff' : '#777', fontWeight: 'bold', cursor: 'pointer',
                display:'flex', alignItems:'center', justifyContent:'center', gap:'8px'
              }}
            >
              <t.icon size={16} /> {t.label}
            </button>
          ))}
        </div>

        {/* ë©”ì¸ ì»¨í…ì¸  ì˜ì—­ (ë¶„ë¦¬ëœ ì»´í¬ë„ŒíŠ¸ ë Œë”ë§) */}
        <div style={{ flex: 1, overflowY: 'auto', padding: '20px' }}>
          {activeTab === 'SAVE' && <SaveLoadTab mode="SAVE" />}
          {activeTab === 'LOAD' && <SaveLoadTab mode="LOAD" />}
          {activeTab === 'OPTION' && <OptionTab />}
        </div>

      </div>
    </div>
  );
};

--- FILE: src/components/system/OptionTab.tsx ---
import React, { useState, useRef, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { exportSaveFile, importSaveFile } from '../../engine/SaveLoadSystem';
// [ì‹ ê·œ] ë‹¤ìš´ë¡œë” ì„í¬íŠ¸
import { downloadAllResources, checkCachedStatus } from '../../utils/ResourceDownloader';
import { 
  Bot, Key, CheckCircle, Download, Upload, Trash2, RefreshCw, 
  Map as MapIcon, Image as ImageIcon, Database, CloudLightning, Loader2 
} from 'lucide-react';

export const OptionTab: React.FC = () => {
  const { gameState, heroes, shopItems, updateAIConfig, resetHeroStats, hardReset, loadModData, setCustomImage, removeCustomImage } = useGameStore();
  const [aiSettings, setAiSettings] = useState(gameState.aiConfig);
  
  // [ì‹ ê·œ] ë‹¤ìš´ë¡œë“œ ìƒíƒœ ê´€ë¦¬
  const [isDownloading, setIsDownloading] = useState(false);
  const [progress, setProgress] = useState(0);
  const [cachedCount, setCachedCount] = useState(0);
  
  const fileInputRef = useRef<HTMLInputElement>(null);
  const modInputRef = useRef<HTMLInputElement>(null);
  const mapInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    checkCachedStatus().then(setCachedCount);
  }, []);

  const handleDownloadResources = async () => {
    if (isDownloading) return;
    if (!confirm("ê²Œì„ì— í•„ìš”í•œ ëª¨ë“  ì´ë¯¸ì§€ë¥¼ ë‹¤ìš´ë¡œë“œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(ì•½ 5~10MB ì†Œìš”)")) return;

    setIsDownloading(true);
    setProgress(0);

    const success = await downloadAllResources((current, total) => {
      setProgress((current / total) * 100);
    });

    if (success) {
      alert("âœ… ëª¨ë“  ë¦¬ì†ŒìŠ¤ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ!\nì´ì œ ë¡œë”© ì—†ì´ ì¾Œì í•˜ê²Œ í”Œë ˆì´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
      checkCachedStatus().then(setCachedCount);
    }
    setIsDownloading(false);
  };

  const saveAISettings = () => {
    updateAIConfig(aiSettings);
    alert("âœ… AI ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!");
  };

  const handleStatReset = () => {
    if (confirm('ëª¨ë“  ì±”í”¼ì–¸ì˜ ëˆ„ì  í†µê³„(ìŠ¹ë¥ , KDA, íŒìˆ˜)ë¥¼ 0ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
      resetHeroStats();
      alert('í†µê³„ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
    }
  };

  const handleSafeReset = () => {
    if(confirm('í˜„ì¬ ê²Œì„ì„ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(ì €ì¥ëœ ìŠ¬ë¡¯ê³¼ ì„¤ì •ì€ ìœ ì§€ë©ë‹ˆë‹¤.)')) {
      hardReset(); 
      window.location.reload();
    }
  };

  // ê¸°ì¡´ í•¨ìˆ˜ë“¤ ìœ ì§€
  const handleExportMod = () => {
    const cleanHeroes = heroes.map(h => ({
      id: h.id, name: h.name, role: h.role, concept: h.concept, stats: h.stats, skills: h.skills
    }));
    const modData = {
      version: 2,
      heroes: cleanHeroes, items: shopItems,
      settings: { battle: gameState.battleSettings, field: gameState.fieldSettings, role: gameState.roleSettings, tier: gameState.tierConfig },
      images: gameState.customImages
    };
    const json = JSON.stringify(modData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = `GodsWar_Mod_${new Date().toISOString().slice(0,10)}.json`;
    a.click(); URL.revokeObjectURL(url);
  };

  const handleImportMod = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    if (!confirm('ì´ íŒŒì¼ì„ ì ìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) { e.target.value = ''; return; }
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const json = JSON.parse(ev.target?.result as string);
        if (json.heroes && json.settings) {
          loadModData(json);
          alert('âœ… MOD ë°ì´í„° ì ìš© ì™„ë£Œ!');
        } else alert('âŒ ì˜¬ë°”ë¥´ì§€ ì•Šì€ MOD íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤.');
      } catch (err) { console.error(err); alert('âŒ íŒŒì¼ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'); }
    };
    reader.readAsText(file); e.target.value = '';
  };

  const handleMapUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if(file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        if(typeof reader.result === 'string') {
          setCustomImage('map_bg', reader.result); 
          alert("âœ… ì „ì¥ ë§µ ìŠ¤í‚¨ì´ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤!");
        }
      };
      reader.readAsDataURL(file);
    }
    e.target.value = '';
  };

  const handleMapReset = () => {
    if(confirm("ë§µ ìŠ¤í‚¨ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë˜ëŒë¦¬ì‹œê² ìŠµë‹ˆê¹Œ?")) {
      removeCustomImage('map_bg');
    }
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '15px' }}>

      {/* 1. [ì‹ ê·œ] ë¦¬ì†ŒìŠ¤ ë‹¤ìš´ë¡œë“œ ì„¹ì…˜ */}
      <div style={{ background: '#161b22', padding: '15px', borderRadius: '8px', border: '1px solid #30363d' }}>
        <h4 style={{ margin:'0 0 10px 0', color:'#f1c40f', display:'flex', alignItems:'center', gap:'6px', fontSize:'14px' }}>
          <CloudLightning size={16}/> ê²Œì„ ë¦¬ì†ŒìŠ¤ ìµœì í™”
        </h4>
        <div style={{ fontSize: '11px', color: '#8b949e', marginBottom: '10px' }}>
          ì´ë¯¸ì§€ê°€ ëŠë¦¬ê²Œ ëœ¬ë‹¤ë©´ ë¦¬ì†ŒìŠ¤ë¥¼ ë¯¸ë¦¬ ë‹¤ìš´ë¡œë“œí•˜ì„¸ìš”.<br/>
          í˜„ì¬ ì €ì¥ëœ ë¦¬ì†ŒìŠ¤: <span style={{color:'#fff', fontWeight:'bold'}}>{cachedCount}ê°œ</span>
        </div>
        
        {isDownloading ? (
          <div style={{ background:'#0d1117', borderRadius:'6px', padding:'10px', border:'1px solid #30363d' }}>
            <div style={{ display:'flex', justifyContent:'space-between', marginBottom:'6px', fontSize:'12px', color:'#fff' }}>
              <span>Downloading...</span>
              <span>{progress.toFixed(0)}%</span>
            </div>
            <div style={{ width:'100%', height:'6px', background:'#333', borderRadius:'3px', overflow:'hidden' }}>
              <div style={{ width:`${progress}%`, height:'100%', background:'#f1c40f', transition:'width 0.1s' }}></div>
            </div>
          </div>
        ) : (
          <button 
            onClick={handleDownloadResources} 
            className="btn" 
            style={{ width:'100%', background: '#d29922', color: '#000', border:'none', fontSize:'13px', display:'flex', alignItems:'center', justifyContent:'center', gap:'6px', padding:'10px' }}
          >
            <Database size={16}/> ë¦¬ì†ŒìŠ¤ ì „ì²´ ë‹¤ìš´ë¡œë“œ (Fast Load)
          </button>
        )}
      </div>

      <div style={{ borderTop: '1px solid #333', margin: '5px 0' }}></div>

      {/* 2. ë§µ ìŠ¤í‚¨ ì„¤ì • */}
      <div style={{ background: '#161b22', padding: '15px', borderRadius: '8px', border: '1px solid #30363d' }}>
        <h4 style={{ margin:'0 0 10px 0', color:'#2ecc71', display:'flex', alignItems:'center', gap:'6px', fontSize:'14px' }}>
          <MapIcon size={16}/> ì „ì¥(Map) ìŠ¤í‚¨ ì„¤ì •
        </h4>
        <div style={{ fontSize: '11px', color: '#8b949e', marginBottom: '10px' }}>
          AIë¡œ ìƒì„±í•œ ë§µ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ë©´ ê´€ì „ ë°°ê²½ì— ì ìš©ë©ë‹ˆë‹¤.
        </div>
        <div style={{ display: 'flex', gap: '10px' }}>
          <button onClick={() => mapInputRef.current?.click()} className="btn" style={{ flex: 2, background: '#238636', color: '#fff', border:'none', fontSize:'12px', display:'flex', alignItems:'center', justifyContent:'center', gap:'6px' }}>
            <ImageIcon size={14}/> ë§µ ì´ë¯¸ì§€ ì—…ë¡œë“œ
          </button>
          <button onClick={handleMapReset} className="btn" style={{ flex: 1, background: '#3f1515', color: '#ff6b6b', border:'1px solid #5a1e1e', fontSize:'12px', display:'flex', alignItems:'center', justifyContent:'center', gap:'6px' }}>
            <Trash2 size={14}/> ì´ˆê¸°í™”
          </button>
          <input type="file" ref={mapInputRef} onChange={handleMapUpload} style={{ display: 'none' }} accept="image/*" />
        </div>
      </div>

      <div style={{ borderTop: '1px solid #333', margin: '5px 0' }}></div>

      {/* 3. AI ì„¤ì • */}
      <div style={{ background: '#161b22', padding: '15px', borderRadius: '8px', border: '1px solid #30363d' }}>
        <h4 style={{ margin:'0 0 15px 0', color:'#58a6ff', display:'flex', alignItems:'center', gap:'6px', fontSize:'14px' }}>
          <Bot size={16}/> ì»¤ë®¤ë‹ˆí‹° AI ì„¤ì •
        </h4>
        <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:'12px' }}>
          <span style={{ fontSize:'13px', color:'#fff' }}>AI ê¸€ì‘ì„± í™œì„±í™”</span>
          <input type="checkbox" checked={aiSettings.enabled} onChange={e => setAiSettings({...aiSettings, enabled: e.target.checked})} style={{ transform:'scale(1.2)', cursor:'pointer' }}/>
        </div>
        <div style={{ marginBottom:'12px' }}>
          <div style={{ fontSize:'11px', color:'#8b949e', marginBottom:'4px' }}>API Key</div>
          <input type="password" value={aiSettings.apiKey} onChange={e => setAiSettings({...aiSettings, apiKey: e.target.value})} placeholder="API í‚¤ ì…ë ¥..." style={{ width:'100%', padding:'8px', background:'#0d1117', border:'1px solid #30363d', color:'#fff', borderRadius:'4px', boxSizing:'border-box' }}/>
        </div>
        <button onClick={saveAISettings} className="btn" style={{ width:'100%', background:'#1f6feb', color:'#fff', display:'flex', justifyContent:'center', alignItems:'center', gap:'6px', padding:'10px' }}>
          <CheckCircle size={16}/> ì„¤ì • ì €ì¥
        </button>
      </div>

      <div style={{ borderTop: '1px solid #333', margin: '5px 0' }}></div>

      {/* 4. íŒŒì¼ ê´€ë¦¬ */}
      <h4 style={{ margin:'0 0 10px 0', color:'#ccc' }}>íŒŒì¼ ê´€ë¦¬</h4>
      <div style={{ display: 'flex', gap: '10px', marginBottom:'10px' }}>
        <button onClick={handleExportMod} className="btn" style={{ flex: 1, background: '#30363d', color: '#ccc', border:'1px solid #444', fontSize:'12px', display:'flex', alignItems:'center', justifyContent:'center', gap:'6px' }}>
          <Download size={14}/> MOD ë‚´ë³´ë‚´ê¸°
        </button>
        <button onClick={() => modInputRef.current?.click()} className="btn" style={{ flex: 1, background: '#30363d', color: '#ccc', border:'1px solid #444', fontSize:'12px', display:'flex', alignItems:'center', justifyContent:'center', gap:'6px' }}>
          <Upload size={14}/> MOD ì ìš©
        </button>
        <input type="file" ref={modInputRef} onChange={handleImportMod} style={{ display: 'none' }} accept=".json" />
      </div>
      <div style={{ display: 'flex', gap: '10px' }}>
        <button onClick={exportSaveFile} className="btn" style={{ flex:1, background: '#30363d', border:'1px solid #444', color: '#ccc', padding: '10px', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px', fontSize:'12px' }}>
          <Download size={14} /> ì„¸ì´ë¸Œ ë°±ì—…
        </button>
        <button onClick={() => fileInputRef.current?.click()} className="btn" style={{ flex:1, background: '#30363d', border:'1px solid #444', color: '#ccc', padding: '10px', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px', fontSize:'12px' }}>
          <Upload size={14} /> ì„¸ì´ë¸Œ ë³µêµ¬
        </button>
        <input type="file" ref={fileInputRef} onChange={async (e) => {
          const file = e.target.files?.[0];
          if(file && await importSaveFile(file, heroes)) { alert('ë¡œë“œ ì„±ê³µ!'); window.location.reload(); }
        }} style={{ display: 'none' }} accept=".json" />
      </div>

      <div style={{ borderTop: '1px solid #333', margin: '10px 0' }}></div>

      {/* 5. ì´ˆê¸°í™” */}
      <h4 style={{ margin:'0 0 10px 0', color:'#da3633' }}>ìœ„í—˜ êµ¬ì—­</h4>
      <div style={{ display:'flex', gap:'10px' }}>
        <button onClick={handleSafeReset} className="btn" style={{ flex:1, background: '#da3633', color: '#fff', display:'flex', alignItems:'center', justifyContent:'center', gap:'8px' }}>
          <Trash2 size={16} /> ê²Œì„ ì¬ì‹œì‘
        </button>
        <button onClick={handleStatReset} className="btn" style={{ flex:1, background: '#d29922', color: '#000', display:'flex', alignItems:'center', justifyContent:'center', gap:'8px', fontWeight:'bold' }}>
          <RefreshCw size={16} /> í†µê³„ ì´ˆê¸°í™”
        </button>
      </div>
    </div>
  );
};


--- FILE: src/components/system/SaveLoadTab.tsx ---
import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { saveToSlot, loadFromSlot, getSlotsMeta, deleteSlot, SaveMeta } from '../../engine/SaveLoadSystem';
import { Trash2, Clock, Calendar, Loader2 } from 'lucide-react';

interface Props {
  mode: 'SAVE' | 'LOAD'; 
}

export const SaveLoadTab: React.FC<Props> = ({ mode }) => {
  const { heroes } = useGameStore();
  const [slots, setSlots] = useState<Record<string, SaveMeta>>({});
  const [isProcessing, setIsProcessing] = useState(false);

  useEffect(() => {
    setSlots(getSlotsMeta());
  }, []);

  const refreshSlots = () => {
    setSlots(getSlotsMeta());
  };

  const handleSave = async (slotId: string) => {
    if (isProcessing) return;
    setIsProcessing(true);
    
    const success = await saveToSlot(slotId);
    if (success) {
      // [ìˆ˜ì •] ë°±í‹±ê³¼ ë³€ìˆ˜ ì•ì˜ ì—­ìŠ¬ë˜ì‹œ ì œê±° (ì˜¬ë°”ë¥¸ JS ë¬¸ë²•)
      alert(`${slotId === 'auto' ? 'ìë™ ì €ì¥' : `ìŠ¬ë¡¯ ${slotId}`}ì— ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);
      refreshSlots();
    }
    setIsProcessing(false);
  };

  const handleLoad = async (slotId: string) => {
    if (isProcessing) return;
    if (!slots[slotId]) return;

    // [ìˆ˜ì •] ë°±í‹±ê³¼ ë³€ìˆ˜ ì•ì˜ ì—­ìŠ¬ë˜ì‹œ ì œê±°
    if (confirm(`[Slot ${slotId}] ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
      setIsProcessing(true);
      
      const success = await loadFromSlot(slotId, heroes);
      
      // ë¡œë“œ ì„±ê³µ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ í”„ë¡œì„¸ì‹± ìƒíƒœ í•´ì œ (í™”ë©´ì€ ì—”ì§„ì´ ì´ë¯¸ ê°±ì‹ í•¨)
      setIsProcessing(false);
    }
  };

  const handleDelete = async (e: React.MouseEvent, slotId: string) => {
    e.stopPropagation();
    if (confirm('ì´ ìŠ¬ë¡¯ì˜ ë°ì´í„°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
      await deleteSlot(slotId);
      refreshSlots();
    }
  };

  const SlotItem = ({ id, label, isAuto = false }: { id: string, label: string, isAuto?: boolean }) => {
    const meta = slots[id];
    const isEmpty = !meta;

    return (
      <div 
        onClick={() => mode === 'SAVE' ? handleSave(id) : handleLoad(id)}
        style={{ 
          background: isEmpty ? '#222' : '#2a2a2e', 
          border: '1px solid #444', 
          borderRadius: '8px', 
          padding: '15px', 
          marginBottom: '10px',
          cursor: isProcessing ? 'wait' : 'pointer',
          display: 'flex', justifyContent: 'space-between', alignItems: 'center',
          transition: '0.2s',
          opacity: (mode === 'LOAD' && isEmpty) || isProcessing ? 0.5 : 1,
          pointerEvents: (mode === 'LOAD' && isEmpty) || isProcessing ? 'none' : 'auto'
        }}
        onMouseEnter={e => e.currentTarget.style.borderColor = '#58a6ff'}
        onMouseLeave={e => e.currentTarget.style.borderColor = '#444'}
      >
        <div style={{ display: 'flex', alignItems: 'center', gap: '15px' }}>
          <div style={{ 
            width: '40px', height: '40px', borderRadius: '50%', 
            background: isAuto ? '#e89d40' : '#58a6ff', color: '#000',
            display: 'flex', alignItems: 'center', justifyContent: 'center', fontWeight: 'bold' 
          }}>
            {isAuto ? 'A' : id}
          </div>
          <div>
            <div style={{ fontWeight: 'bold', color: isEmpty ? '#777' : '#fff', fontSize: '14px', marginBottom:'4px' }}>
              {label}
            </div>
            {isEmpty ? (
              <div style={{ fontSize: '12px', color: '#555' }}>ë¹„ì–´ ìˆìŒ</div>
            ) : (
              <div style={{ display:'flex', flexDirection:'column', gap:'2px' }}>
                <div style={{ fontSize: '12px', color: '#e89d40', fontWeight:'bold', display:'flex', alignItems:'center', gap:'4px' }}>
                   {/* [ìˆ˜ì •] ì—¬ê¸°ë„ ì—­ìŠ¬ë˜ì‹œ ì œê±° */}
                   <Clock size={12}/> {meta.gameTimeDisplay || `S${meta.season} Day${meta.day}`}
                </div>
                <div style={{ fontSize: '11px', color: '#888', display:'flex', alignItems:'center', gap:'4px' }}>
                   <Calendar size={11}/> {meta.realDateStr || new Date(meta.timestamp).toLocaleString()}
                </div>
                <div style={{ fontSize:'11px', color:'#666' }}>ìœ ì € {meta.totalUsers.toLocaleString()}ëª…</div>
              </div>
            )}
          </div>
        </div>

        <div style={{ display:'flex', gap:'10px', alignItems:'center' }}>
            {isProcessing ? <Loader2 size={16} className="animate-spin text-white"/> : (
              <>
                {mode === 'SAVE' && (
                    <div style={{ fontSize:'12px', color:'#58a6ff', fontWeight:'bold' }}>
                        {isEmpty ? 'ì €ì¥í•˜ê¸°' : 'ë®ì–´ì“°ê¸°'}
                    </div>
                )}
                {!isEmpty && mode === 'SAVE' && (
                    <button onClick={(e) => handleDelete(e, id)} style={{ background:'none', border:'none', color:'#da3633', cursor:'pointer' }}>
                        <Trash2 size={16} />
                    </button>
                )}
              </>
            )}
        </div>
      </div>
    );
  };

  return (
    <>
      <div style={{ fontSize:'12px', color:'#888', marginBottom:'15px', textAlign:'center' }}>
        {mode === 'SAVE' ? 'ìŠ¬ë¡¯ì„ ì„ íƒí•˜ì—¬ ì €ì¥í•˜ì„¸ìš”.' : 'ë¶ˆëŸ¬ì˜¬ ìŠ¬ë¡¯ì„ ì„ íƒí•˜ì„¸ìš”.'}
      </div>

      <SlotItem id="auto" label="ìë™ ì €ì¥ ìŠ¬ë¡¯ (Auto)" isAuto />
      <div style={{ height:'10px' }}></div>
      <SlotItem id="1" label="ì €ì¥ ìŠ¬ë¡¯ 1" />
      <SlotItem id="2" label="ì €ì¥ ìŠ¬ë¡¯ 2" />
      <SlotItem id="3" label="ì €ì¥ ìŠ¬ë¡¯ 3" />
      
      <style>{`
        .animate-spin { animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
      `}</style>
    </>
  );
};


--- FILE: src/components/user/TierSettingsModal.tsx ---
// ==========================================
// FILE PATH: /src/components/user/TierSettingsModal.tsx
// ==========================================

import React, { useState } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { X, Save, Settings, Trophy, Swords } from 'lucide-react';
import { TierConfig } from '../../types';

export const TierSettingsModal = ({ onClose }: { onClose: () => void }) => {
  const { gameState, updateTierConfig } = useGameStore();

  // [ìˆ˜ì •] ê¸°ì¡´ ì„¸ì´ë¸Œ íŒŒì¼ í˜¸í™˜ì„± ì²˜ë¦¬ (promosê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì£¼ì…)
  const [config, setConfig] = useState<TierConfig>(() => {
    const current = gameState.tierConfig;
    // ë§Œì•½ promos ê°ì²´ê°€ ì—†ë‹¤ë©´(êµ¬ë²„ì „ ë°ì´í„°ë¼ë©´) ê¸°ë³¸ê°’ìœ¼ë¡œ ì´ˆê¸°í™”
    if (!current.promos) {
      return {
        ...current,
        promos: {
          master: 5,
          ace: 5,
          joker: 5,
          gold: 3,
          silver: 3,
          bronze: 3
        }
      };
    }
    return current;
  });

  const handleSave = () => {
    updateTierConfig(config);
    alert('í‹°ì–´ ì‹œìŠ¤í…œ ì„¤ì •ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.\në‹¤ìŒ ìŠ¹ê¸‰ì „ë¶€í„° ì ìš©ë©ë‹ˆë‹¤.');
    onClose();
  };

  const handlePromoChange = (tier: keyof TierConfig['promos'], value: number) => {
    setConfig(prev => ({
      ...prev,
      promos: { ...prev.promos, [tier]: value }
    }));
  };

  // í‹°ì–´ë³„ ì„¤ì • í–‰ ì»´í¬ë„ŒíŠ¸
  const TierRow = ({ label, keyName, color, promoKey }: { label: string, keyName: keyof TierConfig, color: string, promoKey: keyof TierConfig['promos'] }) => (
    <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:'12px', background:'#252528', padding:'10px', borderRadius:'8px', border:'1px solid #333' }}>

      {/* ì™¼ìª½: í‹°ì–´ ì´ë¦„ ë° ì»¤íŠ¸ë¼ì¸ */}
      <div style={{ display:'flex', alignItems:'center', gap:'15px' }}>
        <div style={{ display:'flex', alignItems:'center', gap:'10px', width:'100px' }}>
          <div style={{ width:'12px', height:'12px', borderRadius:'50%', background:color }}></div>
          <span style={{ color: color, fontWeight:'bold', fontSize:'14px' }}>{label}</span>
        </div>
        <div style={{ display:'flex', alignItems:'center', gap:'6px' }}>
          <input 
            type="number" 
            value={config[keyName] as number} 
            onChange={(e) => setConfig({ ...config, [keyName]: parseInt(e.target.value) })}
            style={{ background:'#0d1117', border:'1px solid #444', color:'#fff', padding:'6px', borderRadius:'4px', width:'70px', textAlign:'right', fontWeight:'bold' }}
          />
          <span style={{ fontSize:'12px', color:'#888' }}>LP</span>
        </div>
      </div>

      {/* ì˜¤ë¥¸ìª½: ìŠ¹ê¸‰ì „ íŒìˆ˜ ì„ íƒ */}
      <div style={{ display:'flex', alignItems:'center', gap:'8px' }}>
        <Swords size={14} color="#666" />
        <select 
          value={config.promos ? config.promos[promoKey] : 3} // ì•ˆì „í•˜ê²Œ ì ‘ê·¼
          onChange={(e) => handlePromoChange(promoKey, parseInt(e.target.value))}
          style={{ background:'#0d1117', border:'1px solid #444', color:'#ccc', padding:'4px 8px', borderRadius:'4px', fontSize:'12px', cursor:'pointer' }}
        >
          <option value={3}>3ì „ 2ì„ ìŠ¹</option>
          <option value={5}>5ì „ 3ì„ ìŠ¹</option>
          <option value={7}>7ì „ 4ì„ ìŠ¹</option>
          <option value={9}>9ì „ 5ì„ ìŠ¹</option>
        </select>
      </div>
    </div>
  );

  return (
    <div style={{ position:'fixed', top:0, left:0, width:'100%', height:'100%', background:'rgba(0,0,0,0.85)', display:'flex', justifyContent:'center', alignItems:'center', zIndex:2000, backdropFilter:'blur(5px)' }}>
      <div className="panel" style={{ width:'500px', background:'#161b22', border:'1px solid #30363d', borderRadius:'12px', padding:0, overflow:'hidden', boxShadow:'0 20px 50px rgba(0,0,0,0.5)' }}>

        {/* í—¤ë” */}
        <div style={{ padding:'20px', background:'#21262d', borderBottom:'1px solid #333', display:'flex', justifyContent:'space-between', alignItems:'center' }}>
          <h3 style={{ margin:0, display:'flex', alignItems:'center', gap:'10px', color:'#fff', fontSize:'16px' }}>
            <Settings size={18} /> ë­í¬ ì‹œìŠ¤í…œ ì„¤ì •
          </h3>
          <button onClick={onClose} style={{ background:'none', border:'none', color:'#888', cursor:'pointer' }}><X size={20}/></button>
        </div>

        <div style={{ padding:'20px' }}>

          {/* 1. ì±Œë¦°ì € ì„¤ì • */}
          <div style={{ marginBottom:'20px', paddingBottom:'15px', borderBottom:'1px dashed #333' }}>
            <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center' }}>
              <div style={{ display:'flex', alignItems:'center', gap:'10px' }}>
                <Trophy size={16} color="#00bfff" />
                <span style={{ color:'#00bfff', fontWeight:'bold' }}>ì±Œë¦°ì € ì •ì› (Ranking)</span>
              </div>
              <div style={{ display:'flex', alignItems:'center', gap:'6px' }}>
                <span style={{ fontSize:'12px', color:'#888' }}>ìƒìœ„</span>
                <input 
                  type="number" 
                  value={config.challengerRank} 
                  onChange={(e) => setConfig({ ...config, challengerRank: parseInt(e.target.value) })}
                  style={{ background:'#00bfff22', border:'1px solid #00bfff', color:'#fff', padding:'6px', borderRadius:'4px', width:'60px', textAlign:'center', fontWeight:'bold' }}
                />
                <span style={{ fontSize:'12px', color:'#888' }}>ìœ„</span>
              </div>
            </div>
            <div style={{ fontSize:'11px', color:'#666', marginTop:'8px', marginLeft:'26px' }}>
              * ë§ˆìŠ¤í„° í‹°ì–´ ì ìˆ˜ë¥¼ ë„˜ê¸´ ìœ ì € ì¤‘, ì„¤ì •ëœ ë“±ìˆ˜ ì•ˆì— ë“¤ì–´ì•¼ ì±Œë¦°ì €ê°€ ë©ë‹ˆë‹¤.
            </div>
          </div>

          {/* 2. í‹°ì–´ë³„ ì»¤íŠ¸ë¼ì¸ ë° ìŠ¹ê¸‰ì „ ì„¤ì • */}
          <div style={{ display:'flex', flexDirection:'column', gap:'5px', maxHeight:'400px', overflowY:'auto' }}>
            {config.promos && (
              <>
                <TierRow label="ë§ˆìŠ¤í„°" keyName="master" color="#9b59b6" promoKey="master" />
                <TierRow label="ì—ì´ìŠ¤" keyName="ace" color="#e74c3c" promoKey="ace" />
                <TierRow label="ì¡°ì»¤" keyName="joker" color="#2ecc71" promoKey="joker" />
                <TierRow label="ê³¨ë“œ" keyName="gold" color="#f1c40f" promoKey="gold" />
                <TierRow label="ì‹¤ë²„" keyName="silver" color="#95a5a6" promoKey="silver" />
                <TierRow label="ë¸Œë¡ ì¦ˆ" keyName="bronze" color="#d35400" promoKey="bronze" />
              </>
            )}
          </div>

        </div>

        <div style={{ padding:'20px', borderTop:'1px solid #333', background:'#21262d' }}>
          <button className="btn" style={{ width:'100%', background:'#238636', color:'#fff', display:'flex', justifyContent:'center', gap:'8px', padding:'12px', fontSize:'14px', borderRadius:'8px', border:'none', cursor:'pointer', fontWeight:'bold' }} onClick={handleSave}>
            <Save size={18} /> ì„¤ì • ì €ì¥í•˜ê¸°
          </button>
        </div>
      </div>
    </div>
  );
};

--- FILE: src/components/user/TierUserListModal.tsx ---
import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { getUsersInTier } from '../../engine/system/UserManager';
import { UserProfile } from '../../types';
import { X, Trophy } from 'lucide-react';

interface Props {
  tierName: string;
  onClose: () => void;
  onUserClick: (u: UserProfile) => void;
}

export const TierUserListModal: React.FC<Props> = ({ tierName, onClose, onUserClick }) => {
  const { gameState } = useGameStore();
  const [users, setUsers] = useState<UserProfile[]>([]);

  useEffect(() => {
    const fetchUsers = () => {
      // getUsersInTierëŠ” ì´ì œ ë‚´ë¶€ì ìœ¼ë¡œ í—¬í¼ë¥¼ ì“°ë¯€ë¡œ ì•ˆì „
      const list = getUsersInTier(tierName, gameState.tierConfig);
      setUsers(list);
    };
    fetchUsers();
    const interval = setInterval(fetchUsers, 1000); 
    return () => clearInterval(interval);
  }, [tierName, gameState.tierConfig]);

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) onClose();
  };

  const getRankStyle = (index: number) => {
    if (index === 0) return { color: '#FFD700' }; 
    if (index === 1) return { color: '#C0C0C0' }; 
    if (index === 2) return { color: '#CD7F32' };
    return { color: '#666' };
  };

  return (
    <div onClick={handleBackdropClick} style={{ position: 'fixed', top: 0, left: 0, width: '100%', height: '100%', background: 'rgba(0,0,0,0.85)', display: 'flex', justifyContent: 'center', alignItems: 'center', zIndex: 1500, backdropFilter: 'blur(5px)', padding: '15px' }}>
      <div className="panel" style={{ width: '100%', maxWidth: '450px', maxHeight: '80vh', background: '#161b22', border: '1px solid #30363d', display: 'flex', flexDirection: 'column', borderRadius: '16px', overflow: 'hidden', boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.5)' }}>
        <div style={{ padding: '16px 20px', background: '#0d1117', borderBottom: '1px solid #30363d', display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexShrink: 0 }}>
          <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
            <Trophy size={18} color="#e89d40" />
            <h3 style={{ margin: 0, fontSize: '16px', color: '#fff', fontWeight: 'bold' }}>{tierName} <span style={{ color:'#8b949e', fontSize:'13px', fontWeight:'normal' }}>TOP {users.length}</span></h3>
          </div>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#8b949e', cursor: 'pointer', padding:'4px' }}><X size={24} /></button>
        </div>
        <div style={{ flex: 1, overflowY: 'auto', background: '#161b22' }}>
          {users.map((u, i) => {
            const rankStyle = getRankStyle(i);
            const isTop3 = i < 3;
            const bgStyle = isTop3 ? `rgba(255, 215, 0, ${0.05 - (i * 0.015)})` : 'transparent';
            return (
              <div key={u.id} onClick={() => onUserClick(u)} style={{ display: 'flex', alignItems: 'center', padding: '12px 16px', borderBottom: '1px solid #21262d', cursor: 'pointer', background: bgStyle }}>
                <div style={{ width: '40px', textAlign: 'center', fontSize: isTop3 ? '18px' : '14px', fontWeight: '900', fontStyle: 'italic', color: rankStyle.color, marginRight: '12px' }}>{i + 1}</div>
                <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '2px' }}>
                  <div style={{ color: '#fff', fontWeight: 'bold', fontSize: '14px' }}>{u.name}</div>
                  <div style={{ fontSize: '12px', color: '#8b949e', display: 'flex', alignItems: 'center', gap: '4px' }}>
                    <span style={{ color: '#e89d40', fontWeight:'bold' }}>{u.score} LP</span>
                    <span style={{ width: '3px', height: '3px', background: '#444', borderRadius: '50%' }}></span>
                    <span>Lv.{Math.floor(u.totalGames / 10) + 1}</span>
                  </div>
                </div>
                <div style={{ textAlign: 'right' }}>
                  <div style={{ fontSize: '14px', fontWeight: 'bold', color: u.winRate >= 60 ? '#ff4d4d' : u.winRate >= 50 ? '#3fb950' : '#8b949e' }}>{u.winRate.toFixed(1)}%</div>
                  <div style={{ fontSize: '11px', color: '#666' }}>{u.totalGames}ì „</div>
                </div>
              </div>
            );
          })}
          {users.length === 0 && <div style={{ padding: '40px 20px', textAlign: 'center', color: '#555', fontSize: '14px' }}>ì´ í‹°ì–´ì— ë°°ì¹˜ëœ ìœ ì €ê°€ ì—†ìŠµë‹ˆë‹¤.</div>}
        </div>
      </div>
    </div>
  );
};


--- FILE: src/components/user/UserDashboard.tsx ---
import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { UserProfile } from '../../types';
import { Clock, Settings, ChevronRight } from 'lucide-react';
import { TierSettingsModal } from './TierSettingsModal';
import { TierUserListModal } from './TierUserListModal';

interface Props { onUserClick: (u: UserProfile) => void; }

export const UserDashboard: React.FC<Props> = ({ onUserClick }) => {
  const { gameState, heroes } = useGameStore();
  const { userStatus, topRankers } = gameState;
  const [showSettings, setShowSettings] = useState(false);
  const [selectedTier, setSelectedTier] = useState<string | null>(null);

  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const getHeroName = (id: string) => {
    const hero = heroes.find(h => h.id === id);
    return hero ? hero.name : id;
  };

  if (!userStatus) return <div>ë°ì´í„° ë¡œë”© ì¤‘...</div>;

  return (
    <div style={{ display: 'grid', gridTemplateColumns: isMobile ? '1fr' : '1fr 1fr', gap: '20px' }}>
      <div style={{ display: 'flex', flexDirection: 'column', gap: '20px' }}>
        <div className="panel">
          <h3 style={{ margin: '0 0 15px 0', borderBottom: '1px solid #333', paddingBottom: '10px', fontSize:'16px' }}>ğŸ“¡ ì‹¤ì‹œê°„ ë§¤ì¹­ í˜„í™©</h3>
          <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '20px' }}>
            <div style={{ textAlign: 'center', flex: 1, borderRight: '1px solid #333' }}>
              <div style={{ fontSize: '12px', color: '#8b949e' }}>ê²Œì„ ì¤‘ (Ingame)</div>
              <div style={{ fontSize: '24px', fontWeight: 'bold', color: '#3fb950' }}>{userStatus.playingUsers.toLocaleString()}</div>
            </div>
            <div style={{ textAlign: 'center', flex: 1 }}>
              <div style={{ fontSize: '12px', color: '#8b949e' }}>ë§¤ì¹­ ëŒ€ê¸° (Queue)</div>
              <div style={{ fontSize: '24px', fontWeight: 'bold', color: '#d29922' }}>{userStatus.queuingUsers.toLocaleString()}</div>
            </div>
          </div>
          <div style={{ background: '#0d1117', padding: '15px', borderRadius: '8px', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '10px' }}>
            <Clock size={16} color="#58a6ff" />
            <span style={{ color: '#8b949e', fontSize: '13px' }}>í‰ê·  ë§¤ì¹­ ì‹œê°„:</span>
            <span style={{ fontWeight: 'bold', color: '#fff' }}>{userStatus.avgWaitTime}ì´ˆ</span>
          </div>
        </div>

        <div className="panel">
          <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', borderBottom: '1px solid #333', paddingBottom: '10px', marginBottom: '15px' }}>
            <h3 style={{ margin: 0, fontSize:'16px' }}>ğŸ† í‹°ì–´ë³„ ì¸êµ¬ ë¶„í¬</h3>
            <button onClick={() => setShowSettings(true)} style={{ background:'none', border:'none', color:'#8b949e', cursor:'pointer', display:'flex', alignItems:'center', gap:'5px', fontSize:'12px' }}>
              <Settings size={14}/> ì„¤ì •
            </button>
          </div>

          <div style={{ display:'flex', flexDirection:'column', gap:'8px' }}>
            {userStatus.tierDistribution.map((tier) => (
              <div key={tier.name} onClick={() => setSelectedTier(tier.name)} style={{ cursor:'pointer', padding:'8px', borderRadius:'6px', background:'#0d1117', transition:'0.2s', display:'flex', alignItems:'center', justifyContent:'space-between' }}>
                <div style={{ display:'flex', alignItems:'center', gap:'10px', width: isMobile ? '80px' : '120px' }}>
                  <div style={{ width:'8px', height:'8px', borderRadius:'50%', background:tier.color }}></div>
                  <span style={{ fontWeight:'bold', color:tier.color, fontSize:'13px' }}>{tier.name}</span>
                </div>
                <div style={{ flex:1, height:'6px', background:'#333', borderRadius:'3px', margin:'0 15px' }}>
                  <div style={{ width:`${tier.percent}%`, height:'100%', background:tier.color, borderRadius:'3px', minWidth:'2px' }}></div>
                </div>
                <div style={{ textAlign:'right', width: isMobile ? '80px' : '100px' }}>
                  <span style={{ fontWeight:'bold', display:'block', fontSize:'13px' }}>{tier.count.toLocaleString()}</span>
                  <span style={{ fontSize:'10px', color:'#666' }}>{tier.percent.toFixed(1)}%</span>
                </div>
                {!isMobile && <ChevronRight size={14} color="#555" />}
              </div>
            ))}
          </div>
        </div>
      </div>

      <div className="panel">
        <h3 style={{ margin: '0 0 15px 0', borderBottom: '1px solid #333', paddingBottom: '10px', display: 'flex', justifyContent: 'space-between', fontSize:'16px' }}>
          <span>ğŸ¥‡ ìƒìœ„ ë­ì»¤ (Top 50)</span>
          <span style={{ fontSize: '12px', color: '#8b949e' }}>ì‹¤ì‹œê°„</span>
        </h3>

        <div style={{ height: '600px', overflowY: 'auto' }}>
          {isMobile ? (
            <div style={{ display:'flex', flexDirection:'column', gap:'10px' }}>
              {topRankers.map((user, idx) => (
                <div key={user.id} onClick={() => onUserClick(user)} style={{ background:'#0d1117', padding:'10px', borderRadius:'6px', border:'1px solid #333', display:'flex', alignItems:'center', gap:'10px' }}>
                  <div style={{ fontSize:'16px', fontWeight:'bold', color: idx < 3 ? '#e74c3c' : '#777', width:'24px', textAlign:'center' }}>{idx + 1}</div>
                  <div style={{ flex:1 }}>
                    <div style={{ fontWeight:'bold', color:'#fff', fontSize:'14px' }}>{user.name}</div>
                    <div style={{ fontSize:'12px', color:'#888' }}>
                      <span style={{ color: user.tier === 'ì²œìƒê³„' ? '#00bfff' : '#fff' }}>{user.tier}</span> ({user.score}LP)
                    </div>
                  </div>
                  <div style={{ textAlign:'right' }}>
                    <div style={{ fontSize:'12px', color:'#ddd', fontWeight:'bold' }}>{getHeroName(user.mainHeroId)}</div>
                    <div style={{ fontSize:'12px', color: user.winRate > 55 ? '#3fb950' : '#8b949e' }}>{user.winRate.toFixed(1)}%</div>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '13px' }}>
              <thead style={{ position: 'sticky', top: 0, background: '#161b22' }}>
                <tr style={{ color: '#8b949e', borderBottom: '1px solid #333', textAlign: 'left' }}>
                  <th style={{ padding: '8px', textAlign: 'center' }}>#</th>
                  <th>ì†Œí™˜ì‚¬ëª…</th>
                  <th>í‹°ì–´ (LP)</th>
                  <th>ëª¨ìŠ¤íŠ¸</th>
                  <th>ìŠ¹ë¥ </th>
                  <th>ìµœê·¼ 5ì „</th>
                </tr>
              </thead>
              <tbody>
                {topRankers.map((user, idx) => (
                  <tr key={user.id} style={{ borderBottom: '1px solid #222', height: '40px', cursor:'pointer' }} onClick={() => onUserClick(user)}>
                    <td style={{ textAlign: 'center', fontWeight: 'bold', color: idx < 3 ? '#e74c3c' : '#fff' }}>{idx + 1}</td>
                    <td style={{ fontWeight: 'bold', color: '#fff' }}>{user.name}</td>
                    <td>
                      <span style={{ color: user.tier === 'ì²œìƒê³„' ? '#00bfff' : user.tier === 'ë§ˆìŠ¤í„°' ? '#9b59b6' : '#fff' }}>{user.tier}</span>
                      <span style={{ fontSize: '11px', color: '#777', marginLeft: '4px' }}>({user.score}LP)</span>
                    </td>
                    <td style={{ color: '#ddd', fontWeight:'bold' }}>{getHeroName(user.mainHeroId)}</td>
                    <td style={{ color: user.winRate > 55 ? '#3fb950' : '#8b949e' }}>{user.winRate.toFixed(1)}%</td>
                    <td>
                      <div style={{ display: 'flex', gap: '2px' }}>
                        {user.history.slice(0, 5).map((h, i) => (
                          <div key={i} style={{ width: '16px', height: '16px', borderRadius: '2px', background: h.result === 'WIN' ? '#3fb950' : '#da3633', fontSize: '10px', color: 'white', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                            {h.result === 'WIN' ? 'W' : 'L'}
                          </div>
                        ))}
                      </div>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          )}
        </div>
      </div>
      {showSettings && <TierSettingsModal onClose={() => setShowSettings(false)} />}
      {selectedTier && <TierUserListModal tierName={selectedTier} onClose={() => setSelectedTier(null)} onUserClick={(u) => { onUserClick(u); setSelectedTier(null); }} />}
    </div>
  );
};


--- FILE: src/components/user/UserDetailModal.tsx ---
// ==========================================
// FILE PATH: /src/components/user/UserDetailModal.tsx
// ==========================================

import React, { useState, useEffect } from 'react';
import { UserProfile } from '../../types';
import { useGameStore } from '../../store/useGameStore';

// ë¶„ë¦¬ëœ ëª¨ë“ˆ ì„í¬íŠ¸
import { ProfileHeader } from './detail/ProfileHeader';
import { StatsOverview } from './detail/StatsOverview';
import { MatchHistoryList } from './detail/MatchHistoryList';

interface Props { user: UserProfile; onClose: () => void; }

export const UserDetailModal: React.FC<Props> = ({ user, onClose }) => {
  const { heroes, gameState } = useGameStore();
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // ë°°ê²½ ì´ë¯¸ì§€ìš© (ì˜ì›… ID ê¸°ë°˜)
  const heroImage = gameState.customImages?.[`${user.mainHeroId}_bg`] || gameState.customImages?.[user.mainHeroId];

  return (
    <div style={{ 
      position: 'fixed', inset: 0, zIndex: 9999, 
      backgroundColor: 'rgba(0,0,0,0.85)', backdropFilter: 'blur(5px)',
      display: 'flex', justifyContent: 'center', alignItems: isMobile ? 'flex-end' : 'center',
      padding: isMobile ? 0 : '20px'
    }}>
      <div className="panel-content" style={{ 
        width: '100%', maxWidth: '900px', 
        height: isMobile ? '90vh' : '85vh',
        background: '#0d1117', border: '1px solid #30363d', borderRadius: isMobile ? '16px 16px 0 0' : '16px',
        display: 'flex', flexDirection: 'column', overflow: 'hidden',
        boxShadow: '0 50px 100px -20px rgba(0,0,0,0.8)'
      }}>
        
        {/* 1. ìƒë‹¨ í—¤ë” ëª¨ë“ˆ */}
        <ProfileHeader user={user} onClose={onClose} heroImage={heroImage} />

        {/* 2. ë©”ì¸ ì»¨í…ì¸  (ìŠ¤í¬ë¡¤ ì˜ì—­) */}
        <div style={{ flex: 1, overflowY: 'auto', padding: isMobile ? '15px' : '25px', display: 'flex', flexDirection: isMobile ? 'column' : 'row', gap: '25px' }}>
          
          {/* ì¢Œì¸¡: ë¶„ì„ ë° ìŠ¤íƒ¯ */}
          <div style={{ flex: 1, minWidth: isMobile ? '100%' : '300px', display:'flex', flexDirection:'column', gap:'20px' }}>
            <StatsOverview user={user} />
            
            {/* ì„ í˜¸ í¬ì§€ì…˜ (ê°„ë‹¨ í‘œì‹œ) */}
            <div style={{ background: '#161b22', padding: '15px', borderRadius: '12px', border: '1px solid #30363d', display:'flex', alignItems:'center', justifyContent:'space-between' }}>
              <span style={{ fontSize:'12px', color:'#888', fontWeight:'bold' }}>ì„ í˜¸ í¬ì§€ì…˜</span>
              <span style={{ fontSize:'14px', color:'#fff', fontWeight:'900' }}>{user.preferredLane}</span>
            </div>
          </div>

          {/* ìš°ì¸¡: ì±”í”¼ì–¸ ë° ì „ì  */}
          <div style={{ flex: 1.5, minWidth: isMobile ? '100%' : '400px' }}>
            <MatchHistoryList user={user} heroes={heroes} />
          </div>

        </div>
      </div>
    </div>
  );
};


--- FILE: src/components/user/detail/MatchHistoryList.tsx ---
import React from 'react';
import { UserProfile } from '../../../types';
import { GameIcon } from '../../common/GameIcon';
import { Trophy, Skull, Crosshair } from 'lucide-react';

interface Props { user: UserProfile; heroes: any[]; }

export const MatchHistoryList: React.FC<Props> = ({ user, heroes }) => {
  const champStats = Object.entries(user.heroStats || {})
    .map(([id, stat]) => ({ id, hero: heroes.find(h => h.id === id), stat }))
    .sort((a, b) => b.stat.matches - a.stat.matches)
    .slice(0, 3);

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '20px' }}>
      
      {/* ëª¨ìŠ¤íŠ¸ ì±”í”¼ì–¸ ì¹´ë“œ */}
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '10px' }}>
        {champStats.map((item, idx) => {
          const wr = item.stat.matches > 0 ? (item.stat.wins / item.stat.matches) * 100 : 0;
          return (
            <div key={idx} style={{ background: '#1c1c1f', borderRadius: '12px', padding: '12px', border: '1px solid #30363d', display:'flex', flexDirection:'column', alignItems:'center', gap:'8px' }}>
              <div style={{ position:'relative' }}>
                <GameIcon id={item.id} size={48} shape="rounded" />
                <div style={{ position:'absolute', bottom:-5, right:-5, background:'#0d1117', border:'1px solid #333', borderRadius:'50%', width:'20px', height:'20px', display:'flex', alignItems:'center', justifyContent:'center', fontSize:'10px', fontWeight:'bold', color: idx===0?'#f1c40f':'#ccc' }}>
                  {idx+1}
                </div>
              </div>
              <div style={{ textAlign:'center' }}>
                <div style={{ fontSize:'12px', fontWeight:'bold', color:'#fff' }}>{item.hero?.name}</div>
                <div style={{ fontSize:'10px', color:'#888' }}>{item.stat.matches}ì „</div>
                <div style={{ fontSize:'12px', fontWeight:'900', color: wr >= 60 ? '#da3633' : wr >= 50 ? '#fff' : '#888' }}>{wr.toFixed(0)}%</div>
              </div>
            </div>
          );
        })}
        {champStats.length === 0 && <div style={{ gridColumn: '1/-1', textAlign:'center', padding:'20px', color:'#555', fontSize:'13px' }}>í”Œë ˆì´ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>}
      </div>

      {/* ìµœê·¼ ì „ì  ë¦¬ìŠ¤íŠ¸ */}
      <div>
        <h4 style={{ margin: '0 0 10px 0', fontSize: '13px', color: '#ccc' }}>ìµœê·¼ ì „ì  (Recent Matches)</h4>
        <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
          {user.history.map((match, idx) => {
            const isWin = match.result === 'WIN' || match.result === 'PROMO WIN';
            const bgColor = isWin ? 'rgba(46, 204, 113, 0.1)' : 'rgba(231, 76, 60, 0.1)';
            const barColor = isWin ? '#2ecc71' : '#e74c3c';
            
            return (
              <div key={idx} style={{ display: 'flex', background: bgColor, borderRadius: '6px', overflow: 'hidden', height: '56px' }}>
                <div style={{ width: '6px', background: barColor }} />
                <div style={{ flex: 1, padding: '0 12px', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                  
                  {/* ì™¼ìª½: ê²°ê³¼ & ì˜ì›… */}
                  <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                    <div style={{ display:'flex', flexDirection:'column' }}>
                      <span style={{ fontSize: '13px', fontWeight: '900', color: barColor }}>{isWin ? 'ìŠ¹ë¦¬' : 'íŒ¨ë°°'}</span>
                      <span style={{ fontSize: '10px', color: '#aaa' }}>{match.date.split(' ')[1]}</span>
                    </div>
                    {/* ì˜ì›… ì´ë¦„ (ì¶”í›„ ì•„ì´ì½˜ìœ¼ë¡œ ëŒ€ì²´ ê°€ëŠ¥) */}
                    <div style={{ fontSize: '13px', fontWeight: 'bold', color: '#fff' }}>{match.heroName}</div>
                  </div>

                  {/* ì˜¤ë¥¸ìª½: KDA & LP */}
                  <div style={{ textAlign: 'right' }}>
                    <div style={{ fontSize: '14px', fontWeight: 'bold', color: '#fff', fontFamily:'monospace' }}>{match.kda}</div>
                    <div style={{ fontSize: '11px', fontWeight: 'bold', color: match.lpChange > 0 ? '#f1c40f' : '#888' }}>
                      {match.lpChange > 0 ? `+${match.lpChange}` : match.lpChange} LP
                    </div>
                  </div>

                </div>
              </div>
            );
          })}
          {user.history.length === 0 && <div style={{ textAlign:'center', padding:'30px', color:'#555', fontSize:'12px' }}>ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>}
        </div>
      </div>

    </div>
  );
};


--- FILE: src/components/user/detail/ProfileHeader.tsx ---
import React from 'react';
import { UserProfile } from '../../../types';
import { X, Award, Hash } from 'lucide-react';
import { GameIcon } from '../../common/GameIcon';

interface Props {
  user: UserProfile;
  onClose: () => void;
  heroImage?: string; // ë°°ê²½ìš© ì´ë¯¸ì§€ URL
}

const getTierColor = (tier: string) => {
  if (tier.includes('ì±Œë¦°ì €') || tier.includes('ì²œìƒê³„')) return '#00bfff';
  if (tier.includes('ë§ˆìŠ¤í„°')) return '#9b59b6';
  if (tier.includes('ì—ì´ìŠ¤')) return '#e74c3c';
  if (tier.includes('ì¡°ì»¤')) return '#2ecc71';
  if (tier.includes('ê³¨ë“œ')) return '#f1c40f';
  if (tier.includes('ì‹¤ë²„')) return '#95a5a6';
  return '#cd7f32'; // ë¸Œë¡ ì¦ˆ
};

export const ProfileHeader: React.FC<Props> = ({ user, onClose, heroImage }) => {
  const tierColor = getTierColor(user.tier);
  const level = Math.floor(user.totalGames / 10) + 1;

  return (
    <div style={{ 
      position: 'relative', 
      padding: '30px 25px', 
      overflow: 'hidden', 
      borderBottom: '1px solid #333',
      background: '#161b22'
    }}>
      {/* ë°°ê²½ ì´ë¯¸ì§€ (ì–´ë‘¡ê²Œ ì²˜ë¦¬) */}
      <div style={{
        position: 'absolute', inset: 0,
        backgroundImage: heroImage ? `url(${heroImage})` : 'none',
        backgroundSize: 'cover', backgroundPosition: 'center 20%',
        opacity: 0.25, filter: 'blur(2px)', zIndex: 0
      }} />
      
      {/* ê·¸ë¼ë°ì´ì…˜ ì˜¤ë²„ë ˆì´ */}
      <div style={{ position: 'absolute', inset: 0, background: 'linear-gradient(to right, #0d1117 10%, rgba(13,17,23,0.6) 100%)', zIndex: 1 }} />

      <div style={{ position: 'relative', zIndex: 10, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '20px' }}>
          
          {/* í”„ë¡œí•„ ì•„ì´ì½˜ */}
          <div style={{ position: 'relative' }}>
            <div style={{ 
              width: '80px', height: '80px', borderRadius: '24px', 
              background: '#0d1117', border: `3px solid ${tierColor}`, 
              overflow: 'hidden', boxShadow: `0 0 20px ${tierColor}44`
            }}>
              <GameIcon id={user.mainHeroId} size="100%" />
            </div>
            <div style={{ 
              position: 'absolute', bottom: -10, left: '50%', transform: 'translateX(-50%)',
              background: '#21262d', color: '#fff', fontSize: '11px', fontWeight: 'bold',
              padding: '2px 8px', borderRadius: '10px', border: '1px solid #444', whiteSpace: 'nowrap'
            }}>
              Lv.{level}
            </div>
          </div>

          {/* ìœ ì € ì •ë³´ í…ìŠ¤íŠ¸ */}
          <div>
            <h1 style={{ margin: 0, fontSize: '28px', color: '#fff', fontWeight: '900', letterSpacing: '-0.5px', textShadow: '0 2px 4px rgba(0,0,0,0.5)' }}>
              {user.name}
            </h1>
            <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginTop: '6px' }}>
              <span style={{ 
                color: tierColor, fontWeight: '800', fontSize: '14px', 
                display: 'flex', alignItems: 'center', gap: '4px',
                background: `${tierColor}11`, padding: '2px 8px', borderRadius: '4px', border: `1px solid ${tierColor}44`
              }}>
                <Award size={14}/> {user.tier}
              </span>
              <span style={{ color: '#8b949e', fontSize: '13px', fontWeight: 'bold' }}>
                {user.score.toLocaleString()} LP
              </span>
              <span style={{ color: '#444' }}>|</span>
              <span style={{ color: '#8b949e', fontSize: '13px' }}>
                ë­í‚¹ {user.rank > 0 ? `${user.rank}ìœ„` : 'Unranked'}
              </span>
            </div>
          </div>
        </div>

        <button onClick={onClose} style={{ 
          background: 'rgba(255,255,255,0.1)', border: 'none', color: '#fff', 
          width: '36px', height: '36px', borderRadius: '50%', 
          cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center',
          backdropFilter: 'blur(4px)'
        }}>
          <X size={20} />
        </button>
      </div>
    </div>
  );
};


--- FILE: src/components/user/detail/StatsOverview.tsx ---
import React from 'react';
import { UserProfile } from '../../../types';
import { TrendingUp, Target, Brain, Zap, Activity } from 'lucide-react';

interface Props { user: UserProfile; }

export const StatsOverview: React.FC<Props> = ({ user }) => {
  // ìŠ¤íƒ¯ ê³„ì‚° (0~100)
  const combat = Math.min(100, user.winRate + 40);
  const brain = user.brain || 50;
  const mechanics = user.mechanics || 50;
  const activity = Math.min(100, 50 + (user.activityBias * 100));
  const potential = Math.min(100, (user.hiddenMmr / 3000) * 100);

  const getBarColor = (val: number) => {
    if (val >= 80) return '#e74c3c'; // ìµœìƒìœ„ (ë¹¨ê°•)
    if (val >= 60) return '#f1c40f'; // ìƒìœ„ (ë…¸ë‘)
    if (val >= 40) return '#2ecc71'; // ì¤‘ìœ„ (ì´ˆë¡)
    return '#8b949e'; // í•˜ìœ„ (íšŒìƒ‰)
  };

  const StatBar = ({ label, value, icon }: any) => (
    <div style={{ marginBottom: '8px' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '11px', color: '#ccc', marginBottom: '2px' }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>{icon} {label}</div>
        <span style={{ fontWeight: 'bold', color: getBarColor(value) }}>{value.toFixed(0)}</span>
      </div>
      <div style={{ width: '100%', height: '6px', background: '#30363d', borderRadius: '3px', overflow: 'hidden' }}>
        <div style={{ width: `${value}%`, height: '100%', background: getBarColor(value), borderRadius: '3px' }} />
      </div>
    </div>
  );

  // ì„±í–¥ íƒœê·¸ ìƒì„±
  const tags = [];
  if (user.playStyle === 'HARDCORE') tags.push({ label: 'ğŸ”¥ íì¸', color: '#da3633' });
  if (user.playStyle === 'WORKER') tags.push({ label: 'ğŸ’¼ ì§ì¥ì¸', color: '#3498db' });
  if (user.playStyle === 'STUDENT') tags.push({ label: 'ğŸ“ ê¸‰ì‹', color: '#f1c40f' });
  if (user.playStyle === 'NIGHT_OWL') tags.push({ label: 'ğŸŒ™ ì˜¬ë¹¼ë¯¸', color: '#9b59b6' });
  
  if (user.winRate >= 55) tags.push({ label: 'ğŸ† ìŠ¹ë¦¬ì™•', color: '#e74c3c' });
  else if (user.winRate <= 45) tags.push({ label: 'ğŸ“‰ ì—°íŒ¨ì¤‘', color: '#7f8c8d' });

  if (brain > 70) tags.push({ label: 'ğŸ§  ë‡Œì§€ì»¬', color: '#2ecc71' });
  if (mechanics > 70) tags.push({ label: 'âš¡ í”¼ì§€ì»¬', color: '#e67e22' });

  return (
    <div style={{ background: '#1c1c1f', borderRadius: '12px', padding: '20px', border: '1px solid #30363d' }}>
      <h3 style={{ margin: '0 0 15px 0', fontSize: '14px', color: '#fff', display: 'flex', alignItems: 'center', gap: '6px' }}>
        <Activity size={16} color="#58a6ff"/> í”Œë ˆì´ì–´ ë¶„ì„
      </h3>

      <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px', marginBottom: '20px' }}>
        {tags.map((t, i) => (
          <span key={i} style={{ fontSize: '11px', color: t.color, border: `1px solid ${t.color}44`, background: `${t.color}11`, padding: '2px 8px', borderRadius: '10px', fontWeight: 'bold' }}>
            {t.label}
          </span>
        ))}
      </div>

      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '15px' }}>
        <StatBar label="ì „íˆ¬ë ¥" value={combat} icon={<TrendingUp size={10}/>} />
        <StatBar label="ìš´ì˜ëŠ¥ë ¥" value={brain} icon={<Brain size={10}/>} />
        <StatBar label="ì»¨íŠ¸ë¡¤" value={mechanics} icon={<Zap size={10}/>} />
        <StatBar label="ì„±ì¥ë ¥" value={potential} icon={<Target size={10}/>} />
      </div>
      
      <div style={{ marginTop: '15px', paddingTop: '15px', borderTop: '1px dashed #30363d', fontSize: '11px', color: '#888', textAlign: 'center' }}>
        * ìµœê·¼ 50ê²½ê¸° ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ AIê°€ ë¶„ì„í•œ ì§€í‘œì…ë‹ˆë‹¤.
      </div>
    </div>
  );
};


--- FILE: src/data/heroes.ts ---
export * from './heroes/index';

--- FILE: src/data/heroes/helpers.ts ---
// src/data/heroes/helpers.ts
import { HeroSkillSet } from '../../types';

export const getEmptyRecord = () => ({ 
  totalMatches: 0, totalWins: 0, totalPicks: 0, totalBans: 0,
  totalKills: 0, totalDeaths: 0, totalAssists: 0, 
  totalDamage: 0, totalDamageTaken: 0, totalCs: 0, totalGold: 0,
  recentResults: [] 
});

export const getEmptyUI = () => ({
  tier: '3' as const, rank: 0, rankChange: 0,
  recentWinRate: 0, pickRate: 0, banRate: 0,
  avgKda: '0.0/0.0/0.0', kdaRatio: '0.00', 
  avgDpm: '0', avgDpg: '0', avgCs: '0', avgGold: '0'
});

export const fallbackSkills: HeroSkillSet = {
  passive: { name: "ê¸°ë³¸ ëŠ¥ë ¥", mechanic: "NONE", val: 0, adRatio: 0, apRatio: 0, cd: 0, isPassive: true },
  q: { name: "Q ìŠ¤í‚¬", mechanic: "NONE", val: 100, adRatio: 0.7, apRatio: 0, cd: 8 },
  w: { name: "W ìŠ¤í‚¬", mechanic: "NONE", val: 80, adRatio: 0.5, apRatio: 0, cd: 12 },
  e: { name: "E ìŠ¤í‚¬", mechanic: "NONE", val: 60, adRatio: 0.3, apRatio: 0, cd: 15 },
  r: { name: "R ìŠ¤í‚¬", mechanic: "STUN", val: 400, adRatio: 1.2, apRatio: 0, cd: 100 }
};

--- FILE: src/data/heroes/heroList.ts ---
// ==========================================
// FILE PATH: /src/data/heroes/heroList.ts
// ==========================================
import { Role } from '../../types';

export const RAW_HERO_LIST = [
  // =================================================================
  // 1. ì§‘í–‰ê´€ (EXECUTOR) - ê·¼ì ‘ ì „ì‚¬ (ë§ˆë‚˜ ì ë‹¹, ë°¸ëŸ°ìŠ¤í˜•)
  // =================================================================
  { id: 'h_ragna', name: "ë¼ê·¸ë‚˜", role: "ì§‘í–‰ê´€" as Role, concept: "ë¶ˆê½ƒì´ì—¬, ë‚˜ì˜ ë¶„ë…¸ê°€ ë˜ì–´ë¼!", stats: { ad: 75, hp: 2200, mp: 300, mpRegen: 5, armor: 45, crit: 20, range: 175, speed: 345, regen: 15, pen: 10 } },
  { id: 'h_kensei', name: "ì¼„ì„¸ì´", role: "ì§‘í–‰ê´€" as Role, concept: "ê²€ì€ ì£¼ì €í•˜ì§€ ì•ŠëŠ”ë‹¤. ì˜¤ì§ ë²¨ ë¿.", stats: { ad: 80, hp: 1950, mp: 250, mpRegen: 6, armor: 35, crit: 25, range: 175, speed: 350, regen: 10, pen: 15 } },
  { id: 'h_baldur', name: "ë°œë‘ë¥´", role: "ì§‘í–‰ê´€" as Role, concept: "ë¹›ì´ ìˆëŠ” í•œ, ë‚˜ëŠ” ì“°ëŸ¬ì§€ì§€ ì•ŠëŠ”ë‹¤.", stats: { ad: 70, hp: 2400, mp: 350, mpRegen: 5, armor: 55, crit: 10, range: 150, speed: 335, regen: 20, pen: 5 } },
  { id: 'h_freya', name: "í”„ë ˆì´ì•¼", role: "ì§‘í–‰ê´€" as Role, concept: "ë°œí‚¤ë¦¬ì˜ ë‚ ê°œê°€ ì „ì¥ì„ ë®ìœ¼ë¦¬ë¼.", stats: { ad: 72, hp: 2100, mp: 320, mpRegen: 7, armor: 40, crit: 15, range: 175, speed: 340, regen: 12, pen: 12 } },
  { id: 'h_gorgon', name: "ê³ ë¥´ê³¤", role: "ì§‘í–‰ê´€" as Role, concept: "ë‚´ ëˆˆì„ ë°”ë¼ë´... ì˜ì›íˆ.", stats: { ad: 85, hp: 2000, mp: 300, mpRegen: 5, armor: 40, crit: 15, range: 150, speed: 330, regen: 18, pen: 20 } },
  { id: 'h_arthur', name: "ì•„ì„œ", role: "ì§‘í–‰ê´€" as Role, concept: "ì™•ì˜ ì´ë¦„ìœ¼ë¡œ, ìŠ¹ë¦¬ë¥¼ ìŸì·¨í•˜ê² ë‹¤.", stats: { ad: 68, hp: 2300, mp: 340, mpRegen: 6, armor: 50, crit: 10, range: 150, speed: 340, regen: 14, pen: 8 } },
  { id: 'h_leonidas', name: "ë ˆì˜¤ë‹ˆë‹¤ìŠ¤", role: "ì§‘í–‰ê´€" as Role, concept: "ìš°ë¦¬ëŠ” ë¬¼ëŸ¬ì„œì§€ ì•ŠëŠ”ë‹¤! ì´ê²ƒì´ ìŠ¤íŒŒë¥´íƒ€ë‹¤!", stats: { ad: 78, hp: 2350, mp: 280, mpRegen: 5, armor: 50, crit: 15, range: 175, speed: 340, regen: 16, pen: 10 } },
  { id: 'h_musashi', name: "ë¬´ì‚¬ì‹œ", role: "ì§‘í–‰ê´€" as Role, concept: "ì´ë„ë¥˜ì˜ ëì„ ë³´ì—¬ì£¼ì§€.", stats: { ad: 82, hp: 2050, mp: 200, mpRegen: 8, armor: 38, crit: 30, range: 150, speed: 355, regen: 12, pen: 20 } },
  { id: 'h_lancelot', name: "ë€ìŠ¬ë¡¯", role: "ì§‘í–‰ê´€" as Role, concept: "ë‚˜ì˜ ê²€ì€ ëª…ì˜ˆë¥¼ ìœ„í•´ ì¡´ì¬í•œë‹¤.", stats: { ad: 74, hp: 2250, mp: 310, mpRegen: 6, armor: 48, crit: 20, range: 175, speed: 345, regen: 14, pen: 15 } },
  { id: 'h_siegfried', name: "ì§€í¬í”„ë¦¬íŠ¸", role: "ì§‘í–‰ê´€" as Role, concept: "ìš©ì˜ í”¼ê°€ ë‚˜ë¥¼ ë¶ˆì‚¬ë¡œ ë§Œë“ ë‹¤.", stats: { ad: 88, hp: 2500, mp: 300, mpRegen: 5, armor: 60, crit: 10, range: 150, speed: 330, regen: 25, pen: 5 } },

  // =================================================================
  // 2. ì„ ì§€ì (PROPHET) - ì›ê±°ë¦¬ ë§ˆë²•ì‚¬ (ë§ˆë‚˜í†µ í¼, ë§ˆë‚˜ì†Œëª¨ ì‹¬í•¨)
  // =================================================================
  { id: 'h_merlin', name: "ë©€ë¦°", role: "ì„ ì§€ì" as Role, concept: "ë§ˆë²•ì˜ ê·¼ì›ì€ ì§€í˜œ, ê·¸ë¦¬ê³  ì•½ê°„ì˜ ê´‘ê¸°ì§€.", stats: { ad: 40, ap: 85, hp: 1600, mp: 600, mpRegen: 12, armor: 25, crit: 0, range: 550, speed: 330, regen: 7, pen: 30 } },
  { id: 'h_crowley', name: "í¬ë¡œìš¸ë¦¬", role: "ì„ ì§€ì" as Role, concept: "ê¸ˆì§€ëœ ì§€ì‹ì—ëŠ” ëŒ€ê°€ê°€ ë”°ë¥´ëŠ” ë²•.", stats: { ad: 45, ap: 90, hp: 1550, mp: 550, mpRegen: 10, armor: 20, crit: 0, range: 525, speed: 335, regen: 6, pen: 35 } },
  { id: 'h_elara', name: "ì—˜ë¼ë¼", role: "ì„ ì§€ì" as Role, concept: "ë³„ë“¤ì´ ë‹¹ì‹ ì˜ ìš´ëª…ì„ ì†ì‚­ì´ë„¤ìš”.", stats: { ad: 38, ap: 80, hp: 1650, mp: 650, mpRegen: 15, armor: 30, crit: 0, range: 575, speed: 325, regen: 8, pen: 25 } },
  { id: 'h_nix', name: "ë‹‰ìŠ¤", role: "ì„ ì§€ì" as Role, concept: "ì–´ë‘ ì´ ë‚´ë¦¬ë©´, ì•„ë¬´ë„ ìˆ¨ì„ ìˆ˜ ì—†ì–´.", stats: { ad: 42, ap: 95, hp: 1500, mp: 580, mpRegen: 11, armor: 22, crit: 0, range: 600, speed: 340, regen: 5, pen: 40 } },
  { id: 'h_sol', name: "ì†”", role: "ì„ ì§€ì" as Role, concept: "íƒœì–‘ ë§Œì„¸! ëª¨ë“  ê²ƒì„ íƒœì›Œ ì •í™”í•˜ë¦¬ë¼!", stats: { ad: 35, ap: 88, hp: 1700, mp: 620, mpRegen: 13, armor: 28, crit: 0, range: 550, speed: 330, regen: 9, pen: 28 } },
  { id: 'h_gaia', name: "ê°€ì´ì•„", role: "ì„ ì§€ì" as Role, concept: "ëŒ€ì§€ëŠ” ê¸°ì–µí•œë‹¤. ë„ˆì˜ ì£„ë¥¼.", stats: { ad: 40, ap: 82, hp: 1800, mp: 700, mpRegen: 14, armor: 35, crit: 0, range: 500, speed: 320, regen: 10, pen: 20 } },
  { id: 'h_nostra', name: "ë…¸ìŠ¤íŠ¸ë¼", role: "ì„ ì§€ì" as Role, concept: "ì´ë¯¸ ë„ˆì˜ íŒ¨ë°°ëŠ” ì˜ˆê²¬ë˜ì–´ ìˆë‹¤.", stats: { ad: 35, ap: 92, hp: 1550, mp: 500, mpRegen: 10, armor: 20, crit: 0, range: 580, speed: 325, regen: 6, pen: 35 } },
  { id: 'h_rasputin', name: "ë¼ìŠ¤í‘¸í‹´", role: "ì„ ì§€ì" as Role, concept: "ì£½ìŒ? ë‚˜ëŠ” ìˆ˜ì—†ì´ ê²ªì–´ë³´ì•˜ë‹¤.", stats: { ad: 45, ap: 88, hp: 1750, mp: 560, mpRegen: 12, armor: 30, crit: 0, range: 525, speed: 330, regen: 15, pen: 25 } },
  { id: 'h_circe', name: "í‚¤ë¥´ì¼€", role: "ì„ ì§€ì" as Role, concept: "ê·€ì—¬ìš´ ë¼ì§€ë¡œ ë§Œë“¤ì–´ì¤„ê¹Œ?", stats: { ad: 40, ap: 96, hp: 1480, mp: 540, mpRegen: 11, armor: 18, crit: 0, range: 600, speed: 335, regen: 5, pen: 40 } },
  { id: 'h_morgana', name: "ëª¨ë¥´ê°€ë‚˜", role: "ì„ ì§€ì" as Role, concept: "ê³ í†µì„ ì¦ê²¨ë¼, í”¼í•  ìˆ˜ ì—†ë‹¤ë©´.", stats: { ad: 42, ap: 85, hp: 1620, mp: 600, mpRegen: 12, armor: 25, crit: 0, range: 550, speed: 340, regen: 8, pen: 30 } },

  // =================================================================
  // 3. ì¶”ì ì (TRACKER) - ê·¼ì ‘ ì•”ì‚´ì (ë§ˆë‚˜ ì ìŒ, ê¸°ë ¥ ëŠë‚Œ)
  // =================================================================
  { id: 'h_kage', name: "ì¹´ê²Œ", role: "ì¶”ì ì" as Role, concept: "ê·¸ë¦¼ìê°€ ì§™ì–´ì§€ë©´, ë‚´ê°€ ê±°ê¸° ìˆë‹¤.", stats: { ad: 88, hp: 1650, mp: 200, mpRegen: 10, armor: 30, crit: 35, range: 125, speed: 360, regen: 8, pen: 40 } },
  { id: 'h_fenrir', name: "íœë¦¬ë¥´", role: "ì¶”ì ì" as Role, concept: "ì‚¬ëƒ¥ê°ì´... ê²ì— ì§ˆë ¸êµ°.", stats: { ad: 82, hp: 1800, mp: 250, mpRegen: 8, armor: 35, crit: 25, range: 125, speed: 355, regen: 12, pen: 30 } },
  { id: 'h_viper', name: "ë°”ì´í¼", role: "ì¶”ì ì" as Role, concept: "ë…ì´ í¼ì§€ëŠ” ê±´ ìˆœì‹ê°„ì´ì§€.", stats: { ad: 78, hp: 1700, mp: 280, mpRegen: 7, armor: 28, crit: 20, range: 150, speed: 350, regen: 9, pen: 35 } },
  { id: 'h_specter', name: "ìŠ¤í™í„°", role: "ì¶”ì ì" as Role, concept: "ë²½ì„ ë„˜ëŠ” ì, ëª©ìˆ¨ì„ ê±·ëŠ” ì.", stats: { ad: 90, hp: 1550, mp: 220, mpRegen: 9, armor: 25, crit: 40, range: 125, speed: 355, regen: 7, pen: 45 } },
  { id: 'h_locust', name: "ë¡œì»¤ìŠ¤íŠ¸", role: "ì¶”ì ì" as Role, concept: "ìš°ë¦¬ëŠ” êµ°ë‹¨ì´ë‹¤. ë‚¨ê¹€ì—†ì´ ë¨¹ì–´ì¹˜ì›Œë¼.", stats: { ad: 75, hp: 1750, mp: 300, mpRegen: 6, armor: 32, crit: 30, range: 150, speed: 365, regen: 10, pen: 25 } },
  { id: 'h_scarlet', name: "ìŠ¤ì¹¼ë ›", role: "ì¶”ì ì" as Role, concept: "í”¼ ëƒ„ìƒˆê°€... í–¥ê¸‹í•´.", stats: { ad: 85, hp: 1600, mp: 0, mpRegen: 0, armor: 20, crit: 45, range: 125, speed: 350, regen: 6, pen: 50 } }, // ë…¸ì½”ìŠ¤íŠ¸ ì»¨ì…‰
  { id: 'h_hattori', name: "í•«í† ë¦¬", role: "ì¶”ì ì" as Role, concept: "ì„ë¬´ ì™„ë£Œ. í”ì ì€ ë‚¨ê¸°ì§€ ì•ŠëŠ”ë‹¤.", stats: { ad: 86, hp: 1600, mp: 240, mpRegen: 10, armor: 28, crit: 40, range: 125, speed: 365, regen: 7, pen: 45 } },
  { id: 'h_jack', name: "ì­", role: "ì¶”ì ì" as Role, concept: "ì•ˆê°œ ì†ì˜ ì‚´ì¸ê·€ê°€ ë‹¹ì‹ ì„ ì°¾ì•„ê°‘ë‹ˆë‹¤.", stats: { ad: 92, hp: 1580, mp: 260, mpRegen: 8, armor: 25, crit: 50, range: 125, speed: 360, regen: 6, pen: 55 } },
  { id: 'h_arachne', name: "ì•„ë¼í¬ë„¤", role: "ì¶”ì ì" as Role, concept: "ë‚´ ê±°ë¯¸ì¤„ì— ê±¸ë¦° ì´ìƒ, ë„ë§ì¹  ê³³ì€ ì—†ì–´.", stats: { ad: 76, hp: 1720, mp: 350, mpRegen: 6, armor: 35, crit: 25, range: 150, speed: 355, regen: 10, pen: 30 } },
  { id: 'h_goemon', name: "ê³ ì—ëª¬", role: "ì¶”ì ì" as Role, concept: "ë„¤ ëª©ìˆ¨ê³¼ ì§€ê°‘, ë‘˜ ë‹¤ ê°€ì ¸ê°€ë§ˆ!", stats: { ad: 84, hp: 1680, mp: 300, mpRegen: 8, armor: 32, crit: 30, range: 150, speed: 350, regen: 9, pen: 35 } },

  // =================================================================
  // 4. ìˆ˜í˜¸ê¸°ì‚¬ (GUARDIAN) - ê·¼ì ‘ íƒ±ì»¤ (ë§ˆë‚˜ ì ë‹¹, ë°©ì–´ë ¥ ë†’ìŒ)
  // =================================================================
  { id: 'h_aigis', name: "ì•„ì´ê¸°ìŠ¤", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "ë‚˜ëŠ” ëš«ë¦¬ì§€ ì•ŠëŠ” ë°©íŒ¨ë‹¤.", stats: { ad: 50, hp: 3500, mp: 400, mpRegen: 5, armor: 95, crit: 0, range: 150, speed: 315, regen: 30, pen: 0 } },
  { id: 'h_golem', name: "ê³¨ë ˜", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "ë°”ìœ„... ë‹¨ë‹¨í•˜ë‹¤... ë¶€ìˆœë‹¤...", stats: { ad: 60, hp: 3300, mp: 200, mpRegen: 4, armor: 90, crit: 5, range: 150, speed: 310, regen: 25, pen: 5 } },
  { id: 'h_paladin', name: "íŒ”ë¼ë”˜", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "ì‹ ì„±í•œ ë¹›ì´ ìš°ë¦¬ë¥¼ ë³´í˜¸í•˜ë¦¬ë¼.", stats: { ad: 55, hp: 3000, mp: 500, mpRegen: 7, armor: 85, crit: 0, range: 150, speed: 325, regen: 20, pen: 0 } },
  { id: 'h_treant', name: "íŠ¸ë¦¬ì–¸íŠ¸", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "ìˆ²ì„ í•´ì¹˜ëŠ” ì, ìš©ì„œí•˜ì§€ ì•Šê² ë‹¤.", stats: { ad: 65, hp: 3200, mp: 450, mpRegen: 6, armor: 80, crit: 5, range: 175, speed: 320, regen: 40, pen: 5 } },
  { id: 'h_magnus', name: "ë§¤ê·¸ë„ˆìŠ¤", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "ì§„ì •í•œ í˜ì´ ë¬´ì—‡ì¸ì§€ ë³´ì—¬ì£¼ë§ˆ!", stats: { ad: 58, hp: 2900, mp: 350, mpRegen: 5, armor: 88, crit: 10, range: 150, speed: 330, regen: 22, pen: 10 } },
  { id: 'h_yeti', name: "ì˜ˆí‹°", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "ì¶”ìœ„ëŠ” ë¼ˆì†ê¹Œì§€ íŒŒê³ ë“¤ì§€.", stats: { ad: 62, hp: 3400, mp: 300, mpRegen: 5, armor: 75, crit: 5, range: 150, speed: 315, regen: 28, pen: 5 } },
  { id: 'h_spartacus', name: "ìŠ¤íŒŒë¥´íƒ€ì¿ ìŠ¤", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "ììœ ë¥¼ ìœ„í•´! ê²°ì½” êµ´ë³µí•˜ì§€ ë§ˆë¼!", stats: { ad: 65, hp: 3100, mp: 250, mpRegen: 6, armor: 85, crit: 10, range: 150, speed: 325, regen: 25, pen: 10 } },
  { id: 'h_titan', name: "íƒ€ì´íƒ„", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "ê³ ëŒ€ì˜ ê±°ì¸ì´ ê¹¨ì–´ë‚¬ë‹¤.", stats: { ad: 70, hp: 3600, mp: 300, mpRegen: 4, armor: 100, crit: 0, range: 150, speed: 305, regen: 40, pen: 0 } },
  { id: 'h_behemoth', name: "ë² í—¤ëª¨ìŠ¤", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "í¬ì•„ì•™! ë‹¤ ë°Ÿì•„ë²„ë¦¬ê² ë‹¤!", stats: { ad: 68, hp: 3450, mp: 200, mpRegen: 5, armor: 92, crit: 5, range: 150, speed: 310, regen: 35, pen: 5 } },
  { id: 'h_tortuga', name: "í† ë¥´íˆ¬ê°€", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "ëŠë¦¬ì§€ë§Œ, í™•ì‹¤í•˜ê²Œ ì§€ì¼œì£¼ì§€.", stats: { ad: 55, hp: 3300, mp: 400, mpRegen: 6, armor: 110, crit: 0, range: 150, speed: 300, regen: 30, pen: 0 } },

  // =================================================================
  // 5. ì‹ ì‚´ì (GOD SLAYER) - ì›ê±°ë¦¬ ë”œëŸ¬ (ë§ˆë‚˜ ì ë‹¹, í‰íƒ€ ìœ„ì£¼)
  // =================================================================
  { id: 'h_hawk', name: "í˜¸í¬", role: "ì‹ ì‚´ì" as Role, concept: "ë‚´ í™”ì‚´ì€ ë¹—ë‚˜ê°€ì§€ ì•Šì•„.", stats: { ad: 80, hp: 1500, mp: 300, mpRegen: 6, armor: 25, crit: 40, range: 600, speed: 330, regen: 5, pen: 25 } },
  { id: 'h_trigger', name: "íŠ¸ë¦¬ê±°", role: "ì‹ ì‚´ì" as Role, concept: "ì´ì•Œì€ ì¶©ë¶„í•´. ë„¤ ëª©ìˆ¨ì´ ë¶€ì¡±í•  ë¿.", stats: { ad: 85, hp: 1450, mp: 250, mpRegen: 7, armor: 22, crit: 35, range: 550, speed: 335, regen: 6, pen: 30 } },
  { id: 'h_nova', name: "ë…¸ë°”", role: "ì‹ ì‚´ì" as Role, concept: "ë¯¸ë˜ì˜ ê¸°ìˆ ë ¥ì„ ë§›ë´ë¼.", stats: { ad: 78, hp: 1550, mp: 400, mpRegen: 8, armor: 28, crit: 30, range: 625, speed: 325, regen: 5, pen: 20 } },
  { id: 'h_flint', name: "í”Œë¦°íŠ¸", role: "ì‹ ì‚´ì" as Role, concept: "í˜„ìƒê¸ˆì´ ê½¤ ì§­ì§¤í•˜ê² ì–´.", stats: { ad: 90, hp: 1600, mp: 320, mpRegen: 6, armor: 30, crit: 25, range: 525, speed: 340, regen: 7, pen: 35 } },
  { id: 'h_sylvia', name: "ì‹¤ë¹„ì•„", role: "ì‹ ì‚´ì" as Role, concept: "ë°”ëŒì´ ë‚˜ë¥¼ ì¸ë„í•´ìš”.", stats: { ad: 75, hp: 1400, mp: 350, mpRegen: 7, armor: 20, crit: 45, range: 650, speed: 320, regen: 4, pen: 22 } },
  { id: 'h_gambit', name: "ê°¬ë¹—", role: "ì‹ ì‚´ì" as Role, concept: "ì¸ìƒì€ ë„ë°•ì´ì§€. ì˜¬ì¸í•  í…ê°€?", stats: { ad: 82, hp: 1580, mp: 300, mpRegen: 9, armor: 26, crit: 50, range: 550, speed: 330, regen: 6, pen: 28 } },
  { id: 'h_robin', name: "ë¡œë¹ˆ", role: "ì‹ ì‚´ì" as Role, concept: "ê°€ë‚œí•œ ìë“¤ì„ ìœ„í•´, ë„¤ ëª©ìˆ¨ì„ ê±°ë‘ë§ˆ.", stats: { ad: 84, hp: 1520, mp: 280, mpRegen: 6, armor: 24, crit: 35, range: 625, speed: 335, regen: 6, pen: 30 } },
  { id: 'h_artemis', name: "ì•„ë¥´í…Œë¯¸ìŠ¤", role: "ì‹ ì‚´ì" as Role, concept: "ë‹¬ë¹› ì•„ë˜ì„œ, ì‚¬ëƒ¥ì„ ì‹œì‘í•˜ì§€.", stats: { ad: 88, hp: 1480, mp: 340, mpRegen: 7, armor: 22, crit: 40, range: 650, speed: 330, regen: 5, pen: 35 } },
  { id: 'h_apollo', name: "ì•„í´ë¡œ", role: "ì‹ ì‚´ì" as Role, concept: "íƒœì–‘ë³´ë‹¤ ëœ¨ê²ê²Œ, ìŒì•…ë³´ë‹¤ ì•„ë¦„ë‹µê²Œ.", stats: { ad: 80, hp: 1600, mp: 380, mpRegen: 8, armor: 28, crit: 30, range: 575, speed: 340, regen: 7, pen: 25 } },
  { id: 'h_kaiser', name: "ì¹´ì´ì €", role: "ì‹ ì‚´ì" as Role, concept: "í™©ì œì˜ íƒ„í™˜ì— ìë¹„ë€ ì—†ë‹¤.", stats: { ad: 95, hp: 1450, mp: 200, mpRegen: 5, armor: 20, crit: 25, range: 700, speed: 320, regen: 4, pen: 40 } }
];

--- FILE: src/data/heroes/index.ts ---
// src/data/heroes/index.ts
import { Hero } from '../../types';
import { RAW_HERO_LIST } from './heroList';
import { HERO_SKILL_DATA } from './skillData';
import { getEmptyRecord, getEmptyUI, fallbackSkills } from './helpers';

export const INITIAL_HEROES: Hero[] = RAW_HERO_LIST.map(h => {
  // ìŠ¤íƒ¯ ë³´ì • ë° ê¸°ë³¸ê°’ ì„¤ì •
  const baseStats = {
    ad: h.stats.ad || 0,
    ap: (h.stats as any).ap || 0,
    hp: h.stats.hp || 1000,
    armor: h.stats.armor || 0,
    crit: h.stats.crit || 0,
    range: h.stats.range || 150,
    speed: h.stats.speed || 340,
    regen: h.stats.regen || 10,
    pen: h.stats.pen || 0,
    baseAtk: h.stats.ad || 50
  };

  return {
    ...h,
    stats: baseStats,
    // IDì— ë§ëŠ” ìŠ¤í‚¬ ë°ì´í„° í• ë‹¹ (ì—†ìœ¼ë©´ fallbackìš© ê¸°ë³¸ ìŠ¤í‚¬ ì£¼ì…)
    skills: HERO_SKILL_DATA[h.id] || fallbackSkills,
    record: getEmptyRecord(),
    ...getEmptyUI()
  } as Hero;
});


--- FILE: src/data/heroes/skillData.ts ---
// ==========================================
// FILE PATH: /src/data/heroes/skillData.ts
// ==========================================
import { HeroSkillSet } from '../../types';

export const HERO_SKILL_DATA: Record<string, HeroSkillSet> = {
  // ===================== [ì§‘í–‰ê´€] =====================
  h_ragna: { 
    passive: { name: "íƒ€ì˜¤ë¥´ëŠ” íˆ¬ì§€", mechanic: "HEAL", val: 30, adRatio: 0.1, apRatio: 0, cost: 0, cd: 5, range: 0, duration: 0, isPassive: true },
    q: { name: "í™”ì—¼ ê°•íƒ€", mechanic: "DAMAGE", val: 120, adRatio: 1.1, apRatio: 0, cost: 40, cd: 6, range: 300, duration: 0 },
    w: { name: "ë¶ˆêµ´ì˜ ì™¸ì¹¨", mechanic: "SHIELD", val: 150, adRatio: 0.5, apRatio: 0, cost: 60, cd: 14, range: 0, duration: 4.0 },
    e: { name: "ëŒê²©", mechanic: "DASH", val: 450, adRatio: 0.6, apRatio: 0, cost: 50, cd: 10, range: 450, duration: 0.2 },
    r: { name: "ì§€ì˜¥ë¶ˆ í­ë°œ", mechanic: "EXECUTE", val: 400, adRatio: 2.0, apRatio: 0, cost: 100, cd: 100, range: 400, duration: 0 }
  },
  h_kensei: { 
    passive: { name: "ê²€ê¸°", mechanic: "DAMAGE", val: 20, adRatio: 0.2, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì¼ì„¬", mechanic: "DAMAGE", val: 140, adRatio: 1.2, apRatio: 0, cost: 45, cd: 5, range: 350, duration: 0 },
    w: { name: "í˜ë¦¬ê¸°", mechanic: "SHIELD", val: 100, adRatio: 0.8, apRatio: 0, cost: 50, cd: 12, range: 0, duration: 1.5 },
    e: { name: "ë°œë„ìˆ ", mechanic: "DASH", val: 500, adRatio: 0.5, apRatio: 0, cost: 40, cd: 9, range: 500, duration: 0.1 },
    r: { name: "ì˜¤ì˜: ì°¸ìˆ˜", mechanic: "STUN", val: 350, adRatio: 1.8, apRatio: 0, cost: 100, cd: 110, range: 550, duration: 1.5 }
  },
  h_baldur: { 
    passive: { name: "ë¹›ì˜ ê°€í˜¸", mechanic: "SHIELD", val: 50, adRatio: 0.1, apRatio: 0, cost: 0, cd: 15, range: 0, duration: 5.0, isPassive: true },
    q: { name: "ì‹¬íŒ", mechanic: "STUN", val: 100, adRatio: 0.9, apRatio: 0, cost: 60, cd: 10, range: 250, duration: 1.2 },
    w: { name: "ì¹˜ìœ ì˜ ë¹›", mechanic: "HEAL", val: 140, adRatio: 0.4, apRatio: 0, cost: 70, cd: 16, range: 0, duration: 0 },
    e: { name: "ì„±ìŠ¤ëŸ¬ìš´ ëŒì§„", mechanic: "DASH", val: 500, adRatio: 0.6, apRatio: 0, cost: 50, cd: 12, range: 500, duration: 0.3 },
    r: { name: "ì—¬ëª…", mechanic: "DAMAGE", val: 300, adRatio: 1.5, apRatio: 0, cost: 100, cd: 90, range: 600, duration: 0 }
  },
  h_freya: { 
    passive: { name: "ì „ì¥ì˜ ì¶¤", mechanic: "DAMAGE", val: 15, adRatio: 0.1, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "íˆ¬ì°½", mechanic: "DAMAGE", val: 110, adRatio: 1.0, apRatio: 0, cost: 40, cd: 6, range: 550, duration: 0 },
    w: { name: "ê¹ƒí„¸ ë°©íŒ¨", mechanic: "SHIELD", val: 100, adRatio: 0.3, apRatio: 0, cost: 55, cd: 13, range: 0, duration: 3.0 },
    e: { name: "ë¹„ìƒ", mechanic: "DASH", val: 550, adRatio: 0.5, apRatio: 0, cost: 60, cd: 14, range: 550, duration: 0.3 },
    r: { name: "ë°œí‚¤ë¦¬ì˜ ê°•ë¦¼", mechanic: "GLOBAL", val: 350, adRatio: 1.5, apRatio: 0, cost: 120, cd: 130, range: 20000, duration: 0 }
  },
  h_gorgon: { 
    passive: { name: "ì„í™”ì˜ ì‹œì„ ", mechanic: "STUN", val: 0, adRatio: 0, apRatio: 0, cost: 0, cd: 30, range: 400, duration: 1.0, isPassive: true },
    q: { name: "ë§¹ë…", mechanic: "DAMAGE", val: 100, adRatio: 0.8, apRatio: 0.3, cost: 50, cd: 5, range: 400, duration: 0 },
    w: { name: "ìœ„í˜‘", mechanic: "DAMAGE", val: 80, adRatio: 0.6, apRatio: 0, cost: 40, cd: 9, range: 300, duration: 0 },
    e: { name: "ê¼¬ë¦¬ì¹˜ê¸°", mechanic: "HOOK", val: 400, adRatio: 0.7, apRatio: 0, cost: 70, cd: 13, range: 450, duration: 0.5 },
    r: { name: "ë©”ë‘ì‚¬ì˜ ì €ì£¼", mechanic: "STUN", val: 250, adRatio: 1.1, apRatio: 0.7, cost: 100, cd: 110, range: 600, duration: 2.0 }
  },
  h_arthur: { 
    passive: { name: "ì™•ì˜ ê¶Œìœ„", mechanic: "DAMAGE", val: 15, adRatio: 0.1, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì—‘ìŠ¤ì¹¼ë¦¬ë²„", mechanic: "DAMAGE", val: 130, adRatio: 1.2, apRatio: 0, cost: 50, cd: 7, range: 300, duration: 0 },
    w: { name: "ì›íƒì˜ ê°€í˜¸", mechanic: "SHIELD", val: 120, adRatio: 0.4, apRatio: 0, cost: 60, cd: 15, range: 0, duration: 4.0 },
    e: { name: "ì™•ì˜ ì§„ê²©", mechanic: "DASH", val: 500, adRatio: 0.7, apRatio: 0, cost: 55, cd: 11, range: 500, duration: 0.3 },
    r: { name: "ì•½ì†ëœ ìŠ¹ë¦¬", mechanic: "EXECUTE", val: 450, adRatio: 1.8, apRatio: 0, cost: 100, cd: 130, range: 500, duration: 0 }
  },
  h_leonidas: { 
    passive: { name: "ìŠ¤íŒŒë¥´íƒ€", mechanic: "SHIELD", val: 60, adRatio: 0.2, apRatio: 0, cost: 0, cd: 18, range: 0, duration: 3.0, isPassive: true },
    q: { name: "ì°½ ì°Œë¥´ê¸°", mechanic: "DAMAGE", val: 120, adRatio: 1.1, apRatio: 0, cost: 45, cd: 5, range: 400, duration: 0 },
    w: { name: "ë°©íŒ¨ ë°€ì¹˜ê¸°", mechanic: "STUN", val: 90, adRatio: 0.5, apRatio: 0, cost: 60, cd: 12, range: 200, duration: 1.2 },
    e: { name: "í•¨ì„±", mechanic: "HEAL", val: 90, adRatio: 0.3, apRatio: 0, cost: 70, cd: 16, range: 0, duration: 0 },
    r: { name: "ìµœí›„ì˜ ì €í•­", mechanic: "SHIELD", val: 400, adRatio: 1.0, apRatio: 0, cost: 100, cd: 140, range: 0, duration: 6.0 }
  },
  h_musashi: { 
    passive: { name: "ì´ë„ë¥˜", mechanic: "DAMAGE", val: 20, adRatio: 0.3, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì‹­ì ë² ê¸°", mechanic: "DAMAGE", val: 130, adRatio: 1.3, apRatio: 0, cost: 40, cd: 6, range: 300, duration: 0 },
    w: { name: "íšŒí”¼", mechanic: "DASH", val: 400, adRatio: 0.2, apRatio: 0, cost: 50, cd: 8, range: 400, duration: 0.1 },
    e: { name: "ëª…ìƒ", mechanic: "HEAL", val: 70, adRatio: 0.3, apRatio: 0, cost: 60, cd: 15, range: 0, duration: 0 },
    r: { name: "ì˜¤ë¥œì˜ ì„œ", mechanic: "EXECUTE", val: 420, adRatio: 2.1, apRatio: 0, cost: 100, cd: 120, range: 400, duration: 0 }
  },
  h_lancelot: { 
    passive: { name: "í˜¸ìˆ˜ì˜ ê¸°ì‚¬", mechanic: "DAMAGE", val: 10, adRatio: 0.1, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì—°ì† ì°Œë¥´ê¸°", mechanic: "DASH", val: 550, adRatio: 1.0, apRatio: 0, cost: 50, cd: 7, range: 550, duration: 0.2 },
    w: { name: "íŒ¨ë§", mechanic: "SHIELD", val: 80, adRatio: 0.5, apRatio: 0, cost: 55, cd: 10, range: 0, duration: 1.5 },
    e: { name: "ê°€ë¥´ê¸°", mechanic: "DAMAGE", val: 110, adRatio: 0.9, apRatio: 0, cost: 45, cd: 8, range: 350, duration: 0 },
    r: { name: "ì•„ë¡ ë‹¤ì´íŠ¸", mechanic: "DAMAGE", val: 350, adRatio: 1.8, apRatio: 0, cost: 100, cd: 110, range: 400, duration: 0 }
  },
  h_siegfried: { 
    passive: { name: "ìš©ì˜ í”¼", mechanic: "SHIELD", val: 80, adRatio: 0.1, apRatio: 0, cost: 0, cd: 20, range: 0, duration: 5.0, isPassive: true },
    q: { name: "ë°œë­‰", mechanic: "DAMAGE", val: 140, adRatio: 1.3, apRatio: 0, cost: 50, cd: 8, range: 350, duration: 0 },
    w: { name: "ìš©ì˜ í¬íš¨", mechanic: "STUN", val: 70, adRatio: 0.4, apRatio: 0, cost: 70, cd: 16, range: 400, duration: 1.5 },
    e: { name: "ì¬ìƒ", mechanic: "HEAL", val: 100, adRatio: 0.3, apRatio: 0, cost: 60, cd: 20, range: 0, duration: 0 },
    r: { name: "ë“œë˜ê³¤ ìŠ¬ë ˆì´ì–´", mechanic: "EXECUTE", val: 500, adRatio: 2.3, apRatio: 0, cost: 100, cd: 130, range: 450, duration: 0 }
  },

  // ===================== [ì„ ì§€ì] =====================
  h_merlin: { 
    passive: { name: "ë§ˆë ¥ ê³¼ë¶€í•˜", mechanic: "DAMAGE", val: 25, adRatio: 0, apRatio: 0.3, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "í™”ì—¼êµ¬", mechanic: "DAMAGE", val: 150, adRatio: 0, apRatio: 1.3, cost: 60, cd: 5, range: 900, duration: 0 },
    w: { name: "ë§ˆë²• ë³´í˜¸ë§‰", mechanic: "SHIELD", val: 120, adRatio: 0, apRatio: 0.7, cost: 80, cd: 14, range: 0, duration: 3.0 },
    e: { name: "ì ë©¸", mechanic: "DASH", val: 450, adRatio: 0, apRatio: 0, cost: 90, cd: 15, range: 450, duration: 0.1 },
    r: { name: "ë©”í…Œì˜¤", mechanic: "GLOBAL", val: 500, adRatio: 0, apRatio: 2.5, cost: 150, cd: 140, range: 20000, duration: 0 }
  },
  h_crowley: { 
    passive: { name: "í‘ë§ˆìˆ ", mechanic: "HEAL", val: 15, adRatio: 0, apRatio: 0.2, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì €ì£¼ë°›ì€ íƒ„í™˜", mechanic: "DAMAGE", val: 120, adRatio: 0, apRatio: 1.0, cost: 50, cd: 4, range: 800, duration: 0 },
    w: { name: "ì˜í˜¼ í¡ìˆ˜", mechanic: "DAMAGE", val: 100, adRatio: 0, apRatio: 0.8, cost: 60, cd: 9, range: 700, duration: 0 },
    e: { name: "ê³µí¬", mechanic: "STUN", val: 60, adRatio: 0, apRatio: 0.5, cost: 80, cd: 16, range: 600, duration: 1.8 },
    r: { name: "ì§€ì˜¥ë¬¸", mechanic: "DAMAGE", val: 400, adRatio: 0, apRatio: 2.2, cost: 120, cd: 120, range: 900, duration: 0 }
  },
  h_elara: { 
    passive: { name: "ë³„ì˜ ì¶•ë³µ", mechanic: "HEAL", val: 40, adRatio: 0, apRatio: 0.4, cost: 0, cd: 10, range: 600, duration: 0, isPassive: true },
    q: { name: "ë¹›ì˜ í™”ì‚´", mechanic: "DAMAGE", val: 110, adRatio: 0, apRatio: 1.1, cost: 55, cd: 5, range: 950, duration: 0 },
    w: { name: "ì¹˜ìœ ", mechanic: "HEAL", val: 130, adRatio: 0, apRatio: 0.8, cost: 70, cd: 10, range: 700, duration: 0 },
    e: { name: "êµ¬ì†", mechanic: "STUN", val: 80, adRatio: 0, apRatio: 0.7, cost: 80, cd: 13, range: 800, duration: 1.5 },
    r: { name: "ì²œìƒì˜ ì‹¬íŒ", mechanic: "GLOBAL", val: 450, adRatio: 0, apRatio: 2.0, cost: 150, cd: 130, range: 20000, duration: 0 }
  },
  h_nix: { 
    passive: { name: "ì–´ë‘ ì˜ ì¥ë§‰", mechanic: "STEALTH", val: 0, adRatio: 0, apRatio: 0, cost: 0, cd: 25, range: 0, duration: 4.0, isPassive: true },
    q: { name: "ì–´ë‘ ì˜ êµ¬ì²´", mechanic: "DAMAGE", val: 130, adRatio: 0, apRatio: 1.2, cost: 60, cd: 6, range: 850, duration: 0 },
    w: { name: "ê·¸ë¦¼ì ì†ë°•", mechanic: "HOOK", val: 400, adRatio: 0, apRatio: 0.6, cost: 70, cd: 15, range: 800, duration: 1.0 },
    e: { name: "ì–´ë‘  ë„ì•½", mechanic: "DASH", val: 400, adRatio: 0, apRatio: 0.4, cost: 50, cd: 12, range: 400, duration: 0.2 },
    r: { name: "ì˜ì›í•œ ë°¤", mechanic: "STUN", val: 400, adRatio: 0, apRatio: 2.1, cost: 120, cd: 140, range: 1000, duration: 2.5 }
  },
  h_sol: { 
    passive: { name: "íƒœì–‘ì—´", mechanic: "DAMAGE", val: 15, adRatio: 0, apRatio: 0.2, cost: 0, cd: 0, range: 400, duration: 0, isPassive: true },
    q: { name: "í”Œë ˆì–´", mechanic: "DAMAGE", val: 160, adRatio: 0, apRatio: 1.4, cost: 65, cd: 7, range: 950, duration: 0 },
    w: { name: "íƒœì–‘ ë°©íŒ¨", mechanic: "SHIELD", val: 120, adRatio: 0, apRatio: 0.6, cost: 70, cd: 14, range: 0, duration: 4.0 },
    e: { name: "ì—´í’", mechanic: "DASH", val: 450, adRatio: 0, apRatio: 0.4, cost: 60, cd: 12, range: 450, duration: 0.2 },
    r: { name: "ìŠˆí¼ë…¸ë°”", mechanic: "DAMAGE", val: 550, adRatio: 0, apRatio: 2.7, cost: 150, cd: 150, range: 1100, duration: 0 }
  },
  h_gaia: { 
    passive: { name: "ëŒ€ì§€ì˜ ê°€í˜¸", mechanic: "SHIELD", val: 60, adRatio: 0, apRatio: 0.3, cost: 0, cd: 15, range: 0, duration: 5.0, isPassive: true },
    q: { name: "ì§€ì§„", mechanic: "DAMAGE", val: 120, adRatio: 0, apRatio: 1.0, cost: 55, cd: 7, range: 800, duration: 0 },
    w: { name: "ë©êµ´ ì†", mechanic: "STUN", val: 80, adRatio: 0, apRatio: 0.7, cost: 70, cd: 13, range: 750, duration: 1.5 },
    e: { name: "ì¬ìƒ", mechanic: "HEAL", val: 110, adRatio: 0, apRatio: 0.6, cost: 65, cd: 14, range: 600, duration: 0 },
    r: { name: "ëŒ€ìì—°ì˜ ë¶„ë…¸", mechanic: "GLOBAL", val: 400, adRatio: 0, apRatio: 2.0, cost: 130, cd: 130, range: 20000, duration: 0 }
  },
  h_nostra: { 
    passive: { name: "ì˜ˆì§€", mechanic: "DAMAGE", val: 20, adRatio: 0, apRatio: 0.2, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ìš´ëª…ì˜ ìˆ˜ë ˆë°”í€´", mechanic: "DAMAGE", val: 130, adRatio: 0, apRatio: 1.1, cost: 50, cd: 6, range: 900, duration: 0 },
    w: { name: "ì¬ì•™", mechanic: "STUN", val: 70, adRatio: 0, apRatio: 0.6, cost: 70, cd: 14, range: 700, duration: 1.5 },
    e: { name: "ì‹œê°„ ì™œê³¡", mechanic: "DASH", val: 400, adRatio: 0, apRatio: 0, cost: 60, cd: 18, range: 400, duration: 0.2 },
    r: { name: "ì¢…ë§ì˜ ì˜ˆì–¸", mechanic: "GLOBAL", val: 480, adRatio: 0, apRatio: 2.3, cost: 150, cd: 150, range: 20000, duration: 0 }
  },
  h_rasputin: { 
    passive: { name: "ë¶ˆë©¸", mechanic: "HEAL", val: 35, adRatio: 0, apRatio: 0.2, cost: 0, cd: 10, range: 0, duration: 0, isPassive: true },
    q: { name: "ë…ê·¹ë¬¼", mechanic: "DAMAGE", val: 110, adRatio: 0, apRatio: 1.0, cost: 50, cd: 5, range: 750, duration: 0 },
    w: { name: "ìµœë©´", mechanic: "STUN", val: 60, adRatio: 0, apRatio: 0.5, cost: 80, cd: 12, range: 650, duration: 2.0 },
    e: { name: "ìê°€ ì¹˜ìœ ", mechanic: "HEAL", val: 130, adRatio: 0, apRatio: 0.8, cost: 70, cd: 10, range: 0, duration: 0 },
    r: { name: "ê´´ìŠ¹ì˜ ì €ì£¼", mechanic: "DAMAGE", val: 380, adRatio: 0, apRatio: 1.9, cost: 120, cd: 120, range: 900, duration: 0 }
  },
  h_circe: { 
    passive: { name: "ë³€ì‹ ìˆ ", mechanic: "DAMAGE", val: 15, adRatio: 0, apRatio: 0.2, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ë…ì•½", mechanic: "DAMAGE", val: 120, adRatio: 0, apRatio: 1.1, cost: 55, cd: 6, range: 800, duration: 0 },
    w: { name: "ë³€ì´", mechanic: "STUN", val: 50, adRatio: 0, apRatio: 0.5, cost: 80, cd: 16, range: 600, duration: 1.5 },
    e: { name: "í™˜ì˜", mechanic: "STEALTH", val: 0, adRatio: 0, apRatio: 0, cost: 70, cd: 18, range: 0, duration: 3.0 },
    r: { name: "ë§ˆë…€ì˜ ì—°íšŒ", mechanic: "GLOBAL", val: 420, adRatio: 0, apRatio: 2.2, cost: 140, cd: 140, range: 20000, duration: 0 }
  },
  h_morgana: { 
    passive: { name: "íƒ€ë½", mechanic: "SHIELD", val: 40, adRatio: 0, apRatio: 0.3, cost: 0, cd: 12, range: 0, duration: 4.0, isPassive: true },
    q: { name: "ì–´ë‘ ì˜ ì†ë°•", mechanic: "STUN", val: 90, adRatio: 0, apRatio: 0.8, cost: 60, cd: 10, range: 900, duration: 2.0 },
    w: { name: "ê³ í†µì˜ ëŒ€ì§€", mechanic: "DAMAGE", val: 100, adRatio: 0, apRatio: 0.9, cost: 50, cd: 8, range: 800, duration: 0 },
    e: { name: "ë¸”ë™ ì‰´ë“œ", mechanic: "SHIELD", val: 150, adRatio: 0, apRatio: 0.7, cost: 80, cd: 16, range: 650, duration: 5.0 },
    r: { name: "ì˜í˜¼ì˜ ì¡±ì‡„", mechanic: "STUN", val: 380, adRatio: 0, apRatio: 2.0, cost: 120, cd: 130, range: 600, duration: 1.5 }
  },

  // ===================== [ì¶”ì ì] =====================
  h_kage: { 
    passive: { name: "ì•”ìŠµ", mechanic: "DAMAGE", val: 35, adRatio: 0.5, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ìˆ˜ë¦¬ê²€", mechanic: "DAMAGE", val: 110, adRatio: 1.1, apRatio: 0, cost: 40, cd: 4, range: 600, duration: 0 },
    w: { name: "ë¶„ì‹ ìˆ ", mechanic: "SHIELD", val: 70, adRatio: 0.4, apRatio: 0, cost: 50, cd: 14, range: 0, duration: 3.0 },
    e: { name: "ì€ì‹ ", mechanic: "STEALTH", val: 0, adRatio: 0, apRatio: 0, cost: 60, cd: 18, range: 0, duration: 5.0 },
    r: { name: "ì•”ì‚´ ë¹„ê¸°", mechanic: "EXECUTE", val: 450, adRatio: 2.5, apRatio: 0, cost: 100, cd: 100, range: 450, duration: 0 }
  },
  h_fenrir: { 
    passive: { name: "ì•¼ìˆ˜ì„±", mechanic: "DAMAGE", val: 20, adRatio: 0.3, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ë¬¼ì–´ëœ¯ê¸°", mechanic: "DAMAGE", val: 130, adRatio: 1.3, apRatio: 0, cost: 45, cd: 5, range: 250, duration: 0 },
    w: { name: "í¬íš¨", mechanic: "STUN", val: 40, adRatio: 0, apRatio: 0, cost: 50, cd: 15, range: 400, duration: 1.5 },
    e: { name: "ë„ì•½", mechanic: "DASH", val: 550, adRatio: 0.8, apRatio: 0, cost: 50, cd: 10, range: 550, duration: 0.2 },
    r: { name: "ë¼ê·¸ë‚˜ë¡œí¬ì˜ ëŠ‘ëŒ€", mechanic: "DAMAGE", val: 380, adRatio: 2.0, apRatio: 0, cost: 100, cd: 110, range: 0, duration: 0 }
  },
  h_viper: { 
    passive: { name: "ì‹ ê²½ë…", mechanic: "DAMAGE", val: 15, adRatio: 0.2, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ë…ì¹¨", mechanic: "DAMAGE", val: 90, adRatio: 1.0, apRatio: 0, cost: 35, cd: 4, range: 550, duration: 0 },
    w: { name: "ì—°ë§‰", mechanic: "STEALTH", val: 0, adRatio: 0, apRatio: 0, cost: 60, cd: 20, range: 0, duration: 4.0 },
    e: { name: "ë…ì‚¬ì˜ ì¶¤", mechanic: "DASH", val: 450, adRatio: 0.6, apRatio: 0, cost: 40, cd: 12, range: 450, duration: 0.2 },
    r: { name: "ì¹˜ëª…ì ì¸ ë§¹ë…", mechanic: "EXECUTE", val: 320, adRatio: 1.8, apRatio: 0, cost: 100, cd: 120, range: 600, duration: 0 }
  },
  h_specter: { 
    passive: { name: "ìœ ì²´í™”", mechanic: "DAMAGE", val: 20, adRatio: 0, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì˜í˜¼ ë² ê¸°", mechanic: "DAMAGE", val: 130, adRatio: 1.2, apRatio: 0, cost: 40, cd: 6, range: 350, duration: 0 },
    w: { name: "ë¹™ì˜", mechanic: "STUN", val: 70, adRatio: 0.5, apRatio: 0, cost: 70, cd: 16, range: 500, duration: 1.0 },
    e: { name: "ë²½ í†µê³¼", mechanic: "DASH", val: 600, adRatio: 0, apRatio: 0, cost: 50, cd: 14, range: 600, duration: 0.5 },
    r: { name: "ì‚¬ì‹ ì˜ ë‚«", mechanic: "EXECUTE", val: 500, adRatio: 2.4, apRatio: 0, cost: 100, cd: 130, range: 400, duration: 0 }
  },
  h_locust: { 
    passive: { name: "êµ°ì²´ì˜ ì˜ì‹", mechanic: "DAMAGE", val: 10, adRatio: 0.2, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ê°ˆí€´ì†", mechanic: "DAMAGE", val: 110, adRatio: 1.1, apRatio: 0, cost: 40, cd: 5, range: 300, duration: 0 },
    w: { name: "ê°‘ê° ê°•í™”", mechanic: "SHIELD", val: 100, adRatio: 0.3, apRatio: 0, cost: 50, cd: 12, range: 0, duration: 4.0 },
    e: { name: "ë„ì•½ ê³µê²©", mechanic: "DASH", val: 600, adRatio: 0.9, apRatio: 0, cost: 50, cd: 8, range: 600, duration: 0.3 },
    r: { name: "í¬ì‹", mechanic: "HEAL", val: 220, adRatio: 1.5, apRatio: 0, cost: 100, cd: 100, range: 300, duration: 0 }
  },
  h_scarlet: { 
    passive: { name: "í”¼ì˜ ê³„ì•½", mechanic: "DAMAGE", val: 25, adRatio: 0.2, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "í˜ˆê²©", mechanic: "DAMAGE", val: 140, adRatio: 1.4, apRatio: 0, cost: 0, cd: 5, range: 400, duration: 0 },
    w: { name: "ë¶‰ì€ ì•ˆê°œ", mechanic: "STEALTH", val: 0, adRatio: 0, apRatio: 0, cost: 0, cd: 18, range: 0, duration: 4.0 },
    e: { name: "íšŒì „ ë² ê¸°", mechanic: "DAMAGE", val: 100, adRatio: 1.0, apRatio: 0, cost: 0, cd: 8, range: 350, duration: 0 },
    r: { name: "ë¸”ëŸ¬ë“œ ë¬¸", mechanic: "EXECUTE", val: 450, adRatio: 2.3, apRatio: 0, cost: 0, cd: 110, range: 600, duration: 0 }
  },
  h_hattori: { 
    passive: { name: "ì¸ìˆ ", mechanic: "DAMAGE", val: 25, adRatio: 0.3, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì•”ì‚´ê²€", mechanic: "DAMAGE", val: 130, adRatio: 1.3, apRatio: 0, cost: 45, cd: 5, range: 350, duration: 0 },
    w: { name: "ì—°ë§‰íƒ„", mechanic: "STEALTH", val: 0, adRatio: 0, apRatio: 0, cost: 60, cd: 14, range: 0, duration: 3.5 },
    e: { name: "ê·¸ë¦¼ì ì´ë™", mechanic: "DASH", val: 550, adRatio: 0.6, apRatio: 0, cost: 50, cd: 10, range: 550, duration: 0.2 },
    r: { name: "ì²œë³¸ì•µ", mechanic: "EXECUTE", val: 420, adRatio: 2.2, apRatio: 0, cost: 100, cd: 110, range: 550, duration: 0 }
  },
  h_jack: { 
    passive: { name: "ëŸ°ë˜ì˜ ì•ˆê°œ", mechanic: "STEALTH", val: 0, adRatio: 0, apRatio: 0, cost: 0, cd: 20, range: 0, duration: 6.0, isPassive: true },
    q: { name: "ë‚˜ì´í”„", mechanic: "DAMAGE", val: 110, adRatio: 1.1, apRatio: 0, cost: 40, cd: 4, range: 600, duration: 0 },
    w: { name: "ê³µí¬ì‹¬", mechanic: "STUN", val: 60, adRatio: 0.5, apRatio: 0, cost: 60, cd: 12, range: 400, duration: 1.2 },
    e: { name: "ì”í˜¹í•œ ì¼ê²©", mechanic: "DAMAGE", val: 140, adRatio: 1.4, apRatio: 0, cost: 50, cd: 8, range: 300, duration: 0 },
    r: { name: "ì‚´ì¸ê·€ì˜ ë°¤", mechanic: "EXECUTE", val: 500, adRatio: 2.4, apRatio: 0, cost: 100, cd: 120, range: 500, duration: 0 }
  },
  h_arachne: { 
    passive: { name: "ê±°ë¯¸ì¤„", mechanic: "HOOK", val: 400, adRatio: 0.3, apRatio: 0, cost: 0, cd: 12, range: 450, duration: 0.5, isPassive: true },
    q: { name: "ë§¹ë… ì£¼ì…", mechanic: "DAMAGE", val: 100, adRatio: 1.0, apRatio: 0, cost: 40, cd: 5, range: 350, duration: 0 },
    w: { name: "ê±°ë¯¸ì¤„íƒ€ê¸°", mechanic: "DASH", val: 700, adRatio: 0.5, apRatio: 0, cost: 50, cd: 12, range: 700, duration: 0.2 },
    e: { name: "ê³ ì¹˜", mechanic: "STUN", val: 70, adRatio: 0.6, apRatio: 0, cost: 60, cd: 15, range: 500, duration: 1.5 },
    r: { name: "ì—¬ì™•ì˜ ì‚¬ëƒ¥", mechanic: "DAMAGE", val: 380, adRatio: 1.8, apRatio: 0, cost: 100, cd: 110, range: 600, duration: 0 }
  },
  h_goemon: { 
    passive: { name: "ì˜ì ", mechanic: "DAMAGE", val: 15, adRatio: 0.2, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì°¸ê²©", mechanic: "DAMAGE", val: 120, adRatio: 1.2, apRatio: 0, cost: 45, cd: 5, range: 300, duration: 0 },
    w: { name: "ë™ì „ ë˜ì§€ê¸°", mechanic: "DAMAGE", val: 90, adRatio: 0.9, apRatio: 0, cost: 40, cd: 8, range: 600, duration: 0 },
    e: { name: "ì§€ë¶• íƒ€ê¸°", mechanic: "DASH", val: 600, adRatio: 0.7, apRatio: 0, cost: 55, cd: 14, range: 600, duration: 0.3 },
    r: { name: "ëŒ€ë„ë‘‘ì˜ ì—°íšŒ", mechanic: "GLOBAL", val: 420, adRatio: 2.0, apRatio: 0, cost: 120, cd: 130, range: 1000, duration: 0 }
  },

  // ===================== [ìˆ˜í˜¸ê¸°ì‚¬] =====================
  h_aigis: { 
    passive: { name: "ì ˆëŒ€ ë°©ì–´", mechanic: "SHIELD", val: 70, adRatio: 0, apRatio: 0, cost: 0, cd: 15, range: 0, duration: 3.0, isPassive: true },
    q: { name: "ë°©íŒ¨ ë°€ì¹˜ê¸°", mechanic: "STUN", val: 90, adRatio: 0.6, apRatio: 0, cost: 50, cd: 10, range: 250, duration: 1.0 },
    w: { name: "ìˆ˜í˜¸ íƒœì„¸", mechanic: "SHIELD", val: 200, adRatio: 0.2, apRatio: 0, cost: 60, cd: 15, range: 0, duration: 4.0 },
    e: { name: "ê°€ë¡œë§‰ê¸°", mechanic: "DASH", val: 450, adRatio: 0, apRatio: 0, cost: 50, cd: 12, range: 450, duration: 0.2 },
    r: { name: "ì² ì˜¹ì„±", mechanic: "GLOBAL", val: 250, adRatio: 0, apRatio: 0, cost: 100, cd: 160, range: 20000, duration: 8.0 }
  },
  h_golem: { 
    passive: { name: "ë°”ìœ„ í”¼ë¶€", mechanic: "DAMAGE", val: 30, adRatio: 0, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì§€ë©´ ê°•íƒ€", mechanic: "DAMAGE", val: 110, adRatio: 0.8, apRatio: 0, cost: 40, cd: 8, range: 350, duration: 0 },
    w: { name: "ë‹¨ë‹¨í•´ì§€ê¸°", mechanic: "SHIELD", val: 180, adRatio: 0.3, apRatio: 0, cost: 50, cd: 14, range: 0, duration: 5.0 },
    e: { name: "ë°”ìœ„ ë˜ì§€ê¸°", mechanic: "STUN", val: 100, adRatio: 0.7, apRatio: 0, cost: 60, cd: 12, range: 600, duration: 1.2 },
    r: { name: "ëŒ€ì§€ì§„", mechanic: "STUN", val: 280, adRatio: 1.0, apRatio: 0, cost: 100, cd: 140, range: 800, duration: 2.0 }
  },
  h_paladin: { 
    passive: { name: "ì‹ ì„±í•œ ì˜¤ë¼", mechanic: "HEAL", val: 10, adRatio: 0, apRatio: 0.1, cost: 0, cd: 5, range: 500, duration: 0, isPassive: true },
    q: { name: "ì„±ìŠ¤ëŸ¬ìš´ ì¼ê²©", mechanic: "DAMAGE", val: 100, adRatio: 0.9, apRatio: 0, cost: 45, cd: 7, range: 300, duration: 0 },
    w: { name: "ì¶•ë³µ", mechanic: "HEAL", val: 130, adRatio: 0, apRatio: 0.5, cost: 70, cd: 12, range: 600, duration: 0 },
    e: { name: "ì‹¬íŒ", mechanic: "STUN", val: 80, adRatio: 0.6, apRatio: 0, cost: 60, cd: 15, range: 400, duration: 1.5 },
    r: { name: "ì‹ ì˜ ê°€í˜¸", mechanic: "GLOBAL", val: 350, adRatio: 0, apRatio: 0, cost: 120, cd: 180, range: 20000, duration: 5.0 }
  },
  h_treant: { 
    passive: { name: "ê´‘í•©ì„±", mechanic: "HEAL", val: 25, adRatio: 0, apRatio: 0, cost: 0, cd: 5, range: 0, duration: 0, isPassive: true },
    q: { name: "ë¿Œë¦¬ ë¬¶ê¸°", mechanic: "STUN", val: 70, adRatio: 0, apRatio: 0.4, cost: 60, cd: 10, range: 650, duration: 1.8 },
    w: { name: "ë‚˜ë¬´ ê»ì§ˆ", mechanic: "SHIELD", val: 140, adRatio: 0, apRatio: 0.3, cost: 50, cd: 16, range: 0, duration: 4.0 },
    e: { name: "ìì—°ì˜ ì†ê¸¸", mechanic: "HEAL", val: 100, adRatio: 0, apRatio: 0.4, cost: 70, cd: 14, range: 600, duration: 0 },
    r: { name: "ìˆ²ì˜ ë¶„ë…¸", mechanic: "DAMAGE", val: 320, adRatio: 0, apRatio: 1.0, cost: 100, cd: 130, range: 800, duration: 0 }
  },
  h_magnus: { 
    passive: { name: "ê±°ì¸ì˜ í˜", mechanic: "DAMAGE", val: 40, adRatio: 0.3, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì¶©ê²©íŒŒ", mechanic: "DAMAGE", val: 120, adRatio: 0.9, apRatio: 0, cost: 45, cd: 8, range: 400, duration: 0 },
    w: { name: "ë“¤ì´ë°›ê¸°", mechanic: "DASH", val: 550, adRatio: 0.8, apRatio: 0, cost: 55, cd: 12, range: 550, duration: 0.2 },
    e: { name: "ìœ„ì••", mechanic: "STUN", val: 60, adRatio: 0.5, apRatio: 0, cost: 60, cd: 15, range: 300, duration: 1.2 },
    r: { name: "ë’¤ì§‘ê¸°", mechanic: "HOOK", val: 200, adRatio: 1.2, apRatio: 0, cost: 100, cd: 100, range: 250, duration: 0.5 }
  },
  h_yeti: { 
    passive: { name: "ì„¤ì¸", mechanic: "DAMAGE", val: 20, adRatio: 0, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì–¼ìŒ ë­‰ì¹˜", mechanic: "STUN", val: 80, adRatio: 0.7, apRatio: 0, cost: 50, cd: 9, range: 550, duration: 1.0 },
    w: { name: "í¬ì‹", mechanic: "HEAL", val: 150, adRatio: 0.5, apRatio: 0, cost: 60, cd: 18, range: 200, duration: 0 },
    e: { name: "ëˆˆì‚¬íƒœ", mechanic: "DAMAGE", val: 110, adRatio: 0.8, apRatio: 0, cost: 50, cd: 10, range: 450, duration: 0 },
    r: { name: "ì ˆëŒ€ ì˜ë„", mechanic: "STUN", val: 320, adRatio: 1.0, apRatio: 0, cost: 100, cd: 140, range: 800, duration: 2.5 }
  },
  h_spartacus: { 
    passive: { name: "ë…¸ì˜ˆì˜ í•´ë°©", mechanic: "DAMAGE", val: 25, adRatio: 0.3, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ê²€íˆ¬ì‚¬ì˜ ì¼ê²©", mechanic: "DAMAGE", val: 120, adRatio: 1.0, apRatio: 0, cost: 40, cd: 7, range: 300, duration: 0 },
    w: { name: "ë°©íŒ¨ ì¹˜ê¸°", mechanic: "STUN", val: 80, adRatio: 0.5, apRatio: 0, cost: 50, cd: 12, range: 250, duration: 1.2 },
    e: { name: "ë¶ˆêµ´", mechanic: "HEAL", val: 120, adRatio: 0.4, apRatio: 0, cost: 60, cd: 16, range: 0, duration: 0 },
    r: { name: "ë°˜ë€ì˜ ì‹œì‘", mechanic: "DAMAGE", val: 350, adRatio: 1.5, apRatio: 0, cost: 100, cd: 140, range: 600, duration: 0 }
  },
  h_titan: { 
    passive: { name: "ê±°ì¸ì˜ í”¼ë¶€", mechanic: "SHIELD", val: 70, adRatio: 0, apRatio: 0, cost: 0, cd: 20, range: 0, duration: 5.0, isPassive: true },
    q: { name: "ë‚´ë ¤ì°ê¸°", mechanic: "STUN", val: 100, adRatio: 0.8, apRatio: 0, cost: 55, cd: 10, range: 350, duration: 1.0 },
    w: { name: "ì§€ì§„", mechanic: "DAMAGE", val: 130, adRatio: 0.7, apRatio: 0, cost: 50, cd: 14, range: 500, duration: 0 },
    e: { name: "ì² ë²½", mechanic: "SHIELD", val: 200, adRatio: 0.3, apRatio: 0, cost: 70, cd: 18, range: 0, duration: 5.0 },
    r: { name: "ë¼ê·¸ë‚˜ë¡œí¬", mechanic: "GLOBAL", val: 400, adRatio: 1.2, apRatio: 0, cost: 150, cd: 160, range: 1000, duration: 0 }
  },
  h_behemoth: { 
    passive: { name: "ê´´ìˆ˜", mechanic: "DAMAGE", val: 40, adRatio: 0, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ëŒì§„", mechanic: "DASH", val: 550, adRatio: 0.7, apRatio: 0, cost: 50, cd: 12, range: 550, duration: 0.3 },
    w: { name: "ì§€ë©´ ë¶•ê´´", mechanic: "STUN", val: 90, adRatio: 0.6, apRatio: 0, cost: 60, cd: 15, range: 400, duration: 1.2 },
    e: { name: "ë‘êº¼ìš´ ê°€ì£½", mechanic: "SHIELD", val: 180, adRatio: 0.2, apRatio: 0, cost: 55, cd: 16, range: 0, duration: 4.0 },
    r: { name: "í¬ì‹", mechanic: "EXECUTE", val: 320, adRatio: 1.5, apRatio: 0, cost: 100, cd: 130, range: 300, duration: 0 }
  },
  h_tortuga: { 
    passive: { name: "ë“±ê»ì§ˆ", mechanic: "SHIELD", val: 80, adRatio: 0, apRatio: 0, cost: 0, cd: 25, range: 0, duration: 5.0, isPassive: true },
    q: { name: "ë¬¼ëŒ€í¬", mechanic: "DAMAGE", val: 100, adRatio: 0.6, apRatio: 0.4, cost: 40, cd: 8, range: 600, duration: 0 },
    w: { name: "ê»ì§ˆ ìˆ¨ê¸°", mechanic: "SHIELD", val: 250, adRatio: 0, apRatio: 0.5, cost: 60, cd: 20, range: 0, duration: 6.0 },
    e: { name: "íšŒì „ ê³µê²©", mechanic: "STUN", val: 80, adRatio: 0.7, apRatio: 0, cost: 50, cd: 14, range: 400, duration: 1.0 },
    r: { name: "í•´ì¼", mechanic: "GLOBAL", val: 350, adRatio: 0, apRatio: 1.5, cost: 120, cd: 150, range: 1200, duration: 0 }
  },

  // ===================== [ì‹ ì‚´ì] =====================
  h_hawk: { 
    passive: { name: "ë§¤ì˜ ëˆˆ", mechanic: "DAMAGE", val: 15, adRatio: 0.5, apRatio: 0, cost: 0, cd: 0, range: 700, duration: 0, isPassive: true },
    q: { name: "ì •ë°€ ì‚¬ê²©", mechanic: "DAMAGE", val: 140, adRatio: 1.4, apRatio: 0, cost: 50, cd: 6, range: 1000, duration: 0 },
    w: { name: "ì†ì‚¬", mechanic: "DAMAGE", val: 100, adRatio: 1.0, apRatio: 0, cost: 40, cd: 10, range: 600, duration: 0 },
    e: { name: "íšŒí”¼ ê¸°ë™", mechanic: "DASH", val: 450, adRatio: 0.3, apRatio: 0, cost: 50, cd: 14, range: 450, duration: 0.2 },
    r: { name: "ê´€í†µìƒ", mechanic: "EXECUTE", val: 420, adRatio: 2.0, apRatio: 0, cost: 100, cd: 110, range: 1200, duration: 0 }
  },
  h_trigger: { 
    passive: { name: "ë”ë¸” íƒ­", mechanic: "DAMAGE", val: 20, adRatio: 0.4, apRatio: 0, cost: 0, cd: 0, range: 550, duration: 0, isPassive: true },
    q: { name: "ë‚œì‚¬", mechanic: "DAMAGE", val: 130, adRatio: 1.2, apRatio: 0, cost: 45, cd: 5, range: 600, duration: 0 },
    w: { name: "ìˆ˜ë¥˜íƒ„", mechanic: "DAMAGE", val: 110, adRatio: 0.8, apRatio: 0, cost: 50, cd: 12, range: 700, duration: 0 },
    e: { name: "ìŠ¬ë¼ì´ë”©", mechanic: "DASH", val: 500, adRatio: 0.4, apRatio: 0, cost: 40, cd: 10, range: 500, duration: 0.3 },
    r: { name: "ë¶ˆê½ƒë†€ì´", mechanic: "GLOBAL", val: 480, adRatio: 1.8, apRatio: 0, cost: 120, cd: 130, range: 2500, duration: 0 }
  },
  h_nova: { 
    passive: { name: "ì—ë„ˆì§€ ì¶©ì „", mechanic: "DAMAGE", val: 15, adRatio: 0.3, apRatio: 0.2, cost: 0, cd: 0, range: 600, duration: 0, isPassive: true },
    q: { name: "í”Œë¼ì¦ˆë§ˆ", mechanic: "DAMAGE", val: 150, adRatio: 1.3, apRatio: 0, cost: 55, cd: 7, range: 900, duration: 0 },
    w: { name: "ì¤‘ë ¥íƒ„", mechanic: "STUN", val: 70, adRatio: 0.5, apRatio: 0, cost: 65, cd: 15, range: 800, duration: 1.2 },
    e: { name: "ì¶”ì§„ê¸°", mechanic: "DASH", val: 550, adRatio: 0.5, apRatio: 0, cost: 60, cd: 18, range: 550, duration: 0.4 },
    r: { name: "ê¶¤ë„ í­ê²©", mechanic: "GLOBAL", val: 500, adRatio: 2.2, apRatio: 0, cost: 140, cd: 150, range: 20000, duration: 0 }
  },
  h_flint: { 
    passive: { name: "í™”ì•½ ëƒ„ìƒˆ", mechanic: "DAMAGE", val: 25, adRatio: 0.3, apRatio: 0, cost: 0, cd: 0, range: 500, duration: 0, isPassive: true },
    q: { name: "ì‚°íƒ„ ì‚¬ê²©", mechanic: "DAMAGE", val: 160, adRatio: 1.5, apRatio: 0, cost: 50, cd: 8, range: 400, duration: 0 },
    w: { name: "ì—°ë§‰íƒ„", mechanic: "STEALTH", val: 0, adRatio: 0, apRatio: 0, cost: 60, cd: 20, range: 0, duration: 3.5 },
    e: { name: "ì™€ì´ì–´", mechanic: "DASH", val: 650, adRatio: 0.6, apRatio: 0, cost: 50, cd: 16, range: 650, duration: 0.5 },
    r: { name: "ë°ìŠ¤í˜ë¼ë„", mechanic: "DAMAGE", val: 420, adRatio: 2.5, apRatio: 0, cost: 100, cd: 120, range: 800, duration: 0 }
  },
  h_sylvia: { 
    passive: { name: "ë°”ëŒì˜ ì†ì‚­ì„", mechanic: "DAMAGE", val: 15, adRatio: 0.4, apRatio: 0, cost: 0, cd: 0, range: 650, duration: 0, isPassive: true },
    q: { name: "ë°”ëŒ í™”ì‚´", mechanic: "DAMAGE", val: 130, adRatio: 1.3, apRatio: 0, cost: 45, cd: 6, range: 1000, duration: 0 },
    w: { name: "ë°€ì³ë‚´ê¸°", mechanic: "DAMAGE", val: 90, adRatio: 0.6, apRatio: 0, cost: 50, cd: 12, range: 500, duration: 0 },
    e: { name: "ë°”ëŒíƒ€ê¸°", mechanic: "DASH", val: 500, adRatio: 0.4, apRatio: 0, cost: 40, cd: 14, range: 500, duration: 0.3 },
    r: { name: "í­í’ìš°", mechanic: "DAMAGE", val: 380, adRatio: 1.8, apRatio: 0, cost: 100, cd: 110, range: 900, duration: 0 }
  },
  h_gambit: { 
    passive: { name: "ë„ë°•ì‚¬ì˜ í–‰ìš´", mechanic: "DAMAGE", val: 20, adRatio: 0.5, apRatio: 0, cost: 0, cd: 0, range: 550, duration: 0, isPassive: true },
    q: { name: "ì¹´ë“œ íˆ¬ì²™", mechanic: "DAMAGE", val: 140, adRatio: 1.2, apRatio: 0, cost: 40, cd: 5, range: 750, duration: 0 },
    w: { name: "ì†ì„ìˆ˜", mechanic: "STEALTH", val: 0, adRatio: 0, apRatio: 0, cost: 60, cd: 18, range: 0, duration: 3.0 },
    e: { name: "íŒëˆ ì˜¬ë¦¬ê¸°", mechanic: "DAMAGE", val: 0, adRatio: 0.4, apRatio: 0, cost: 50, cd: 10, range: 0, duration: 0 },
    r: { name: "ë¡œì—´ ìŠ¤íŠ¸ë ˆì´íŠ¸", mechanic: "EXECUTE", val: 500, adRatio: 2.4, apRatio: 0, cost: 120, cd: 130, range: 1200, duration: 0 }
  },
  h_robin: { 
    passive: { name: "ì˜ì ", mechanic: "DAMAGE", val: 15, adRatio: 0.2, apRatio: 0, cost: 0, cd: 0, range: 600, duration: 0, isPassive: true },
    q: { name: "ì •í™•í•œ ì‚¬ê²©", mechanic: "DAMAGE", val: 140, adRatio: 1.3, apRatio: 0, cost: 45, cd: 6, range: 1100, duration: 0 },
    w: { name: "í™”ì‚´ë¹„", mechanic: "DAMAGE", val: 110, adRatio: 1.0, apRatio: 0, cost: 55, cd: 10, range: 800, duration: 0 },
    e: { name: "ìˆ²ìœ¼ë¡œ ë„ì£¼", mechanic: "DASH", val: 500, adRatio: 0.4, apRatio: 0, cost: 40, cd: 14, range: 500, duration: 0.3 },
    r: { name: "ë¡œë¹ˆì˜ í™”ì‚´", mechanic: "EXECUTE", val: 420, adRatio: 2.1, apRatio: 0, cost: 100, cd: 110, range: 1300, duration: 0 }
  },
  h_artemis: { 
    passive: { name: "ë‹¬ì˜ ì‚¬ëƒ¥ê¾¼", mechanic: "DAMAGE", val: 10, adRatio: 0.4, apRatio: 0, cost: 0, cd: 0, range: 650, duration: 0, isPassive: true },
    q: { name: "ì›”ê´‘ í™”ì‚´", mechanic: "DAMAGE", val: 130, adRatio: 1.2, apRatio: 0.3, cost: 40, cd: 5, range: 900, duration: 0 },
    w: { name: "ë« ì„¤ì¹˜", mechanic: "STUN", val: 60, adRatio: 0.5, apRatio: 0, cost: 60, cd: 12, range: 700, duration: 1.5 },
    e: { name: "ë‹¬ë¹› ì§ˆì£¼", mechanic: "DASH", val: 550, adRatio: 0.5, apRatio: 0, cost: 50, cd: 15, range: 550, duration: 0.4 },
    r: { name: "ì‚¬ëƒ¥ ê°œì‹œ", mechanic: "DAMAGE", val: 400, adRatio: 1.9, apRatio: 0, cost: 100, cd: 120, range: 1000, duration: 0 }
  },
  h_apollo: { 
    passive: { name: "íƒœì–‘ì˜ ì „ì°¨", mechanic: "DAMAGE", val: 25, adRatio: 0.3, apRatio: 0.2, cost: 0, cd: 0, range: 550, duration: 0, isPassive: true },
    q: { name: "ìŒíŒŒ ê³µê²©", mechanic: "DAMAGE", val: 120, adRatio: 1.1, apRatio: 0.4, cost: 50, cd: 6, range: 850, duration: 0 },
    w: { name: "ëˆˆë¶€ì‹  ë¹›", mechanic: "STUN", val: 50, adRatio: 0, apRatio: 0.6, cost: 65, cd: 14, range: 600, duration: 1.0 },
    e: { name: "ì „ì°¨ ëŒì§„", mechanic: "DASH", val: 550, adRatio: 0.6, apRatio: 0, cost: 60, cd: 16, range: 550, duration: 0.3 },
    r: { name: "íƒœì–‘ í­ë°œ", mechanic: "GLOBAL", val: 450, adRatio: 2.0, apRatio: 0.5, cost: 120, cd: 140, range: 1500, duration: 0 }
  },
  h_kaiser: { 
    passive: { name: "í™©ì œì˜ ìœ„ì—„", mechanic: "DAMAGE", val: 30, adRatio: 0.5, apRatio: 0, cost: 0, cd: 0, range: 700, duration: 0, isPassive: true },
    q: { name: "ê´€í†µíƒ„", mechanic: "DAMAGE", val: 150, adRatio: 1.4, apRatio: 0, cost: 55, cd: 8, range: 1000, duration: 0 },
    w: { name: "ì§€íœ˜", mechanic: "DAMAGE", val: 0, adRatio: 0, apRatio: 0, cost: 40, cd: 15, range: 0, duration: 0 },
    e: { name: "ì „ìˆ  ì´ë™", mechanic: "DASH", val: 500, adRatio: 0.4, apRatio: 0, cost: 50, cd: 12, range: 500, duration: 0.3 },
    r: { name: "ê¶¤ë©¸ ì‚¬ê²©", mechanic: "EXECUTE", val: 550, adRatio: 2.5, apRatio: 0, cost: 150, cd: 150, range: 3000, duration: 0 } 
  }
};

--- FILE: src/data/items.ts ---
// ==========================================
// FILE PATH: /src/data/items.ts
// ==========================================
import { Item } from '../types';

export const INITIAL_ITEMS: Item[] = [
  // =================================================================
  // 1. BOOTS (ì‹ ë°œ) - ì´ë™ì†ë„ í•„ìˆ˜í…œ (5ê°œ)
  // =================================================================
  { id: 'i_boots_1', name: 'ë‚¡ì€ ì—¬í–‰í™”', cost: 300, ad: 0, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 25, regen: 0, mpRegen: 0, pen: 0, type: 'BOOTS', description: 'ê°€ë³ê³  ì§ˆê¸´ ê°€ì£½ìœ¼ë¡œ ë§Œë“  ì‹ ë°œì…ë‹ˆë‹¤.' },
  { id: 'i_boots_2', name: 'ëŒí’ì˜ ë¶€ì¸ ', cost: 1100, ad: 10, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 45, regen: 0, mpRegen: 0, pen: 0, type: 'BOOTS', description: 'ë°”ëŒì„ ê°€ë¥´ëŠ” ë“¯í•œ ê°€ë²¼ì›€ì„ ì„ ì‚¬í•©ë‹ˆë‹¤.' },
  { id: 'i_boots_3', name: 'ë¹„ì „ì˜ êµ¬ë‘', cost: 1100, ad: 0, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 45, regen: 0, mpRegen: 0, pen: 15, type: 'BOOTS', description: 'ë§ˆë²•ì˜ íë¦„ì„ ì›í™œí•˜ê²Œ í•´ì¤ë‹ˆë‹¤.' },
  { id: 'i_boots_4', name: 'ê°•ì²  ë§ì‹ ', cost: 1200, ad: 0, ap: 0, hp: 0, mp: 0, armor: 25, crit: 0, speed: 45, regen: 0, mpRegen: 0, pen: 0, type: 'BOOTS', description: 'ë‹¨ë‹¨í•œ ê°•ì² ë¡œ ë³´ê°•ëœ ì „íˆ¬í™”ì…ë‹ˆë‹¤.' },
  { id: 'i_boots_5', name: 'ê·¸ë¦¼ì ë°œê±¸ìŒ', cost: 900, ad: 0, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 65, regen: 0, mpRegen: 0, pen: 0, type: 'BOOTS', description: 'ë°œì†Œë¦¬ë¥¼ ì£½ì´ê³  ë¹ ë¥´ê²Œ ì´ë™í•©ë‹ˆë‹¤.' },

  // =================================================================
  // 2. WEAPON (ë¬´ê¸°) - ë¬¼ë¦¬ ê³µê²©ë ¥, ì¹˜ëª…íƒ€, ê´€í†µ (10ê°œ)
  // =================================================================
  { id: 'i_wep_1', name: 'ìš©ë³‘ì˜ ê²€', cost: 350, ad: 10, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'WEAPON', description: 'ì „ì¥ì—ì„œ í”íˆ ë³¼ ìˆ˜ ìˆëŠ” ì² ê²€ì…ë‹ˆë‹¤.' },
  { id: 'i_wep_2', name: 'ì¤‘ì¥ë³´ë³‘ì˜ ëŒ€ê²€', cost: 1300, ad: 45, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'WEAPON', description: 'ë¬´ê²Œê°ì´ ëŠê»´ì§€ëŠ” íŒŒê´´ì ì¸ ëŒ€ê²€ì…ë‹ˆë‹¤.' },
  { id: 'i_wep_3', name: 'ì‹¬íŒì˜ ëŒ€ê²€', cost: 3400, ad: 75, ap: 0, hp: 0, mp: 0, armor: 0, crit: 25, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'WEAPON', description: 'ì£„ì¸ì„ ë‹¨ì£„í•˜ëŠ” ì¹˜ëª…ì ì¸ ì¼ê²©ì…ë‹ˆë‹¤.' },
  { id: 'i_wep_4', name: 'ì§„í™ë¹› ì•½íƒˆì', cost: 3200, ad: 55, ap: 0, hp: 300, mp: 0, armor: 0, crit: 0, speed: 0, regen: 20, mpRegen: 0, pen: 0, type: 'WEAPON', description: 'ì ì˜ ìƒëª…ë ¥ì„ í¡ìˆ˜í•˜ëŠ” ì €ì£¼ë°›ì€ ê²€ì…ë‹ˆë‹¤.' },
  { id: 'i_wep_5', name: 'ë¼ˆ ë¶„ì‡„ê¸°', cost: 2800, ad: 40, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 35, type: 'WEAPON', description: 'ë‘êº¼ìš´ ê°‘ì˜·ë„ ì¢…ì´ì²˜ëŸ¼ ëš«ì–´ë²„ë¦½ë‹ˆë‹¤.' },
  { id: 'i_wep_6', name: 'ì¹ í‘ì˜ ë„ë¼', cost: 3100, ad: 50, ap: 0, hp: 450, mp: 0, armor: 0, crit: 0, speed: 10, regen: 0, mpRegen: 0, pen: 15, type: 'WEAPON', description: 'ê²€ì€ ë¬´ì‡ ë¡œ ì£¼ì¡°ëœ ë¬µì§í•œ ë„ë¼ì…ë‹ˆë‹¤.' },
  { id: 'i_wep_7', name: 'í™˜ì˜ì˜ ìŒê²€', cost: 2600, ad: 30, ap: 0, hp: 0, mp: 0, armor: 0, crit: 35, speed: 15, regen: 0, mpRegen: 0, pen: 0, type: 'WEAPON', description: 'ëˆˆì— ë³´ì´ì§€ ì•Šì„ ë§Œí¼ ë¹ ë¥¸ ì—°ê²©ì„ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.' },
  { id: 'i_wep_8', name: 'ë°¤ì˜ ì¶”ì ì', cost: 3000, ad: 65, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 20, type: 'WEAPON', description: 'ì–´ë‘  ì†ì—ì„œ ë¹›ì„ ë°œí•˜ëŠ” ì•”ì‚´ìì˜ ë¹„ìˆ˜ì…ë‹ˆë‹¤.' },
  { id: 'i_wep_9', name: 'ë‡Œì „ì°½', cost: 2900, ad: 55, ap: 0, hp: 0, mp: 0, armor: 0, crit: 15, speed: 10, regen: 0, mpRegen: 0, pen: 0, type: 'WEAPON', description: 'ì°Œë¥¼ ë•Œë§ˆë‹¤ ì „ë¥˜ê°€ íë¥´ëŠ” ì°½ì…ë‹ˆë‹¤.' },
  { id: 'i_wep_10', name: 'ë¶€ì‹ëœ ì¹¼ë‚ ', cost: 900, ad: 25, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 10, type: 'WEAPON', description: 'ìƒì²˜ê°€ ì‰½ê²Œ ì•„ë¬¼ì§€ ì•Šê²Œ ë§Œë“­ë‹ˆë‹¤.' },

  // =================================================================
  // 3. ARTIFACT (ë§ˆë„êµ¬) - ì£¼ë¬¸ë ¥, ë§ˆë‚˜, ë§ˆë‚˜ì¬ìƒ (10ê°œ)
  // =================================================================
  { id: 'i_art_1', name: 'ë§ˆë²• ì…ë¬¸ì„œ', cost: 435, ad: 0, ap: 25, hp: 0, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'ARTIFACT', description: 'ë§ˆë²•ì‚¬ì˜ ê¸°ì´ˆ ì†Œì–‘ì„ ë‹´ì€ ì±…ì…ë‹ˆë‹¤.' },
  { id: 'i_art_2', name: 'ê³ ëŒ€ ë£¬ì„', cost: 1100, ad: 0, ap: 40, hp: 0, mp: 350, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 8, type: 'ARTIFACT', description: 'ì˜¤ë˜ëœ ë§ˆë ¥ì´ ê¹ƒë“  ëŒì…ë‹ˆë‹¤.' },
  { id: 'i_art_3', name: 'ëŒ€ë§ˆë²•ì‚¬ì˜ ì™•ê´€', cost: 3600, ad: 0, ap: 130, hp: 0, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'ARTIFACT', description: 'ì „ì„¤ì ì¸ ëŒ€ë§ˆë²•ì‚¬ê°€ ì°©ìš©í–ˆë˜ ì™•ê´€ì…ë‹ˆë‹¤.' },
  { id: 'i_art_4', name: 'ì‹¬ì—°ì˜ ìˆ˜ì •êµ¬', cost: 2800, ad: 0, ap: 75, hp: 0, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 45, type: 'ARTIFACT', description: 'ë§ˆë²• ì €í•­ì„ ë¬´ë ¥í™”í•˜ëŠ” ê³µí—ˆì˜ í˜ì´ ë‹´ê²¨ìˆìŠµë‹ˆë‹¤.' },
  { id: 'i_art_5', name: 'ì²œë‘¥ì˜ ì§€íŒ¡ì´', cost: 3200, ad: 0, ap: 95, hp: 0, mp: 500, armor: 0, crit: 0, speed: 5, regen: 0, mpRegen: 0, pen: 10, type: 'ARTIFACT', description: 'í­ë°œì ì¸ ì—ë„ˆì§€ë¥¼ ë°©ì¶œí•©ë‹ˆë‹¤.' },
  { id: 'i_art_6', name: 'ì„í™”ì˜ ë¶€ì ', cost: 2900, ad: 0, ap: 80, hp: 0, mp: 0, armor: 50, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'ARTIFACT', description: 'ìœ„ê¸° ìƒí™©ì—ì„œ ëª¸ì„ ëŒì²˜ëŸ¼ ë‹¨ë‹¨í•˜ê²Œ ë§Œë“­ë‹ˆë‹¤.' },
  { id: 'i_art_7', name: 'ì§€í˜œì˜ ì„±ë°°', cost: 3000, ad: 0, ap: 85, hp: 250, mp: 800, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 15, type: 'ARTIFACT', description: 'ë§ˆë¥´ì§€ ì•ŠëŠ” ë§ˆë‚˜ì˜ ìƒ˜ì…ë‹ˆë‹¤.' },
  { id: 'i_art_8', name: 'ì—­ë³‘ì˜ ì„œ', cost: 2500, ad: 0, ap: 85, hp: 300, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 15, type: 'ARTIFACT', description: 'ì¹˜ìœ í•  ìˆ˜ ì—†ëŠ” ë§¹ë…ì˜ ê¸°ë¡ì…ë‹ˆë‹¤.' },
  { id: 'i_art_9', name: 'ì—í…Œë¥´ ì¹¼ë‚ ', cost: 3000, ad: 0, ap: 110, hp: 0, mp: 0, armor: 0, crit: 0, speed: 15, regen: 0, mpRegen: 0, pen: 0, type: 'ARTIFACT', description: 'ë§ˆë ¥ì„ ì¹¼ë‚  í˜•íƒœë¡œ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.' },
  { id: 'i_art_10', name: 'ì‘ì¶•ëœ ë§ˆë ¥ì„', cost: 400, ad: 0, ap: 0, hp: 0, mp: 300, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 5, type: 'ARTIFACT', description: 'ìˆœìˆ˜í•œ ë§ˆë‚˜ ê²°ì •ì²´ì…ë‹ˆë‹¤.' },

  // =================================================================
  // 4. ARMOR (ë°©ì–´êµ¬) - ì²´ë ¥, ë°©ì–´ë ¥, ì²´ë ¥ì¬ìƒ (10ê°œ)
  // =================================================================
  { id: 'i_armor_1', name: 'ìˆ˜ìŠµ ê¸°ì‚¬ì˜ ê°‘ì˜·', cost: 300, ad: 0, ap: 0, hp: 0, mp: 0, armor: 18, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ê°€ì¥ ê¸°ì´ˆì ì¸ ì² ì œ ë°©ì–´êµ¬ì…ë‹ˆë‹¤.' },
  { id: 'i_armor_2', name: 'ìƒëª…ì˜ ë³´ì„', cost: 400, ad: 0, ap: 0, hp: 180, mp: 0, armor: 0, crit: 0, speed: 0, regen: 2, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ì€ì€í•œ ìƒëª…ë ¥ì„ ë‚´ë¿œëŠ” ë³´ì„ì…ë‹ˆë‹¤.' },
  { id: 'i_armor_3', name: 'í™”ì—¼ì˜ íŒê¸ˆ', cost: 2800, ad: 0, ap: 0, hp: 550, mp: 0, armor: 55, crit: 0, speed: 0, regen: 10, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ì£¼ë³€ì˜ ì ì„ íƒœìš°ëŠ” ì—´ê¸°ë¥¼ ë°œì‚°í•©ë‹ˆë‹¤.' },
  { id: 'i_armor_4', name: 'ì¹¼ë‚  ê»ì§ˆ', cost: 2700, ad: 0, ap: 0, hp: 400, mp: 0, armor: 75, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ê³µê²©í•˜ëŠ” ì ì—ê²Œ ìƒì²˜ë¥¼ ì…íˆëŠ” ê°‘ì˜·ì…ë‹ˆë‹¤.' },
  { id: 'i_armor_5', name: 'ë¶ˆì‚¬ì˜ ì‹¬ì¥', cost: 3000, ad: 0, ap: 0, hp: 900, mp: 0, armor: 0, crit: 0, speed: 0, regen: 40, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ê²½ì´ë¡œìš´ íšŒë³µë ¥ì„ ë¶€ì—¬í•©ë‹ˆë‹¤.' },
  { id: 'i_armor_6', name: 'ìƒëª…ì˜ ë‚˜ë¬´ ê»ì§ˆ', cost: 2900, ad: 0, ap: 0, hp: 500, mp: 0, armor: 45, crit: 0, speed: 0, regen: 20, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ëª¨ë“  ì¹˜ìœ  íš¨ê³¼ë¥¼ ì¦í­ì‹œí‚µë‹ˆë‹¤.' },
  { id: 'i_armor_7', name: 'ìš”ìƒˆì˜ ë°©ë²½', cost: 2900, ad: 0, ap: 0, hp: 450, mp: 0, armor: 70, crit: 0, speed: -5, regen: 0, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ì¹˜ëª…íƒ€ í”¼í•´ë¥¼ ë§‰ì•„ë‚´ëŠ” ê²¬ê³ í•œ ë°©íŒ¨ì…ë‹ˆë‹¤.' },
  { id: 'i_armor_8', name: 'ëŒê²©ëŒ€ì¥ì˜ ê°‘ì˜·', cost: 2800, ad: 0, ap: 0, hp: 350, mp: 0, armor: 50, crit: 0, speed: 25, regen: 0, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ì „ì¥ìœ¼ë¡œ ë¹ ë¥´ê²Œ ëŒì§„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.' },
  { id: 'i_armor_9', name: 'ì„ìƒì˜ ì‹¬ì¥', cost: 3200, ad: 0, ap: 0, hp: 0, mp: 0, armor: 90, crit: 0, speed: 0, regen: 10, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ì ì§„ í•œê°€ìš´ë°ì„œë„ ë²„í‹¸ ìˆ˜ ìˆëŠ” ë‹¨ë‹¨í•¨ì…ë‹ˆë‹¤.' },
  { id: 'i_armor_10', name: 'ìˆ˜í˜¸ìì˜ íœë˜íŠ¸', cost: 1500, ad: 0, ap: 0, hp: 0, mp: 0, armor: 35, crit: 0, speed: 0, regen: 10, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ì•„êµ°ì—ê²Œ ë³´í˜¸ì˜ ê¸°ìš´ì„ ë‚˜ëˆ•ë‹ˆë‹¤.' },

  // =================================================================
  // 5. ACCESSORY (ì¥ì‹ êµ¬) - í•˜ì´ë¸Œë¦¬ë“œ, ë³´ì¡° ìŠ¤íƒ¯ (5ê°œ)
  // =================================================================
  { id: 'i_acc_1', name: 'í•™ìì˜ ë°˜ì§€', cost: 400, ad: 0, ap: 18, hp: 70, mp: 50, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 4, pen: 0, type: 'ACCESSORY', description: 'ë§ˆë²• ì…ë¬¸ìì—ê²Œ ì í•©í•œ ë°˜ì§€ì…ë‹ˆë‹¤.' },
  { id: 'i_acc_2', name: 'ì „ì‚¬ì˜ ëª©ê±¸ì´', cost: 450, ad: 10, ap: 0, hp: 90, mp: 0, armor: 0, crit: 0, speed: 0, regen: 3, mpRegen: 0, pen: 0, type: 'ACCESSORY', description: 'ì „íˆ¬ì˜ ê¸°ë³¸ì´ ë˜ëŠ” ê²€ì…ë‹ˆë‹¤.' },
  { id: 'i_acc_3', name: 'ë‚˜ë¬´ ë°©íŒ¨', cost: 450, ad: 0, ap: 0, hp: 100, mp: 0, armor: 0, crit: 0, speed: 0, regen: 8, mpRegen: 0, pen: 0, type: 'ACCESSORY', description: 'ì´ˆë°˜ ìƒì¡´ë ¥ì„ ë†’ì—¬ì¤ë‹ˆë‹¤.' },
  { id: 'i_acc_4', name: 'ë¶€ì„œì§„ ëª¨ë˜ì‹œê³„', cost: 750, ad: 0, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'ACCESSORY', description: 'ì‹œê°„ì„ ë©ˆì¶”ëŠ” ë§ˆë²•ì´ ê¹ƒë“¤ì–´ ìˆìŠµë‹ˆë‹¤.' },
  { id: 'i_acc_5', name: 'ë¹›ë‚˜ëŠ” íŒŒí¸', cost: 700, ad: 0, ap: 0, hp: 0, mp: 300, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'ACCESSORY', description: 'ìŠ¤í‚¬ ì‚¬ìš© í›„ í‰íƒ€ë¥¼ ê°•í™”í•©ë‹ˆë‹¤.' },

  // =================================================================
  // 6. POWER (ê¶ŒëŠ¥) - ì‹ ì˜ ì¶•ë³µì´ ê¹ƒë“  ê¶ê·¹ ì•„ì´í…œ (ì´ 6ê°œ)
  // =================================================================

  // [ì´ì¦ˆë§ˆí•œì˜ ê¶ŒëŠ¥ - íŒŒê´´/í”¼/ì†ë„]
  { 
    id: 'p_izman_low', name: 'ì´ì¦ˆë§ˆí•œì˜ ë¶ˆì”¨', cost: 1500, 
    ad: 40, ap: 0, hp: 0, mp: 0, armor: 0, crit: 10, speed: 5, regen: 0, mpRegen: 0, pen: 5, 
    type: 'POWER', description: '[ì´ì¦ˆë§ˆí•œ] íŒŒê´´ì‹ ì˜ í˜ì´ ë¯¸ì•½í•˜ê²Œ ê¹ƒë“  ë¶ˆì”¨ì…ë‹ˆë‹¤.' 
  },
  { 
    id: 'p_izman_mid', name: 'ì´ì¦ˆë§ˆí•œì˜ í•ë¹› ë‚«', cost: 3200, 
    ad: 80, ap: 0, hp: 300, mp: 0, armor: 0, crit: 20, speed: 10, regen: 20, mpRegen: 0, pen: 15, 
    type: 'POWER', description: '[ì´ì¦ˆë§ˆí•œ] ì ì˜ í”¼ë¥¼ ê°ˆêµ¬í•˜ëŠ” ì €ì£¼ë°›ì€ ë‚«ì…ë‹ˆë‹¤.' 
  },
  { 
    id: 'p_izman_high', name: 'ì´ì¦ˆë§ˆí•œì˜ ë©¸ë§', cost: 5500, 
    ad: 150, ap: 0, hp: 500, mp: 0, armor: 0, crit: 50, speed: 20, regen: 40, mpRegen: 0, pen: 40, 
    type: 'POWER', description: '[ì´ì¦ˆë§ˆí•œ] ì„¸ìƒì˜ ì¢…ë§ì„ ë¶ˆëŸ¬ì˜¤ëŠ” íŒŒê´´ì‹ ì˜ ì§„ì •í•œ í˜ì…ë‹ˆë‹¤.' 
  },

  // [ë‹¨í…Œì˜ ê¶ŒëŠ¥ - ëƒ‰ê¸°/ì§€í˜œ/ë¶ˆë©¸]
  { 
    id: 'p_dante_low', name: 'ë‹¨í…Œì˜ ëƒ‰ê¸° íŒŒí¸', cost: 1500, 
    ad: 0, ap: 50, hp: 100, mp: 200, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 5, pen: 0, 
    type: 'POWER', description: '[ë‹¨í…Œ] ìˆ˜í˜¸ì‹ ì˜ ëƒ‰ê¸°ê°€ ì„œë ¤ìˆëŠ” íŒŒí¸ì…ë‹ˆë‹¤.' 
  },
  { 
    id: 'p_dante_mid', name: 'ë‹¨í…Œì˜ ì„œë¦¬ ê°‘ì£¼', cost: 3200, 
    ad: 0, ap: 80, hp: 600, mp: 400, armor: 60, crit: 0, speed: 0, regen: 10, mpRegen: 10, pen: 0, 
    type: 'POWER', description: '[ë‹¨í…Œ] ì–´ë–¤ ê³µê²©ë„ ë§‰ì•„ë‚´ëŠ” ì ˆëŒ€ì ì¸ ë°©ì–´êµ¬ì…ë‹ˆë‹¤.' 
  },
  { 
    id: 'p_dante_high', name: 'ë‹¨í…Œì˜ ì ˆëŒ€ ì˜ë„', cost: 5500, 
    ad: 0, ap: 200, hp: 1000, mp: 1000, armor: 100, crit: 0, speed: 0, regen: 30, mpRegen: 30, pen: 20, 
    type: 'POWER', description: '[ë‹¨í…Œ] ëª¨ë“  ê²ƒì„ ì–¼ì–´ë¶™ê²Œ ë§Œë“œëŠ” ìˆ˜í˜¸ì‹ ì˜ ì§„ì •í•œ ê¶ŒëŠ¥ì…ë‹ˆë‹¤.' 
  }
];

--- FILE: src/data/jungle.ts ---
// ==========================================
// FILE PATH: /src/data/jungle.ts
// ==========================================

export const JUNGLE_CONFIG = {
  NAME: "í˜¼ëˆì˜ ê· ì—´ (Chaos Rift)",
  DESCRIPTION: "ì „ì¥ì˜ í‹ˆìƒˆì— ì¡´ì¬í•˜ëŠ” ë¶ˆì•ˆì •í•œ ì°¨ì›ì…ë‹ˆë‹¤. ì´ê³³ì—ëŠ” ì–´ëŠ ì§„ì˜ì—ë„ ì†í•˜ì§€ ì•ŠëŠ” 'ì´ê³„ì˜ í¬ë¦¬ì²˜'ë“¤ì´ ì„œì‹í•©ë‹ˆë‹¤.",

  // 2. ê¸°ë³¸ ë°¸ëŸ°ìŠ¤ ìˆ˜ì¹˜ (0~100)
  DEFAULT_SETTINGS: {
    density: 50, // ë°€ë„
    yield: 50,   // í’ìš”ë„
    attack: 30,  // í¬ë¦¬ì²˜ ê³µê²©ë ¥
    defense: 20, // í¬ë¦¬ì²˜ ë°©ì–´ë ¥
    threat: 0    
  },

  // 3. ì‹œë®¬ë ˆì´ì…˜ ê³„ìˆ˜
  BASE_SPAWN_RATE: 0.13,  
  BASE_GOLD: 18,          
  BASE_XP_INTERVAL: 12,   
  BASE_DAMAGE_TAKEN: 10,  
  BASE_REGEN: 15          
};

--- FILE: src/data/roles.ts ---
// === FILE: src/data/roles.ts ===

import { Role } from '../types';
import { Shield, Swords, Zap, Crosshair, Skull } from 'lucide-react';

export interface RoleInfo {
  role: Role;
  name: string;      // ì˜ë¬¸ëª… (EXECUTOR ë“±)
  icon: any;         // ì•„ì´ì½˜ ì»´í¬ë„ŒíŠ¸
  color: string;     // ëŒ€í‘œ ìƒ‰ìƒ
  concept: string;   // í•œì¤„ ìš”ì•½ (ë”°ì˜´í‘œ ë‚´ìš©)
  desc: string;      // ìƒì„¸ ì„¤ëª…
  traitName: string; // ê³ ìœ  íŠ¹ì„± ì´ë¦„
  traitEffect: string; // ê³ ìœ  íŠ¹ì„± íš¨ê³¼ ì„¤ëª…
  simEffect: string;   // ì‹œë®¬ë ˆì´ì…˜ ë°˜ì˜ ì„¤ëª…
}

export const ROLE_DATA: Record<Role, RoleInfo> = {
  'ì§‘í–‰ê´€': {
    role: 'ì§‘í–‰ê´€', 
    name: 'EXECUTOR', 
    icon: Shield, // (ê¸°ì¡´ ì•„ì´ì½˜ ìœ ì§€)
    color: '#e74c3c',
    concept: 'ì‹ ì˜ ëœ»ì„ ì§€ìƒì— ì§‘í–‰í•˜ëŠ” ë¬´ìë¹„í•œ íˆ¬ì‚¬',
    desc: 'ìµœì „ì„ ì—ì„œ ì ì˜ ì§„í˜•ì„ ë¶•ê´´ì‹œí‚¤ê³ , 1:1 ëŒ€ê²°ì—ì„œ ë¬¼ëŸ¬ì„œì§€ ì•ŠëŠ” ê³ ë…í•œ ì „ì‚¬ë“¤ì…ë‹ˆë‹¤.',
    traitName: '[ê²°íˆ¬ì˜ ì„œì•½]',
    traitEffect: 'ì£¼ë³€ì— ì•„êµ°ì´ ì—†ì„ ë•Œ(ì†”ë¡œ ë¼ì¸ì „ ì‹œ) í”¼í•´ëŸ‰ +10%, ë°©ì–´ë ¥ +10%.',
    simEffect: 'ë¼ì¸ì „ ë‹¨ê³„ì—ì„œ 1:1 í‚¬ í™•ë¥  ë³´ì •.'
  },
  'ì¶”ì ì': {
    role: 'ì¶”ì ì', 
    name: 'TRACKER', 
    icon: Swords, 
    color: '#2ecc71',
    concept: 'ë³´ì´ì§€ ì•ŠëŠ” ê³³ì—ì„œ ì´ë‹¨ì„ ì‚¬ëƒ¥í•˜ëŠ” ê·¸ë¦¼ì',
    desc: 'ì •í•´ì§„ ë¼ì¸ ì—†ì´ ì „ì¥ì„ ëˆ„ë¹„ë©°, ë³€ìˆ˜ë¥¼ ì°½ì¶œí•˜ê³  ì£¼ìš” ëª©í‘œë¬¼(ê±°ì‹ ë³‘/ì£¼ì‹œì)ì„ í™•ë³´í•©ë‹ˆë‹¤.',
    traitName: '[ì‚¬ëƒ¥ê¾¼ì˜ ë³¸ëŠ¥]',
    traitEffect: 'ëª¬ìŠ¤í„°/ì˜¤ë¸Œì íŠ¸ ì²˜ì¹˜ ì‹œ ê³¨ë“œ íšë“ëŸ‰ +20%. ë‹¤ë¥¸ ë¼ì¸ ê°œì…(ê°±í‚¹) ì‹œ ì„±ê³µë¥  ì¦ê°€.',
    simEffect: 'ì •ê¸€ëŸ¬ì˜ ì„±ì¥ ì†ë„ ë³´ì •, ì˜¤ë¸Œì íŠ¸ ë§‰íƒ€ í™•ë¥  ë³´ì •.'
  },
  'ì„ ì§€ì': {
    role: 'ì„ ì§€ì', 
    name: 'PROPHET', 
    icon: Zap, 
    color: '#3498db',
    concept: 'ì˜¤ë¼í´ì˜ ê³„ì‹œë¥¼ í•´ì„í•˜ì—¬ ë§ˆë²•ìœ¼ë¡œ êµ¬í˜„í•˜ëŠ” ì',
    desc: 'ì „ì¥ì˜ ì¤‘ì‹¬ì—ì„œ ê°•ë ¥í•œ ê´‘ì—­ ë§ˆë²•ìœ¼ë¡œ ì ì„ ì“¸ì–´ë²„ë¦¬ê³ , ì „í™©ì„ ê¿°ëš«ì–´ ë´…ë‹ˆë‹¤.',
    traitName: '[ë§ˆë ¥ì˜ íë¦„]',
    traitEffect: 'ë ˆë²¨ì´ ì˜¤ë¥¼ìˆ˜ë¡ ìŠ¤í‚¬ ê°€ì†(ì¿¨íƒ€ì„ ê°ì†Œ) íš¨ê³¼ê°€ ì¶”ê°€ë¡œ ë¶™ìŒ.',
    simEffect: 'ì¤‘í›„ë°˜ êµì „ ì‹œ ìŠ¤í‚¬ ì ìˆ˜ ê³„ì‚° ê°€ì¤‘ì¹˜ ëŒ€í­ ìƒìŠ¹.'
  },
  'ì‹ ì‚´ì': {
    role: 'ì‹ ì‚´ì', 
    name: 'GOD SLAYER', 
    icon: Crosshair, 
    color: '#f1c40f',
    concept: 'ì‹ ì¡°ì°¨ ì£½ì¼ ìˆ˜ ìˆëŠ” ê¸ˆë‹¨ì˜ ë¬´ê¸°ë¥¼ ë‹¤ë£¨ëŠ” ì',
    desc: 'ì´ˆë°˜ì—” ì•½í•˜ì§€ë§Œ, ì„±ì¥ì´ ëë‚˜ëŠ” ìˆœê°„ ì‹ (ìˆ˜í˜¸ì)ê³¼ ê±°ì‹ ë³‘ì„ ìˆœì‹ê°„ì— íŒŒê´´í•˜ëŠ” í•µì‹¬ í™”ë ¥ì…ë‹ˆë‹¤.',
    traitName: '[ê±°ì¸ í•™ì‚´ì]',
    traitEffect: 'êµ¬ì¡°ë¬¼(íƒ€ì›Œ, ì–µì œê¸°, ìˆ˜í˜¸ì) ë° ê±°ì‹ ë³‘ì—ê²Œ ì…íˆëŠ” í”¼í•´ëŸ‰ +30%.',
    simEffect: 'ê³µì„± ëª¨ë“œì¼ ë•Œ íƒ€ì›Œ ì² ê±° ì†ë„ ê°€ì†.'
  },
  'ìˆ˜í˜¸ê¸°ì‚¬': {
    role: 'ìˆ˜í˜¸ê¸°ì‚¬', 
    name: 'GUARDIAN', 
    icon: Skull, 
    color: '#9b59b6',
    concept: 'ë™ë£Œë¥¼ ìœ„í•´ ê¸°êº¼ì´ í¬ìƒí•˜ëŠ” ì‹ ë…ì˜ ë°©íŒ¨',
    desc: 'ì•„êµ°(íŠ¹íˆ ì‹ ì‚´ì)ì„ ë³´í˜¸í•˜ê³ , ì ì˜ ê³µê²©ì„ ëŒ€ì‹  ë°›ì•„ë‚´ë©° ì „ì„ ì„ ìœ ì§€í•©ë‹ˆë‹¤.',
    traitName: '[í¬ìƒì˜ ì„±ì—­]',
    traitEffect: 'ê°™ì€ ë¼ì¸ì— ìˆëŠ” ì•„êµ°ì˜ ìƒì¡´ìœ¨ì„ 20% ì˜¬ë ¤ì¤Œ. (ìì‹ ì´ ëŒ€ì‹  ì£½ì„ í™•ë¥  ì¦ê°€)',
    simEffect: 'ë´‡ ë¼ì¸ì „ì—ì„œ ì‹ ì‚´ìê°€ ì£½ì„ í™•ë¥ ì„ ë‚®ì¶”ê³ , ìì‹ ì˜ ë°ìŠ¤ í™•ë¥ ì„ ë†’ì„.'
  }
};

--- FILE: src/data/types/hero.ts ---
// src/types/hero.ts
export type Role = 'ì§‘í–‰ê´€' | 'ì„ ì§€ì' | 'ìˆ˜í˜¸ê¸°ì‚¬' | 'ì¶”ì ì' | 'ì‹ ì‚´ì';
export type Tier = 'OP' | '1' | '2' | '3' | '4' | '5';

// [NEW] íŠ¹ìˆ˜ ìŠ¤í‚¬ ë©”ì»¤ë‹ˆì¦˜
export type SkillMechanic = 
  | 'NONE' | 'STUN' | 'HOOK' | 'DASH' | 'STEALTH' 
  | 'SHIELD' | 'HEAL' | 'EXECUTE' | 'GLOBAL';

export interface HeroStats {
  ad: number;      // ê³µê²©ë ¥ (ìŠ¤í‚¬/í‰íƒ€ ê³„ìˆ˜ìš©)
  baseAtk: number; // [NEW] ê¸°ë³¸ í‰íƒ€ ë°ë¯¸ì§€ (ê¹¡ë€)
  ap: number;      // ì£¼ë¬¸ë ¥
  hp: number;      // ì²´ë ¥
  armor: number;   // ë°©ì–´ë ¥
  crit: number;    // ì¹˜ëª…íƒ€
  range: number;   // ì‚¬ê±°ë¦¬
  speed: number;   // ì´ì†
  regen: number;   // ì¬ìƒ
  pen: number;     // ê´€í†µ
}

// ìŠ¤í‚¬ ìƒì„¸ êµ¬ì¡°
export interface SkillDetail {
  name: string;
  mechanic: SkillMechanic;
  val: number;
  adRatio: number;
  apRatio: number;
  cd: number;
  isPassive?: boolean;
}

// ìŠ¤í‚¬ì…‹ (P, Q, W, E, R)
export interface HeroSkillSet {
  passive: SkillDetail;
  q: SkillDetail;
  w: SkillDetail;
  e: SkillDetail;
  r: SkillDetail;
}

export interface HeroRecord {
  totalMatches: number; totalWins: number; totalPicks: number; totalBans: number;
  totalKills: number; totalDeaths: number; totalAssists: number;
  totalDamage: number; totalDamageTaken: number; totalCs: number; totalGold: number;
  recentResults: boolean[]; 
}

export interface Hero {
  id: string; name: string; role: Role;
  stats: HeroStats;
  skills: HeroSkillSet;

  // (í•˜ìœ„ í˜¸í™˜ìš© - ì‚¬ìš© ì•ˆí•¨)
  skill?: any; skillLevels?: any; 

  record: HeroRecord;
  tier: Tier; rank: number; rankChange: number;
  recentWinRate: number; pickRate: number; banRate: number;
  avgKda: string; kdaRatio: string;
  avgDpm: string; avgDpg: string; avgCs: string; avgGold: string;
}

--- FILE: src/data/types/index.ts ---
// ==========================================
// FILE PATH: /src/types/index.ts
// ==========================================

// ------------------------------------------------------------------
// 1. ê¸°ë³¸ ìƒìˆ˜ ë° ìŠ¤í‚¬ ê´€ë ¨
// ------------------------------------------------------------------
export type Role = 'ì§‘í–‰ê´€' | 'ì„ ì§€ì' | 'ìˆ˜í˜¸ê¸°ì‚¬' | 'ì¶”ì ì' | 'ì‹ ì‚´ì';
export type Tier = 'OP' | '1' | '2' | '3' | '4' | '5';
export type SkillMechanic = 
  | 'DAMAGE' | 'HEAL' | 'SHIELD' | 'HOOK' | 'DASH' 
  | 'STUN' | 'STEALTH' | 'EXECUTE' | 'GLOBAL' | 'NONE';

export interface HeroStats {
  ad: number;      // ê³µê²©ë ¥
  ap: number;      // ì£¼ë¬¸ë ¥
  hp: number;      // ì²´ë ¥
  armor: number;   // ë°©ì–´ë ¥
  crit: number;    // ì¹˜ëª…íƒ€ìœ¨
  range: number;   // ì‚¬ê±°ë¦¬
  speed: number;   // ì´ë™ì†ë„
  regen: number;   // ì²´ë ¥ ì¬ìƒ
  pen: number;     // ê´€í†µë ¥
  baseAtk: number; // ê¸°ë³¸ ê³µê²©ë ¥
}

export interface SkillDetail {
  name: string; 
  mechanic: SkillMechanic; 
  val: number;
  adRatio: number; 
  apRatio: number; 
  cd: number; 
  range?: number; 
  duration?: number; 
  isPassive?: boolean;
}

export interface HeroSkillSet {
  passive: SkillDetail; q: SkillDetail; w: SkillDetail; e: SkillDetail; r: SkillDetail;
}

export interface HeroRecord {
  totalMatches: number; totalWins: number; totalPicks: number; totalBans: number;
  totalKills: number; totalDeaths: number; totalAssists: number;
  totalDamage: number; totalDamageTaken: number; totalCs: number; totalGold: number;
  recentResults: boolean[]; 
}

export interface Hero {
  id: string; name: string; role: Role; stats: HeroStats; skills: HeroSkillSet;
  record: HeroRecord; tier: Tier; rank: number; rankChange: number;
  recentWinRate: number; pickRate: number; banRate: number;
  avgKda: string; kdaRatio: string;
  avgDpm: string; avgDpg: string; avgCs: string; avgGold: string;
}

// ------------------------------------------------------------------
// 2. ì•„ì´í…œ(Item) ë° ìƒì  ê´€ë ¨
// ------------------------------------------------------------------
export interface Item {
  id: string;
  name: string;
  cost: number;
  ad: number; ap: number; hp: number; armor: number; crit: number; speed: number;
  type: 'WEAPON' | 'ARMOR' | 'ACCESSORY' | 'POWER'; 
  description?: string;
}

export interface ItemStatData {
  itemId: string;
  totalPicks: number;
  totalWins: number;
  totalKills: number;
  totalDeaths: number;
  totalAssists: number;
}

// ------------------------------------------------------------------
// 3. ê²Œì„ ì„¤ì • (Gods, Battle, Tier, Role)
// ------------------------------------------------------------------
export interface ObjectStats { hp: number; armor: number; rewardGold: number; }
export interface ColossusSettings extends ObjectStats { attack: number; }
export interface WatcherSettings extends ObjectStats { buffType: 'COMBAT' | 'GOLD'; buffAmount: number; buffDuration: number; }

// [ì‹ ê·œ] ì •ê¸€(í˜¼ëˆì˜ ê· ì—´) ì„¤ì • íƒ€ì… ì •ì˜
export interface JungleSettings {
  density: number; // ë°€ë„ (0~100)
  threat: number;  // ìœ„í˜‘ë„ (0~100)
  yield: number;   // í’ìš”ë„ (0~100)
}

export interface BattlefieldSettings {
  tower: ObjectStats; 
  colossus: ColossusSettings; 
  watcher: WatcherSettings;
  jungle: JungleSettings; // [ì¶”ê°€ë¨]
}

// [ì‹ ê·œ] ì—­í• êµ° ë°¸ëŸ°ìŠ¤ ì„¤ì •ê°’ êµ¬ì¡°ì²´
export interface RoleSettings {
  executor: { damage: number; defense: number }; // ì§‘í–‰ê´€ (í”¼í•´ëŸ‰%, ë°©ì–´ë ¥%)
  tracker: { gold: number; smiteChance: number }; // ì¶”ì ì (ê³¨ë“œ%, ê°•íƒ€ë°°ìœ¨)
  prophet: { cdrPerLevel: number }; // ì„ ì§€ì (ë ˆë²¨ë‹¹ ì¿¨ê°%)
  slayer: { structureDamage: number }; // ì‹ ì‚´ì (êµ¬ì¡°ë¬¼ í”¼í•´ëŸ‰%)
  guardian: { survivalRate: number }; // ìˆ˜í˜¸ê¸°ì‚¬ (ìƒì¡´ìœ¨ ë³´ì •%)
}

export interface TierConfig { challenger: number; master: number; ace: number; joker: number; gold: number; silver: number; bronze: number; }
export interface AIConfig { provider: 'GEMINI' | 'OPENAI'; apiKey: string; model: string; enabled: boolean; }

// ------------------------------------------------------------------
// 4. ìœ ì €(User) ë° í†µê³„
// ------------------------------------------------------------------
export interface MatchHistory { 
  season: number; result: 'WIN' | 'LOSE'; heroName: string; kda: string; lpChange: number; date: string; 
}

export interface UserHeroStat {
  matches: number; wins: number; kills: number; deaths: number; assists: number;
}

export interface UserProfile { 
  id: number; name: string; mainHeroId: string; score: number; 
  tier: string; winRate: number; totalGames: number; 
  history: MatchHistory[]; heroStats: Record<string, UserHeroStat>; preferredLane: string;
  mostChamps: any[]; laneStats: any[];
}

export interface TierStat { name: string; minScore: number; count: number; percent: number; color: string; }
export interface UserStatus { totalGames: number; playingUsers: number; queuingUsers: number; avgWaitTime: number; tierDistribution: TierStat[]; }

export interface GodStats { 
  totalMatches: number; 
  izmanWins: number; izmanAvgKills: string; izmanAvgTime: string; 
  danteWins: number; danteAvgKills: string; danteAvgTime: string; 
  avgGameDuration: number; guardianDeathRate: number; godAwakenRate: number; 
}

// ------------------------------------------------------------------
// 5. ì¸ê²Œì„(LiveMatch) ë° ì‹œë®¬ë ˆì´ì…˜ ë¡œê·¸
// ------------------------------------------------------------------
export type EventType = 'KILL' | 'TOWER' | 'COLOSSUS' | 'WATCHER' | 'START';
export interface GameLog { time: number; message: string; type: EventType; team?: 'BLUE' | 'RED'; }
export interface TimelineEvent { time: number; type: EventType; killerId: string; victimId: string; message: string; }

export interface LivePlayer { 
  name: string; heroId: string; kills: number; deaths: number; assists: number; 
  gold: number; cs: number; currentHp: number; maxHp: number; level: number; 
  items: Item[]; 
  totalDamageDealt: number; // ëˆ„ì  í”¼í•´ëŸ‰
  x: number; y: number; lane: 'TOP' | 'MID' | 'BOT' | 'JUNGLE'; buffs: string[]; 
  mmr: number; 
}

export interface TowerStatus { top: number; mid: number; bot: number; }

export interface TeamStats { 
  towers: TowerStatus; colossus: number; watcher: number; fury: number; 
  nexusHp: number; maxNexusHp: number;
  activeBuffs: { siegeUnit: boolean; voidPower: boolean; voidBuffEndTime?: number; };
}

export interface LiveMatch { 
  id: string; blueTeam: LivePlayer[]; redTeam: LivePlayer[]; bans: { blue: string[]; red: string[]; }; 
  startTime: number; duration: number; currentDuration: number; avgTier: string; 
  score: { blue: number, red: number }; stats: { blue: TeamStats; red: TeamStats; };
  timeline: TimelineEvent[]; logs: GameLog[]; 
}

// ------------------------------------------------------------------
// 6. ì»¤ë®¤ë‹ˆí‹°(Community)
// ------------------------------------------------------------------
export interface Comment { id: number; author: string; authorTier: string; content: string; timestamp: string; }

export interface Post { 
  id: number; author: string; authorTier: string; title: string; content: string; 
  category: 'ê³µëµ' | 'ìœ ë¨¸' | 'ì§•ì§•' | 'ë¶„ì„' | 'ì¡ë‹´' | 'ì§ˆë¬¸' | 'ìë‘' | 'ê³µì§€'; 
  views: number; upvotes: number; downvotes: number; 
  comments: number; commentList: Comment[]; createdAt: number; potential: number; isBest: boolean; displayTime: string; 
}

// ------------------------------------------------------------------
// 7. ì „ì²´ ê²Œì„ ìƒíƒœ (GameState)
// ------------------------------------------------------------------
export interface GameState {
  season: number; day: number; hour: number; minute: number;
  isPlaying: boolean; gameSpeed: number;
  userSentiment: number; ccu: number; totalUsers: number;

  userStatus: UserStatus; 
  topRankers: UserProfile[];
  godStats: GodStats; 

  liveMatches: LiveMatch[];

  // ì„¤ì • ê´€ë ¨
  tierConfig: TierConfig;
  battleSettings: BattleSettings;
  fieldSettings: BattlefieldSettings; 

  // [ì‹ ê·œ] ì—­í• êµ° ì„¤ì •
  roleSettings: RoleSettings;

  aiConfig: AIConfig;
  itemStats: Record<string, ItemStatData>;
}

--- FILE: src/data/types/match.ts ---
// ==========================================
// FILE PATH: /src/data/types/match.ts
// ==========================================

export type EventType = 'KILL' | 'TOWER' | 'COLOSSUS' | 'WATCHER' | 'START' | 'LEVELUP';

export interface GameLog {
  time: number;
  message: string;
  type: EventType;
  team?: 'BLUE' | 'RED';
}

export interface TimelineEvent {
  time: number; 
  type: EventType;
  killerId: string; 
  victimId: string; 
  message: string;
}

export interface LivePlayer {
  name: string; 
  heroId: string;
  kills: number; deaths: number; assists: number;
  gold: number; cs: number;
  currentHp: number; 
  maxHp: number;
  currentMp: number;
  maxMp: number;
  mpRegen: number;
  level: number;
  items: any[]; 
  totalDamageDealt: number;
  x: number; 
  y: number;
  lane: 'TOP' | 'MID' | 'BOT' | 'JUNGLE';
  buffs: string[];
  mmr: number;
  respawnTimer: number;
  cooldowns?: { q:number, w:number, e:number, r:number };
  stats: { brain: number, mechanics: number };

  // [ì‹ ê·œ] íƒ€ì›Œ ì–´ê·¸ë¡œ ì‹œìŠ¤í…œì„ ìœ„í•œ í•„ë“œ
  lastAttackTime?: number;       // ë§ˆì§€ë§‰ìœ¼ë¡œ ì ì„ ê³µê²©í•œ ì‹œê°„
  lastAttackedTargetId?: string; // ë§ˆì§€ë§‰ìœ¼ë¡œ ê³µê²©í•œ ëŒ€ìƒ(ì˜ì›…)ì˜ ID
}

export interface TowerStatus {
  top: number; 
  mid: number;
  bot: number;
}

export interface TeamStats {
  towers: TowerStatus; 
  laneHealth: { top: number; mid: number; bot: number };
  colossus: number;
  watcher: number;
  fury: number;
  nexusHp: number;
  maxNexusHp: number;
  activeBuffs: { siegeUnit: boolean; voidPower: boolean; voidBuffEndTime?: number; };
}

export interface LiveMatch {
  id: string;
  status: 'DRAFTING' | 'PLAYING' | 'ENDED';
  draft?: any;
  blueTeam: LivePlayer[];
  redTeam: LivePlayer[];
  bans: { blue: string[]; red: string[]; };
  startTime: number;
  duration: number;
  currentDuration: number;
  avgTier: string;
  score: { blue: number, red: number };
  stats: {
    blue: TeamStats;
    red: TeamStats;
  };
  timeline: TimelineEvent[];
  logs: GameLog[];
  
  nextColossusSpawnTime?: number;
  nextWatcherSpawnTime?: number;
  objectives: {
      colossus: { hp: number; maxHp: number; status: 'ALIVE'|'DEAD'; nextSpawnTime: number };
      watcher: { hp: number; maxHp: number; status: 'ALIVE'|'DEAD'; nextSpawnTime: number };
  };
  minions: any[];
  projectiles: any[];
  jungleMobs: any[];
}


--- FILE: src/data/types/user.ts ---
// src/types/user.ts
export interface MatchHistory {
  season: number; result: 'WIN' | 'LOSE'; heroName: string; kda: string; lpChange: number; date: string;
}
export interface UserProfile {
  id: number; name: string; mainHeroId: string; score: number;
  tier: string; winRate: number; totalGames: number;
  history: MatchHistory[];
  mostChamps: { name: string, winRate: number, kda: string }[];
  laneStats: { role: string, winRate: number }[];
}
export interface TierStat {
  name: string; minScore: number; count: number; percent: number; color: string;
}
export interface UserStatus {
  totalGames: number; playingUsers: number; queuingUsers: number; avgWaitTime: number;
  tierDistribution: TierStat[];
}
export interface TierConfig {
  challenger: number; master: number; ace: number; joker: number;
  gold: number; silver: number; bronze: number;
}

--- FILE: src/data/initialImages.ts ---
export const INITIAL_CUSTOM_IMAGES: Record<string, string> = {
  // [ì „ì¥ ë§µ]
  'map_bg': '/images/map.png',

  // [ì‹  (GODS)]
  'god_izman': '/images/gods/god_izman.png',
  'god_dante': '/images/gods/god_dante.png',

  // [ì—­í• êµ° (ROLES)]
  'role_executor': '/images/roles/role_executor.png',
  'role_tracker': '/images/roles/role_tracker.png',
  'role_prophet': '/images/roles/role_prophet.png',
  'role_slayer': '/images/roles/role_slayer.png',
  'role_guardian': '/images/roles/role_guardian.png',

  'role_executor_bg': '/images/roles/role_executor_bg.png',
  'role_tracker_bg': '/images/roles/role_tracker_bg.png',
  'role_prophet_bg': '/images/roles/role_prophet_bg.png',
  'role_slayer_bg': '/images/roles/role_slayer_bg.png',
  'role_guardian_bg': '/images/roles/role_guardian_bg.png',

  // [ì•„ì´í…œ (ITEMS)] - ëˆ„ë½ëœ ê²ƒë“¤ ì „ë¶€ ì¶”ê°€
  // 1. ì‹ ë°œ
  'i_boots_1': '/images/items/i_boots_1.png',
  'i_boots_2': '/images/items/i_boots_2.png',
  'i_boots_3': '/images/items/i_boots_3.png',
  'i_boots_4': '/images/items/i_boots_4.png',
  'i_boots_5': '/images/items/i_boots_5.png',

  // 2. ë¬´ê¸°
  'i_wep_1': '/images/items/i_wep_1.png',
  'i_wep_2': '/images/items/i_wep_2.png',
  'i_wep_3': '/images/items/i_wep_3.png',
  'i_wep_4': '/images/items/i_wep_4.png',
  'i_wep_5': '/images/items/i_wep_5.png',
  'i_wep_6': '/images/items/i_wep_6.png',
  'i_wep_7': '/images/items/i_wep_7.png',
  'i_wep_8': '/images/items/i_wep_8.png',
  'i_wep_9': '/images/items/i_wep_9.png',
  'i_wep_10': '/images/items/i_wep_10.png',

  // 3. ë§ˆë„êµ¬
  'i_art_1': '/images/items/i_art_1.png',
  'i_art_2': '/images/items/i_art_2.png',
  'i_art_3': '/images/items/i_art_3.png',
  'i_art_4': '/images/items/i_art_4.png',
  'i_art_5': '/images/items/i_art_5.png',
  'i_art_6': '/images/items/i_art_6.png',
  'i_art_7': '/images/items/i_art_7.png',
  'i_art_8': '/images/items/i_art_8.png',
  'i_art_9': '/images/items/i_art_9.png',
  'i_art_10': '/images/items/i_art_10.png',

  // 4. ë°©ì–´êµ¬
  'i_armor_1': '/images/items/i_armor_1.png',
  'i_armor_2': '/images/items/i_armor_2.png',
  'i_armor_3': '/images/items/i_armor_3.png',
  'i_armor_4': '/images/items/i_armor_4.png',
  'i_armor_5': '/images/items/i_armor_5.png',
  'i_armor_6': '/images/items/i_armor_6.png',
  'i_armor_7': '/images/items/i_armor_7.png',
  'i_armor_8': '/images/items/i_armor_8.png',
  'i_armor_9': '/images/items/i_armor_9.png',
  'i_armor_10': '/images/items/i_armor_10.png',

  // 5. ì¥ì‹ êµ¬
  'i_acc_1': '/images/items/i_acc_1.png',
  'i_acc_2': '/images/items/i_acc_2.png',
  'i_acc_3': '/images/items/i_acc_3.png',
  'i_acc_4': '/images/items/i_acc_4.png',
  'i_acc_5': '/images/items/i_acc_5.png',

  // 6. ê¶ŒëŠ¥ (Power)
  'p_izman_low': '/images/items/p_izman_low.png',
  'p_izman_mid': '/images/items/p_izman_mid.png',
  'p_izman_high': '/images/items/p_izman_high.png',
  'p_dante_low': '/images/items/p_dante_low.png',
  'p_dante_mid': '/images/items/p_dante_mid.png',
  'p_dante_high': '/images/items/p_dante_high.png',

  // [ì˜ì›… (HEROES)]
  'h_ragna': '/images/heroes/h_ragna.png',
  'h_kensei': '/images/heroes/h_kensei.png',
  'h_baldur': '/images/heroes/h_baldur.png',
  'h_freya': '/images/heroes/h_freya.png',
  'h_gorgon': '/images/heroes/h_gorgon.png',
  'h_arthur': '/images/heroes/h_arthur.png',
  'h_leonidas': '/images/heroes/h_leonidas.png',
  'h_musashi': '/images/heroes/h_musashi.png',
  'h_lancelot': '/images/heroes/h_lancelot.png',
  'h_siegfried': '/images/heroes/h_siegfried.png',

  'h_merlin': '/images/heroes/h_merlin.png',
  'h_crowley': '/images/heroes/h_crowley.png',
  'h_elara': '/images/heroes/h_elara.png',
  'h_nix': '/images/heroes/h_nix.png',
  'h_sol': '/images/heroes/h_sol.png',
  'h_gaia': '/images/heroes/h_gaia.png',
  'h_nostra': '/images/heroes/h_nostra.png',
  'h_rasputin': '/images/heroes/h_rasputin.png',
  'h_circe': '/images/heroes/h_circe.png',
  'h_morgana': '/images/heroes/h_morgana.png',

  'h_kage': '/images/heroes/h_kage.png',
  'h_fenrir': '/images/heroes/h_fenrir.png',
  'h_viper': '/images/heroes/h_viper.png',
  'h_specter': '/images/heroes/h_specter.png',
  'h_locust': '/images/heroes/h_locust.png',
  'h_scarlet': '/images/heroes/h_scarlet.png',
  'h_hattori': '/images/heroes/h_hattori.png',
  'h_jack': '/images/heroes/h_jack.png',
  'h_arachne': '/images/heroes/h_arachne.png',
  'h_goemon': '/images/heroes/h_goemon.png',

  'h_aigis': '/images/heroes/h_aigis.png',
  'h_golem': '/images/heroes/h_golem.png',
  'h_paladin': '/images/heroes/h_paladin.png',
  'h_treant': '/images/heroes/h_treant.png',
  'h_magnus': '/images/heroes/h_magnus.png',
  'h_yeti': '/images/heroes/h_yeti.png',
  'h_spartacus': '/images/heroes/h_spartacus.png',
  'h_titan': '/images/heroes/h_titan.png',
  'h_behemoth': '/images/heroes/h_behemoth.png',
  'h_tortuga': '/images/heroes/h_tortuga.png',

  'h_hawk': '/images/heroes/h_hawk.png',
  'h_trigger': '/images/heroes/h_trigger.png',
  'h_nova': '/images/heroes/h_nova.png',
  'h_flint': '/images/heroes/h_flint.png',
  'h_sylvia': '/images/heroes/h_sylvia.png',
  'h_gambit': '/images/heroes/h_gambit.png',
  'h_robin': '/images/heroes/h_robin.png',
  'h_artemis': '/images/heroes/h_artemis.png',
  'h_apollo': '/images/heroes/h_apollo.png',
  'h_kaiser': '/images/heroes/h_kaiser.png',
};


--- FILE: src/data/jungle/jungleDefaults.ts ---
// ==========================================
// FILE PATH: /src/data/jungle/jungleDefaults.ts
// ==========================================
import { JungleSettings, JungleMonsterStats } from '../../types/jungle';

const BASE: JungleMonsterStats = {
  name: '', hp: 1200, atk: 60, def: 20, 
  gold: 80, xp: 120, respawnTime: 90, 
  isBuffMob: false, 
  buffs: [] 
};

export const DEFAULT_JUNGLE_CONFIG: JungleSettings = {
  density: 100,
  camps: {
    // 1. [Blue Top] ìˆ˜ì • ë™êµ´: ì¤‘ì•™ ê¸¸ê°€ê°€ ì•„ë‹ˆë¼ 'ì¢Œì¸¡ ë‘¥ì§€'ë¡œ ì´ë™
    TOP_BLUE: {
      id: 'TOP_BLUE',
      name: 'ìˆ˜ì • ë™êµ´ (Blue Top)',
      monsters: [
        // ë©”ì¸: ì¢Œì¸¡ ë²½ìª½ ê¹Šìˆ™ì´
        { spotId: 'main', x: 28, y: 45, stats: { ...BASE, name: 'ìˆ˜ì • íŒŒìˆ˜ê¾¼', hp: 2000, isBuffMob: true, buffs: [{type: 'REGEN', value: 50}] } }, 
        // ì«„ëª¹: ë‘¥ì§€ ì•ˆì—ì„œ ë©”ì¸ì„ ê°ì‹¸ë„ë¡
        { spotId: 'sub1', x: 18, y: 35, stats: { ...BASE, name: 'ìˆ˜ì • ë„ë§ˆë±€', hp: 600, gold: 30, xp: 40 } },
        { spotId: 'sub2', x: 18, y: 55, stats: { ...BASE, name: 'ìˆ˜ì • ë„ë§ˆë±€', hp: 600, gold: 30, xp: 40 } },
        { spotId: 'sub3', x: 40, y: 45, stats: { ...BASE, name: 'ìˆ˜ì • ë„ë§ˆë±€', hp: 600, gold: 30, xp: 40 } }
      ]
    },

    // 2. [Blue Bot] ë¶‰ì€ ìˆ²: ì¤‘ì•™ ì‚¼ê±°ë¦¬ê°€ ì•„ë‹ˆë¼ 'ìš°ì¸¡ í•˜ë‹¨ ë‘¥ì§€'ë¡œ ì´ë™
    BOT_BLUE: {
      id: 'BOT_BLUE',
      name: 'ë¶‰ì€ ìˆ² (Blue Bot)',
      monsters: [
        // ë©”ì¸: ìš°ì¸¡ ë‘¥ì§€ ì•ˆìª½
        { spotId: 'main', x: 72, y: 60, stats: { ...BASE, name: 'ìš©ì•” ê±°ë¶', hp: 2200, isBuffMob: true, buffs: [{type: 'ATK', value: 15}] } }, 
        // ì«„ëª¹: ë‘¥ì§€ í…Œë‘ë¦¬
        { spotId: 'sub1', x: 62, y: 50, stats: { ...BASE, name: 'ë¶ˆê½ƒ ì„í”„', hp: 800, gold: 40, xp: 50 } }, 
        { spotId: 'sub2', x: 82, y: 50, stats: { ...BASE, name: 'ë¶ˆê½ƒ ì„í”„', hp: 800, gold: 40, xp: 50 } }, 
        { spotId: 'sub3', x: 72, y: 75, stats: { ...BASE, name: 'ë¶ˆê½ƒ ì„í”„', hp: 800, gold: 40, xp: 50 } }
      ]
    },
    
    // 3. [Red Top] ë©”ë§ˆë¥¸ í˜‘ê³¡: ì¢Œì¸¡ ìƒë‹¨ ë‘¥ì§€ (ì´ì „ ìˆ˜ì • ìœ ì§€)
    TOP_RED: {
      id: 'TOP_RED',
      name: 'ë©”ë§ˆë¥¸ í˜‘ê³¡ (Red Top)',
      monsters: [
        { spotId: 'main', x: 30, y: 30, stats: { ...BASE, name: 'í™©ì•¼ì˜ í¬ì‹ì', hp: 2200, isBuffMob: true, buffs: [{type: 'ATK', value: 15}] } }, 
        { spotId: 'sub1', x: 20, y: 40, stats: { ...BASE, name: 'ì‚¬ë§‰ ì „ê°ˆ', hp: 800, gold: 40, xp: 50 } }, 
        { spotId: 'sub2', x: 40, y: 40, stats: { ...BASE, name: 'ì‚¬ë§‰ ì „ê°ˆ', hp: 800, gold: 40, xp: 50 } }, 
        { spotId: 'sub3', x: 30, y: 50, stats: { ...BASE, name: 'ì‚¬ë§‰ ì „ê°ˆ', hp: 800, gold: 40, xp: 50 } }  
      ]
    },

    // 4. [Red Bot] ì‹¬ì—°ì˜ ëŠª: ìš°ì¸¡ ìƒë‹¨ ë‘¥ì§€ (ì´ì „ ìˆ˜ì • ìœ ì§€)
    BOT_RED: {
      id: 'BOT_RED',
      name: 'ì‹¬ì—°ì˜ ëŠª (Red Bot)',
      monsters: [
        { spotId: 'main', x: 65, y: 35, stats: { ...BASE, name: 'ì‹¬ì—°ì˜ ì£¼ì‹œì', hp: 2000, isBuffMob: true, buffs: [{type: 'HASSTE', value: 20}] } }, 
        { spotId: 'sub1', x: 55, y: 25, stats: { ...BASE, name: 'ì§„í™ ê´´ë¬¼', hp: 700, gold: 30, xp: 40 } },
        { spotId: 'sub2', x: 75, y: 25, stats: { ...BASE, name: 'ì§„í™ ê´´ë¬¼', hp: 700, gold: 30, xp: 40 } },
        { spotId: 'sub3', x: 65, y: 50, stats: { ...BASE, name: 'ì§„í™ ê´´ë¬¼', hp: 700, gold: 30, xp: 40 } }
      ]
    }
  }
};


--- FILE: src/engine/MatchEngine.ts ---
// ==========================================
// FILE PATH: /src/engine/MatchEngine.ts
// ==========================================

// ì´ì œ ì‹¤ì œ ë¡œì§ì€ ì•„ë˜ íŒŒì¼ë“¤ë¡œ ë¶„ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.
// ì´ íŒŒì¼ì€ í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•´ í•¨ìˆ˜ë“¤ì„ ë‹¤ì‹œ ë‚´ë³´ë‚´ê¸°ë§Œ í•©ë‹ˆë‹¤.

export { createLiveMatches } from './match/MatchCreator';
export { updateLiveMatches } from './match/MatchUpdater';
export { finishMatch } from './match/MatchSettlement';

--- FILE: src/engine/data/MapData.ts ---
// ==========================================
// FILE PATH: /src/engine/data/MapData.ts
// ==========================================

export interface Vector2 { x: number; y: number; }

export const BASES = {
  BLUE: { x: 5, y: 95 },
  RED: { x: 95, y: 5 }
};

// ë‹¨ìˆœ ê±°ë¦¬ ê³„ì‚° (ì„œë²„ ë¡œì§ìš©)
export const getDistance = (a: {x:number, y:number}, b: {x:number, y:number}) => {
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
};

export const POI = { 
  // [ìˆ˜ì •] ê±°ì‹ ë³‘ ìœ„ì¹˜ë¥¼ ë§µì˜ 10~11ì‹œ ë°©í–¥(ë°”ë¡  ë‘¥ì§€)ìœ¼ë¡œ ì´ë™
  BARON: { x: 25, y: 30 },    
  // [ìˆ˜ì •] ì£¼ì‹œì ìœ„ì¹˜ë¥¼ ë§µì˜ 4~5ì‹œ ë°©í–¥(ìš© ë‘¥ì§€)ìœ¼ë¡œ ì´ë™
  DRAGON: { x: 75, y: 70 },   
  TOP_RIVER: { x: 20, y: 20 },
  BOT_RIVER: { x: 80, y: 80 }
};

export const getTowerSafeZone = (lane: string, isBlue: boolean) => {
    if (lane === 'TOP') return isBlue ? {x: 5, y: 20} : {x: 20, y: 5};
    if (lane === 'MID') return isBlue ? {x: 20, y: 80} : {x: 80, y: 20}; 
    if (lane === 'BOT') return isBlue ? {x: 80, y: 95} : {x: 95, y: 80};
    return isBlue ? BASES.BLUE : BASES.RED;
};


--- FILE: src/engine/system/SentimentEngine.ts ---
// ==========================================
// FILE PATH: /src/engine/system/SentimentEngine.ts
// ==========================================
// [ìˆ˜ì •] ../types -> ../../types
import { GameState, Hero, Post } from '../../types';

export function calculateTargetSentiment(
  gameState: GameState,
  heroes: Hero[],
  posts: Post[]
): number {
  let target = 65; 

  let brokenCount = 0;
  let goldenCount = 0; 

  heroes.forEach(h => {
    const wr = h.recentWinRate;
    if (wr >= 48 && wr <= 52) goldenCount++;
    if (wr > 58 || wr < 42) {
      brokenCount++;
      target -= (Math.abs(wr - 50) - 8) * 2; 
    }
  });

  if (brokenCount === 0) target += 10;
  if (goldenCount >= (heroes.length / 2)) target += 10;

  const izmanKills = parseFloat(gameState.godStats.izmanAvgKills);
  const danteKills = parseFloat(gameState.godStats.danteAvgKills);
  const totalAvgKills = izmanKills + danteKills;

  if (totalAvgKills >= 30) target += 5;
  if (totalAvgKills >= 50) target += 5;
  if (totalAvgKills < 15) target -= 5;

  let totalGold = 0;
  let heroCount = 0;
  heroes.forEach(h => {
    const goldVal = parseInt(h.avgGold.replace(/,/g, '')) || 0;
    if(goldVal > 0) {
        totalGold += goldVal;
        heroCount++;
    }
  });
  const globalAvgGold = heroCount > 0 ? totalGold / heroCount : 0;

  if (globalAvgGold >= 12000) target += 5;
  if (globalAvgGold >= 15000) target += 5;

  const waitTime = gameState.userStatus.avgWaitTime;
  if (waitTime <= 20) target += 5;
  else if (waitTime > 60) target -= 10;

  const recentPosts = posts.slice(0, 30);
  let communityScore = 0;

  recentPosts.forEach(p => {
    if (p.category === 'ì§•ì§•' && p.isBest) communityScore -= 2;
    if (p.category === 'ê³µëµ' || p.category === 'ë¶„ì„') communityScore += 0.5;
    if (p.category === 'ìë‘' && p.upvotes > 5) communityScore += 0.2;
  });

  target += Math.max(-20, Math.min(15, communityScore));

  return Math.max(0, Math.min(100, target));
}

export function smoothSentiment(current: number, target: number): number {
  const diff = target - current;
  if (Math.abs(diff) < 0.1) return target;
  let speed = 0.05; 
  if (diff > 0) speed = 0.08;
  else speed = 0.03;
  return current + diff * speed;
}

--- FILE: src/engine/system/CommunityEngine.ts ---
import { Hero, TierConfig, Post, Comment, AIConfig, BattleSettings, BattlefieldSettings } from '../../types';
import { fetchAIPost, fetchAIComment } from '../../utils/AIService';
// [ì¤‘ìš”] ìœ ì € ê°ì²´ ì•ˆì— í•¨ìˆ˜ê°€ ì—†ìœ¼ë¯€ë¡œ, ì™¸ë¶€ í•¨ìˆ˜ë¥¼ ê°€ì ¸ì™€ì„œ ì”ë‹ˆë‹¤.
import { getUserTierName } from './UserManager'; 

const pick = <T>(arr: T[]): T => arr[Math.floor(Math.random() * arr.length)];

const getTierWeight = (tier: string) => {
  if (tier.includes('ì²œìƒê³„') || tier.includes('ì±Œë¦°ì €')) return 50;
  if (tier.includes('ë§ˆìŠ¤í„°') || tier.includes('ì—ì´ìŠ¤')) return 30;
  if (tier.includes('ì¡°ì»¤') || tier.includes('ë‹¤ì´ì•„')) return 20;
  if (tier.includes('ê³¨ë“œ') || tier.includes('í”Œë˜í‹°ë„˜')) return 10;
  if (tier.includes('ì‹¤ë²„')) return 5;
  return 0; 
};

const getRichTopicContext = (heroes: Hero[], userPool: any[], battleSettings: BattleSettings) => {
  const rand = Math.random();

  if (rand < 0.05 && userPool.length > 0) {
    const targetUser = pick(userPool); 
    // ì—¬ê¸°ì„œëŠ” ë‹¨ìˆœíˆ ì´ë¦„ë§Œ ì“°ë¯€ë¡œ ìˆ˜ì • ë¶ˆí•„ìš”
    const isHighRank = targetUser.score > 3000;
    const isFeeder = targetUser.winRate < 45;

    let tone = "ë¹„ë‚œ";
    if (isHighRank) tone = "ì§ˆíˆ¬/ì˜ì‹¬";
    else if (isFeeder) tone = "ê·¹ë”œ";

    return {
      type: 'SNIPING',
      text: `ì£¼ì œ: ìœ ì € '${targetUser.name}' ì €ê²©. (ì ìˆ˜: ${targetUser.score}). ${tone}í•˜ëŠ” ë‚´ìš©.`
    };
  } 
  else if (rand < 0.40) {
    const h = pick(heroes);
    return { type: 'BALANCE', text: `ì£¼ì œ: ${h.name} ë°¸ëŸ°ìŠ¤ í† ë¡ .` };
  }
  else if (rand < 0.55) {
    return { type: 'SYSTEM', text: `ì£¼ì œ: ê²Œì„ ì‹œìŠ¤í…œ ë¶ˆë§Œ.` };
  }
  else if (rand < 0.75) {
    return { type: 'NONSENSE', text: `ì£¼ì œ: ì•„ë¬´ë§ ëŒ€ì”ì¹˜.` };
  }
  else {
    return { type: 'NORMAL', text: `ì£¼ì œ: ê²Œì„ ì¡ë‹´.` };
  }
};

export async function generatePostAsync(
  uniqueId: number, 
  heroes: Hero[], 
  tierConfig: TierConfig, 
  currentTick: number, 
  aiConfig: AIConfig,
  userPool: any[], 
  battleSettings: BattleSettings,
  fieldSettings: BattlefieldSettings
): Promise<Post | null> {

  if (!aiConfig.apiKey || !aiConfig.enabled) return null;
  if (!userPool || userPool.length === 0) return null;

  const author = pick(userPool);
  // [ìˆ˜ì •] author.getTierName() -> getUserTierName(author, tierConfig)
  const currentTierName = getUserTierName(author, tierConfig); 
  const mostChamp = heroes.find(h => h.id === author.mainHeroId)?.name || 'ëœë¤';

  const contextObj = getRichTopicContext(heroes, userPool, battleSettings);
  let category = "ì¡ë‹´";
  if (contextObj.type === 'SNIPING') category = 'ì§•ì§•';
  else if (contextObj.type === 'BALANCE') category = 'ë¶„ì„';
  else if (contextObj.type === 'NONSENSE') category = 'ìœ ë¨¸';
  else if (contextObj.type === 'SYSTEM') category = 'ì§•ì§•';

  if (Math.random() < 0.1) category = pick(['ê³µëµ', 'ì§ˆë¬¸', 'ìë‘']);

  const userContext = `[ì‘ì„±ì ì •ë³´] ë‹‰ë„¤ì„: ${author.name}, í‹°ì–´: ${currentTierName}, ì£¼ì±”: ${mostChamp}`;
  const fullContext = `${userContext}\n${contextObj.text}\n(ì¹´í…Œê³ ë¦¬: ${category} ê²Œì‹œíŒ)`;

  const aiResult = await fetchAIPost(aiConfig, fullContext, category);
  if (!aiResult) return null;

  let basePotential = 10;
  if (category === 'ê³µëµ' || category === 'ë¶„ì„') basePotential += 20;

  return {
    id: uniqueId,
    author: author.name, 
    authorTier: currentTierName,
    title: aiResult.title,
    content: aiResult.content,
    category: category as any,
    views: 1, upvotes: 0, downvotes: 0, 
    comments: 0, commentList: [],
    createdAt: currentTick,
    potential: Math.min(100, Math.max(10, basePotential)), 
    isBest: false,
    displayTime: "ë°©ê¸ˆ ì „"
  };
}

export async function generateCommentAsync(
  post: Post, 
  aiConfig: AIConfig, 
  userPool: any[], 
  tierConfig: TierConfig
): Promise<Comment | null> {
  if (!aiConfig.apiKey || !aiConfig.enabled) return null;
  if (!userPool || userPool.length === 0) return null;

  const commenter = pick(userPool);
  // [ìˆ˜ì •] ë©”ì„œë“œ í˜¸ì¶œ -> í•¨ìˆ˜ í˜¸ì¶œ
  const commenterTier = getUserTierName(commenter, tierConfig); 
  const commentText = await fetchAIComment(aiConfig, post.title, post.content);

  if (!commentText) return null;

  return {
    id: Date.now() + Math.random(), 
    author: commenter.name, 
    authorTier: commenterTier,
    content: commentText, 
    timestamp: "ë°©ê¸ˆ ì „"
  };
}

export function updatePostInteractions(posts: Post[], currentTick: number): Post[] {
  return posts.map(post => {
    const age = currentTick - post.createdAt;
    if (age > 1440) return post; 

    const updatedPost = { ...post };
    if (age < 1) updatedPost.displayTime = "ë°©ê¸ˆ ì „";
    else if (age < 60) updatedPost.displayTime = `${Math.floor(age)}ë¶„ ì „`;
    else updatedPost.displayTime = `${Math.floor(age / 60)}ì‹œê°„ ì „`;

    let exposure = (post.potential / (age * 1.5 + 20)); 
    if (post.isBest) exposure *= 3.0; 

    if (Math.random() < exposure) {
        updatedPost.views += Math.floor(Math.random() * 5) + 1;
        if (Math.random() < 0.1) updatedPost.upvotes++;
    }

    if (!updatedPost.isBest && updatedPost.upvotes >= 10) {
      updatedPost.isBest = true;
      updatedPost.potential += 50; 
      updatedPost.title = `[ë…ê¸€] ${updatedPost.title}`;
    }
    return updatedPost;
  });
}


--- FILE: src/engine/system/UserActivitySystem.ts ---
import { UserProfile, PlayStyle } from '../../types';

/**
 * [ì‹œê°„ëŒ€ë³„ ì ‘ì† ê°€ì¤‘ì¹˜ í…Œì´ë¸” (0ì‹œ ~ 23ì‹œ)]
 * ê° ì„±í–¥ë³„ë¡œ í•´ë‹¹ ì‹œê°„ì— ì ‘ì†í•  í™•ë¥  ê°€ì¤‘ì¹˜ (1.0 = ë³´í†µ)
 */
const SCHEDULE_WEIGHTS: Record<PlayStyle, number[]> = {
  // ì§ì¥ì¸: í‰ì¼ ë‚®(09~18)ì—” ì ‘ì† ë¶ˆê°€, ì €ë…(19~24)ì— í”¼í¬
  'WORKER': [
    0.3, 0.1, 0.0, 0.0, 0.0, 0.0, 0.1, 0.2, 0.1, 0.0, 0.0, 0.0, // 00~11
    0.1, 0.0, 0.0, 0.0, 0.1, 0.2, 0.8, 1.5, 2.5, 3.0, 2.5, 1.0  // 12~23
  ],
  // í•™ìƒ: í•™êµ ì‹œê°„(09~15) ë‚®ìŒ, ë°©ê³¼ í›„(16~22) í”¼í¬
  'STUDENT': [
    0.2, 0.1, 0.0, 0.0, 0.0, 0.0, 0.1, 0.5, 0.2, 0.1, 0.1, 0.1, // 00~11
    0.5, 0.2, 0.2, 1.0, 2.0, 2.5, 2.5, 2.0, 1.5, 1.0, 0.5, 0.3  // 12~23
  ],
  // ì˜¬ë¹¼ë¯¸: ì‹¬ì•¼(22~05)ì— í”¼í¬, ë‚®ì— ì 
  'NIGHT_OWL': [
    3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, // 00~11
    0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.8, 1.0, 1.5, 2.0, 2.5, 3.0  // 12~23
  ],
  // íì¸: ë°¥ ë¨¹ê³  ì ìëŠ” ì‹œê°„ ë¹¼ê³  í•­ìƒ ì ‘ì†
  'HARDCORE': Array(24).fill(1.5)
};

// ì‹œê°„ëŒ€ë³„ ì „ì²´ ëª©í‘œ ì ‘ì†ë¥  (0.0 ~ 1.0) -> ì „ì²´ ìœ ì €ì˜ ëª‡ %ê°€ ì ‘ì†í•´ ìˆì–´ì•¼ í•˜ëŠ”ê°€
const GLOBAL_CCU_CURVE = [
  0.15, 0.10, 0.06, 0.04, 0.03, 0.04, 0.07, 0.12, 0.10, 0.09, 0.10, 0.12, // 00~11
  0.15, 0.14, 0.15, 0.18, 0.22, 0.25, 0.28, 0.32, 0.35, 0.32, 0.28, 0.22  // 12~23 (20ì‹œ í”¼í¬ 35%)
];

export class UserActivitySystem {
  
  static updateTraffic(hour: number, userPool: UserProfile[]) {
    if (!userPool || userPool.length === 0) return;

    // 1. í˜„ì¬ ì‹œê°„ëŒ€ ëª©í‘œ ë™ì ‘ì ìˆ˜ ê³„ì‚°
    const currentHour = Math.floor(hour) % 24;
    const baseRatio = GLOBAL_CCU_CURVE[currentHour];
    // ì•½ê°„ì˜ ëœë¤ì„± (Â±5%) ë¶€ì—¬í•˜ì—¬ ê¸°ê³„ì ì¸ ëŠë‚Œ ì œê±°
    const targetCCU = Math.floor(userPool.length * (baseRatio * (0.95 + Math.random() * 0.1)));

    // 2. í˜„ì¬ ì ‘ì†ì ìˆ˜ (INGAME í¬í•¨)
    const onlineUsers = userPool.filter(u => u.status !== 'OFFLINE');
    const currentCCU = onlineUsers.length;
    const diff = targetCCU - currentCCU;

    // 3. íŠ¸ë˜í”½ ì¡°ì • (ì ‘ì† or ì¢…ë£Œ)
    if (diff > 0) {
      // [ì ‘ì† í•„ìš”] OFFLINE ìœ ì €ë¥¼ ê¹¨ì›€
      this.loginUsers(diff, currentHour, userPool);
    } else if (diff < 0) {
      // [ì¢…ë£Œ í•„ìš”] IDLE ìœ ì €ë¥¼ ì§‘ì— ë³´ëƒ„ (ê²Œì„ ì¤‘ì¸ ìœ ì €ëŠ” ê±´ë“œë¦¬ì§€ ì•ŠìŒ)
      this.logoutUsers(Math.abs(diff), currentHour, userPool);
    }

    // 4. íœ´ì‹ ìƒíƒœ ê´€ë¦¬
    this.handleRestingUsers(userPool);
  }

  private static loginUsers(count: number, hour: number, pool: UserProfile[]) {
    const offlineUsers = pool.filter(u => u.status === 'OFFLINE');
    if (offlineUsers.length === 0) return;

    // í‹±ë‹¹ ë„ˆë¬´ ë§ì´ ì ‘ì†í•˜ë©´ ë ‰ ê±¸ë¦¬ë¯€ë¡œ ì œí•œ (ìµœëŒ€ 30ëª…ì”©)
    const limit = Math.min(count, 30);
    let loggedIn = 0;

    // ëœë¤ìœ¼ë¡œ ìœ ì €ë¥¼ ë½‘ë˜, 'ì„±í–¥'ì´ ì‹œê°„ì— ë§ì§€ ì•Šìœ¼ë©´ ì ‘ì† ê±°ë¶€
    // ì˜ˆ: ìƒˆë²½ 4ì‹œì— ì§ì¥ì¸(WORKER)ì„ ë½‘ìœ¼ë©´ ì ‘ì† í™•ë¥  ë§¤ìš° ë‚®ìŒ
    for (let i = 0; i < limit * 3; i++) { // ì‹œë„ íšŸìˆ˜ë¥¼ ë„‰ë„‰íˆ
      if (loggedIn >= limit || offlineUsers.length === 0) break;
      
      const idx = Math.floor(Math.random() * offlineUsers.length);
      const user = offlineUsers[idx];
      
      const weight = SCHEDULE_WEIGHTS[user.playStyle][hour];
      // (ê¸°ë³¸ í™•ë¥  20% * ì‹œê°„ ê°€ì¤‘ì¹˜ * ê°œì¸ í™œë™ì„±)
      const prob = 0.2 * weight * (1 + user.activityBias);

      if (Math.random() < prob) {
        // ì ‘ì† ì„±ê³µ
        user.status = 'IDLE';
        user.tiredness = 0;
        // ì´ë²ˆ ì„¸ì…˜ ëª©í‘œ íŒìˆ˜ ì„¤ì • (2~5íŒ + ì„±í–¥ ë³´ì •)
        user.sessionTarget = 2 + Math.floor(Math.random() * 4);
        if (user.playStyle === 'HARDCORE') user.sessionTarget += 5;
        
        loggedIn++;
        // ì¤‘ë³µ ë°©ì§€ë¥¼ ìœ„í•´ ë°°ì—´ì—ì„œ ì œê±° (Swap & Pop)
        offlineUsers[idx] = offlineUsers[offlineUsers.length - 1];
        offlineUsers.pop();
      }
    }
  }

  private static logoutUsers(count: number, hour: number, pool: UserProfile[]) {
    // ê²Œì„ ëŒ€ê¸°ì¤‘(IDLE)ì¸ ì‚¬ëŒë§Œ ì§‘ì— ê°ˆ ìˆ˜ ìˆìŒ
    const idleUsers = pool.filter(u => u.status === 'IDLE');
    if (idleUsers.length === 0) return;

    const limit = Math.min(count, 30);
    let loggedOut = 0;

    for (let i = 0; i < limit * 3; i++) {
      if (loggedOut >= limit || idleUsers.length === 0) break;

      const idx = Math.floor(Math.random() * idleUsers.length);
      const user = idleUsers[idx];

      // ëª©í‘œ íŒìˆ˜ë¥¼ ë‹¤ ì±„ì› ê±°ë‚˜, ì§€ê¸ˆì´ í™œë™ ì‹œê°„ì´ ì•„ë‹ˆë©´ ì´íƒˆ í™•ë¥  ì¦ê°€
      const progress = user.tiredness / (user.sessionTarget || 3);
      const weight = SCHEDULE_WEIGHTS[user.playStyle][hour];
      
      // ì´íƒˆ í™•ë¥  = (ëª©í‘œë‹¬ì„±ë„ * 0.5) + (ì‹œê°„ëŒ€ê°€ ì•ˆë§ì„ìˆ˜ë¡ ì¦ê°€)
      let prob = (progress * 0.5);
      if (weight < 0.2) prob += 0.5; // ì˜ ì‹œê°„ì´ë‹¤ ì§‘ì— ê°€ë¼

      if (Math.random() < prob) {
        user.status = 'OFFLINE';
        loggedOut++;
        idleUsers[idx] = idleUsers[idleUsers.length - 1];
        idleUsers.pop();
      }
    }
  }

  private static handleRestingUsers(pool: UserProfile[]) {
    pool.forEach(u => {
      if (u.status === 'RESTING') {
        u.restTimer -= 1;
        if (u.restTimer <= 0) {
          // íœ´ì‹ ë. í•œ íŒ í–ˆìœ¼ë¯€ë¡œ í”¼ë¡œë„ ì¦ê°€
          u.tiredness++;
          
          // ëª©í‘œ ë‹¬ì„±í–ˆìœ¼ë©´ 50% í™•ë¥ ë¡œ ë¡œê·¸ì•„ì›ƒ, ì•„ë‹ˆë©´ ë‹¤ì‹œ í ëŒë¦¼
          if (u.tiredness >= u.sessionTarget) {
             u.status = Math.random() < 0.5 ? 'OFFLINE' : 'IDLE';
          } else {
             u.status = 'IDLE';
          }
        }
      }
    });
  }
}


--- FILE: src/engine/system/UserManager.ts ---
import { Hero, UserProfile, TierConfig, PlayStyle } from '../../types';
import { generateUserName } from '../../utils/nameGenerator';

const registeredNames = new Set<string>();
export let userPool: UserProfile[] = [];

export function replaceUserPool(newUsers: UserProfile[]) {
  userPool = newUsers;
}

export function createUser(id: number, heroes: Hero[]): UserProfile {
  let tempName = generateUserName(id);
  if (!registeredNames.has(tempName)) registeredNames.add(tempName);
  else tempName = `${tempName}#${id}`;

  const hiddenMmr = 1000 + Math.floor(Math.random() * 2000);
  const mmrFactor = (hiddenMmr - 1000) / 2000;
  const baseStat = 20 + (mmrFactor * 40) + (Math.random() * 20); 

  let brain = 50, mechanics = 50;
  if (Math.random() < 0.5) { brain = baseStat * 1.2; mechanics = baseStat * 0.8; } 
  else { brain = baseStat * 0.8; mechanics = baseStat * 1.2; }
  brain = Math.min(100, Math.max(10, Math.floor(brain)));
  mechanics = Math.min(100, Math.max(10, Math.floor(mechanics)));

  const lanes = ['TOP', 'JUNGLE', 'MID', 'BOT'];
  const preferredLane = lanes[Math.floor(Math.random() * lanes.length)] as any;

  let preferredHeroes: string[] = [];
  if (heroes && heroes.length > 0) {
    const myRoleHeroes = heroes.filter(h => isHeroForLane(h, preferredLane));
    const poolSize = Math.min(myRoleHeroes.length, 3);
    preferredHeroes = myRoleHeroes.slice(0, poolSize).map(h => h.id);
    if (preferredHeroes.length === 0) preferredHeroes = [heroes[0].id];
  }

  // [í•µì‹¬] í˜„ì‹¤ì ì¸ ì„±í–¥ ë¹„ìœ¨ í• ë‹¹
  const rand = Math.random();
  let style: PlayStyle = 'WORKER'; // ê¸°ë³¸: ì§ì¥ì¸ (40%)
  if (rand < 0.4) style = 'WORKER';
  else if (rand < 0.7) style = 'STUDENT'; // í•™ìƒ (30%)
  else if (rand < 0.85) style = 'NIGHT_OWL'; // ì˜¬ë¹¼ë¯¸ (15%)
  else style = 'HARDCORE'; // íì¸ (15%)

  return {
    id, name: tempName, score: 0, hiddenMmr, tier: 'ì•„ì´ì–¸', rank: 0, isChallenger: false,
    winRate: 0, totalGames: 0, wins: 0, losses: 0,
    mainHeroId: preferredHeroes[0] || '', preferredLane, preferredHeroes,
    brain, mechanics,
    
    // ì‹ ê·œ ì†ì„± ì´ˆê¸°í™”
    playStyle: style, 
    activityBias: (Math.random() * 0.4) - 0.2, // -0.2 ~ +0.2 (í™œë™ì„± í¸ì°¨)
    tiredness: 0, 
    sessionTarget: 3,

    status: 'OFFLINE', restTimer: 0, history: [], heroStats: {}, promoStatus: null,
    mostChamps: [], laneStats: []
  };
}

function isHeroForLane(hero: Hero, lane: string) {
  if (lane === 'TOP') return hero.role === 'ìˆ˜í˜¸ê¸°ì‚¬' || hero.role === 'ì§‘í–‰ê´€';
  if (lane === 'MID') return hero.role === 'ì„ ì§€ì' || hero.role === 'ì¶”ì ì';
  if (lane === 'BOT') return hero.role === 'ì‹ ì‚´ì';
  if (lane === 'JUNGLE') return hero.role === 'ì¶”ì ì' || hero.role === 'ì§‘í–‰ê´€';
  return true;
}

export function getUserTierName(user: UserProfile, config: TierConfig) {
  const cfg = config || { challengerRank:50, master:4800, ace:3800, joker:3200, gold:2100, silver:1300, bronze:300 };
  if (user.isChallenger) return 'ì²œìƒê³„';
  if (user.score >= cfg.master) return 'ë§ˆìŠ¤í„°';
  if (user.score >= cfg.ace) return 'ì—ì´ìŠ¤';
  if (user.score >= cfg.joker) return 'ì¡°ì»¤';
  if (user.score >= cfg.gold) return 'ê³¨ë“œ';
  if (user.score >= cfg.silver) return 'ì‹¤ë²„';
  if (user.score >= cfg.bronze) return 'ë¸Œë¡ ì¦ˆ';
  return 'ì•„ì´ì–¸';
}

export function initUserPool(heroes: Hero[], count: number = 3000) {
  const startId = userPool.length;
  if (count > userPool.length) {
    const newUsersCount = count - userPool.length;
    for(let i=0; i<newUsersCount; i++) userPool.push(createUser(startId + i, heroes));
  }
}

// êµ¬ë²„ì „ í˜¸í™˜ìš© (ì‚¬ìš© ì•ˆí•¨)
export function updateUserActivity(hour: number, heroes: Hero[]) {}

export function getTopRankers(heroes: Hero[], config: TierConfig): UserProfile[] {
  const sorted = [...userPool].sort((a, b) => b.score - a.score || a.id - b.id);
  return sorted.slice(0, 50).map(u => ({ ...u, tier: getUserTierName(u, config) }));
}

export function getUsersInTier(tierName: string, config: TierConfig): UserProfile[] {
  return userPool
    .filter(u => getUserTierName(u, config) === tierName)
    .sort((a, b) => b.score - a.score);
}

export function findUserProfileByName(name: string, config: TierConfig): UserProfile | null {
  const user = userPool.find(u => u.name === name);
  if (!user) return null;
  return { ...user, tier: getUserTierName(user, config) };
}

export function getTierNameHelper(score: number, config: TierConfig) {
  return getUserTierName({ score, isChallenger: false } as UserProfile, config);
}


--- FILE: src/engine/system/RankingSystem.ts ---
// ==========================================
// FILE PATH: /src/engine/system/RankingSystem.ts
// ==========================================
import { Hero, UserStatus, TierStat, TierConfig, Tier, UserProfile } from '../../types';
import { userPool } from './UserManager';

const safeDiv = (num: number, den: number) => (!den || den === 0 ? 0 : num / den);

export function analyzeHeroMeta(heroes: Hero[]): Hero[] {
  // [Safety] ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì¦‰ì‹œ ì¢…ë£Œ
  if (!heroes || !Array.isArray(heroes) || heroes.length === 0) return [];

  // ê¸€ë¡œë²Œ í”½ í†µê³„ ê³„ì‚°
  const totalGlobalPicks = heroes.reduce((sum, h) => sum + (h?.record?.totalPicks || 0), 0);
  const totalGlobalGames = Math.max(1, Math.floor(totalGlobalPicks / 10));

  const scoredHeroes = heroes.map(h => {
    if (!h) return null; 

    const r = h.record || { 
      totalMatches: 0, totalWins: 0, recentResults: [], totalBans: 0, 
      totalPicks: 0, totalKills: 0, totalDeaths: 0, totalAssists: 0, 
      totalDamage: 0, totalDamageTaken: 0, totalCs: 0, totalGold: 0 
    };
    
    const matches = Math.max(1, r.totalMatches);
    const totalWinRate = matches > 0 ? (r.totalWins / matches) * 100 : 50;
    
    // [ìµœê·¼ ì „ì  ê³„ì‚°]
    const recentResults = Array.isArray(r.recentResults) ? r.recentResults : [];
    const recentCount = recentResults.length;
    let recentWinRate = totalWinRate; // ê¸°ë³¸ê°’ì€ ì „ì²´ ìŠ¹ë¥ 

    if (recentCount > 0) {
        const recentWins = recentResults.filter(win => win).length;
        recentWinRate = (recentWins / recentCount) * 100;
    }

    // ---------------------------------------------------------------
    // [í•µì‹¬ ìˆ˜ì •] ë©”íƒ€ ë°˜ì‘ì„± ê°•í™”
    // ---------------------------------------------------------------
    
    // 1. ê°€ì¤‘ì¹˜ ë³€ê²½: ìµœê·¼ ìŠ¹ë¥  ë¹„ì¤‘ì„ 30% -> 70%ë¡œ ëŒ€í­ ìƒí–¥
    // (íŒ¨ì¹˜ë‚˜ ì—ë””í„° ìˆ˜ì • ì§í›„ì˜ ì„±ëŠ¥ì„ ë” ì¤‘ìš”í•˜ê²Œ ë´„)
    let weightedWinRate = (totalWinRate * 0.3) + (recentWinRate * 0.7);
    if (isNaN(weightedWinRate)) weightedWinRate = 50;

    // 2. ì‹ ë¢°ë„ ì„ê³„ê°’(Threshold) í•˜í–¥: 2000íŒ -> 100íŒ
    // 100íŒë§Œ ìŒ“ì—¬ë„ ë°ì´í„°ë¥¼ 100% ì‹ ë¢°í•¨ (ê¸°ì¡´ì—” 2000íŒ í•„ìš”í–ˆìŒ)
    const TRUST_THRESHOLD = 100;

    if (matches < TRUST_THRESHOLD) {
       // ì‹ ë¢°ë„ê°€ ë‚®ì•„ë„, ìµœì†Œ 30%ëŠ” ì‹¤ì œ ìŠ¹ë¥ ì„ ë°˜ì˜í•˜ì—¬ "ê°€ëŠ¥ì„±"ì„ ë³´ì—¬ì¤Œ
       // (ê¸°ì¡´ì—ëŠ” 0%ì—ì„œ ì‹œì‘í•´ì„œ 50%ì— ê³ ì •ë˜ì—ˆìŒ)
       const factor = Math.max(0.3, matches / TRUST_THRESHOLD);
       weightedWinRate = (weightedWinRate * factor) + (50 * (1 - factor));
    }

    // ---------------------------------------------------------------

    // [OP Score ì‚°ì¶œ]
    let winScore = (weightedWinRate - 50) * 4.0; // ìŠ¹ë¥  1% ì°¨ì´ë‹¹ 4ì 
    const banRate = (r.totalBans / totalGlobalGames) * 100;
    const banScore = isNaN(banRate) ? 0 : banRate * 1.0; // ë°´ë¥  ê°€ì¤‘ì¹˜ ìƒí–¥
    const pickRate = (r.totalPicks / totalGlobalGames) * 100;
    let pickScore = isNaN(pickRate) ? 0 : pickRate * 0.5;

    // ìŠ¹ë¥ ì´ ë‚®ìœ¼ë©´ í”½ë¥ /ë°´ë¥  ì ìˆ˜ ì‚­ê° (ê±°í’ˆ ì œê±°)
    if (weightedWinRate < 49) { pickScore *= 0.5; winScore -= 5; }
    if (weightedWinRate < 47) winScore -= 15;
    if (weightedWinRate < 45) winScore -= 30;

    const opScore = winScore + banScore + pickScore;

    // í†µê³„ ë¬¸ìì—´ í¬ë§·íŒ…
    const k = safeDiv(r.totalKills, matches);
    const d = safeDiv(r.totalDeaths, matches);
    const a = safeDiv(r.totalAssists, matches);
    const kdaVal = d < 1 ? (k + a) : (k + a) / d;

    // [ìˆ˜ì • ì™„ë£Œ] í…œí”Œë¦¿ ë¦¬í„°ëŸ´ ë¬¸ë²• ì •ìƒí™” (ì—­ìŠ¬ë˜ì‹œ ì œê±°ë¨)
    return {
      ...h,
      recentWinRate: weightedWinRate, 
      pickRate: pickRate || 0,
      banRate: banRate || 0,
      opScore: opScore || 0, 
      avgKda: `${k.toFixed(1)}/${d.toFixed(1)}/${a.toFixed(1)}`,
      kdaRatio: kdaVal.toFixed(2),
      avgDpm: Math.floor((r.totalDamage / matches) / 20).toLocaleString(), 
      avgDpg: Math.floor((r.totalDamageTaken / matches) / 20).toLocaleString(),
      avgCs: (r.totalCs / matches).toFixed(1),
      avgGold: Math.floor(r.totalGold / matches).toLocaleString(),
    };
  }).filter(h => h !== null) as Hero[];

  // ì ìˆ˜ ê¸°ë°˜ ì •ë ¬
  scoredHeroes.sort((a, b) => ((b as any).opScore || 0) - ((a as any).opScore || 0));

  // í‹°ì–´ í• ë‹¹
  return scoredHeroes.map((h, index) => {
    const rank = index + 1;
    const score = (h as any).opScore || 0;
    let tier: Tier = '3';

    // í‹°ì–´ ì»·ë¼ì¸ ì¡°ì •
    if (score >= 60 && rank <= 5) tier = 'OP';      // ê¸°ì¤€ ì™„í™” (80 -> 60)
    else if (score >= 30) tier = '1';               // ê¸°ì¤€ ì™„í™” (40 -> 30)
    else if (score >= 10) tier = '2';
    else if (score >= -10) tier = '3';
    else if (score >= -40) tier = '4';
    else tier = '5';

    // í•˜ìœ„ê¶Œ ê°•ì œ í• ë‹¹
    if (rank >= 46) tier = '5'; 
    else if (rank >= 41 && tier !== '5') tier = '4';

    return { ...h, rank, tier };
  });
}

// (ê¸°ì¡´ ìœ ì € ìƒíƒœê³„ ê³„ì‚° ë¡œì§ ìœ ì§€)
export function calculateUserEcosystem(ccu: number, totalUsers: number, config: TierConfig): UserStatus {
  if (!userPool || !Array.isArray(userPool)) {
      return { totalGames: 0, playingUsers: 0, queuingUsers: 0, avgWaitTime: 0, tierDistribution: [] };
  }

  const cfg = config || { master: 4800, ace: 3800, joker: 3200, gold: 2100, silver: 1300, bronze: 300 };

  const playingUsers = userPool.filter(u => u && u.status === 'INGAME').length;
  const queuingUsers = userPool.filter(u => u && (u.status === 'QUEUE' || u.status === 'IDLE')).length;
  
  const tiers: TierStat[] = [
    { name: 'ì²œìƒê³„', minScore: 9999, color: '#00bfff', count: 0, percent: 0 },
    { name: 'ë§ˆìŠ¤í„°', minScore: cfg.master || 4800, color: '#9b59b6', count: 0, percent: 0 },
    { name: 'ì—ì´ìŠ¤', minScore: cfg.ace || 3800, color: '#e74c3c', count: 0, percent: 0 },
    { name: 'ì¡°ì»¤', minScore: cfg.joker || 3200, color: '#2ecc71', count: 0, percent: 0 },
    { name: 'ê³¨ë“œ', minScore: cfg.gold || 2100, color: '#f1c40f', count: 0, percent: 0 },
    { name: 'ì‹¤ë²„', minScore: cfg.silver || 1300, color: '#95a5a6', count: 0, percent: 0 },
    { name: 'ë¸Œë¡ ì¦ˆ', minScore: cfg.bronze || 300, color: '#d35400', count: 0, percent: 0 },
    { name: 'ì•„ì´ì–¸', minScore: 0, color: '#7f8c8d', count: 0, percent: 0 },
  ];

  userPool.forEach(u => {
    if (!u) return;
    const score = typeof u.score === 'number' ? u.score : 0;
    
    let assigned = false;
    if (u.isChallenger) {
        tiers[0].count++;
        assigned = true;
    } else {
        for (let i = 1; i < tiers.length; i++) { 
            if (score >= tiers[i].minScore) { 
                tiers[i].count++; 
                assigned = true; 
                break; 
            } 
        }
    }
    
    if (!assigned) tiers[tiers.length - 1].count++;
  });

  const totalTracked = Math.max(1, userPool.length);
  tiers.forEach(t => { t.percent = parseFloat(((t.count / totalTracked) * 100).toFixed(1)); });

  return { 
    totalGames: Math.floor(playingUsers / 10), 
    playingUsers, 
    queuingUsers, 
    avgWaitTime: Math.max(5, Math.floor(120 / ((queuingUsers / 10) + 1))), 
    tierDistribution: tiers 
  };
}


--- FILE: src/engine/spectate/SpectateAI.ts ---
// src/engine/SpectateAI.ts
import { LivePlayer } from '../types';

export interface VisualUnit extends LivePlayer {
  vx: number;
  vy: number;
  role: string;
}

const getDist = (x1: number, y1: number, x2: number, y2: number) => 
  Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));

export function updateUnitAI(
  u: VisualUnit, 
  allies: VisualUnit[], 
  enemies: VisualUnit[], 
  isBlue: boolean
): VisualUnit {

  // 1. ì‚¬ë§ ì‹œ ê¸°ì§€ ìœ„ì¹˜ ê³ ì •
  if (u.currentHp <= 0) {
    u.vx = isBlue ? 12 : 88;
    u.vy = isBlue ? 88 : 12;
    return u;
  }

  // 2. ì  íƒì§€
  let target: VisualUnit | null = null;
  let minDist = 20; // ì¸ì‹ ë²”ìœ„ 20%

  enemies.forEach(e => {
    if (e.currentHp > 0) {
      const d = getDist(u.vx, u.vy, e.vx, e.vy);
      if (d < minDist) { minDist = d; target = e; }
    }
  });

  const speed = 0.25; // ì´ë™ ì†ë„ (ì˜ìƒë³´ë‹¤ ë” ë¹ ë¥´ê²Œ ì„¤ì •)

  if (target) {
    const d = getDist(u.vx, u.vy, target.vx, target.vy);
    if (d > 4) { // ì‚¬ê±°ë¦¬ ë°–ì´ë©´ ì¶”ê²©
      u.vx += ((target.vx - u.vx) / d) * speed;
      u.vy += ((target.vy - u.vy) / d) * speed;
    } else {
      // êµì „ ì¤‘ (ë¯¸ì„¸í•œ ë–¨ë¦¼)
      u.vx += (Math.random() - 0.5) * 0.15;
      u.vy += (Math.random() - 0.5) * 0.15;
    }
  } else {
    // [ë¼ì¸ ì´ë™]
    const dest = getLanePath(u.lane, isBlue, u.vx, u.vy);
    const dDest = getDist(u.vx, u.vy, dest.x, dest.y);
    if (dDest > 1) {
      u.vx += ((dest.x - u.vx) / dDest) * speed;
      u.vy += ((dest.y - u.vy) / dDest) * speed;
    }
  }

  // ìœ ë‹›ë¼ë¦¬ ë„ˆë¬´ ê²¹ì¹˜ì§€ ì•Šê²Œ ë°€ì–´ë‚´ê¸°
  allies.forEach(mate => {
    if (mate.name === u.name) return;
    if (getDist(u.vx, u.vy, mate.vx, mate.vy) < 2) {
      u.vx += (Math.random() - 0.5) * 0.1;
      u.vy += (Math.random() - 0.5) * 0.1;
    }
  });

  return u;
}

function getLanePath(lane: string, isBlue: boolean, cx: number, cy: number) {
  const blueBase = { x: 12, y: 88 };
  const redBase = { x: 88, y: 12 };
  const target = isBlue ? redBase : blueBase;

  if (lane === 'MID') return target;
  if (lane === 'TOP') {
    if (isBlue) return cy > 15 ? { x: 12, y: 12 } : target;
    return cx > 15 ? { x: 12, y: 12 } : target;
  }
  if (lane === 'BOT') {
    if (isBlue) return cx < 85 ? { x: 88, y: 88 } : target;
    return cy < 85 ? { x: 88, y: 88 } : target;
  }
  return { x: 50, y: 50 };
}

--- FILE: src/engine/spectate/SpectateEngine.ts ---
// ==========================================
// FILE PATH: /src/engine/spectate/SpectateEngine.ts
// ==========================================

export const MAP = {
  BLUE_BASE: { x: 15, y: 85 },
  RED_BASE: { x: 85, y: 15 },
  CENTER: { x: 50, y: 50 }
};

// [ë³´ê°„ í•¨ìˆ˜] í˜„ì¬ UI ì¢Œí‘œ(current)ë¥¼ ëª©í‘œ ì‹œë®¬ë ˆì´ì…˜ ì¢Œí‘œ(target)ë¡œ ë¶€ë“œëŸ½ê²Œ ì´ë™
export const lerpPosition = (current: {x:number, y:number}, target: {x:number, y:number}, factor: number) => {
  const dx = target.x - current.x;
  const dy = target.y - current.y;
  
  // ê±°ë¦¬ê°€ ë„ˆë¬´ ë©€ë©´(í…”ë ˆí¬íŠ¸, ê·€í™˜ ë“±) ìˆœê°„ì´ë™ ì²˜ë¦¬ (ë¶€ë“œëŸ¬ìš´ ì´ë™ ìƒëµ)
  if (Math.abs(dx) > 20 || Math.abs(dy) > 20) return target;

  return {
    x: current.x + dx * factor,
    y: current.y + dy * factor
  };
};


--- FILE: src/engine/match/phases/CombatPhase.ts ---
// ==========================================
// FILE PATH: /src/engine/match/phases/CombatPhase.ts
// ==========================================
import { LiveMatch, Hero, BattleSettings, RoleSettings } from '../../../types';
import { getLevelScaledStats } from '../utils/StatUtils';
import { TargetEvaluator } from '../ai/evaluators/TargetEvaluator';
import { Collision } from '../utils/Collision';
import { SpatialGrid } from '../utils/SpatialGrid'; // [ì‹ ê·œ]
import { 
    calculateHeroDamage, 
    calculateUnitDamage, 
    distributeAssist, 
    distributeRewards,
    MINION_REWARD 
} from '../logics/CombatLogic';

export const processCombatPhase = (
  match: LiveMatch, 
  heroes: Hero[], 
  settings: BattleSettings, 
  roleSettings: RoleSettings, 
  watcherBuffType: string, 
  watcherBuffAmount: number,
  dt: number
) => {
  const blueAlive = match.blueTeam.filter(p => p.currentHp > 0 && p.respawnTimer <= 0);
  const redAlive = match.redTeam.filter(p => p.currentHp > 0 && p.respawnTimer <= 0);

  if (blueAlive.length === 0 && redAlive.length === 0) return;

  // [ìµœì í™”] ë§¤ í”„ë ˆì„ ê·¸ë¦¬ë“œ êµ¬ì¶• (ë¹„ìš© ì €ë ´í•¨)
  const enemyGrid = {
      BLUE: new SpatialGrid(redAlive), // ë¸”ë£¨íŒ€ ì…ì¥ì—ì„œì˜ ì (ë ˆë“œ)
      RED: new SpatialGrid(blueAlive)  // ë ˆë“œíŒ€ ì…ì¥ì—ì„œì˜ ì (ë¸”ë£¨)
  };
  
  // ë¯¸ë‹ˆì–¸ ê·¸ë¦¬ë“œ êµ¬ì¶•
  const minionList = match.minions || [];
  const minionGrid = {
      BLUE: new SpatialGrid(minionList.filter(m => m.team === 'RED' && m.hp > 0)),
      RED: new SpatialGrid(minionList.filter(m => m.team === 'BLUE' && m.hp > 0))
  };

  const allAttackers = [...blueAlive, ...redAlive];
  allAttackers.sort(() => Math.random() - 0.5);

  allAttackers.forEach(attacker => {
      const isBlue = match.blueTeam.includes(attacker);
      const enemyTeamKey = isBlue ? 'BLUE' : 'RED'; // ë‚´ ì…ì¥ì—ì„œì˜ ì  ê·¸ë¦¬ë“œ í‚¤

      const attackerHero = heroes.find(h => h.id === attacker.heroId);
      if (!attackerHero) return;

      const atkStats = getLevelScaledStats(attackerHero.stats, attacker.level);
      const attackRange = atkStats.range / 100;

      // -------------------------------------------------------------
      // 1. [ìµœìš°ì„ ] CS ë§‰íƒ€ (Smart Farming)
      // -------------------------------------------------------------
      let farmed = false;

      if (match.minions && attacker.lane !== 'JUNGLE') {
          // [ìµœì í™”] ì „ì²´ ë¯¸ë‹ˆì–¸ ë£¨í”„ ëŒ€ì‹ , ë‚´ ì£¼ë³€ ë¯¸ë‹ˆì–¸ë§Œ ê°€ì ¸ì˜´ (ìˆ˜ë°±ë²ˆ -> ìˆ˜ì‹­ë²ˆìœ¼ë¡œ ê°ì†Œ)
          const nearbyMinions = minionGrid[enemyTeamKey].getNearbyUnits(attacker);
          
          const minionsInRange = nearbyMinions.filter(m => Collision.inRange(attacker, m, attackRange));

          if (minionsInRange.length > 0) {
              const myDamage = calculateUnitDamage(attacker, atkStats, 5, isBlue, settings);
              
              // ì²˜í˜• ì„ê³„ê°’
              let executeThreshold = myDamage * 2.5; 
              if (attackerHero.role === 'ìˆ˜í˜¸ê¸°ì‚¬') {
                  if (Math.random() < 0.05) executeThreshold = myDamage * 6.0; 
                  else return; 
              }

              const targetMinion = TargetEvaluator.selectFarmTarget(attacker, minionsInRange, executeThreshold);

              if (targetMinion) {
                  if (targetMinion.hp <= executeThreshold) targetMinion.hp = 0;
                  else targetMinion.hp -= myDamage;
                  
                  attacker.totalDamageDealt += myDamage;

                  if (targetMinion.hp <= 0) {
                      const reward = (MINION_REWARD as any)[targetMinion.type] || MINION_REWARD.MELEE;
                      attacker.cs++;
                      attacker.gold += reward.gold;
                      distributeRewards(match, targetMinion, attacker, isBlue ? 'BLUE' : 'RED', reward, heroes);

                      if (targetMinion.type === 'SUMMONED_COLOSSUS') {
                          match.logs.push({ 
                              time: Math.floor(match.currentDuration), 
                              message: `âš”ï¸ [${attackerHero.name}]ê°€ ì ì˜ ê±°ì‹ ë³‘ì„ ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤!`, 
                              type: 'KILL', team: isBlue ? 'BLUE' : 'RED' 
                          });
                      }
                  }
                  farmed = true;
              }
          }
      }

      if (farmed) return;

      // -------------------------------------------------------------
      // 2. ì  ì˜ì›… íƒ€ê²ŸíŒ…
      // -------------------------------------------------------------
      if (Math.random() < dt * 2.0) {
          // [ìµœì í™”] ë‚´ ì£¼ë³€ ì  ì˜ì›…ë§Œ íƒìƒ‰
          const nearbyEnemies = enemyGrid[enemyTeamKey].getNearbyUnits(attacker);
          const targetsInRange = nearbyEnemies.filter(e => Collision.inRange(attacker, e, attackRange));

          if (targetsInRange.length > 0) {
              const defender = TargetEvaluator.selectBestTarget(attacker, attackerHero, targetsInRange, heroes);
              if (defender) {
                attacker.lastAttackTime = match.currentDuration;
                attacker.lastAttackedTargetId = defender.heroId;

                const defenderHero = heroes.find(h => h.id === defender.heroId);
                if (defenderHero) {
                    const defStats = getLevelScaledStats(defenderHero.stats, defender.level);
                    const damage = calculateHeroDamage(attacker, defender, atkStats, defStats, attackerHero, isBlue, settings, roleSettings, watcherBuffType);
                    
                    defender.currentHp -= damage;
                    attacker.totalDamageDealt += damage;

                    if (defender.currentHp <= 0) {
                        attacker.kills++; defender.deaths++; attacker.gold += 300;
                        distributeAssist(match, attacker, defender, isBlue);

                        if (isBlue) match.score.blue++; else match.score.red++;
                        match.logs.push({ 
                            time: Math.floor(match.currentDuration), 
                            message: `ğŸ’€ [${attackerHero.name}]ê°€ [${defenderHero.name}] ì²˜ì¹˜!`, 
                            type: 'KILL', team: isBlue ? 'BLUE' : 'RED' 
                        });
                        defender.currentHp = 0;
                        defender.respawnTimer = 10 + (defender.level * 2);
                    }
                }
                return;
              }
          }
      }
  });
};


--- FILE: src/engine/match/phases/GrowthPhase.ts ---
// ==========================================
// FILE PATH: /src/engine/match/phases/GrowthPhase.ts
// ==========================================
import { LiveMatch, BattleSettings, Hero, BattlefieldSettings } from '../../../types';
import { updateLivePlayerStats } from '../systems/ItemManager';

const getRequiredExpForLevel = (level: number): number => {
  if (level >= 18) return 999999;
  return 250 + (level * 90) + (Math.pow(level, 2) * 5);
};

export const processGrowthPhase = (
  match: LiveMatch, 
  battleSettings: BattleSettings,
  fieldSettings: BattlefieldSettings,
  heroes: Hero[], 
  dt: number
) => {
  const allPlayers = [...match.blueTeam, ...match.redTeam];

  allPlayers.forEach(p => {
    if (p.respawnTimer > 0) return;

    const heroData = heroes.find(h => h.id === p.heroId);
    if (!heroData) return;

    // 1. ê¸°ë³¸ íšŒë³µ
    const mpRegen = p.mpRegen || 5;
    const hpRegen = (p as any).hpRegen || heroData.stats.regen; 

    if (p.currentMp < p.maxMp) {
        p.currentMp = Math.min(p.maxMp, p.currentMp + (mpRegen * dt));
    }
    if (p.currentHp < p.maxHp) {
        p.currentHp = Math.min(p.maxHp, p.currentHp + (hpRegen * dt));
    }

    // 2. [ì •ìƒí™”] ìì—° ê³¨ë“œ/ê²½í—˜ì¹˜ (í˜„ì‹¤ì  ìˆ˜ì¹˜)
    // ë¶„ë‹¹ 180ê³¨ë“œ (ì´ˆë‹¹ 3)
    p.gold += (3.0 * dt);
    // ìì—° ê²½í—˜ì¹˜ëŠ” ì•„ì£¼ ì¡°ê¸ˆë§Œ (ë¼ì¸ ì„œìˆìœ¼ë©´ ë¨¹ëŠ”ê±´ CombatPhase ë“±ì—ì„œ ì²˜ë¦¬)
    (p as any).exp = ((p as any).exp || 0) + (2.0 * dt);

    // 3. ë ˆë²¨ì—… ì²˜ë¦¬
    let reqExp = getRequiredExpForLevel(p.level);
    
    while ((p as any).exp >= reqExp && p.level < 18) {
        (p as any).exp -= reqExp;
        p.level++;

        const oldMaxHp = p.maxHp;
        const oldMaxMp = p.maxMp;

        updateLivePlayerStats(p, heroData);

        p.currentHp += (p.maxHp - oldMaxHp) + 100; 
        p.currentMp += (p.maxMp - oldMaxMp) + 100;

        match.logs.push({
            time: Math.floor(match.currentDuration),
            message: `ğŸ†™ [${heroData.name}] ${p.level}ë ˆë²¨ ë‹¬ì„±!`,
            type: 'LEVELUP',
            team: match.blueTeam.includes(p) ? 'BLUE' : 'RED'
        });

        reqExp = getRequiredExpForLevel(p.level);
    }

    // 4. ë¹„ìƒ ê·€í™˜
    const isLowHp = p.currentHp < p.maxHp * 0.2; 
    const isLowMp = p.currentMp < p.maxMp * 0.1; 
    const hasLotsOfGold = p.gold > 2000; 

    if ((isLowHp || isLowMp || hasLotsOfGold) && Math.random() < 0.1 * dt) {
        p.currentHp += p.maxHp * 0.05 * dt; 
    }
  });
};


--- FILE: src/engine/match/phases/SiegePhase.ts ---
// ==========================================
// FILE PATH: /src/engine/match/phases/SiegePhase.ts
// ==========================================
import { LiveMatch, Hero, RoleSettings, BattlefieldSettings, BattleSettings } from '../../../types';
import { applyRoleBonus } from '../systems/RoleManager';
import { getDistance, BASES } from '../../data/MapData';
import { TOWER_COORDS } from '../constants/MapConstants';
import { TowerLogic } from '../logics/TowerLogic';
// [ìˆ˜ì •] DamageCalculator ì„í¬íŠ¸
import { calcMitigatedDamage } from '../systems/DamageCalculator';

const getTowerPos = (lane: string, tier: number, isBlueSide: boolean) => {
  const coords = isBlueSide ? TOWER_COORDS.BLUE : TOWER_COORDS.RED;
  if (lane === 'MID') return coords.MID[tier - 1];
  if (lane === 'TOP') return coords.TOP[tier - 1];
  if (lane === 'BOT') return coords.BOT[tier - 1];
  return coords.NEXUS;
};

export const processSiegePhase = (
  match: LiveMatch, 
  heroes: Hero[], 
  fieldSettings: BattlefieldSettings,
  roleSettings: RoleSettings, 
  battleSettings: BattleSettings, 
  dt: number
) => {
  const allPlayers = [...match.blueTeam, ...match.redTeam];
  
  allPlayers.forEach(p => {
    if (p.currentHp <= 0 || p.respawnTimer > 0) return;

    const isBlue = match.blueTeam.includes(p);
    const enemyStats = isBlue ? match.stats.red : match.stats.blue;
    const enemyBase = isBlue ? BASES.RED : BASES.BLUE;
    
    const hero = heroes.find(h => h.id === p.heroId);
    if (!hero) return;

    // íƒ€ì›Œ ê³µê²©
    if (p.lane !== 'JUNGLE') {
        const laneKey = p.lane.toLowerCase();
        const brokenCount = (enemyStats.towers as any)[laneKey];

        if (brokenCount < 3) {
            const targetTier = brokenCount + 1;
            const towerPos = getTowerPos(p.lane, targetTier, !isBlue);
            const dist = getDistance(p, towerPos);

            if (dist <= 10) {
                const tStats = (fieldSettings.towers as any)[`t${targetTier}`];
                const { siegeMod } = applyRoleBonus(p, hero.role, true, [], roleSettings);
                
                const myStats = isBlue ? match.stats.blue : match.stats.red;
                const buffFactor = myStats.activeBuffs.siegeUnit ? 1.5 : 1.0;

                const rawDmg = hero.stats.ad * siegeMod * buffFactor;
                const realDmg = calcMitigatedDamage(rawDmg, tStats.armor) * dt;
                
                if (!(enemyStats as any).laneHealth) {
                    (enemyStats as any).laneHealth = { top: 10000, mid: 10000, bot: 10000 };
                }
                
                (enemyStats as any).laneHealth[laneKey] -= realDmg;

                if ((enemyStats as any).laneHealth[laneKey] <= 0) {
                    (enemyStats.towers as any)[laneKey]++;
                    (isBlue ? match.blueTeam : match.redTeam).forEach(m => m.gold += tStats.rewardGold);
                    
                    match.logs.push({ 
                        time: Math.floor(match.currentDuration), 
                        message: `ğŸ”¥ [${hero.name}] ${targetTier}ì°¨ í¬íƒ‘ ì² ê±°!`, 
                        type: 'TOWER', team: isBlue ? 'BLUE' : 'RED' 
                    });
                    
                    if (brokenCount + 1 < 3) {
                        const nextStats = (fieldSettings.towers as any)[`t${targetTier + 1}`];
                        (enemyStats as any).laneHealth[laneKey] = nextStats.hp;
                    }
                }
            }
        }
    }

    // ë„¥ì„œìŠ¤ ê³µê²©
    const inhibitorsDown = enemyStats.towers.top >= 3 || enemyStats.towers.mid >= 3 || enemyStats.towers.bot >= 3;
    if (inhibitorsDown) {
        const distToNexus = getDistance(p, enemyBase);
        if (distToNexus <= 12) { 
            const nStats = fieldSettings.towers.nexus;
            const { siegeMod } = applyRoleBonus(p, hero.role, true, [], roleSettings);
            const buffFactor = (isBlue ? match.stats.blue : match.stats.red).activeBuffs.siegeUnit ? 2.5 : 1.0;
            const rawDmg = hero.stats.ad * siegeMod * buffFactor;
            const realDmg = calcMitigatedDamage(rawDmg, nStats.armor) * dt;

            enemyStats.nexusHp -= realDmg;
        }
    }
  });

  // êµ¬ì¡°ë¬¼ ë°©ì–´ (íƒ€ì›Œ ì–´ê·¸ë¡œ)
  const lanes = ['TOP', 'MID', 'BOT'];
  const teams = ['BLUE', 'RED'] as const;

  teams.forEach(defendingTeam => {
      const isBlueDef = defendingTeam === 'BLUE';
      const myStats = isBlueDef ? match.stats.blue : match.stats.red;
      
      const allies = isBlueDef ? match.blueTeam : match.redTeam; 
      const enemies = {
          heroes: isBlueDef ? match.redTeam : match.blueTeam,
          minions: (match.minions || []).filter(m => m.team !== defendingTeam)
      };

      // A. ë ˆì¸ íƒ€ì›Œ
      lanes.forEach(lane => {
          const laneKey = lane.toLowerCase();
          const brokenCount = (myStats.towers as any)[laneKey];
          
          if (brokenCount < 3) {
              const currentTier = brokenCount + 1;
              const towerPos = getTowerPos(lane, currentTier, isBlueDef);
              const towerStats = (fieldSettings.towers as any)[`t${currentTier}`];

              const target = TowerLogic.selectTarget(towerPos, enemies, allies, 12, match.currentDuration);
              if (target) {
                  const hasMinions = enemies.minions.some(m => m.hp > 0 && getDistance(m, towerPos) <= 12);
                  TowerLogic.applyDamage(target, towerStats, dt, false, hasMinions);
              }
          }
      });

      // B. ë„¥ì„œìŠ¤ íƒ€ì›Œ
      const inhibitorsDown = myStats.towers.top >= 3 || myStats.towers.mid >= 3 || myStats.towers.bot >= 3;
      if (inhibitorsDown) {
          const nexusPos = isBlueDef ? BASES.BLUE : BASES.RED;
          const nexusStats = fieldSettings.towers.nexus;
          
          const target = TowerLogic.selectTarget(nexusPos, enemies, allies, 15, match.currentDuration);
          if (target) {
              const hasMinions = enemies.minions.some(m => m.hp > 0 && getDistance(m, nexusPos) <= 15);
              TowerLogic.applyDamage(target, nexusStats, dt, true, hasMinions);
          }
      }
  });
};


--- FILE: src/engine/match/systems/RoleManager.ts ---
// ==========================================
// FILE PATH: /src/engine/match/RoleManager.ts
// ==========================================

import { Role, LivePlayer, RoleSettings } from '../../../types';

// ê¸°ë³¸ê°’ (ì„¤ì • ë¡œë“œ ì‹¤íŒ¨ ì‹œ ì•ˆì „ì¥ì¹˜)
const DEFAULT_SETTINGS: RoleSettings = {
  executor: { damage: 15, defense: 15 },
  tracker: { gold: 20, smiteChance: 1.5 },
  prophet: { cdrPerLevel: 2 },
  slayer: { structureDamage: 30 },
  guardian: { survivalRate: 20 }
};

export const applyRoleBonus = (
  player: LivePlayer, 
  role: Role, 
  isSiegeMode: boolean, 
  allies: LivePlayer[],
  settings: RoleSettings = DEFAULT_SETTINGS // [ì¤‘ìš”] ì„¤ì •ê°’ ì¸ì ì¶”ê°€
) => {
  let damageMod = 1.0;
  let defenseMod = 1.0;
  let siegeMod = 1.0;

  switch (role) {
    case 'ì§‘í–‰ê´€': 
      // ê³ ë¦½ ì‹œ ë³´ë„ˆìŠ¤ (ì„¤ì •ëœ %ë§Œí¼ ì¦ê°€)
      const nearbyAllies = allies.filter(a => a.lane === player.lane && a.heroId !== player.heroId).length;
      if (nearbyAllies === 0) {
        damageMod = 1 + (settings.executor.damage / 100); 
        defenseMod = 1 + (settings.executor.defense / 100);
      }
      break;

    case 'ì¶”ì ì': 
      // ì •ê¸€ëŸ¬ ê¸°ë³¸ ë³´ì •
      damageMod = 1.05; 
      break;

    case 'ì„ ì§€ì': 
      // ë ˆë²¨ë‹¹ ì„¤ì •ëœ %ë§Œí¼ ë°ë¯¸ì§€ ë³´ë„ˆìŠ¤ (ì¿¨ê°ì„ ë”œëŸ‰ìœ¼ë¡œ í™˜ì‚°)
      // ì˜ˆ: ë ˆë²¨ 10 * 2% = 20% ë°ë¯¸ì§€ ì¦ê°€
      damageMod = 1 + ((player.level * settings.prophet.cdrPerLevel) / 100);
      break;

    case 'ì‹ ì‚´ì': 
      if (isSiegeMode) {
        // êµ¬ì¡°ë¬¼ í”¼í•´ëŸ‰ ë³´ë„ˆìŠ¤
        siegeMod = 1 + (settings.slayer.structureDamage / 100);
      }
      if (player.items.length >= 3) {
        damageMod = 1.25;
      }
      break;

    case 'ìˆ˜í˜¸ê¸°ì‚¬': 
      // ë°©ì–´ë ¥ ë³´ë„ˆìŠ¤
      defenseMod = 1.3; 
      damageMod = 0.6;  
      break;
  }

  return { damageMod, defenseMod, siegeMod };
};

// ì •ê¸€ëŸ¬ ê°•íƒ€ í™•ë¥  ë³´ì •
export const getSmiteChance = (role: Role, settings: RoleSettings = DEFAULT_SETTINGS) => {
  return role === 'ì¶”ì ì' ? settings.tracker.smiteChance : 1.0; 
};

--- FILE: src/engine/match/systems/StatCalculator.ts ---
// src/engine/battle/StatCalculator.ts
import { HeroStats, GodSettings } from '../../../types';

export const calculateDamage = (
  attackerStats: HeroStats,
  defenderStats: HeroStats,
  godBuff: GodSettings,
  isCritical: boolean
) => {
  // ê¸°ë³¸ ë°ë¯¸ì§€ = (ê¸°ë³¸ê³µê²©ë ¥ + AD) * ì§„ì˜ ê³µê²© ê°€ì¤‘ì¹˜
  let baseDmg = (attackerStats.baseAtk + attackerStats.ad) * godBuff.atkRatio;

  if (isCritical) baseDmg *= 1.75;

  // ë°©ì–´ë ¥ ê³„ì‚° (ê´€í†µë ¥ ì ìš©)
  const effectiveArmor = Math.max(0, defenderStats.armor - attackerStats.pen);
  const damageReduction = 100 / (100 + (effectiveArmor * godBuff.defRatio));

  return Math.floor(baseDmg * damageReduction);
};

--- FILE: src/engine/match/systems/SkillProcessor.ts ---
// src/engine/battle/SkillProcessor.ts
import { SkillDetail, HeroStats } from '../../../types';

export const processSkillEffect = (skill: SkillDetail, attacker: any, target: any) => {
  let power = skill.val + (attacker.stats.ad * skill.adRatio) + (attacker.stats.ap * skill.apRatio);

  switch (skill.mechanic) {
    case 'EXECUTE':
      if (target.currentHp / target.maxHp < 0.25) power *= 5; // ì²´ë ¥ 25% ì´í•˜ë©´ 5ë°° ë°ë¯¸ì§€
      break;
    case 'STUN':
      target.isStunned = true; // CCê¸° ìƒíƒœ ë¶€ì—¬ (ì‹œë®¬ë ˆì´ì…˜ ë°˜ì˜ìš©)
      break;
    case 'HEAL':
      attacker.currentHp = Math.min(attacker.maxHp, attacker.currentHp + power);
      return 0; // ë°ë¯¸ì§€ëŠ” 0
    case 'SHIELD':
      attacker.shield = power;
      return 0;
  }
  return Math.floor(power);
};

--- FILE: src/engine/match/systems/BanPickEngine.ts ---
// ==========================================
// FILE PATH: /src/engine/match/systems/BanPickEngine.ts
// ==========================================

import { Hero, LiveMatch } from '../../../types';

// ì˜ì›… íƒœê·¸ ë¶„ì„ (ì¹´ìš´í„°/ì‹œë„ˆì§€ ê³„ì‚°ìš©)
const analyzeHeroTags = (h: Hero) => {
  if (!h || !h.skills) return { hasCC: false, hasDash: false, hasShield: false, hasExecute: false, isTank: false, isSquishy: false, isBurst: false };
  const skills = [h.skills.q, h.skills.w, h.skills.e, h.skills.r];
  return {
    hasCC: skills.some(s => s.mechanic === 'STUN' || s.mechanic === 'HOOK'),
    hasDash: skills.some(s => s.mechanic === 'DASH'),
    hasShield: skills.some(s => s.mechanic === 'SHIELD' || s.mechanic === 'HEAL'),
    hasExecute: skills.some(s => s.mechanic === 'EXECUTE'),
    isTank: h.stats.hp >= 2500 || h.stats.armor >= 50,
    isSquishy: h.stats.hp < 1800,
    isBurst: h.stats.ad > 80 || h.stats.ap > 80
  };
};

export const processDraftTurn = (match: LiveMatch, heroes: Hero[], userIq: number) => {
  if (!match.draft) return;
  const { turnIndex } = match.draft;

  // 1. ì´ë¯¸ ë°´/í”½ëœ ì˜ì›… ëª©ë¡ (ì¤‘ë³µ ë°©ì§€)
  const unavailableIds = new Set<string>();
  [...match.bans.blue, ...match.bans.red].forEach(id => unavailableIds.add(id));
  [...match.blueTeam, ...match.redTeam].forEach(p => { if(p.heroId) unavailableIds.add(p.heroId); });

  // ----------------------------------------------------
  // A. ë°´ í˜ì´ì¦ˆ (0~9í„´)
  // ----------------------------------------------------
  if (turnIndex < 10) {
    const candidates = heroes.filter(h => !unavailableIds.has(h.id));
    if (candidates.length === 0) return;

    // ìŠ¹ë¥  ë†’ì€ ì˜ì›…(OP) ìœ„ì£¼ë¡œ ë°´
    candidates.sort((a, b) => b.recentWinRate - a.recentWinRate);
    
    // [ê°œì„ ] ìƒìœ„ 15ê°œ ì¤‘ ëœë¤ ë°´ (ë„ˆë¬´ ê³ ì •ë˜ì§€ ì•Šê²Œ ë²”ìœ„ í™•ëŒ€)
    const banPoolSize = Math.min(candidates.length, 15);
    const banTarget = candidates[Math.floor(Math.random() * banPoolSize)];

    if (banTarget) {
      if (turnIndex % 2 === 0) {
          match.bans.blue.push(banTarget.id);
      } else {
          match.bans.red.push(banTarget.id);
      }
    }
    return;
  }

  // ----------------------------------------------------
  // B. í”½ í˜ì´ì¦ˆ (10~19í„´)
  // ----------------------------------------------------
  const pickOrderIndex = turnIndex - 10;
  // ìŠ¤ë„¤ì´í¬ í”½ ìˆœì„œ
  const SNAKE_ORDER = [0, 1, 1, 0, 0, 1, 1, 0, 0, 1]; 
  const TEAM_SLOT_MAP = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4]; 

  if (pickOrderIndex >= SNAKE_ORDER.length) return;

  const isBluePick = SNAKE_ORDER[pickOrderIndex] === 0;
  const teamIndex = TEAM_SLOT_MAP[pickOrderIndex];
  
  const targetTeam = isBluePick ? match.blueTeam : match.redTeam;
  const enemyTeam = isBluePick ? match.redTeam : match.blueTeam; 
  
  if (!targetTeam || !targetTeam[teamIndex]) return;
  const player = targetTeam[teamIndex]; 
  
  if (player.heroId) return;

  // ì—­í• êµ° í•„í„°
  const roleKey = (teamIndex === 4) ? 'SUP' : player.lane; 
  const preferredRoles: Record<string, string[]> = {
    'TOP': ['ì§‘í–‰ê´€', 'ìˆ˜í˜¸ê¸°ì‚¬'],
    'JUNGLE': ['ì¶”ì ì', 'ì§‘í–‰ê´€'],
    'MID': ['ì„ ì§€ì', 'ì¶”ì ì', 'ì‹ ì‚´ì'], 
    'BOT': ['ì‹ ì‚´ì'], 
    'SUP': ['ìˆ˜í˜¸ê¸°ì‚¬', 'ì„ ì§€ì']
  };
  const targetRoles = preferredRoles[roleKey] || ['ì§‘í–‰ê´€'];

  let candidates = heroes.filter(h => !unavailableIds.has(h.id) && targetRoles.includes(h.role));
  
  // í›„ë³´ ì—†ìœ¼ë©´ ì „ì²´ì—ì„œ ê²€ìƒ‰
  if (candidates.length === 0) candidates = heroes.filter(h => !unavailableIds.has(h.id));
  if (candidates.length === 0 && heroes.length > 0) candidates = [heroes[0]];

  // ----------------------------------------------------
  // [ê°œì„ ëœ] í”½ ë¡œì§
  // ----------------------------------------------------
  let pickedHeroId = candidates[0].id;

  // 1. [ì¥ì¸/ì¦ê²œ ëª¨ë“œ] (20% í™•ë¥ ): ì„±ëŠ¥ ë¬´ê´€í•˜ê²Œ ë¬´ì‘ìœ„ í”½
  // ìŠ¹ë¥ ì´ ë‚®ì•„ë„ ì• ì •ìœ¼ë¡œ í•˜ëŠ” ìœ ì €ë“¤ì„ ì‹œë®¬ë ˆì´ì…˜
  const isOneTrickPony = Math.random() < 0.2;

  if (isOneTrickPony) {
      const randomPick = candidates[Math.floor(Math.random() * candidates.length)];
      if (randomPick) pickedHeroId = randomPick.id;
  } 
  else if (userIq >= 70) {
    // 2. [ê³ ìˆ˜/ì²œìƒê³„] (IQ ë†’ìŒ): ì² ì €í•œ ìƒì„±/ì¡°í•© ê³„ì‚°
    const scored = candidates.map(hero => {
      let score = hero.recentWinRate * 10;
      const myTags = analyzeHeroTags(hero);

      // (1) ì  ì¹´ìš´í„° ì ìˆ˜
      enemyTeam.forEach(e => {
        if (!e.heroId) return;
        const eHero = heroes.find(h => h.id === e.heroId);
        if (!eHero) return;
        const eTags = analyzeHeroTags(eHero);

        if (eTags.isSquishy && myTags.hasDash && myTags.isBurst) score += 150; // ì•”ì‚´ ê°€ëŠ¥
        if (eTags.hasCC && (myTags.hasDash || myTags.hasShield)) score += 80; // ìƒì¡´ ìš©ì´
        if (eTags.isTank && myTags.hasExecute) score += 120; // íƒ±ì»¤ ì²˜ë¦¬
      });

      // (2) ì•„êµ° ì‹œë„ˆì§€ ì ìˆ˜
      targetTeam.forEach(a => {
        if (!a.heroId || a === player) return;
        const aHero = heroes.find(h => h.id === a.heroId);
        if (!aHero) return;
        const aTags = analyzeHeroTags(aHero);

        if (aTags.hasCC && myTags.isBurst) score += 100; // CCì—°ê³„
        if (aTags.isTank && myTags.isSquishy) score += 60; // ë³´í˜¸ ë°›ìŒ
      });

      return { hero, score };
    });

    // ì ìˆ˜ ë†’ì€ ìˆœ ì •ë ¬
    scored.sort((a, b) => b.score - a.score);
    
    // ìµœìƒìœ„ 1~2ê°œ ì¤‘ í•˜ë‚˜ ì„ íƒ (ê³ ìˆ˜ë„ ê°€ë” ì‹¤ìˆ˜í•˜ê±°ë‚˜ ì·¨í–¥ íƒ)
    const topPicks = scored.slice(0, 2);
    const chosen = topPicks[Math.floor(Math.random() * topPicks.length)];
    if (chosen) pickedHeroId = chosen.hero.id;

  } else {
    // 3. [ì¼ë°˜ ìœ ì €] (IQ ë‚®ìŒ): ìŠ¹ë¥  ìœ„ì£¼ì§€ë§Œ, í­ë„“ê²Œ ì„ íƒ
    candidates.sort((a, b) => b.recentWinRate - a.recentWinRate);
    
    // [ê°œì„ ] ìƒìœ„ 3ê°œê°€ ì•„ë‹ˆë¼ ìƒìœ„ 50% ì•ˆì—ì„œ ëœë¤ ì„ íƒ
    // ì˜ˆ: í›„ë³´ê°€ 10ëª…ì´ë©´ 1~5ë“± ì•ˆì—ì„œ ëœë¤ (4, 5ë“± ì±”í”¼ì–¸ë„ ì„ íƒë  ê¸°íšŒ ë¶€ì—¬)
    const pickPoolSize = Math.max(3, Math.ceil(candidates.length * 0.5));
    const chosen = candidates[Math.floor(Math.random() * pickPoolSize)];
    if (chosen) pickedHeroId = chosen.id;
  }

  player.heroId = pickedHeroId;
};

--- FILE: src/engine/match/systems/JungleSystem.ts ---
// ==========================================
// FILE PATH: /src/engine/match/systems/JungleSystem.ts
// ==========================================
import { LiveMatch, JungleMob } from '../../../types';
import { Collision } from '../utils/Collision';
import { useGameStore } from '../../../store/useGameStore';
import { DEFAULT_JUNGLE_CONFIG } from '../../../data/jungle/jungleDefaults';
import { JungleCampType } from '../../../types/jungle';

export class JungleSystem {
  static update(match: LiveMatch, dt: number) {
    if (!match.jungleMobs || match.jungleMobs.length === 0) {
        match.jungleMobs = this.initJungle();
    }

    match.jungleMobs.forEach(mob => {
      if (!mob.isAlive) {
        mob.respawnTimer -= dt;
        if (mob.respawnTimer <= 0) {
          mob.isAlive = true;
          mob.hp = mob.maxHp;
        }
        return;
      }

      const nearbyHeroes = [...match.blueTeam, ...match.redTeam].filter(
        h => h.currentHp > 0 && Collision.inRange(h, mob, 10)
      );

      if (nearbyHeroes.length > 0) {
        const dps = nearbyHeroes.reduce((sum, h) => sum + (h.level * 30) + (h.items.length * 20), 0);
        mob.hp -= dps * dt;
        nearbyHeroes.forEach(h => { h.currentHp -= (mob.atk * dt) / nearbyHeroes.length; });

        if (mob.hp <= 0) {
          mob.isAlive = false;
          mob.respawnTimer = (mob as any).configRespawnTime || 60; 
          
          const killer = Collision.findNearest(mob, nearbyHeroes);
          if (killer) {
             const bonus = killer.lane === 'JUNGLE' ? 1.2 : 1.0;
             killer.gold += Math.floor(((mob as any).rewardGold || 50) * bonus);
             (killer as any).exp = ((killer as any).exp || 0) + Math.floor(((mob as any).rewardXp || 80) * bonus);
             
             // [ìˆ˜ì •] ì •ê¸€ CS ì§€ê¸‰ (ëŒ€í˜•ëª¹ì€ 4ì , ì†Œí˜•ì€ 1ì ) - ì‹¤ì œ ë¡¤ ë°©ì‹
             // isBuffMob(ë ˆë“œ/ë¸”ë£¨/ë‘êº¼ë¹„ ë“±)ì€ 4ì , ë‚˜ë¨¸ì§€ëŠ” 1ì 
             killer.cs += (mob as any).isBuffMob ? 4 : 1;
             
             if ((mob as any).isBuffMob && (mob as any).buffs) {
                const buffs = (mob as any).buffs as { type: string, value: number }[];
                const buffMsg = buffs.map(b => `${b.type} +${b.value}`).join(', ');
                buffs.forEach(b => {
                    if(!killer.buffs) killer.buffs = [];
                    killer.buffs.push(`${b.type}:${b.value}`);
                });
                // ì •ê¸€ëª¹ ì²˜ì¹˜ ë¡œê·¸ëŠ” ë„ˆë¬´ ìì£¼ ëœ¨ë©´ ì‹œë„ëŸ¬ìš°ë¯€ë¡œ ì¤‘ìš” ë²„í”„ëª¹ë§Œ
                if (Math.random() < 0.3) {
                    match.logs.push({
                        time: Math.floor(match.currentDuration),
                        type: 'KILL',
                        message: `Buff: ${killer.name} -> [${buffMsg}] íšë“!`
                    });
                }
             }
          }
        }
      } else {
        if (mob.hp < mob.maxHp) mob.hp += mob.maxHp * 0.2 * dt;
      }
    });
  }

  private static initJungle(): JungleMob[] {
    const state = useGameStore.getState().gameState;
    const settings = state.fieldSettings.jungle as any;
    const camps = settings?.camps || DEFAULT_JUNGLE_CONFIG.camps;
    const positions = state.fieldSettings.positions;
    
    const CAMP_POSITIONS: Record<JungleCampType, {x:number, y:number}> = {
        TOP_BLUE: positions.jungle[0] || { x: 15, y: 42 }, 
        BOT_BLUE: positions.jungle[1] || { x: 50, y: 82 }, 
        TOP_RED:  positions.jungle[2] || { x: 58, y: 22 },
        BOT_RED:  positions.jungle[3] || { x: 82, y: 55 }
    };

    const mobs: JungleMob[] = [];

    (Object.keys(camps) as JungleCampType[]).forEach(campKey => {
        const campConfig = camps[campKey];
        const basePos = CAMP_POSITIONS[campKey];

        campConfig.monsters.forEach((m: any, idx: number) => {
            const worldX = basePos.x + (m.x - 50) * 0.12; 
            const worldY = basePos.y + (m.y - 50) * 0.12;

            mobs.push({
                id: `j_${campKey}_${m.spotId}`,
                campId: idx,
                type: m.stats.isBuffMob ? 'GOLEM' : 'WOLF',
                x: worldX,
                y: worldY,
                hp: m.stats.hp,
                maxHp: m.stats.hp,
                atk: m.stats.atk,
                respawnTimer: 0,
                isAlive: true,
                // @ts-ignore
                rewardGold: m.stats.gold,
                // @ts-ignore
                rewardXp: m.stats.xp,
                // @ts-ignore
                configRespawnTime: m.stats.respawnTime,
                // @ts-ignore
                isBuffMob: m.stats.isBuffMob,
                // @ts-ignore
                buffs: m.stats.buffs, 
                // @ts-ignore
                name: m.stats.name
            });
        });
    });

    return mobs;
  }
}


--- FILE: src/engine/match/systems/MinionSystem.ts ---
// ==========================================
// FILE PATH: /src/engine/match/systems/MinionSystem.ts
// ==========================================
import { LiveMatch, Minion, BattleSettings, Hero } from '../../../types';
import { MinionLogic } from '../logics/MinionLogic';
import { MinionSpawner } from './MinionSpawner';
import { SpatialGrid } from '../utils/SpatialGrid'; // [ì‹ ê·œ]

const WAVE_INTERVAL = 30;

export class MinionSystem {
  static update(match: LiveMatch, settings: BattleSettings, dt: number, heroes: Hero[]) {
    if (!match.minions) match.minions = [];

    const currentWaveCycle = Math.floor(match.currentDuration / WAVE_INTERVAL);
    const prevWaveCycle = Math.floor((match.currentDuration - dt) / WAVE_INTERVAL);

    if (currentWaveCycle > prevWaveCycle) {
      MinionSpawner.spawnWave(match, 'BLUE');
      MinionSpawner.spawnWave(match, 'RED');
    }

    this.processMinions(match, settings, dt, heroes);
  }

  private static processMinions(match: LiveMatch, settings: BattleSettings, dt: number, heroes: Hero[]) {
    // 1. ì£½ì€ ë¯¸ë‹ˆì–¸ ì •ë¦¬
    match.minions = match.minions!.filter(m => m.hp > 0);

    // 2. [ìµœì í™”] ì „ì²´ ë¯¸ë‹ˆì–¸ ë° ì˜ì›… ê·¸ë¦¬ë“œ êµ¬ì¶•
    // ê¸°ì¡´ì˜ ë¼ì¸ë³„ ìºì‹±(cachedEnemies) ëŒ€ì‹  ê·¸ë¦¬ë“œ ì‚¬ìš©
    const minionList = match.minions;
    const blueMinions = minionList.filter(m => m.team === 'BLUE');
    const redMinions = minionList.filter(m => m.team === 'RED');
    const blueHeroes = match.blueTeam.filter(h => h.currentHp > 0);
    const redHeroes = match.redTeam.filter(h => h.currentHp > 0);

    const grids = {
        // ë¸”ë£¨íŒ€ ì…ì¥ì—ì„œì˜ ì  (ë ˆë“œíŒ€)
        BLUE_ENEMIES: {
            minions: new SpatialGrid(redMinions),
            heroes: new SpatialGrid(redHeroes)
        },
        // ë ˆë“œíŒ€ ì…ì¥ì—ì„œì˜ ì  (ë¸”ë£¨íŒ€)
        RED_ENEMIES: {
            minions: new SpatialGrid(blueMinions),
            heroes: new SpatialGrid(blueHeroes)
        }
    };

    // 3. ë¯¸ë‹ˆì–¸ ë¡œì§ ì‹¤í–‰
    // ë¯¸ë‹ˆì–¸ì€ ì¸í„°ë¦¬ë¹™ ì—†ì´ ë§¤ í”„ë ˆì„ ëŒë ¤ë„ ê·¸ë¦¬ë“œ ë•ë¶„ì— ë¹ ë¦„
    for (let i = 0; i < match.minions.length; i++) {
        const m = match.minions[i];
        
        // ë‚´ íŒ€ì— ë§ëŠ” ì  ê·¸ë¦¬ë“œ ì„ íƒ
        const enemyGrids = m.team === 'BLUE' ? grids.BLUE_ENEMIES : grids.RED_ENEMIES;

        MinionLogic.processSingleMinion(
            m, match, settings, dt, enemyGrids, true, heroes
        );
    }
  }
}


--- FILE: src/engine/match/systems/ObjectiveSystem.ts ---
// ==========================================
// FILE PATH: /src/engine/match/systems/ObjectiveSystem.ts
// ==========================================
import { LiveMatch } from '../../../types';
import { useGameStore } from '../../../store/useGameStore';
import { POI, getDistance, BASES } from '../../data/MapData';

export function applyColossusReward(match: LiveMatch, isBlueTeam: boolean) {
  const teamName = isBlueTeam ? 'ë‹¨í…Œ' : 'ì´ì¦ˆë§ˆí•œ';
  const teamColor = isBlueTeam ? 'BLUE' : 'RED';
  const stats = isBlueTeam ? match.stats.blue : match.stats.red;

  stats.activeBuffs.siegeUnit = true;

  if (!match.minions) match.minions = [];
  
  const startPos = isBlueTeam ? BASES.BLUE : BASES.RED;
  
  match.minions.push({
    id: `summoned_colossus_${Date.now()}`,
    type: 'SUMMONED_COLOSSUS',
    team: teamColor,
    lane: 'MID', 
    x: startPos.x, 
    y: startPos.y,
    hp: 15000, 
    maxHp: 15000, 
    atk: 300,
    pathIdx: 0
  });

  match.logs.push({ 
    time: match.currentDuration, 
    message: `ğŸ¤– ${teamName} ì§„ì˜ì´ ê±°ì‹ ë³‘ì„ ì†Œí™˜í–ˆìŠµë‹ˆë‹¤! ë¯¸ë“œ ë¼ì¸ìœ¼ë¡œ ì§„ê²©í•©ë‹ˆë‹¤!`, 
    type: 'COLOSSUS', 
    team: teamColor 
  });
}

export function applyWatcherReward(match: LiveMatch, isBlueTeam: boolean) {
  const settings = useGameStore.getState().gameState.fieldSettings;
  const teamName = isBlueTeam ? 'ë‹¨í…Œ' : 'ì´ì¦ˆë§ˆí•œ';
  const teamColor = isBlueTeam ? 'BLUE' : 'RED';
  const stats = isBlueTeam ? match.stats.blue : match.stats.red;

  const buffDuration = settings?.watcher?.buffDuration || 180;

  stats.activeBuffs.voidPower = true;
  stats.activeBuffs.voidBuffEndTime = match.currentDuration + buffDuration;

  match.logs.push({
    time: match.currentDuration,
    message: `ğŸ‘ï¸ ${teamName} ì§„ì˜ì´ ê³µí—ˆì˜ í˜ì„ ì–»ì—ˆìŠµë‹ˆë‹¤!`,
    type: 'WATCHER',
    team: teamColor
  });
}

export const updateNeutralObjectives = (match: LiveMatch, fieldSettings: any, dt: number) => {
    (['colossus', 'watcher'] as const).forEach(type => {
        const obj = match.objectives[type];
        const setting = fieldSettings[type];
        if (!obj || !setting) return;

        if (obj.status === 'DEAD' && match.currentDuration >= obj.nextSpawnTime) {
            obj.status = 'ALIVE';
            obj.hp = setting.hp;
            obj.maxHp = setting.hp;
            match.logs.push({ 
                time: match.currentDuration, 
                message: `ğŸ“¢ ${type === 'colossus' ? 'ê±°ì‹ ë³‘' : 'ì£¼ì‹œì'}ê°€ ì „ì¥ì— ë“±ì¥í–ˆìŠµë‹ˆë‹¤!`, 
                type: 'START' 
            });
        }

        if (obj.status === 'ALIVE') {
            const objectivePos = type === 'colossus' ? POI.BARON : POI.DRAGON;
            const nearbyHeroes = [...match.blueTeam, ...match.redTeam].filter(p => 
                p.currentHp > 0 && p.respawnTimer <= 0 && getDistance(p, objectivePos) < 15
            );

            if (nearbyHeroes.length > 0) {
                const dps = nearbyHeroes.reduce((sum, p) => sum + (p.level * 15) + (p.items.length * 10), 0);
                obj.hp -= dps * dt;

                if (obj.hp <= 0) {
                    obj.status = 'DEAD';
                    obj.nextSpawnTime = match.currentDuration + (setting.respawnTime || 300);

                    const blueCnt = nearbyHeroes.filter(p => match.blueTeam.includes(p)).length;
                    const redCnt = nearbyHeroes.length - blueCnt;
                    const isBlueWin = blueCnt >= redCnt;

                    if (type === 'colossus') {
                        match.stats[isBlueWin ? 'blue' : 'red'].colossus++;
                        applyColossusReward(match, isBlueWin);
                    } else {
                        match.stats[isBlueWin ? 'blue' : 'red'].watcher++;
                        applyWatcherReward(match, isBlueWin);
                    }
                }
            }
        }
    });
};


--- FILE: src/engine/match/systems/PathSystem.ts ---
import { Vector, Vector2 } from '../utils/Vector';
import { BASES, MOVEMENT_SETTINGS } from '../constants/MapConstants';
import { LivePlayer } from '../../../types';

// MapConstantsì—ì„œ ì •ì˜í•œ ì¢Œí‘œë¥¼ ì—­ìœ¼ë¡œ ê°€ì ¸ì™€ì„œ ê²½ë¡œë¡œ ì‚¬ìš©
// (ìˆœí™˜ ì°¸ì¡° ë°©ì§€ë¥¼ ìœ„í•´ ê°’ í•˜ë“œì½”ë”© ëŒ€ì‹  ë¡œì§ìœ¼ë¡œ ì²˜ë¦¬)
const LANE_TARGETS = {
  BLUE: {
    TOP: [{x: 8, y: 35}, {x: 8, y: 55}, {x: 10, y: 75}, {x: 12, y: 88}],
    MID: [{x: 40, y: 60}, {x: 30, y: 70}, {x: 22, y: 78}, {x: 12, y: 88}],
    BOT: [{x: 75, y: 92}, {x: 50, y: 90}, {x: 25, y: 88}, {x: 12, y: 88}]
  },
  RED: {
    TOP: [{x: 45, y: 10}, {x: 65, y: 12}, {x: 80, y: 15}, {x: 88, y: 12}],
    MID: [{x: 60, y: 40}, {x: 70, y: 30}, {x: 78, y: 22}, {x: 88, y: 12}],
    BOT: [{x: 92, y: 65}, {x: 92, y: 45}, {x: 88, y: 25}, {x: 88, y: 12}]
  }
};

export class PathSystem {
  static getNextWaypoint(player: LivePlayer, isBlue: boolean): Vector2 {
    const lane = player.lane === 'JUNGLE' ? 'MID' : player.lane;
    
    // ë‚´ê°€ ê°€ì•¼í•  ëª©í‘œ íƒ€ì›Œ ë¦¬ìŠ¤íŠ¸ (ì  ì§„ì˜ì˜ íƒ€ì›Œ ìœ„ì¹˜)
    // ë¸”ë£¨íŒ€ì´ë©´ RED ì§„ì˜ì˜ íƒ€ì›Œë¥¼ 1ì°¨->2ì°¨->3ì°¨ ìˆœìœ¼ë¡œ ê°€ì•¼ í•¨
    const targets = isBlue ? LANE_TARGETS.RED[lane] : LANE_TARGETS.BLUE[lane];
    
    // í˜„ì¬ ë„ë‹¬í•´ì•¼ í•  íƒ€ì›Œ ì¸ë±ìŠ¤ (pathIdx)
    let currentIdx = (player as any).pathIdx || 0;
    
    // ë§Œì•½ ë‹¤ ê¹¼ìœ¼ë©´ ë§ˆì§€ë§‰(ë„¥ì„œìŠ¤) ìœ ì§€
    if (currentIdx >= targets.length) {
      return targets[targets.length - 1];
    }
    
    const target = targets[currentIdx];
    const dist = Vector.dist({ x: player.x, y: player.y }, target);
    
    // íƒ€ì›Œ ê·¼ì²˜ì— ë„ë‹¬í–ˆìœ¼ë©´ ë‹¤ìŒ íƒ€ì›Œë¡œ ëª©í‘œ ë³€ê²½
    // ë‹¨, íƒ€ì›Œê°€ ì‹¤ì œë¡œ ê¹¨ì¡ŒëŠ”ì§€ í™•ì¸í•˜ëŠ” ë¡œì§ì€ SiegePhaseì—ì„œ ì²˜ë¦¬í•˜ë¯€ë¡œ
    // ì—¬ê¸°ì„œëŠ” ë‹¨ìˆœíˆ "ë„ì°©í•˜ë©´ ë‹¤ìŒê±°"ê°€ ì•„ë‹ˆë¼, "ë„ì°©í–ˆê³  + íƒ€ì›Œê°€ ì—†ìœ¼ë©´ ë‹¤ìŒê±°" ë¡œ ê°€ì•¼ ì™„ë²½í•˜ì§€ë§Œ
    // ì‹œë®¬ë ˆì´ì…˜ ë‹¨ìˆœí™”ë¥¼ ìœ„í•´ "ë„ì°©í•˜ë©´ ì¼ë‹¨ ë©ˆì¶°ì„œ ì‹¸ìš°ê³ (SiegePhase), ì‹œê°„ ì§€ë‚˜ë©´ ë‹¤ìŒê±°" ë¡œì§ìœ¼ë¡œ ê°.
    
    if (dist < MOVEMENT_SETTINGS.WAYPOINT_TOLERANCE) {
      // ì—¬ê¸°ì„œ ê°•ì œë¡œ ë‹¤ìŒ ì¸ë±ìŠ¤ë¡œ ë„˜ê¸°ë©´ íƒ€ì›Œ ë¬´ì‹œí•˜ê³  ì§€ë‚˜ê°€ë²„ë¦¼.
      // ë”°ë¼ì„œ SiegePhaseì—ì„œ íƒ€ì›Œê°€ ê¹¨ì§ˆ ë•Œ pathIdxë¥¼ ì¦ê°€ì‹œì¼œì£¼ëŠ”ê²Œ ë§ìŒ.
      // ì„ì‹œë¡œ: íƒ€ì›Œ ê·¼ì²˜ì—ì„  ì†ë„ë¥¼ ëŠ¦ì¶”ê±°ë‚˜ ëŒ€ê¸°í•˜ê²Œ ë¨ (DecisionEngineì—ì„œ ì²˜ë¦¬)
      return target; 
    }
    
    return target;
  }
}


--- FILE: src/engine/match/systems/ProjectileSystem.ts ---
// ==========================================
// FILE PATH: /src/engine/match/systems/ProjectileSystem.ts
// ==========================================
import { LiveMatch, Projectile } from '../../../types';
import { Collision } from '../utils/Collision';

export class ProjectileSystem {
  static update(match: LiveMatch, dt: number) {
    if (!match.projectiles) match.projectiles = [];

    // [ìµœì í™”] ì‚­ì œ ì˜ˆì •ì¸ íˆ¬ì‚¬ì²´ ë¯¸ë¦¬ í•„í„°ë§ (ë©”ëª¨ë¦¬ ì ˆì•½)
    match.projectiles = match.projectiles.filter(p => !p.remove);

    match.projectiles.forEach(p => {
      // [ì‹ ê·œ] ìˆ˜ëª… ê´€ë¦¬: ìƒì„±ëœ ì§€ 3ì´ˆ ë„˜ìœ¼ë©´ ê°•ì œ ì‚­ì œ
      // Projectile íƒ€ì…ì— lifeTimeì´ ì—†ìœ¼ë¯€ë¡œ ì„ì‹œë¡œ í™•ì¥í•˜ê±°ë‚˜, ê±°ë¦¬ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì²´í¬
      // ì—¬ê¸°ì„œëŠ” ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ê±°ë‚˜ ëª©í‘œ ë„ë‹¬ ì‹¤íŒ¨ ì‹œ ì‚­ì œ ë¡œì§ ê°•í™”
      
      let targetPos = p.targetPos;

      if (p.targetId) {
        const target = [...match.blueTeam, ...match.redTeam].find(u => u.heroId === p.targetId);
        if (target && target.currentHp > 0) {
          targetPos = { x: target.x, y: target.y };
        } else {
          p.remove = true; 
          return;
        }
      }

      if (!targetPos) { p.remove = true; return; }

      const dx = targetPos.x - p.x;
      const dy = targetPos.y - p.y;
      const dist = Math.sqrt(dx*dx + dy*dy);

      // ì¶©ëŒ íŒì •
      if (dist < p.hitRadius || dist < (p.speed * dt * 0.1)) {
        this.onHit(match, p);
        p.remove = true;
      } else {
        // ì´ë™
        p.x += (dx / dist) * p.speed * dt * 0.1;
        p.y += (dy / dist) * p.speed * dt * 0.1;

        // [ì•ˆì „ì¥ì¹˜] ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì‚­ì œ
        if (p.x < -10 || p.x > 110 || p.y < -10 || p.y > 110) {
            p.remove = true;
        }
      }
    });
  }

  static spawn(match: LiveMatch, p: Projectile) {
    if (!match.projectiles) match.projectiles = [];
    // [ìµœì í™”] í™”ë©´ì— íˆ¬ì‚¬ì²´ê°€ ë„ˆë¬´ ë§ìœ¼ë©´(50ê°œ ì´ìƒ) ì´í™íŠ¸ ìƒëµ
    if (match.projectiles.length < 50) {
        match.projectiles.push(p);
    } else {
        // ì´í™íŠ¸ëŠ” ìƒëµí•˜ë˜ ë°ë¯¸ì§€ëŠ” ì¦‰ì‹œ ì ìš© (ì‹œë®¬ë ˆì´ì…˜ ì •í•©ì„± ìœ ì§€)
        this.onHit(match, p);
    }
  }

  private static onHit(match: LiveMatch, p: Projectile) {
    let targets = p.team === 'BLUE' ? match.redTeam : match.blueTeam;
    let victim = null;

    if (p.targetId) {
      victim = targets.find(t => t.heroId === p.targetId);
    } else {
      victim = Collision.findNearest(p, targets, p.hitRadius + 2);
    }

    if (victim) {
      victim.currentHp -= p.damage;
    }
  }
}


--- FILE: src/engine/match/systems/SteeringSystem.ts ---
// ==========================================
// FILE PATH: /src/engine/match/systems/SteeringSystem.ts
// ==========================================
import { Vector, Vector2 } from '../utils/Vector';
import { LivePlayer } from '../../../types';
import { MOVEMENT_SETTINGS } from '../constants/MapConstants';

export class SteeringSystem {
  static calculateSteering(
    me: LivePlayer, 
    target: Vector2, 
    neighbors: LivePlayer[], 
    maxSpeed: number
  ): Vector2 {
    const myPos = { x: me.x, y: me.y };
    
    // 1. Seek (ëª©ì ì§€ ì´ë™)
    const desired = Vector.sub(target, myPos);
    const dist = Vector.mag(desired);
    
    // [ìµœì í™”] ë„ì°© ì‹œ ì™„ì „ ì •ì§€ (ë–¨ë¦¼ ë°©ì§€)
    if (dist < 0.5) {
        return { x: 0, y: 0 };
    }

    let seekForce = Vector.normalize(desired);
    
    // Arrival (ê°ì†)
    if (dist < MOVEMENT_SETTINGS.ARRIVAL_TOLERANCE * 5) {
      const m = (dist / (MOVEMENT_SETTINGS.ARRIVAL_TOLERANCE * 5)) * maxSpeed;
      seekForce = Vector.mult(seekForce, m);
    } else {
      seekForce = Vector.mult(seekForce, maxSpeed);
    }

    // 2. Separation (ë°€ì–´ë‚´ê¸°) - [ìˆ˜ì •] í˜ ëŒ€í­ ì•½í™”
    let sepForce = { x: 0, y: 0 };
    let count = 0;
    
    for (const other of neighbors) {
      if (other === me || other.currentHp <= 0) continue;
      const d = Vector.dist(myPos, { x: other.x, y: other.y });
      
      if (d > 0 && d < MOVEMENT_SETTINGS.SEPARATION_DIST) {
        let diff = Vector.sub(myPos, { x: other.x, y: other.y });
        diff = Vector.normalize(diff);
        diff = Vector.div(diff, d); 
        sepForce = Vector.add(sepForce, diff);
        count++;
      }
    }
    
    if (count > 0) {
      sepForce = Vector.div(sepForce, count);
      sepForce = Vector.normalize(sepForce);
      // [ìˆ˜ì •] ë°€ì–´ë‚´ëŠ” í˜ì„ maxSpeedë§Œí¼ ì£¼ì§€ ì•Šê³  0.5ë°°ë¡œ ì¤„ì„ (ëœëœê±°ë¦¼ ë°©ì§€)
      sepForce = Vector.mult(sepForce, maxSpeed * 0.5); 
    }

    // [ìˆ˜ì •] í˜ì˜ í•©ì„± ë¹„ìœ¨ ì¡°ì • (ì´ë™ ìš°ì„ ìˆœìœ„ ë†’ì„)
    // ê¸°ì¡´: Seek 1.0 : Sep 1.5 -> ë³€ê²½: Seek 1.2 : Sep 0.6
    const totalForce = Vector.add(
      Vector.mult(seekForce, 1.2),
      Vector.mult(sepForce, 0.6) 
    );
    
    return totalForce; 
  }
}


--- FILE: src/engine/match/systems/ItemManager.ts ---
import { Item, LivePlayer, Hero, Role, HeroStats } from '../../../types';
import { getLevelScaledStats, calculateTotalStats } from '../utils/StatUtils';

export const updateLivePlayerStats = (player: LivePlayer, hero: Hero) => {
  const baseStats = getLevelScaledStats(hero.stats, player.level);
  const totalStats = calculateTotalStats({ ...hero, stats: baseStats }, player.items);

  const oldMaxHp = player.maxHp;
  const oldMaxMp = player.maxMp;

  player.maxHp = totalStats.hp;
  player.maxMp = totalStats.mp || 300;

  if (player.maxHp > oldMaxHp) player.currentHp += (player.maxHp - oldMaxHp);
  if (player.maxMp > oldMaxMp) player.currentMp += (player.maxMp - oldMaxMp);

  if (player.currentHp > player.maxHp) player.currentHp = player.maxHp;
  if (player.currentMp > player.maxMp) player.currentMp = player.maxMp;

  (player as any).moveSpeed = totalStats.speed;
  (player as any).hpRegen = totalStats.regen;
  player.mpRegen = totalStats.mpRegen || 5;
};

// sellItem
export const sellItem = (player: LivePlayer, index: number, hero: Hero) => {
  const itemToSell = player.items[index];
  if (!itemToSell) return 0;
  const refundGold = Math.floor(itemToSell.cost * 0.7);
  player.gold += refundGold;
  player.items.splice(index, 1);
  updateLivePlayerStats(player, hero);
  return refundGold;
};

// calculateTotalStatsëŠ” StatUtilsë¡œ ì´ë™í–ˆìœ¼ë¯€ë¡œ ì—¬ê¸°ì„œ ì œê±°í•˜ê³ , í•„ìš” ì‹œ importí•´ì„œ ì”€
// (attemptBuyItem ë“± ë‹¤ë¥¸ ë¡œì§ì€ ê¸°ì¡´ ìœ ì§€í•˜ë˜ íŒŒì¼ ëë¶€ë¶„ì— ë®ì–´ì”€)

const ROLE_WEIGHTS: Record<Role, any> = {
  'ì§‘í–‰ê´€': { ad: 1.2, hp: 0.8, armor: 0.8, regen: 0.5, pen: 1.0, speed: 0.5, crit: 0.8 },
  'ì¶”ì ì': { ad: 1.5, speed: 1.5, pen: 1.2, crit: 1.0, hp: 0.2 },
  'ì„ ì§€ì': { ap: 1.5, mp: 1.2, mpRegen: 1.2, pen: 0.8, hp: 0.3 },
  'ì‹ ì‚´ì': { ad: 1.5, crit: 1.5, speed: 1.0, pen: 1.2, hp: 0.1 },
  'ìˆ˜í˜¸ê¸°ì‚¬': { hp: 1.5, armor: 1.5, regen: 1.5, mp: 0.5, speed: 0.3 },
};

const analyzeEnemyThreat = (enemies: LivePlayer[], heroes: Hero[]) => {
  let totalAD = 0, totalAP = 0;
  let maxThreatType: 'AD' | 'AP' | 'BALANCED' = 'BALANCED';
  let highestGold = 0;

  enemies.forEach(e => {
    const h = heroes.find(x => x.id === e.heroId);
    if (!h) return;
    const itemAD = e.items.reduce((s, i) => s + (i.ad || 0), 0);
    const itemAP = e.items.reduce((s, i) => s + (i.ap || 0), 0);
    const currentAD = h.stats.ad + itemAD + (h.stats.ad * e.level * 0.1);
    const currentAP = h.stats.ap + itemAP + (h.stats.ap * e.level * 0.1);
    totalAD += currentAD; totalAP += currentAP;

    if (e.gold > highestGold) {
        highestGold = e.gold;
        if (currentAD > currentAP * 1.5) maxThreatType = 'AD';
        else if (currentAP > currentAD * 1.5) maxThreatType = 'AP';
        else maxThreatType = 'BALANCED';
    }
  });

  if (maxThreatType === 'BALANCED') {
      if (totalAD > totalAP * 1.3) maxThreatType = 'AD';
      if (totalAP > totalAD * 1.3) maxThreatType = 'AP';
  }
  return maxThreatType;
};

export const attemptBuyItem = (
  player: LivePlayer, shopItems: Item[], heroes: Hero[], enemies: LivePlayer[], gameTime: number
) => {
  const hero = heroes.find(h => h.id === player.heroId);
  if (!hero) return;

  const weights = { ...(ROLE_WEIGHTS[hero.role] || { ad: 1, ap: 1, hp: 1 }) };
  const threatType = analyzeEnemyThreat(enemies, heroes);
  
  if (player.stats.brain >= 50) {
      if (threatType === 'AD') { weights.armor = (weights.armor || 0.5) * 2.0; weights.hp = (weights.hp || 0.5) * 1.2; }
      else if (threatType === 'AP') { weights.hp = (weights.hp || 0.5) * 2.0; weights.regen = (weights.regen || 0.5) * 1.5; weights.armor = (weights.armor || 0.5) * 0.5; }
  }

  const kdaRatio = player.deaths === 0 ? player.kills : player.kills / player.deaths;
  if (player.deaths > 3 && kdaRatio < 0.5) { weights.hp = (weights.hp || 0.5) * 1.5; weights.regen = (weights.regen || 0.5) * 1.5; }

  const itemCount = player.items.length;
  const hasBoots = player.items.some(i => i.type === 'BOOTS');
  const existingPowerIdx = player.items.findIndex(i => i.type === 'POWER');
  const hasPower = existingPowerIdx !== -1;

  let minPriceLimit = gameTime < 600 ? 300 : (gameTime < 1200 ? 800 : 1500);
  if (itemCount >= 6) minPriceLimit = 2500;

  const candidates = shopItems.filter(item => {
      if (player.items.some(owned => owned.id === item.id)) return false; 
      if (item.type === 'BOOTS' && hasBoots) return false; 
      if (item.type === 'POWER' && hasPower) { if (item.cost <= player.items[existingPowerIdx].cost) return false; }
      return item.cost <= (player.gold + 200) && item.cost >= minPriceLimit;
    }).map(item => {
      let score = 0;
      score += (item.ad || 0) * (weights.ad || 0.1);
      score += (item.ap || 0) * (weights.ap || 0.1);
      score += (item.hp || 0) * (weights.hp || 0.1) / 10;
      score += (item.mp || 0) * (weights.mp || 0.1) / 10;
      score += (item.armor || 0) * (weights.armor || 0.1);
      score += (item.crit || 0) * (weights.crit || 0.1) * 2;
      score += (item.pen || 0) * (weights.pen || 0.1) * 2;
      score += (item.regen || 0) * (weights.regen || 0.1) * 5;
      score += (item.mpRegen || 0) * (weights.mpRegen || 0.1) * 5;
      score += (item.speed || 0) * (weights.speed || 0.5) * 2; 
      if (hero.role === 'ì„ ì§€ì' && item.type === 'ARTIFACT') score *= 1.2;
      if (hero.role === 'ìˆ˜í˜¸ê¸°ì‚¬' && item.type === 'ARMOR') score *= 1.2;
      if (!hasBoots && item.type === 'BOOTS') score += 1000; 
      if (item.type === 'POWER') score *= 5;
      return { item, score };
    });

  if (candidates.length === 0) return;
  candidates.sort((a, b) => b.score - a.score);
  const bestTarget = candidates[0].item;

  if (bestTarget.type === 'POWER' && hasPower) {
      const refund = sellItem(player, existingPowerIdx, hero);
      if ((player.gold) >= bestTarget.cost) { player.gold -= bestTarget.cost; player.items.push(bestTarget); updateLivePlayerStats(player, hero); return; }
  }

  if (itemCount < 6) {
    if (player.gold >= bestTarget.cost) { player.gold -= bestTarget.cost; player.items.push(bestTarget); updateLivePlayerStats(player, hero); }
  } else {
    let cheapestIdx = -1; let minCost = 999999;
    player.items.forEach((item, idx) => { if (item.type !== 'POWER' && item.type !== 'BOOTS' && item.cost < minCost) { minCost = item.cost; cheapestIdx = idx; } });
    if (cheapestIdx !== -1) {
      if (bestTarget.cost > (minCost * 1.5)) {
          const refund = sellItem(player, cheapestIdx, hero); 
          if ((player.gold) >= bestTarget.cost) { player.gold -= bestTarget.cost; player.items.push(bestTarget); updateLivePlayerStats(player, hero); }
      }
    }
  }
};


--- FILE: src/engine/match/systems/PlayerSystem.ts ---
import { LivePlayer, LiveMatch, Hero, RoleSettings } from '../../../types';
import { attemptBuyItem, updateLivePlayerStats } from './ItemManager'; 
import { SteeringSystem } from './SteeringSystem';
import { PathSystem } from './PathSystem';
import { BASES } from '../constants/MapConstants';
import { MacroBrain } from '../ai/MacroBrain';
import { MicroBrain } from '../ai/MicroBrain';

export const updatePlayerBehavior = (
  player: LivePlayer,
  match: LiveMatch,
  heroes: Hero[],
  shopItems: any[],
  roleSettings: RoleSettings,
  dt: number
) => {
  if (!player.cooldowns) player.cooldowns = { q:0, w:0, e:0, r:0 };
  Object.keys(player.cooldowns).forEach(k => {
    if ((player.cooldowns as any)[k] > 0) (player.cooldowns as any)[k] -= dt;
  });

  if (player.respawnTimer > 0) {
    player.respawnTimer -= dt;
    (player as any).currentRecallTime = 0; 
    if (player.respawnTimer <= 0) {
      player.respawnTimer = 0;
      const heroData = heroes.find(h => h.id === player.heroId);
      if (heroData) updateLivePlayerStats(player, heroData);
      player.currentHp = player.maxHp;
      player.currentMp = player.maxMp;
      const isBlueStart = match.blueTeam.includes(player);
      player.x = isBlueStart ? BASES.BLUE.x : BASES.RED.x;
      player.y = isBlueStart ? BASES.BLUE.y : BASES.RED.y;
      (player as any).pathIdx = 0;
    }
    return;
  }

  const hero = heroes.find(h => h.id === player.heroId);
  if (!hero) return;

  const isBlue = match.blueTeam.includes(player);
  const allies = isBlue ? match.blueTeam : match.redTeam;

  const macroDecision = MacroBrain.decide(player, match, hero);
  
  if (macroDecision.action !== 'RECALL') {
    (player as any).currentRecallTime = 0;
  }

  let finalTargetPos = macroDecision.targetPos;
  let moveSpeed = (player as any).moveSpeed || hero.stats.speed;

  switch (macroDecision.action) {
    case 'RECALL':
      handleRecall(player, isBlue, dt, hero, shopItems, match, heroes);
      return; 

    case 'FIGHT':
    case 'DEFEND': 
      if (macroDecision.targetUnit) {
        const micro = MicroBrain.control(player, macroDecision.targetUnit, hero, isBlue);
        if (micro.type === 'MOVE') {
          finalTargetPos = micro.targetPos;
        } else {
          finalTargetPos = { x: player.x, y: player.y }; 
        }
      }
      break;

    case 'FLEE':
      // [ì‹ ê·œ] ë¬´ì¡°ê±´ ë„ë§ (ì „íˆ¬ X)
      finalTargetPos = macroDecision.targetPos;
      break;

    case 'SUPPORT':
    case 'GANK':
    case 'OBJECTIVE':
      finalTargetPos = macroDecision.targetPos;
      break;

    case 'PUSH':
    case 'FARM':
    default:
      finalTargetPos = PathSystem.getNextWaypoint(player, isBlue);
      break;
  }

  const mapScaleSpeed = (moveSpeed / 100) * dt * 0.8; 
  const steering = SteeringSystem.calculateSteering(player, finalTargetPos, allies, mapScaleSpeed);

  player.x += steering.x;
  player.y += steering.y;

  player.x = Math.max(0, Math.min(100, player.x));
  player.y = Math.max(0, Math.min(100, player.y));

  if (Math.random() < 0.1 * dt && player.gold > 1000) {
    const enemyTeam = isBlue ? match.redTeam : match.blueTeam;
    attemptBuyItem(player, shopItems, heroes, enemyTeam, match.currentDuration);
  }
};

function handleRecall(p: LivePlayer, isBlue: boolean, dt: number, hero: Hero, shopItems: any[], match: LiveMatch, heroes: Hero[]) {
  const basePos = isBlue ? BASES.BLUE : BASES.RED;
  const dist = Math.sqrt(Math.pow(p.x - basePos.x, 2) + Math.pow(p.y - basePos.y, 2));

  if (dist <= 5) {
    p.currentHp += p.maxHp * 0.5 * dt;
    p.currentMp += p.maxMp * 0.5 * dt;
    if(p.currentHp > p.maxHp) p.currentHp = p.maxHp;
    if(p.currentMp > p.maxMp) p.currentMp = p.maxMp;
    (p as any).currentRecallTime = 0;
    const enemyTeam = isBlue ? match.redTeam : match.blueTeam;
    attemptBuyItem(p, shopItems, heroes, enemyTeam, match.currentDuration);
    return;
  }

  const RECALL_DURATION = 4.0;
  (p as any).currentRecallTime = ((p as any).currentRecallTime || 0) + dt;
  if ((p as any).currentRecallTime >= RECALL_DURATION) {
      p.x = basePos.x;
      p.y = basePos.y;
      (p as any).currentRecallTime = 0;
      p.currentHp += p.maxHp * 0.2;
  }
}


--- FILE: src/engine/match/systems/PowerCalculator.ts ---
import { Hero, LivePlayer, RoleSettings, HeroStats } from '../../../types';
// [ìˆ˜ì •] ìˆœí™˜ ì°¸ì¡° ì œê±° (StatUtils ì‚¬ìš©)
import { getLevelScaledStats, calculateTotalStats } from '../utils/StatUtils';
import { applyRoleBonus } from './RoleManager';

// getLevelScaledStatsëŠ” StatUtilsë¡œ ì´ë™í–ˆìœ¼ë¯€ë¡œ exportë§Œ ë‹¤ì‹œ í•´ì¤ë‹ˆë‹¤ (í•˜ìœ„ í˜¸í™˜ì„±)
export { getLevelScaledStats } from '../utils/StatUtils';

export const calculateHeroPower = (
  heroId: string, 
  heroes: Hero[], 
  player: LivePlayer, 
  isSiege: boolean, 
  allies: LivePlayer[],
  roleSettings: RoleSettings
) => {
  const hero = heroes.find(h => h.id === heroId);
  if (!hero) return 1000;

  const scaledBaseStats = getLevelScaledStats(hero.stats, player.level);
  const { damageMod, defenseMod } = applyRoleBonus(player, hero.role, isSiege, allies, roleSettings);
  const currentTotalStats = calculateTotalStats({ ...hero, stats: scaledBaseStats }, player.items);

  const hpScore = currentTotalStats.hp / 12;
  const atkScore = (currentTotalStats.ad + currentTotalStats.ap) * 2.5;
  const utilScore = currentTotalStats.speed / 6;

  let basePower = (hpScore + atkScore + utilScore) * damageMod * defenseMod;
  const skillMultiplier = 0.85 + (player.mmr / 15000) + (player.stats.mechanics / 1000); 

  return basePower * skillMultiplier;
};


--- FILE: src/engine/match/systems/MinionSpawner.ts ---
// ==========================================
// FILE PATH: /src/engine/match/systems/MinionSpawner.ts
// ==========================================
import { LiveMatch, Minion } from '../../../types';
import { BASES } from '../constants/MapConstants';

// [í•µì‹¬] ì „ì²´ ì œí•œ(120) ëŒ€ì‹  íŒ€ë³„ ì œí•œ(60)ì„ ì ìš©í•˜ì—¬ í•œ íŒ€ì´ ìŠ¤í°ì„ ë…ì í•˜ëŠ” í˜„ìƒ ë°©ì§€
const MAX_MINIONS_PER_TEAM = 60;

export class MinionSpawner {
  
  static spawnWave(match: LiveMatch, team: 'BLUE' | 'RED') {
    if (!match.minions) match.minions = [];

    // 1. í•´ë‹¹ íŒ€ì˜ í˜„ì¬ ë¯¸ë‹ˆì–¸ ìˆ˜ ì²´í¬
    const currentCount = match.minions.filter(m => m.team === team && m.hp > 0).length;
    
    // 2. íŒ€ë³„ ì œí•œì„ ë„˜ìœ¼ë©´ ìƒì„± ì¤‘ë‹¨ (ìƒëŒ€íŒ€ ìƒì„±ì—ëŠ” ì˜í–¥ ì—†ìŒ - ì´ì¦ˆë§ˆí•œ êµ¬ì›!)
    if (currentCount >= MAX_MINIONS_PER_TEAM) return;

    const lanes = ['TOP', 'MID', 'BOT'] as const;
    const startPos = team === 'BLUE' ? BASES.BLUE : BASES.RED;
    
    // ê²Œì„ ì‹œê°„ì— ë”°ë¥¸ ìŠ¤íƒ¯ ìŠ¤ì¼€ì¼ë§
    const rawScaling = 1 + (match.currentDuration / 900); 
    const timeScaling = Math.min(3.5, rawScaling); 

    // ëŒ€í¬ ë¯¸ë‹ˆì–¸ ìƒì„± ì£¼ê¸° (3ì›¨ì´ë¸Œë§ˆë‹¤)
    const isSiegeWave = Math.floor(match.currentDuration / 30) % 3 === 0;

    lanes.forEach(lane => {
      // ì „ì‚¬ ë¯¸ë‹ˆì–¸ 3ë§ˆë¦¬
      for (let i = 0; i < 3; i++) {
        match.minions!.push(this.createMinion(team, lane, 'MELEE', startPos, timeScaling));
      }
      // ë§ˆë²•ì‚¬ ë¯¸ë‹ˆì–¸ 3ë§ˆë¦¬
      for (let i = 0; i < 3; i++) {
        match.minions!.push(this.createMinion(team, lane, 'RANGED', startPos, timeScaling));
      }
      // ëŒ€í¬ ë¯¸ë‹ˆì–¸ 1ë§ˆë¦¬
      if (isSiegeWave) {
        match.minions!.push(this.createMinion(team, lane, 'SIEGE', startPos, timeScaling));
      }
    });
  }

  private static createMinion(team: 'BLUE' | 'RED', lane: any, type: any, pos: {x:number, y:number}, scaling: number): Minion {
    // ê²¹ì¹¨ ë°©ì§€ë¥¼ ìœ„í•œ ì•½ê°„ì˜ ìœ„ì¹˜ ëœë¤ê°’
    const offsetX = (Math.random() - 0.5) * 2;
    const offsetY = (Math.random() - 0.5) * 2;
    
    let hp = 550, atk = 25;
    if (type === 'RANGED') { hp = 350; atk = 45; }
    if (type === 'SIEGE') { hp = 950; atk = 70; }

    return {
      id: `minion_${team}_${lane}_${Date.now()}_${Math.random().toString(36).substr(2,4)}`,
      team, lane, type,
      x: pos.x + offsetX, 
      y: pos.y + offsetY,
      hp: Math.floor(hp * scaling), 
      maxHp: Math.floor(hp * scaling), 
      atk: Math.floor(atk * scaling),
      pathIdx: 0
    };
  }
}


--- FILE: src/engine/match/systems/DamageCalculator.ts ---
// ==========================================
// FILE PATH: /src/engine/match/systems/DamageCalculator.ts
// ==========================================
import { BattleSettings, RoleSettings } from '../../../types';
import { applyRoleBonus } from './RoleManager';

// ë°©ì–´ë ¥ ì ìš© ê³µì‹
export const calcMitigatedDamage = (rawDmg: number, armor: number) => {
  const reduction = 100 / (100 + armor);
  return rawDmg * reduction;
};

// [ì˜ì›… vs ì˜ì›…] ë°ë¯¸ì§€ ê³„ì‚°
export const calculateHeroDamage = (
    attacker: any, defender: any, atkStats: any, defStats: any, attackerHero: any, 
    isBlue: boolean, settings: BattleSettings, roleSettings: RoleSettings, buffType: string
) => {
    // 1. ê³µê²©ë ¥ (ê¸°ë³¸ + ì•„ì´í…œ + ì‹  ë²„í”„)
    const god = isBlue ? settings.dante : settings.izman;
    const atkRatio = god?.atkRatio || 1.0;
    const itemAD = attacker.items.reduce((s:number, i:any) => s + (i.ad||0), 0);
    const totalAD = (atkStats.baseAtk + atkStats.ad + itemAD) * atkRatio;

    // 2. í¬ë¦¬í‹°ì»¬
    const itemCrit = attacker.items.reduce((s:number, i:any) => s + (i.crit||0), 0);
    let isCrit = Math.random() < (atkStats.crit + itemCrit) / 100;
    let rawDmg = totalAD * (isCrit ? 1.75 : 1.0);

    // 3. ë°©ì–´ë ¥
    const defGod = isBlue ? settings.izman : settings.dante; 
    const defRatio = defGod?.defRatio || 1.0;
    const itemArmor = defender.items.reduce((s:number, i:any) => s + (i.armor||0), 0);
    const totalArmor = (defStats.armor + itemArmor) * defRatio;
    
    // ê´€í†µ
    const itemPen = attacker.items.reduce((s:number, i:any) => s + (i.pen||0), 0);
    const effectiveArmor = Math.max(0, totalArmor - (atkStats.pen + itemPen));
    
    // 4. ìµœì¢… ë°ë¯¸ì§€
    const finalDamage = calcMitigatedDamage(rawDmg, effectiveArmor);
    
    // 5. ì—­í• êµ°/ë²„í”„ ë³´ì •
    const { damageMod } = applyRoleBonus(attacker, attackerHero.role, false, [], roleSettings);
    let result = finalDamage * damageMod;

    if (buffType === 'COMBAT') result *= 1.1; 

    return Math.floor(result);
};

// [ì˜ì›… -> ë¯¸ë‹ˆì–¸/ëª¬ìŠ¤í„°] ë°ë¯¸ì§€ ê³„ì‚°
export const calculateUnitDamage = (
    attacker: any, atkStats: any, targetArmor: number, isBlue: boolean, settings: BattleSettings
) => {
    const god = isBlue ? settings.dante : settings.izman;
    const atkRatio = god?.atkRatio || 1.0;
    const itemAD = attacker.items.reduce((s:number, i:any) => s + (i.ad||0), 0);
    const totalAD = (atkStats.baseAtk + atkStats.ad + itemAD) * atkRatio;

    return Math.floor(calcMitigatedDamage(totalAD, targetArmor));
};


--- FILE: src/engine/match/systems/RewardSystem.ts ---
// ==========================================
// FILE PATH: /src/engine/match/systems/RewardSystem.ts
// ==========================================
import { LiveMatch, LivePlayer, Hero } from '../../../types';
import { getDistance } from '../../data/MapData';

export const MINION_REWARD = {
    'MELEE': { gold: 21, xp: 60 },
    'RANGED': { gold: 14, xp: 30 },
    'SIEGE': { gold: 60, xp: 90 },
    'SUMMONED_COLOSSUS': { gold: 150, xp: 200 }
};

/**
 * í†µí•© ë³´ìƒ ë¶„ë°° ì‹œìŠ¤í…œ
 * - ë§‰íƒ€ ì¹œ ì˜ì›…: ê³¨ë“œ/XP íšë“
 * - ì£¼ë³€ ì•„êµ°: XP ê³µìœ 
 * - ìˆ˜í˜¸ê¸°ì‚¬(ì„œí¬í„°): íƒ€ê³¤ì‚° ê³¨ë“œ ê³µìœ 
 */
export const distributeRewards = (
    match: LiveMatch, 
    deadUnitPos: {x:number, y:number}, 
    killer: LivePlayer | null, 
    killerTeam: 'BLUE'|'RED', 
    reward: { gold: number, xp: number },
    heroes: Hero[] 
) => {
    // 1. í‚¬ëŸ¬ ë³´ìƒ
    if (killer) {
        killer.cs++;
        killer.gold += reward.gold;

        // [ì„œí¬í„° íƒ€ê³¤ì‚° ë¡œì§]
        const killerHero = heroes.find(h => h.id === killer.heroId);
        if (killerHero && killerHero.role === 'ìˆ˜í˜¸ê¸°ì‚¬') {
            const allies = killerTeam === 'BLUE' ? match.blueTeam : match.redTeam;
            let nearestAlly = null;
            let minDist = 15;
            
            for (const ally of allies) {
                if (ally !== killer && ally.currentHp > 0) {
                    const d = getDistance(killer, ally);
                    if (d < minDist) {
                        minDist = d;
                        nearestAlly = ally;
                    }
                }
            }

            if (nearestAlly) {
                nearestAlly.gold += reward.gold; // ê³¨ë“œ ê³µìœ 
                nearestAlly.cs++; // ê¸°ë¶„ ì¢‹ê²Œ CSë„ 1 ì˜¬ë ¤ì¤Œ
            }
        }
    }

    // 2. ê²½í—˜ì¹˜ ë¶„ë°° (Në¹µ)
    const allies = killerTeam === 'BLUE' ? match.blueTeam : match.redTeam;
    const beneficiaries = allies.filter(p => 
        p.currentHp > 0 && 
        p.respawnTimer <= 0 &&
        getDistance(p, deadUnitPos) < 18 
    );

    if (beneficiaries.length > 0) {
        const xpPerPerson = Math.floor(reward.xp / beneficiaries.length);
        beneficiaries.forEach(p => {
            (p as any).exp = ((p as any).exp || 0) + xpPerPerson;
        });
    }
};

// ì–´ì‹œìŠ¤íŠ¸ ë³´ìƒ
export const distributeAssist = (match: LiveMatch, killer: LivePlayer, victim: LivePlayer, isBlue: boolean) => {
    const allies = isBlue ? match.blueTeam : match.redTeam;
    const assists = allies.filter(p => p !== killer && p.currentHp > 0 && getDistance(p, victim) < 20);
    
    assists.forEach(p => {
        p.assists++;
        p.gold += 150; 
        (p as any).exp = ((p as any).exp || 0) + 100;
    });
};


--- FILE: src/engine/match/BattleLogic.ts ---
// ==========================================
// FILE PATH: /src/engine/match/BattleLogic.ts
// ==========================================
import { LivePlayer, Hero } from '../../types';
import { getDistance, Vector2 } from '../data/MapData';

// ìœ ë‹›ì˜ í˜„ì¬ ìƒíƒœ
export type UnitState = 'IDLE' | 'MOVING' | 'ATTACKING' | 'RECALLING' | 'DEAD';

// --- [ì´ë™ ë¡œì§] ---
// ëª©í‘œ ì§€ì ê¹Œì§€ ì´ë™. ë„ì°©í–ˆìœ¼ë©´ true ë°˜í™˜
export const moveUnit = (p: LivePlayer, target: Vector2, dt: number, speedVal: number) => {
  const dist = getDistance(p, target);

  // ì•„ì£¼ ê°€ê¹ë‹¤ë©´ ë„ì°© ì²˜ë¦¬
  if (dist <= 1.0) return true; 

  // ë§µ í¬ê¸° 100 ê¸°ì¤€, ì†ë„ ìŠ¤ì¼€ì¼ ë³´ì • (ëŒ€ëµì ì¸ ê²Œì„ ì†ë„ ì¡°ì ˆ)
  // speedVal(ì´ì†)ì´ ë³´í†µ 300~400 ì •ë„ì´ë¯€ë¡œ 1/100 ì •ë„ë¡œ ì¤„ì—¬ì„œ ì´ë™
  const speed = (speedVal / 100) * dt * 0.8; 

  // [ìˆ˜ì •] ê±°ë¦¬ê°€ ë„ˆë¬´ ê°€ê¹Œìš°ë©´(0ì— ìˆ˜ë ´í•˜ë©´) ë‚˜ëˆ„ê¸° 0 ì—ëŸ¬ ë°œìƒ ê°€ëŠ¥í•˜ë¯€ë¡œ ë°©ì–´
  if (dist > 0.001) {
      const dx = (target.x - p.x) / dist;
      const dy = (target.y - p.y) / dist;

      p.x += dx * speed;
      p.y += dy * speed;
  }

  // ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šê²Œ ì œí•œ (0~100)
  p.x = Math.max(0, Math.min(100, p.x));
  p.y = Math.max(0, Math.min(100, p.y));

  return false;
};

// --- [íƒ€ê²ŸíŒ… ë¡œì§] ---
// ì‚¬ê±°ë¦¬ ë‚´ì˜ ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
export const findTarget = (me: LivePlayer, enemies: LivePlayer[], range: number): LivePlayer | null => {
  let target = null;
  // ë§µ í¬ê¸°ê°€ 100ì´ë¯€ë¡œ, ì‚¬ê±°ë¦¬(ë³´í†µ 500~600)ë¥¼ ë§µ ë‹¨ìœ„(5~6)ë¡œ ë³€í™˜
  let minDist = range / 10; 

  for (const e of enemies) {
    // ì‚´ì•„ìˆê³  ë¶€í™œ ëŒ€ê¸°ì¤‘ì´ ì•„ë‹Œ ì ë§Œ íƒ€ê²ŸíŒ…
    if (e.currentHp > 0 && e.respawnTimer <= 0) {
      const d = getDistance(me, e);
      if (d < minDist) {
        minDist = d;
        target = e;
      }
    }
  }
  return target;
};

// --- [ê³µê²© ì‹¤í–‰ ë¡œì§] ---
// *Note: ì‹¤ì œ ë°ë¯¸ì§€ ê³„ì‚°ì€ CombatPhase.tsì—ì„œ í†µí•© ì²˜ë¦¬í•˜ë¯€ë¡œ, ì—¬ê¸°ì„œëŠ” ìŠ¤í‚¬ ì‚¬ìš© í…ìŠ¤íŠ¸ ì²˜ë¦¬ ë“±ë§Œ ë‹´ë‹¹í•  ìˆ˜ë„ ìˆìŒ
// í•˜ì§€ë§Œ í˜„ì¬ êµ¬ì¡°ìƒ ì´ í•¨ìˆ˜ëŠ” PlayerSystem ë“±ì—ì„œ ì§ì ‘ í˜¸ì¶œë˜ì§€ ì•Šê³  CombatPhaseë¡œ ëŒ€ì²´ë˜ì—ˆìŠµë‹ˆë‹¤.
// í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•´ í•¨ìˆ˜ í˜•íƒœë§Œ ìœ ì§€í•˜ê±°ë‚˜, íŠ¹ì • ìƒí™©(ë°˜ê²© ë“±)ì—ì„œ ì“¸ ìˆ˜ ìˆë„ë¡ ë‚¨ê²¨ë‘¡ë‹ˆë‹¤.
export const executeAttack = (
  attacker: LivePlayer, 
  target: LivePlayer, 
  hero: Hero, 
  dt: number,
  logs: any[],
  time: number
) => {
  // CombatPhase.ts ì—ì„œ ì²˜ë¦¬ë˜ë¯€ë¡œ ì—¬ê¸° ë¡œì§ì€ ë¹„ì›Œë‘ê±°ë‚˜ ë‹¨ìˆœí™” ê°€ëŠ¥
  // (í˜„ì¬ ì‹œë®¬ë ˆì´ì…˜ êµ¬ì¡°ì—ì„œëŠ” CombatPhaseê°€ ë©”ì¸ì´ë¯€ë¡œ ì´ í•¨ìˆ˜ëŠ” ì‚¬ìš©ë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŒ)
};

--- FILE: src/engine/match/ai/AIUtils.ts ---
import { LivePlayer, LiveMatch } from '../../../types';
// [ìˆ˜ì •] ê²½ë¡œ ìˆ˜ì •: ../../utils -> ../utils
import { Vector } from '../utils/Vector';
import { BASES } from '../constants/MapConstants';

export class AIUtils {
  static dist(a: {x:number, y:number}, b: {x:number, y:number}): number {
    return Vector.dist({x: a.x, y: a.y}, {x: b.x, y: b.y});
  }

  static hpPercent(unit: LivePlayer): number {
    return unit.maxHp > 0 ? unit.currentHp / unit.maxHp : 0;
  }

  static mpPercent(unit: LivePlayer): number {
    return unit.maxMp > 0 ? unit.currentMp / unit.maxMp : 0;
  }

  static getCombatPower(unit: LivePlayer): number {
    return (unit.level * 100) + (this.hpPercent(unit) * 1000) + (unit.items.length * 150);
  }

  static getMyBasePos(isBlue: boolean): {x: number, y: number} {
    return isBlue ? BASES.BLUE : BASES.RED;
  }

  static getNextObjectivePos(player: LivePlayer, match: LiveMatch, isBlue: boolean): {x: number, y: number} {
    if (player.lane === 'JUNGLE') return { x: 50, y: 50 }; 

    const enemyStats = isBlue ? match.stats.red : match.stats.blue;
    const laneKey = player.lane.toLowerCase(); 
    
    const brokenCount = (enemyStats.towers as any)[laneKey];

    if (brokenCount >= 3) {
      return isBlue ? BASES.RED : BASES.BLUE;
    }

    const tier = brokenCount + 1;
    return this.calculateTowerPos(player.lane, tier, !isBlue); 
  }

  private static calculateTowerPos(lane: string, tier: number, isBlueSide: boolean) {
    let start = isBlueSide ? BASES.BLUE : BASES.RED;
    let end = isBlueSide ? BASES.RED : BASES.BLUE;

    let ratio = 0;
    if (tier === 1) ratio = 0.5; 
    else if (tier === 2) ratio = 0.75;
    else ratio = 0.9;

    let tx = start.x + (end.x - start.x) * ratio;
    let ty = start.y + (end.y - start.y) * ratio;

    if (lane === 'TOP') {
        if (isBlueSide) ty = 10; else tx = 10;
    } else if (lane === 'BOT') {
        if (isBlueSide) tx = 90; else ty = 90;
    }
    
    return { x: tx, y: ty };
  }
}


--- FILE: src/engine/match/ai/MacroBrain.ts ---
// ==========================================
// FILE PATH: /src/engine/match/ai/MacroBrain.ts
// ==========================================
import { LivePlayer, LiveMatch, Hero } from '../../../types';
import { Perception } from './Perception';
import { AIUtils } from './AIUtils';
import { PathSystem } from '../systems/PathSystem';
import { GankEvaluator } from './evaluators/GankEvaluator';
import { BASES } from '../constants/MapConstants';
import { LaningLogic } from '../logics/LaningLogic';

export type MacroAction = 'RECALL' | 'DEFEND' | 'FIGHT' | 'FARM' | 'PUSH' | 'WAIT' | 'OBJECTIVE' | 'SUPPORT' | 'GANK' | 'FLEE' | 'FINISH' | 'LANING';

export interface MacroDecision {
  action: MacroAction;
  targetPos: { x: number, y: number };
  targetUnit?: LivePlayer;
  reason: string;
}

export class MacroBrain {
  static decide(player: LivePlayer, match: LiveMatch, hero: Hero): MacroDecision {
    const isBlue = match.blueTeam.includes(player);
    const myBase = AIUtils.getMyBasePos(isBlue);
    const enemyBase = isBlue ? BASES.RED : BASES.BLUE;
    const distToBase = AIUtils.dist(player, myBase);

    // [0] ìš°ë¬¼ ë³µê·€ ì™„ë£Œ (íšŒë³µ)
    if (distToBase < 5) {
      const hpP = AIUtils.hpPercent(player);
      const mpP = AIUtils.mpPercent(player);
      if (hpP < 0.95 || (player.maxMp > 0 && mpP < 0.95)) {
        return { action: 'RECALL', targetPos: myBase, reason: 'ìš°ë¬¼ íšŒë³µ ì¤‘' };
      }
    }

    // [1] ìƒì¡´ íŒë‹¨ (ë”¸í”¼ë©´ ê·€í™˜/ë„ë§)
    if (Perception.needsRecall(player)) {
      const nearbyEnemy = Perception.findNearbyEnemy(player, match, isBlue);
      if (nearbyEnemy && AIUtils.dist(player, nearbyEnemy) < 15) {
         return { action: 'FLEE', targetPos: myBase, reason: 'êµì „ ì´íƒˆ' };
      }
      return { action: 'RECALL', targetPos: myBase, reason: 'ì •ë¹„ í•„ìš”' };
    }

    const situation = Perception.analyzeSituation(player, match);
    const enemyNexusHp = isBlue ? match.stats.red.nexusHp : match.stats.blue.nexusHp;
    const distToEnemyBase = AIUtils.dist(player, enemyBase);

    // [2] ë„¥ì„œìŠ¤ ì ì‚¬ (ëë‚´ê¸° ê°)
    if (situation.isEnemyWipedOut && AIUtils.hpPercent(player) > 0.3) {
        if (situation.isNexusVulnerable) {
            return { action: 'FINISH', targetPos: enemyBase, reason: 'ì  ì „ë©¸! ëë‚´ì!' };
        } else {
            const towerPos = AIUtils.getNextObjectivePos(player, match, isBlue);
            return { action: 'PUSH', targetPos: towerPos, reason: 'ì  ì „ë©¸! íƒ€ì›Œ ì² ê±°' };
        }
    }
    if (distToEnemyBase < 30 && enemyNexusHp < 3000 && situation.isNexusVulnerable) {
        return { action: 'FINISH', targetPos: enemyBase, reason: 'ë„¥ì„œìŠ¤ ì ì‚¬' };
    }
    if (situation.hasSiegeBuff && situation.powerDifference > 1000 && situation.isNexusVulnerable) {
        return { action: 'PUSH', targetPos: enemyBase, reason: 'ê±°ì‹ ë³‘ ì§„ê²©' };
    }

    // [3] ë³¸ì§„/íƒ€ì›Œ ìˆ˜ë¹„ (ìµœìš°ì„  ë°©ì–´)
    const baseThreat = Perception.isBaseUnderThreat(player, match, isBlue);
    if (baseThreat.isThreatened && baseThreat.enemyUnit) {
      const isBaseRace = distToEnemyBase < 30 && situation.isNexusVulnerable;
      if (!isBaseRace) {
          return { action: 'DEFEND', targetPos: { x: baseThreat.enemyUnit.x, y: baseThreat.enemyUnit.y }, targetUnit: baseThreat.enemyUnit, reason: 'ë³¸ì§„ ë°©ì–´' };
      }
    }
    if (AIUtils.hpPercent(player) > 0.6) {
      const towerThreat = Perception.findThreatenedStructure(player, match, isBlue);
      if (towerThreat) {
        const distToTower = AIUtils.dist(player, towerThreat.pos);
        // ë‚´ ë¼ì¸ íƒ€ì›Œê±°ë‚˜, ì •ê¸€ëŸ¬ê±°ë‚˜, ì•„ì£¼ ê°€ê¹Œìš°ë©´ ìˆ˜ë¹„
        if (player.lane === 'JUNGLE' || AIUtils.dist(player, towerThreat.pos) < 40) {
           return { action: 'DEFEND', targetPos: towerThreat.pos, targetUnit: towerThreat.enemy, reason: 'íƒ€ì›Œ ìˆ˜ë¹„' };
        }
      }
    }

    // =================================================================
    // [ì¤‘ìš” ìˆ˜ì •] ë¼ì¸ì „ ë¡œì§ (LaningLogic) ìš°ì„ ìˆœìœ„ ìƒí–¥
    // ê¸°ì¡´ [7]ë²ˆì—ì„œ [4]ë²ˆìœ¼ë¡œ ì´ë™ -> ì´ì œ ë¶ˆí•„ìš”í•œ ë¡œë°/í•œíƒ€ë³´ë‹¤ ë¼ì¸ì „ì´ ë¨¼ì €ì„
    // =================================================================
    const laningDecision = LaningLogic.decide(player, match, hero);
    if (laningDecision) {
        return laningDecision;
    }

    // [5] ê°±í‚¹ (ì •ê¸€ëŸ¬ ì „ìš©)
    if (AIUtils.hpPercent(player) > 0.6) {
        const gankTarget = GankEvaluator.evaluate(player, match, hero);
        if (gankTarget) {
            return { action: 'GANK', targetPos: { x: gankTarget.x, y: gankTarget.y }, targetUnit: gankTarget, reason: 'ê°±í‚¹' };
        }
    }

    // [6] ì•„êµ° ì§€ì› (ë¡œë°) - ë¼ì¸ì „ ë‹¨ê³„ê°€ ëë‚¬ê±°ë‚˜ ì •ê¸€ëŸ¬ì¼ ë•Œë§Œ
    if (AIUtils.hpPercent(player) > 0.4) {
        const allyInTrouble = Perception.findAllyInTrouble(player, match, isBlue);
        if (allyInTrouble) {
            const chance = 60 + (player.stats.brain * 0.3);
            if (Math.random() * 100 < chance) {
                return { action: 'SUPPORT', targetPos: { x: allyInTrouble.x, y: allyInTrouble.y }, targetUnit: allyInTrouble, reason: 'ì•„êµ° ì§€ì›' };
            }
        }
    }

    // [7] ì˜¤ë¸Œì íŠ¸ (ë°”ë¡ /ìš©)
    const activeObj = Perception.findActiveObjective(match);
    if (activeObj) {
      const isJungler = player.lane === 'JUNGLE';
      const distanceToObj = AIUtils.dist(player, activeObj.pos);
      if (isJungler && AIUtils.hpPercent(player) > 0.5) {
          return { action: 'OBJECTIVE', targetPos: activeObj.pos, reason: 'ì˜¤ë¸Œì íŠ¸ ì‚¬ëƒ¥' };
      }
      else if (distanceToObj < 40 && player.stats.brain > 50) {
         return { action: 'OBJECTIVE', targetPos: activeObj.pos, reason: 'ì˜¤ë¸Œì íŠ¸ í•©ë¥˜' };
      }
    }

    // [8] êµì „ (ìµœí›„ìˆœìœ„: ë¼ì¸ì „ ë‹¨ê³„ë„ ì•„ë‹ˆê³ , í•  ê²ƒë„ ì—†ì„ ë•Œ ì  ë³´ì´ë©´ ì‹¸ì›€)
    const nearbyEnemy = Perception.findNearbyEnemy(player, match, isBlue);
    if (nearbyEnemy) {
      const myPower = AIUtils.getCombatPower(player);
      const enemyPower = AIUtils.getCombatPower(nearbyEnemy);
      const aggro = (100 - player.stats.brain) * 10; 
      
      if (myPower + aggro >= enemyPower) {
        return { action: 'FIGHT', targetPos: { x: nearbyEnemy.x, y: nearbyEnemy.y }, targetUnit: nearbyEnemy, reason: 'êµì „' };
      } else {
        return { action: 'FLEE', targetPos: myBase, reason: 'í›„í‡´' };
      }
    }

    // [9] ê¸°ë³¸ í–‰ë™ (ë¼ì¸ í‘¸ì‰¬ / ì •ê¸€ë§)
    if (player.lane !== 'JUNGLE') {
        const towerPos = AIUtils.getNextObjectivePos(player, match, isBlue);
        const distToTower = AIUtils.dist(player, towerPos);
        
        if (distToTower < 20) {
            if (Perception.isSafeToSiege(player, match, towerPos)) {
                return { action: 'PUSH', targetPos: towerPos, reason: 'ê³µì„±' };
            } else {
                const waitPos = { 
                    x: towerPos.x + (isBlue ? -5 : 5), 
                    y: towerPos.y + (isBlue ? -5 : 5) 
                };
                return { action: 'WAIT', targetPos: waitPos, reason: 'ë¯¸ë‹ˆì–¸ ëŒ€ê¸°' };
            }
        } else {
            const nextPath = PathSystem.getNextWaypoint(player, isBlue);
            return { action: 'FARM', targetPos: nextPath, reason: 'ë¼ì¸ ë³µê·€' };
        }
    }

    const nextPath = PathSystem.getNextWaypoint(player, isBlue);
    return { action: 'FARM', targetPos: nextPath, reason: 'ì •ê¸€ë§' };
  }
}


--- FILE: src/engine/match/ai/MicroBrain.ts ---
import { LivePlayer, Hero } from '../../../types';
import { AIUtils } from './AIUtils';
import { BASES } from '../constants/MapConstants';

export interface MicroDecision {
  type: 'ATTACK' | 'MOVE';
  targetPos: { x: number, y: number };
}

export class MicroBrain {
  static control(
    player: LivePlayer, 
    target: LivePlayer, 
    hero: Hero, 
    isBlue: boolean
  ): MicroDecision {
    const dist = AIUtils.dist(player, target);
    // ë§µ í¬ê¸° 100 ê¸°ì¤€ ë³´ì •ëœ ì‚¬ê±°ë¦¬ (ì•½ê°„ì˜ ì—¬ìœ  ë‘ )
    const range = (hero.stats.range / 100) * 1.1; 
    
    // í”¼ì§€ì»¬ ìŠ¤íƒ¯ (0~100)
    const mechanics = player.stats.mechanics;
    
    // [1] ì‚¬ê±°ë¦¬ ë°– -> ì¶”ê²©
    if (dist > range) {
      return { type: 'MOVE', targetPos: { x: target.x, y: target.y } };
    }

    // [2] ì‚¬ê±°ë¦¬ ì•ˆ -> ì—­í• êµ°ë³„ í–‰ë™ ë¶„ê¸°
    const isRanged = hero.role === 'ì‹ ì‚´ì' || hero.role === 'ì„ ì§€ì';
    
    if (isRanged) {
      // [ì›ê±°ë¦¬] ì¹´ì´íŒ… ë¡œì§
      // í”¼ì§€ì»¬ì´ 50 ì´ìƒì´ì–´ì•¼ ì¹´ì´íŒ… ì‹œë„ (ë‚®ìœ¼ë©´ ë§ëšë”œ)
      if (mechanics >= 50) {
        // ì ì´ ë„ˆë¬´ ê°€ê¹Œìš°ë©´(ì‚¬ê±°ë¦¬ì˜ 50%) ë’¤ë¡œ ë¹ ì§
        if (dist < range * 0.5) {
          const myBase = AIUtils.getMyBasePos(isBlue);
          return { type: 'MOVE', targetPos: myBase };
        }
      }
      return { type: 'ATTACK', targetPos: { x: target.x, y: target.y } };
    } 
    else {
      // [ê·¼ê±°ë¦¬] ì ì—ê²Œ ë”± ë¶™ê¸°
      // í”¼ì§€ì»¬ì´ ë†’ìœ¼ë©´ ì ì˜ ì˜ˆìƒ ë„ì£¼ ê²½ë¡œë¡œ ì›€ì§ì¼ ìˆ˜ë„ ìˆê² ì§€ë§Œ(ì‹¬í™”), ì¼ë‹¨ì€ ë¶™ì–´ì„œ ë•Œë¦¼
      if (dist > 1.5) { 
        return { type: 'MOVE', targetPos: { x: target.x, y: target.y } };
      }
      return { type: 'ATTACK', targetPos: { x: target.x, y: target.y } };
    }
  }
}


--- FILE: src/engine/match/ai/Perception.ts ---
// ==========================================
// FILE PATH: /src/engine/match/ai/Perception.ts
// ==========================================
import { LivePlayer, LiveMatch } from '../../../types';
import { AIUtils } from './AIUtils';
import { POI, getDistance } from '../../data/MapData';
import { TOWER_COORDS } from '../constants/MapConstants';
import { Collision } from '../utils/Collision';

export interface ThreatInfo {
  isThreatened: boolean;
  enemyUnit: any; // LivePlayer | Minion
  distance: number;
}

export interface GameSituation {
  myTeamAlive: number;
  enemyTeamAlive: number;
  isEnemyWipedOut: boolean;
  powerDifference: number; 
  hasSiegeBuff: boolean; 
  isNexusVulnerable: boolean;
}

export class Perception {
  static isSafeToSiege(player: LivePlayer, match: LiveMatch, targetPos: {x:number, y:number}): boolean {
    const isBlue = match.blueTeam.includes(player);
    const myMinions = match.minions || [];
    
    const nearbyMinions = myMinions.filter(m => 
      m.team === (isBlue ? 'BLUE' : 'RED') && 
      m.hp > 0 &&
      getDistance(m, targetPos) < 15 
    );

    if (nearbyMinions.length > 0) return true; 

    if (player.level < 10) return false;
    const isTank = player.maxHp > 3000 && player.currentHp > player.maxHp * 0.8;
    return isTank; 
  }

  static analyzeSituation(player: LivePlayer, match: LiveMatch): GameSituation {
    const isBlue = match.blueTeam.includes(player);
    const allies = isBlue ? match.blueTeam : match.redTeam;
    const enemies = isBlue ? match.redTeam : match.blueTeam;
    const myStats = isBlue ? match.stats.blue : match.stats.red;
    const enemyStats = isBlue ? match.stats.red : match.stats.blue;

    const myAlive = allies.filter(p => p.currentHp > 0 && p.respawnTimer <= 0).length;
    const enemyAlive = enemies.filter(p => p.currentHp > 0 && p.respawnTimer <= 0).length;

    const getPower = (team: LivePlayer[]) => team.reduce((sum, p) => {
        if (p.currentHp <= 0) return sum;
        return sum + (p.level * 100) + (p.items.length * 200) + (p.currentHp / 10);
    }, 0);

    const myPower = getPower(allies);
    const enemyPower = getPower(enemies);

    const isNexusVulnerable = 
        enemyStats.towers.top >= 3 || 
        enemyStats.towers.mid >= 3 || 
        enemyStats.towers.bot >= 3;

    return {
        myTeamAlive: myAlive,
        enemyTeamAlive: enemyAlive,
        isEnemyWipedOut: enemyAlive === 0,
        powerDifference: myPower - enemyPower,
        hasSiegeBuff: myStats.activeBuffs.siegeUnit,
        isNexusVulnerable
    };
  }

  static needsRecall(player: LivePlayer): boolean {
    const iq = Math.max(0, Math.min(100, player.stats.brain)) / 100;
    const threshold = 0.15 + (iq * 0.25); 
    const lowMp = player.maxMp > 0 && (player.currentMp / player.maxMp) < 0.1;
    return AIUtils.hpPercent(player) < threshold || lowMp;
  }

  // [ìˆ˜ì •] ë³¸ì§„ ìœ„í˜‘ ì²´í¬: ì  ì˜ì›… OR ì  ê±°ì‹ ë³‘
  static isBaseUnderThreat(player: LivePlayer, match: LiveMatch, isBlue: boolean): ThreatInfo {
    const myBase = AIUtils.getMyBasePos(isBlue);
    const enemies = isBlue ? match.redTeam : match.blueTeam;
    const enemyMinions = match.minions || [];
    const myNexusHp = isBlue ? match.stats.blue.nexusHp : match.stats.red.nexusHp;
    
    const emergencyMode = myNexusHp < (isBlue ? match.stats.blue.maxNexusHp : match.stats.red.maxNexusHp) * 0.3;
    const threatRange = emergencyMode ? 40 : 25; 

    let closestThreat: any = null;
    let minDist = 999;

    // 1. ì  ì˜ì›… ì²´í¬
    for (const enemy of enemies) {
      if (enemy.currentHp <= 0 || enemy.respawnTimer > 0) continue;
      const d = AIUtils.dist(myBase, {x: enemy.x, y: enemy.y});
      if (d < minDist) {
        minDist = d;
        closestThreat = enemy;
      }
    }

    // 2. ì  ê±°ì‹ ë³‘ ì²´í¬ (ì¶”ê°€)
    const enemyColossus = enemyMinions.find(m => 
        m.team !== (isBlue ? 'BLUE' : 'RED') && 
        m.type === 'SUMMONED_COLOSSUS' && 
        m.hp > 0
    );
    if (enemyColossus) {
        const d = AIUtils.dist(myBase, {x: enemyColossus.x, y: enemyColossus.y});
        if (d < minDist) {
            minDist = d;
            closestThreat = enemyColossus; // ê±°ì‹ ë³‘ì´ ë” ê°€ê¹Œìš°ë©´ ì–˜ë¥¼ ë§‰ìœ¼ëŸ¬ ê°
        }
    }

    if (closestThreat && minDist < threatRange) {
        return { isThreatened: true, enemyUnit: closestThreat, distance: minDist };
    }
    return { isThreatened: false, enemyUnit: null, distance: 999 };
  }

  static findThreatenedStructure(player: LivePlayer, match: LiveMatch, isBlue: boolean): { pos: {x:number, y:number}, enemy: LivePlayer } | null {
    const enemies = isBlue ? match.redTeam : match.blueTeam;
    const myTowers = isBlue ? match.stats.blue.towers : match.stats.red.towers;
    const towerCoords = isBlue ? TOWER_COORDS.BLUE : TOWER_COORDS.RED;
    const lanes = ['TOP', 'MID', 'BOT'];
    
    for (const lane of lanes) {
      const brokenCount = (myTowers as any)[lane.toLowerCase()];
      if (brokenCount >= 3) continue; 
      const currentTier = brokenCount + 1; 
      // @ts-ignore
      const tPos = towerCoords[lane][currentTier - 1]; 
      if (!tPos) continue;

      for (const enemy of enemies) {
        if (enemy.currentHp > 0 && enemy.respawnTimer <= 0) {
          const dist = getDistance({x: tPos.x, y: tPos.y}, enemy);
          if (dist < 12) {
             return { pos: tPos, enemy: enemy };
          }
        }
      }
    }
    return null;
  }

  static findNearbyEnemy(player: LivePlayer, match: LiveMatch, isBlue: boolean): LivePlayer | null {
    const enemies = isBlue ? match.redTeam : match.blueTeam;
    const sightRange = 15;
    let target: LivePlayer | null = null;
    let minDist = 999;

    for (const enemy of enemies) {
      if (enemy.currentHp <= 0 || enemy.respawnTimer > 0) continue;
      const d = AIUtils.dist(player, enemy);
      if (d <= sightRange && d < minDist) {
        minDist = d;
        target = enemy;
      }
    }
    return target;
  }

  static findActiveObjective(match: LiveMatch): { type: 'colossus'|'watcher', pos: {x:number, y:number} } | null {
    if (match.objectives.colossus.status === 'ALIVE') return { type: 'colossus', pos: POI.BARON };
    if (match.objectives.watcher.status === 'ALIVE') return { type: 'watcher', pos: POI.DRAGON };
    return null;
  }

  static findAllyInTrouble(player: LivePlayer, match: LiveMatch, isBlue: boolean): LivePlayer | null {
    const allies = isBlue ? match.blueTeam : match.redTeam;
    const enemies = isBlue ? match.redTeam : match.blueTeam;
    const sightRange = 25;
    const candidates = allies.filter(a => a !== player && a.currentHp > 0 && a.respawnTimer <= 0);

    for (const ally of candidates) {
      const distToAlly = AIUtils.dist(player, ally);
      if (distToAlly > sightRange) continue;
      if (AIUtils.hpPercent(ally) < 0.5) return ally;
      for (const enemy of enemies) {
        if (enemy.currentHp > 0 && AIUtils.dist(ally, enemy) < 8) {
          return ally;
        }
      }
    }
    return null;
  }
}


--- FILE: src/engine/match/ai/evaluators/GankEvaluator.ts ---
// ==========================================
// FILE PATH: /src/engine/match/ai/evaluators/GankEvaluator.ts
// ==========================================
import { LivePlayer, LiveMatch, Hero } from '../../../../types';
import { AIUtils } from '../AIUtils';
import { BASES } from '../../constants/MapConstants';

export class GankEvaluator {
  /**
   * ê°±í‚¹/ë¡œë°ì„ ê°ˆë§Œí•œ ìµœì ì˜ íƒ€ê²Ÿì„ ë°˜í™˜í•©ë‹ˆë‹¤.
   * [ìˆ˜ì •] ê°±í‚¹ ì ìˆ˜ í—ˆë“¤ì„ ë‚®ì¶”ê³ , ê±°ë¦¬ ê°€ì¤‘ì¹˜ë¥¼ ì¡°ì ˆí•˜ì—¬ ë” ìì£¼ ê°±í‚¹ì„ ê°€ê²Œ í•¨
   */
  static evaluate(player: LivePlayer, match: LiveMatch, hero: Hero): LivePlayer | null {
    const isJungler = player.lane === 'JUNGLE';
    const isMid = player.lane === 'MID';
    
    // ë¡œë° ì¡°ê±´ ì™„í™”: ë‡Œì§€ì»¬ 60 ì´ìƒì´ë©´ ì„œí¿/íƒ‘ë„ ê°€ë” ë¡œë° ê³ ë ¤
    if (!isJungler && !isMid && player.stats.brain < 60) return null;

    const isBlue = match.blueTeam.includes(player);
    const enemies = isBlue ? match.redTeam : match.blueTeam;
    const enemyBase = isBlue ? BASES.RED : BASES.BLUE;

    let bestTarget: LivePlayer | null = null;
    let maxScore = 0;

    for (const enemy of enemies) {
      if (enemy.currentHp <= 0 || enemy.respawnTimer > 0) continue;
      if (enemy.lane === 'JUNGLE') continue; // ì¹´ì •ì€ ë³„ë„ ë¡œì§

      let score = 0;

      // A. ê±°ë¦¬ ì ìˆ˜
      const dist = AIUtils.dist(player, enemy);
      if (dist > 70) continue; // ë„ˆë¬´ ë©€ë©´ í¬ê¸° (ê¸°ì¡´ 60 -> 70 í™•ì¥)
      score += (70 - dist) * 1.5; // ê°€ê¹Œìš¸ìˆ˜ë¡ ì ìˆ˜ ê°€ì¤‘ì¹˜ ì¦ê°€

      // B. ì²´ë ¥ ì ìˆ˜ (ë”¸í”¼ ì‚¬ëƒ¥)
      const hpPer = AIUtils.hpPercent(enemy);
      if (hpPer < 0.5) score += (1 - hpPer) * 150; // ê°€ì¤‘ì¹˜ ìƒí–¥

      // C. ë¼ì¸ ìƒí™© (Overextension)
      // ì ì´ ìš°ë¦¬ ì§„ì˜ ê¹Šìˆ™ì´ ë“¤ì–´ì™€ ìˆìœ¼ë©´ ë§›ì§‘
      const distFromEnemyBase = AIUtils.dist(enemy, enemyBase);
      
      // ë§µ ì¤‘ì•™(50) ê¸°ì¤€
      if (distFromEnemyBase > 40) { // ì¡°ê¸ˆë§Œ ë‚˜ì™€ë„ ì ìˆ˜ ë¶€ì—¬
        score += (distFromEnemyBase - 40) * 3; // ê°€ì¤‘ì¹˜ ëŒ€í­ ìƒí–¥
      } else {
        score -= 30; // íƒ€ì›Œ í—ˆê¹… ì¤‘ì´ë©´ ê°ì 
      }

      // D. ë ˆë²¨ ìš°ìœ„
      score += (player.level - enemy.level) * 15;

      // E. ì—­í• êµ° ë³´ì • (ë´‡ ê°±í‚¹ ì„ í˜¸)
      if (enemy.lane === 'BOT') score += 20;

      // ê°±í‚¹ ì„ê³„ì  (ê¸°ì¡´ 60 -> 50ìœ¼ë¡œ í•˜í–¥í•˜ì—¬ ë” ìì£¼ ê°)
      if (score > 50 && score > maxScore) {
        maxScore = score;
        bestTarget = enemy;
      }
    }

    return bestTarget;
  }
}


--- FILE: src/engine/match/ai/evaluators/TargetEvaluator.ts ---
// ==========================================
// FILE PATH: /src/engine/match/ai/evaluators/TargetEvaluator.ts
// ==========================================
import { LivePlayer, Hero, Minion } from '../../../../types';
import { AIUtils } from '../AIUtils';

export class TargetEvaluator {
  static selectBestTarget(
    attacker: LivePlayer, 
    attackerHero: Hero, 
    enemiesInRange: LivePlayer[], 
    heroes: Hero[] 
  ): LivePlayer | null {
    if (enemiesInRange.length === 0) return null;
    if (enemiesInRange.length === 1) return enemiesInRange[0];

    const myRole = attackerHero.role;
    
    let bestTarget: LivePlayer | null = null;
    let maxScore = -9999;

    for (const enemy of enemiesInRange) {
      const enemyHero = heroes.find(h => h.id === enemy.heroId);
      if (!enemyHero) continue;

      let score = 0;

      const estimatedDmg = attackerHero.stats.ad * 3 + attackerHero.stats.ap * 2; 
      if (enemy.currentHp < estimatedDmg) score += 5000; 

      const dist = AIUtils.dist(attacker, enemy);
      score -= dist * 10; 

      const isSquishy = ['ì‹ ì‚´ì', 'ì„ ì§€ì', 'ì¶”ì ì'].includes(enemyHero.role);
      
      if (myRole === 'ì¶”ì ì' || myRole === 'ì§‘í–‰ê´€') {
        if (isSquishy) score += 200;
      } else if (myRole === 'ì‹ ì‚´ì') {
        if (isSquishy) score += 50; 
      }

      score += (1 - AIUtils.hpPercent(enemy)) * 100;

      if (score > maxScore) {
        maxScore = score;
        bestTarget = enemy;
      }
    }
    return bestTarget;
  }

  /**
   * [Smart Farming]
   * killThreshold ì´í•˜ì˜ ì²´ë ¥ì„ ê°€ì§„ ë¯¸ë‹ˆì–¸ì„ ìµœìš°ì„ ìœ¼ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
   */
  static selectFarmTarget(
    attacker: LivePlayer,
    minionsInRange: Minion[],
    killThreshold: number 
  ): Minion | null {
    if (minionsInRange.length === 0) return null;

    // 1. ë§‰íƒ€ ê°€ëŠ¥ ë¯¸ë‹ˆì–¸ ì°¾ê¸°
    const killableMinions = minionsInRange.filter(m => m.hp <= killThreshold);

    if (killableMinions.length > 0) {
        // ëŒ€í¬ > ê·¼ê±°ë¦¬ > ì›ê±°ë¦¬ ìˆœ + í”¼ ì ì€ ìˆœ
        killableMinions.sort((a, b) => {
            const valA = this.getMinionValue(a.type);
            const valB = this.getMinionValue(b.type);
            if (valA !== valB) return valB - valA; 
            return a.hp - b.hp;
        });
        return killableMinions[0];
    }

    // ë§‰íƒ€ ì¹  ê²Œ ì—†ìœ¼ë©´ null ë°˜í™˜ (ë¶ˆí•„ìš”í•œ ê³µê²© ìì œ -> ë§‰íƒ€ ëŒ€ê¸°)
    return null;
  }

  private static getMinionValue(type: string): number {
      if (type === 'SUMMONED_COLOSSUS') return 10;
      if (type === 'SIEGE') return 3;
      if (type === 'MELEE') return 2;
      return 1;
  }
}


--- FILE: src/engine/match/constants/MapConstants.ts ---
// ==========================================
// FILE PATH: /src/engine/match/constants/MapConstants.ts
// ==========================================
import { Vector2 } from '../utils/Vector';

export const MAP_SIZE = 100;

export const BASES = {
  BLUE: { x: 5, y: 95 },
  RED: { x: 95, y: 5 }
};

export const MOVEMENT_SETTINGS = {
  SEPARATION_DIST: 2.0, 
  WAYPOINT_TOLERANCE: 3.0, 
  ARRIVAL_TOLERANCE: 1.0, 
  MAX_FORCE: 0.5, 
};

// [ì´ë™] ì›¨ì´í¬ì¸íŠ¸ ê²½ë¡œ (íƒ€ì›Œ ìœ„ì¹˜ ë³€ê²½ì— ë”°ë¼ ë¯¸ì„¸ ì¡°ì •)
export const WAYPOINTS: Record<string, Vector2[]> = {
  TOP: [
    { x: 5, y: 95 }, { x: 5, y: 50 }, { x: 5, y: 20 }, { x: 10, y: 10 },
    { x: 35, y: 8 }, { x: 60, y: 10 }, { x: 95, y: 5 } // ë ˆë“œ íƒ‘ 1/2ì°¨ íƒ€ì›Œ ê²½ìœ 
  ],
  MID: [
    { x: 5, y: 95 }, { x: 25, y: 75 }, { x: 50, y: 50 }, { x: 75, y: 25 }, { x: 95, y: 5 }
  ],
  BOT: [
    { x: 5, y: 95 }, { x: 50, y: 95 }, { x: 80, y: 95 }, { x: 90, y: 90 },
    { x: 92, y: 70 }, { x: 92, y: 45 }, { x: 95, y: 5 } // ë ˆë“œ ë´‡ 1/2ì°¨ íƒ€ì›Œ ê²½ìœ 
  ],
  JUNGLE: [ 
    { x: 20, y: 70 }, { x: 35, y: 65 }, { x: 45, y: 55 }, { x: 55, y: 45 }, { x: 65, y: 35 }, { x: 80, y: 30 }  
  ]
};

// [ì¤‘ìš”] Engine ë‚´ì—ì„œë„ ë™ì¼í•œ íƒ€ì›Œ ì¢Œí‘œ ì‚¬ìš©
export const TOWER_COORDS = {
  BLUE: {
    TOP: [{x: 8, y: 35}, {x: 8, y: 55}, {x: 10, y: 75}],
    MID: [{x: 40, y: 60}, {x: 30, y: 70}, {x: 22, y: 78}],
    BOT: [{x: 75, y: 92}, {x: 50, y: 90}, {x: 25, y: 88}],
    NEXUS: {x: 12, y: 88}
  },
  RED: {
    TOP: [{x: 35, y: 8}, {x: 60, y: 10}, {x: 78, y: 12}],
    MID: [{x: 65, y: 35}, {x: 75, y: 28}, {x: 82, y: 20}],
    BOT: [{x: 92, y: 70}, {x: 92, y: 45}, {x: 88, y: 25}],
    NEXUS: {x: 88, y: 12}
  }
};


--- FILE: src/engine/match/logics/ColossusLogic.ts ---
// ==========================================
// FILE PATH: /src/engine/match/logics/ColossusLogic.ts
// ==========================================
import { LiveMatch, Minion, BattleSettings } from '../../../types';
import { BASES, WAYPOINTS, TOWER_COORDS } from '../constants/MapConstants';
import { Collision } from '../utils/Collision';

// ë°©ì–´ë ¥ ì ìš© ë°ë¯¸ì§€ ê³µì‹
const calcMitigatedDamage = (rawDmg: number, armor: number) => {
  const reduction = 100 / (100 + armor);
  return rawDmg * reduction;
};

export class ColossusLogic {
  
  static update(colossus: Minion, match: LiveMatch, settings: BattleSettings, dt: number) {
    const isBlue = colossus.team === 'BLUE';
    
    // 1. ìµœìš°ì„  ëª©í‘œ: ë¯¸ë“œ ë¼ì¸ì˜ ë‹¤ìŒ êµ¬ì¡°ë¬¼
    const structureTarget = this.findNextStructure(colossus, match);
    
    let distToStructure = 999;
    if (structureTarget) {
        const dx = structureTarget.x - colossus.x;
        const dy = structureTarget.y - colossus.y;
        distToStructure = Math.sqrt(dx*dx + dy*dy);
    }

    // ê³µê²© ì‚¬ê±°ë¦¬ (ê±°ì‹ ë³‘ì€ ë©ì¹˜ê°€ í¬ë‹ˆê¹Œ 12)
    const ATTACK_RANGE = 12;

    // 2. í–‰ë™ ê²°ì •
    if (structureTarget && distToStructure <= ATTACK_RANGE) {
        // [ê³µì„±] ì‚¬ê±°ë¦¬ ì•ˆì´ë©´ ê³µê²©
        this.processAttack(colossus, structureTarget, 'STRUCTURE', match, settings, dt, isBlue);
    } 
    else {
        // [ì§„ê²©] ì‚¬ê±°ë¦¬ ë°–ì´ë©´ ì´ë™
        // ê¸¸ì„ ë§‰ëŠ” ì ì´ ìˆëŠ”ì§€ í™•ì¸
        const nearbyEnemy = this.findBlockingEnemy(colossus, match);
        
        if (nearbyEnemy) {
            // ê¸¸ ë§‰ëŠ” ì  ì²˜ë¦¬
            this.processAttack(colossus, nearbyEnemy, nearbyEnemy.heroId ? 'HERO' : 'MINION', match, settings, dt, isBlue);
        } else {
            // êµ¬ì¡°ë¬¼ì´ ê°€ê¹Œìš°ë©´(30ì´ë‚´) ì›¨ì´í¬ì¸íŠ¸ ë¬´ì‹œí•˜ê³  êµ¬ì¡°ë¬¼ë¡œ ì§ì§„
            if (structureTarget && distToStructure < 30) {
                this.moveToTarget(colossus, structureTarget, dt);
            } else {
                // ë©€ë©´ ì›¨ì´í¬ì¸íŠ¸ ë”°ë¼ ì´ë™
                this.processWaypointMovement(colossus, isBlue, dt);
            }
        }
    }
  }

  // ê³µê²© ì‹¤í–‰
  private static processAttack(
    me: Minion, 
    target: any, 
    type: string, 
    match: LiveMatch, 
    settings: BattleSettings, 
    dt: number,
    isBlue: boolean
  ) {
    // ê±°ì‹ ë³‘ ê³µì† (ì•½ê°„ ëŠë¦¼)
    if (Math.random() > dt * 1.5) return; 

    // ì„¤ì •ê°’ ë¡œë“œ
    const s = settings.siege || { 
        superDmg: 1.0, colossusToHero: 1.0, colossusToT1: 0.4 
    };
    const fieldTowers = settings.fieldSettings?.towers || ({} as any);
    
    let dmgFactor = 1.0;
    let targetArmor = 50; // ê¸°ë³¸ ë°©ì–´ë ¥

    if (type === 'STRUCTURE') {
        if (target.isNexus) {
            dmgFactor = s.colossusToNexus ?? 0.05; // ë„¥ì„œìŠ¤ ë°ë¯¸ì§€ ê³„ìˆ˜
            targetArmor = fieldTowers.nexus?.armor || 200;
        } else {
            const laneKey = me.lane.toLowerCase();
            const enemyStats = isBlue ? match.stats.red : match.stats.blue;
            const tier = ((enemyStats.towers as any)[laneKey] || 0) + 1;
            
            if (tier === 1) { 
                dmgFactor = s.colossusToT1 ?? 0.4; 
                targetArmor = fieldTowers.t1?.armor || 80; 
            }
            else if (tier === 2) { 
                dmgFactor = s.colossusToT2 ?? 0.2; 
                targetArmor = fieldTowers.t2?.armor || 120; 
            }
            else { 
                dmgFactor = s.colossusToT3 ?? 0.1; 
                targetArmor = fieldTowers.t3?.armor || 150; 
            }
        }
    } else if (type === 'HERO') {
        dmgFactor = s.colossusToHero ?? 0.3;
        targetArmor = (target.level * 3) + 40;
    }

    // ìµœì¢… ë°ë¯¸ì§€ ê³„ì‚°
    const baseMult = s.superDmg ?? 1.0;
    const rawDmg = me.atk * baseMult * dmgFactor;
    const finalDmg = Math.max(1, calcMitigatedDamage(rawDmg, targetArmor));

    // ë°ë¯¸ì§€ ì ìš©
    if (type === 'STRUCTURE') {
        const enemyStats = isBlue ? match.stats.red : match.stats.blue;
        if (target.isNexus) {
            enemyStats.nexusHp -= finalDmg;
        } else {
            const laneKey = me.lane.toLowerCase();
            // ì²´ë ¥ ë°ì´í„° ì•ˆì „ ì´ˆê¸°í™”
            if (!(enemyStats as any).laneHealth) {
                 (enemyStats as any).laneHealth = { top: 10000, mid: 10000, bot: 10000 };
            }
            
            // [ìˆ˜ì •ì™„ë£Œ] í™•ë¥  ì œê±° -> ì‹¤ì œ ì²´ë ¥ ê¹ê¸°
            (enemyStats as any).laneHealth[laneKey] -= finalDmg;

            if ((enemyStats as any).laneHealth[laneKey] <= 0) {
                (enemyStats.towers as any)[laneKey]++;
                match.logs.push({ 
                    time: Math.floor(match.currentDuration), 
                    message: `ğŸ¤– ê±°ì‹ ë³‘ì´ ${laneKey.toUpperCase()} íƒ€ì›Œë¥¼ íŒŒê´´í–ˆìŠµë‹ˆë‹¤!`, 
                    type: 'TOWER', team: isBlue ? 'BLUE' : 'RED' 
                });
                // ë‹¤ìŒ íƒ€ì›Œ ì²´ë ¥ ë¦¬ì…‹ (ì„ì‹œ)
                (enemyStats as any).laneHealth[laneKey] = 15000;
            }
        }
    } else {
        target.hp -= finalDmg;
        if (target.currentHp !== undefined) target.currentHp -= finalDmg;
    }
  }

  // ì§ì§„ ì´ë™
  private static moveToTarget(me: Minion, target: {x:number, y:number}, dt: number) {
    const dx = target.x - me.x;
    const dy = target.y - me.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const speed = 10;

    if (dist > 0.1) {
        me.x += (dx / dist) * speed * dt * 0.1;
        me.y += (dy / dist) * speed * dt * 0.1;
    }
  }

  // ì›¨ì´í¬ì¸íŠ¸ ì´ë™
  private static processWaypointMovement(me: Minion, isBlue: boolean, dt: number) {
    const waypoints = WAYPOINTS['MID'];
    if (!waypoints) return;

    const path = isBlue ? waypoints : [...waypoints].reverse();
    let targetPos = path[me.pathIdx];
    
    if (!targetPos) targetPos = isBlue ? BASES.RED : BASES.BLUE;

    const dx = targetPos.x - me.x;
    const dy = targetPos.y - me.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    if (dist < 3) {
        if (me.pathIdx < path.length - 1) {
            me.pathIdx++;
        }
    } else {
        const speed = 10;
        me.x += (dx / dist) * speed * dt * 0.1;
        me.y += (dy / dist) * speed * dt * 0.1;
    }
  }

  private static findNextStructure(me: Minion, match: LiveMatch) {
    const isBlue = me.team === 'BLUE';
    const enemyStats = isBlue ? match.stats.red : match.stats.blue;
    const brokenCount = enemyStats.towers.mid; // ë¯¸ë“œë§Œ ë´„

    let targetPos = null;
    let isNexus = false;

    if (brokenCount < 3) {
        const tier = brokenCount + 1;
        const coords = isBlue ? TOWER_COORDS.RED : TOWER_COORDS.BLUE;
        targetPos = coords.MID[tier - 1];
    } else {
        const coords = isBlue ? TOWER_COORDS.RED : TOWER_COORDS.BLUE;
        targetPos = coords.NEXUS;
        isNexus = true;
    }

    if (!targetPos) return null;
    return { ...targetPos, isNexus };
  }

  private static findBlockingEnemy(me: Minion, match: LiveMatch) {
    const isBlue = me.team === 'BLUE';
    const enemyTeam = isBlue ? 'RED' : 'BLUE';
    const enemyHeroes = isBlue ? match.redTeam : match.blueTeam;
    
    // ì½”ì•ì˜ ì  ì˜ì›… (ê±°ë¦¬ 8)
    const closeHero = enemyHeroes.find(h => h.currentHp > 0 && Collision.inRange(me, h, 8));
    if (closeHero) return closeHero;

    // ì½”ì•ì˜ ì  ë¯¸ë‹ˆì–¸ (ê±°ë¦¬ 8)
    if (match.minions) {
        const closeMinion = match.minions.find(m => m.team === enemyTeam && m.hp > 0 && Collision.inRange(me, m, 8));
        if (closeMinion) return closeMinion;
    }
    
    return null;
  }
}


--- FILE: src/engine/match/logics/LaningLogic.ts ---
import { LivePlayer, LiveMatch, Hero } from '../../../types';
import { AIUtils } from '../ai/AIUtils';
import { BASES, TOWER_COORDS } from '../constants/MapConstants';
import { Collision } from '../utils/Collision';
import { MacroDecision } from '../ai/MacroBrain';

export class LaningLogic {
  
  static decide(player: LivePlayer, match: LiveMatch, hero: Hero): MacroDecision | null {
    // 1. ë¼ì¸ì „ ìˆ˜í–‰ ì¡°ê±´ (ì—„ê²©í•˜ê²Œ ì œí•œ)
    // - ì •ê¸€ëŸ¬ ì œì™¸
    // - ê²Œì„ ì‹œê°„ 8ë¶„ ë¯¸ë§Œ (ì´ˆë°˜)
    // - ìì‹ ì˜ ë¼ì¸ 1ì°¨ íƒ€ì›Œ ìƒì¡´
    if (player.lane === 'JUNGLE') return null;
    if (match.currentDuration > 480) return null; // 8ë¶„

    const isBlue = match.blueTeam.includes(player);
    const myTowers = isBlue ? match.stats.blue.towers : match.stats.red.towers;
    const laneKey = player.lane.toLowerCase();
    
    // 1ì°¨ íƒ€ì›Œê°€ ê¹¨ì¡Œìœ¼ë©´ ë¼ì¸ì „ ì¢…ë£Œ (ììœ  í–‰ë™)
    if ((myTowers as any)[laneKey] >= 1) return null;

    // 2. ë¯¸ë‹ˆì–¸ ì „ì„ (Wave Line) íŒŒì•…
    const minions = match.minions || [];
    const laneMinions = minions.filter(m => m.lane === player.lane && m.hp > 0);
    const allyMinions = laneMinions.filter(m => m.team === (isBlue ? 'BLUE' : 'RED'));
    const enemyMinions = laneMinions.filter(m => m.team !== (isBlue ? 'BLUE' : 'RED'));

    // ì•„êµ° ë¯¸ë‹ˆì–¸ì´ ì—†ìœ¼ë©´ -> íƒ€ì›Œ í—ˆê¹… (ì•ˆì „ ì œì¼)
    if (allyMinions.length === 0) {
        const myTowerPos = this.getMyTowerPos(player.lane, 1, isBlue);
        // íƒ€ì›Œë³´ë‹¤ ì‚´ì§ ë’¤ì— ì„œê¸°
        return { 
            action: 'WAIT', 
            targetPos: myTowerPos, 
            reason: 'ë¼ì¸ì „: íƒ€ì›Œ í—ˆê¹… (ë¯¸ë‹ˆì–¸ ì—†ìŒ)' 
        };
    }

    // 3. í¬ì§€ì…”ë‹: "ì•„êµ° ì›ê±°ë¦¬ ë¯¸ë‹ˆì–¸" ìœ„ì¹˜ë¥¼ ê¸°ì¤€ì ìœ¼ë¡œ ì‚¼ìŒ
    // (íƒ±ì»¤ì—¬ë„ ì´ˆë°˜ì—” ë¯¸ë‹ˆì–¸ ë’¤ê°€ ì•ˆì „í•¨)
    const anchorMinion = allyMinions[allyMinions.length - 1]; // ë°°ì—´ ë’¤ìª½ì´ ë³´í†µ ì›ê±°ë¦¬/ëŠ¦ê²Œ ì˜¨ ë¯¸ë‹ˆì–¸
    let idealPos = { x: anchorMinion.x, y: anchorMinion.y };

    // 4. [CS ë§‰íƒ€] ë¡œì§ (ìµœìš°ì„ )
    const range = hero.stats.range / 100; // ë§µ ìŠ¤ì¼€ì¼ ë³€í™˜
    const farmableMinion = enemyMinions.find(em => 
        Collision.inRange(player, em, range) && em.hp < (player.level * 60 + 50)
    );

    if (farmableMinion) {
        return { 
            action: 'FIGHT', 
            targetPos: { x: farmableMinion.x, y: farmableMinion.y }, 
            targetUnit: farmableMinion as any, 
            reason: 'ë¼ì¸ì „: CS ë§‰íƒ€' 
        };
    }

    // 5. [ê²¬ì œ] ë¡œì§ (CSê°€ ì—†ì„ ë•Œë§Œ)
    // - ì  ì˜ì›…ì´ ì‚¬ê±°ë¦¬ ë‚´ì— ìˆìŒ
    // - ì  ë¯¸ë‹ˆì–¸ë³´ë‹¤ ìš°ë¦¬ ë¯¸ë‹ˆì–¸ì´ ë§ê±°ë‚˜ ë¹„ìŠ·í•¨
    const nearbyEnemyHero = this.findLaneOpponent(player, match, isBlue);
    if (nearbyEnemyHero) {
        const dist = AIUtils.dist(player, nearbyEnemyHero);
        
        // ë”œêµí™˜ ì¡°ê±´: ì‚¬ê±°ë¦¬ ë‚´ + ë¬´ë¦¬í•˜ê²Œ ì«“ì§€ ì•ŠìŒ(íƒ€ì›Œ ê±°ë¦¬ í™•ì¸)
        if (dist <= range * 1.2 && allyMinions.length >= enemyMinions.length - 1) {
            const enemyTowerPos = this.getMyTowerPos(player.lane, 1, !isBlue);
            // ì  íƒ€ì›Œ ë‹¤ì´ë¸Œ ë°©ì§€ (ê±°ë¦¬ 15 ìœ ì§€)
            if (AIUtils.dist(nearbyEnemyHero, enemyTowerPos) > 15) {
                return {
                    action: 'FIGHT',
                    targetPos: { x: nearbyEnemyHero.x, y: nearbyEnemyHero.y },
                    targetUnit: nearbyEnemyHero,
                    reason: 'ë¼ì¸ì „: ê²¬ì œ'
                };
            }
        }
    }

    // 6. [ëŒ€ê¸°/ì´ë™] í•  ê±° ì—†ìœ¼ë©´ ë¯¸ë‹ˆì–¸ ë’¤ì—ì„œ ë¬´ë¹™
    // ë³¸ì§„ ë°©í–¥ìœ¼ë¡œ ì‚´ì§ ë’¤ë¡œ ë¹ ì ¸ì„œ ì•ˆì •ì ìœ¼ë¡œ ìœ„ì¹˜
    const myBase = AIUtils.getMyBasePos(isBlue);
    const dirX = myBase.x - idealPos.x;
    const dirY = myBase.y - idealPos.y;
    const len = Math.sqrt(dirX*dirX + dirY*dirY);
    
    // ì•½ê°„ì˜ ëœë¤ ë¬´ë¹™ ì¶”ê°€ (AIê°€ ëœ ë”±ë”±í•´ ë³´ì´ê²Œ)
    const offsetX = (Math.random() - 0.5) * 2;
    const offsetY = (Math.random() - 0.5) * 2;

    idealPos.x += (dirX / len) * 3 + offsetX;
    idealPos.y += (dirY / len) * 3 + offsetY;

    return { action: 'FARM', targetPos: idealPos, reason: 'ë¼ì¸ì „: ëŒ€ì¹˜ ë° íŒŒë°' };
  }

  private static getMyTowerPos(lane: string, tier: number, isBlue: boolean) {
    const coords = isBlue ? TOWER_COORDS.BLUE : TOWER_COORDS.RED;
    if (lane === 'MID') return coords.MID[tier - 1];
    if (lane === 'TOP') return coords.TOP[tier - 1];
    if (lane === 'BOT') return coords.BOT[tier - 1];
    return coords.NEXUS;
  }

  private static findLaneOpponent(player: LivePlayer, match: LiveMatch, isBlue: boolean) {
    const enemies = isBlue ? match.redTeam : match.blueTeam;
    // ë‚´ ë¼ì¸ì— ìˆê³ , ë„ˆë¬´ ë©€ì§€ ì•Šì€ ì  (ê±°ë¦¬ 25 ì´ë‚´)
    return enemies.find(e => e.lane === player.lane && e.currentHp > 0 && AIUtils.dist(player, e) < 25);
  }
}


--- FILE: src/engine/match/logics/MinionLogic.ts ---
// ==========================================
// FILE PATH: /src/engine/match/logics/MinionLogic.ts
// ==========================================
import { LiveMatch, Minion, BattleSettings, Hero } from '../../../types';
import { WAYPOINTS, TOWER_COORDS } from '../constants/MapConstants';
import { Collision } from '../utils/Collision';
import { SpatialGrid } from '../utils/SpatialGrid'; // [ì‹ ê·œ]
import { 
    distributeRewards, 
    calcMitigatedDamage, 
    MINION_REWARD 
} from './CombatLogic'; 

const MINION_SPEED = 15;

export class MinionLogic {

  // [ìˆ˜ì •] cachedEnemies -> enemyGrids (SpatialGrid ê°ì²´)
  static processSingleMinion(
      m: Minion, 
      match: LiveMatch, 
      settings: BattleSettings, 
      dt: number, 
      enemyGrids: { minions: SpatialGrid, heroes: SpatialGrid },
      shouldThink: boolean,
      heroes: Hero[] 
  ) {
    if (m.type === 'SUMMONED_COLOSSUS') return;

    // íƒ€ê²Ÿì´ ìˆìœ¼ë©´ ì´ë™ ë©ˆì¶¤ (Sticky Target)
    if (m.targetId) {
       // ... (ê¸°ì¡´ íƒ€ê²Ÿ ìœ íš¨ì„± ê²€ì‚¬ ë¡œì§ì´ í•„ìš”í•˜ì§€ë§Œ, ì„±ëŠ¥ìƒ ìƒëµí•˜ê³  ê³µê²© ì‹œë„ì—ì„œ ì²´í¬)
    }

    const isBlue = m.team === 'BLUE';
    const range = m.type === 'MELEE' ? 6 : 16;
    
    // [ìµœì í™”] ê·¸ë¦¬ë“œë¥¼ í†µí•´ ë‚´ ì£¼ë³€ ì ë§Œ ê°€ì ¸ì˜´
    // 1. ë¯¸ë‹ˆì–¸ íƒ€ê²ŸíŒ…
    const nearbyEnemyMinions = enemyGrids.minions.getNearbyUnits(m);
    let target: any = Collision.findNearest(m, nearbyEnemyMinions, range);
    let targetType = 'MINION';

    // 2. ì˜ì›… íƒ€ê²ŸíŒ…
    if (!target) {
      const nearbyEnemyHeroes = enemyGrids.heroes.getNearbyUnits(m);
      target = Collision.findNearest(m, nearbyEnemyHeroes, range);
      if (target) targetType = 'HERO';
    }

    // 3. êµ¬ì¡°ë¬¼ íƒ€ê²ŸíŒ… (êµ¬ì¡°ë¬¼ì€ ëª‡ ê°œ ì—†ìœ¼ë¯€ë¡œ ê·¸ë¦¬ë“œ ë¶ˆí•„ìš”)
    if (!target) {
      const structure = this.findEnemyStructure(m, match);
      if (structure) {
          target = structure;
          targetType = 'STRUCTURE';
      }
    }

    if (target) {
        m.targetId = target.id || target.heroId || 'structure'; // íƒ€ê²Ÿ ê¸°ì–µ
        this.attackTarget(m, target, targetType, match, settings, dt, isBlue, heroes);
    } else {
        m.targetId = undefined;
        this.move(m, isBlue, dt);
    }
  }

  private static attackTarget(
      m: Minion, target: any, type: string, match: LiveMatch, 
      settings: BattleSettings, dt: number, isBlue: boolean, heroes: Hero[]
  ) {
    // íƒ€ê²Ÿì´ ì£½ì—ˆê±°ë‚˜ ë©€ì–´ì¡Œìœ¼ë©´ ê³µê²© ì·¨ì†Œ
    if ((target.hp !== undefined && target.hp <= 0) || 
        (target.currentHp !== undefined && target.currentHp <= 0) ||
        !Collision.inRange(m, target, (m.type === 'MELEE' ? 6 : 16) + 2)) {
        m.targetId = undefined;
        return;
    }

    if (Math.random() > dt * 1.5) return; 

    const s = settings.siege || { minionDmg: 1.0, cannonDmg: 1.0, dmgToHero: 1.0, dmgToT1: 0.3, dmgToT2: 0.25, dmgToT3: 0.2, dmgToNexus: 0.1 };

    let sourceFactor = s.minionDmg ?? 1.0;
    if (m.type === 'SIEGE') sourceFactor = s.cannonDmg ?? 1.0;

    let targetFactor = 1.0; 
    let targetArmor = 0;
    const fieldTowers = settings.fieldSettings?.towers || ({} as any);

    if (type === 'HERO') {
        targetFactor = s.dmgToHero ?? 1.0;
        targetArmor = (target.level * 3) + 30; 
    }
    else if (type === 'STRUCTURE') {
        if (target.isNexus) {
            targetFactor = s.dmgToNexus ?? 0.1;
            targetArmor = fieldTowers.nexus?.armor || 200;
        } else {
            const laneKey = m.lane.toLowerCase();
            const enemyStats = isBlue ? match.stats.red : match.stats.blue;
            const tier = ((enemyStats.towers as any)[laneKey] || 0) + 1;
            
            if (tier === 1) { targetFactor = s.dmgToT1 ?? 0.3; targetArmor = fieldTowers.t1?.armor || 80; }
            else if (tier === 2) { targetFactor = s.dmgToT2 ?? 0.25; targetArmor = fieldTowers.t2?.armor || 120; }
            else { targetFactor = s.dmgToT3 ?? 0.2; targetArmor = fieldTowers.t3?.armor || 150; }
        }
    }

    if (type === 'MINION') {
        sourceFactor *= 0.3; 
    }

    const rawAtk = m.atk || 10;
    const mitigatedDmg = calcMitigatedDamage(rawAtk, targetArmor);
    const finalDmg = Math.max(1, mitigatedDmg * sourceFactor * targetFactor * 3.0);

    if (type === 'MINION' || type === 'HERO') {
        target.hp -= finalDmg;
        if (target.currentHp !== undefined) target.currentHp -= finalDmg;

        if (type === 'MINION' && target.hp <= 0) {
            const reward = (MINION_REWARD as any)[target.type] || MINION_REWARD.MELEE;
            distributeRewards(match, target, null, isBlue ? 'BLUE' : 'RED', reward, heroes);
        }
    } 
    else if (type === 'STRUCTURE') {
        const laneKey = m.lane.toLowerCase();
        const enemyStats = isBlue ? match.stats.red : match.stats.blue;

        if (target.isNexus) {
            enemyStats.nexusHp -= finalDmg;
        } else {
            if (!(enemyStats as any).laneHealth) {
                (enemyStats as any).laneHealth = { top: 10000, mid: 10000, bot: 10000 };
            }
            (enemyStats as any).laneHealth[laneKey] -= finalDmg;

            if ((enemyStats as any).laneHealth[laneKey] <= 0) {
                (enemyStats.towers as any)[laneKey]++;
                match.logs.push({ 
                    time: Math.floor(match.currentDuration), 
                    message: `ğŸ”¥ ë¯¸ë‹ˆì–¸ êµ°ë‹¨ì´ ${laneKey.toUpperCase()} íƒ€ì›Œë¥¼ íŒŒê´´í–ˆìŠµë‹ˆë‹¤!`, 
                    type: 'TOWER', team: isBlue ? 'BLUE' : 'RED' 
                });
                const currentBroken = (enemyStats.towers as any)[laneKey];
                if (currentBroken < 3) {
                     const nextTierStats = (fieldTowers as any)[`t${currentBroken + 1}`];
                     (enemyStats as any).laneHealth[laneKey] = nextTierStats?.hp || 15000;
                }
            }
        }
    }
  }

  private static move(m: Minion, isBlue: boolean, dt: number) {
    const waypoints = WAYPOINTS[m.lane];
    if (!waypoints) return; 

    const path = isBlue ? waypoints : [...waypoints].reverse();
    const targetPos = path[m.pathIdx];

    if (!targetPos) return;

    const dx = targetPos.x - m.x;
    const dy = targetPos.y - m.y;
    const distSq = dx*dx + dy*dy;

    if (distSq < 4.0 || distSq < 0.00001) { 
      m.pathIdx = Math.min(m.pathIdx + 1, path.length - 1);
    } else {
      const dist = Math.sqrt(distSq);
      m.x += (dx / dist) * MINION_SPEED * dt * 0.1;
      m.y += (dy / dist) * MINION_SPEED * dt * 0.1;
    }
  }

  private static findEnemyStructure(m: Minion, match: LiveMatch) {
    if (m.lane === 'JUNGLE') return null; 

    const isBlue = m.team === 'BLUE';
    const enemyStats = isBlue ? match.stats.red : match.stats.blue;
    const laneKey = m.lane.toLowerCase();
    const brokenCount = (enemyStats.towers as any)[laneKey];
    
    let targetPos = null;
    let isNexus = false;

    if (brokenCount < 3) {
        const tier = brokenCount + 1;
        const coords = isBlue ? TOWER_COORDS.RED : TOWER_COORDS.BLUE;
        // @ts-ignore
        targetPos = coords[m.lane][tier - 1];
    } else {
        const coords = isBlue ? TOWER_COORDS.RED : TOWER_COORDS.BLUE;
        targetPos = coords.NEXUS;
        isNexus = true;
    }

    if (!targetPos) return null;

    const dx = m.x - targetPos.x;
    const dy = m.y - targetPos.y;
    const distSq = dx*dx + dy*dy;
    
    if (distSq < 100) return { ...targetPos, isNexus };
    return null;
  }
}


--- FILE: src/engine/match/logics/CombatLogic.ts ---
// ==========================================
// FILE PATH: /src/engine/match/logics/CombatLogic.ts
// ==========================================
import { LiveMatch, LivePlayer, RoleSettings, BattleSettings, Hero } from '../../../types';
import { getDistance } from '../../data/MapData';
import { applyRoleBonus } from '../systems/RoleManager';

export const MINION_REWARD = {
    'MELEE': { gold: 21, xp: 60 },
    'RANGED': { gold: 14, xp: 30 },
    'SIEGE': { gold: 60, xp: 90 },
    'SUMMONED_COLOSSUS': { gold: 150, xp: 200 }
};

export const calcMitigatedDamage = (rawDmg: number, armor: number) => {
  const reduction = 100 / (100 + armor);
  return rawDmg * reduction;
};

export const distributeRewards = (
    match: LiveMatch, 
    deadUnitPos: {x:number, y:number}, 
    killer: LivePlayer | null, 
    killerTeam: 'BLUE'|'RED', 
    reward: { gold: number, xp: number },
    heroes: Hero[] 
) => {
    // 1. í‚¬ëŸ¬ ë³´ìƒ
    if (killer) {
        killer.cs++;
        killer.gold += reward.gold;

        // [ì‹ ê·œ] ìˆ˜í˜¸ê¸°ì‚¬(Support) ì „ìš© ë¡œì§: íƒ€ê³¤ì‚° íš¨ê³¼ (Relic Shield)
        // ìˆ˜í˜¸ê¸°ì‚¬ê°€ ë§‰íƒ€ë¥¼ ì³¤ë‹¤ë©´, ê°€ì¥ ê°€ê¹Œìš´ ì•„êµ°ì—ê²Œë„ ê³¨ë“œë¥¼ ë³µì‚¬í•´ì¤Œ
        const killerHero = heroes.find(h => h.id === killer.heroId);
        if (killerHero && killerHero.role === 'ìˆ˜í˜¸ê¸°ì‚¬') {
            const allies = killerTeam === 'BLUE' ? match.blueTeam : match.redTeam;
            // ë‚˜ë¥¼ ì œì™¸í•œ ê°€ì¥ ê°€ê¹Œìš´ ì•„êµ° ì°¾ê¸°
            let nearestAlly = null;
            let minDist = 15; // ê³µìœ  ë²”ìœ„
            
            for (const ally of allies) {
                if (ally !== killer && ally.currentHp > 0) {
                    const d = getDistance(killer, ally);
                    if (d < minDist) {
                        minDist = d;
                        nearestAlly = ally;
                    }
                }
            }

            if (nearestAlly) {
                nearestAlly.gold += reward.gold; // ê³¨ë“œ ê³µìœ 
                nearestAlly.cs++; // (ì„ íƒì‚¬í•­) ì›ë”œ CSë„ ì˜¬ë ¤ì¤Œ (ê¸°ë¶„ ì¢‹ìœ¼ë¼ê³ )
            }
        }
    }

    // 2. ê²½í—˜ì¹˜ ë¶„ë°° (ê¸°ì¡´ ë¡œì§)
    const allies = killerTeam === 'BLUE' ? match.blueTeam : match.redTeam;
    const beneficiaries = allies.filter(p => 
        p.currentHp > 0 && 
        p.respawnTimer <= 0 &&
        getDistance(p, deadUnitPos) < 18 
    );

    if (beneficiaries.length > 0) {
        const xpPerPerson = Math.floor(reward.xp / beneficiaries.length);
        beneficiaries.forEach(p => {
            (p as any).exp = ((p as any).exp || 0) + xpPerPerson;
            
            // (ì´ì „ì˜ ë‹¨ìˆœ ê³µìœ  ë¡œì§ì€ ìœ„ íƒ€ê³¤ì‚° ë¡œì§ê³¼ ê²¹ì¹˜ë¯€ë¡œ ì‚­ì œí•˜ê±°ë‚˜ ìœ ì§€í•´ë„ ë¨)
            // ì—¬ê¸°ì„  íƒ€ê³¤ì‚° ë¡œì§ì„ ìœ„í•´ 'ê³¨ë“œ ê³µìœ ' ë¶€ë¶„ì€ ì œê±°í•˜ê³  ê²½í—˜ì¹˜ë§Œ ë‚¨ê¹€
        });
    }
};

export const distributeAssist = (match: LiveMatch, killer: LivePlayer, victim: LivePlayer, isBlue: boolean) => {
    const allies = isBlue ? match.blueTeam : match.redTeam;
    const assists = allies.filter(p => p !== killer && p.currentHp > 0 && getDistance(p, victim) < 20);
    
    assists.forEach(p => {
        p.assists++;
        p.gold += 150; 
        (p as any).exp = ((p as any).exp || 0) + 100;
    });
};

export const calculateHeroDamage = (
    attacker: any, defender: any, atkStats: any, defStats: any, attackerHero: any, 
    isBlue: boolean, settings: BattleSettings, roleSettings: RoleSettings, buffType: string
) => {
    const god = isBlue ? settings.dante : settings.izman;
    const atkRatio = god?.atkRatio || 1.0;
    const itemAD = attacker.items.reduce((s:number, i:any) => s + (i.ad||0), 0);
    const totalAD = (atkStats.baseAtk + atkStats.ad + itemAD) * atkRatio;

    const itemCrit = attacker.items.reduce((s:number, i:any) => s + (i.crit||0), 0);
    let isCrit = Math.random() < (atkStats.crit + itemCrit) / 100;
    let rawDmg = totalAD * (isCrit ? 1.75 : 1.0);

    const defGod = isBlue ? settings.izman : settings.dante; 
    const defRatio = defGod?.defRatio || 1.0;
    const itemArmor = defender.items.reduce((s:number, i:any) => s + (i.armor||0), 0);
    const totalArmor = (defStats.armor + itemArmor) * defRatio;
    
    const itemPen = attacker.items.reduce((s:number, i:any) => s + (i.pen||0), 0);
    const effectiveArmor = Math.max(0, totalArmor - (atkStats.pen + itemPen));
    
    const finalDamage = calcMitigatedDamage(rawDmg, effectiveArmor);
    
    const { damageMod } = applyRoleBonus(attacker, attackerHero.role, false, [], roleSettings);
    let result = finalDamage * damageMod;

    if (buffType === 'COMBAT') result *= 1.1; 

    return Math.floor(result);
};

export const calculateUnitDamage = (
    attacker: any, atkStats: any, targetArmor: number, isBlue: boolean, settings: BattleSettings
) => {
    const god = isBlue ? settings.dante : settings.izman;
    const atkRatio = god?.atkRatio || 1.0;
    const itemAD = attacker.items.reduce((s:number, i:any) => s + (i.ad||0), 0);
    const totalAD = (atkStats.baseAtk + atkStats.ad + itemAD) * atkRatio;

    return Math.floor(calcMitigatedDamage(totalAD, targetArmor));
};


--- FILE: src/engine/match/logics/TowerLogic.ts ---
// ==========================================
// FILE PATH: /src/engine/match/logics/TowerLogic.ts
// ==========================================
import { LivePlayer, Minion } from '../../../types';
import { getDistance } from '../../data/MapData';
import { calcMitigatedDamage } from './CombatLogic';

export class TowerLogic {
  /**
   * íƒ€ì›Œì˜ ê³µê²© ëŒ€ìƒì„ ì„ ì •í•©ë‹ˆë‹¤.
   * ìš°ì„ ìˆœìœ„:
   * 1. [ë„ì›€ ìš”ì²­] ì•„êµ° ì˜ì›…ì„ ê³µê²©í•œ ì  ì˜ì›…
   * 2. [ì¼ë°˜] ê°€ì¥ ê°€ê¹Œìš´ ë¯¸ë‹ˆì–¸
   * 3. [ì¼ë°˜] ê°€ì¥ ê°€ê¹Œìš´ ì˜ì›…
   */
  static selectTarget(
    towerPos: { x: number, y: number },
    enemies: { heroes: LivePlayer[], minions: Minion[] },
    allies: LivePlayer[], // ë³´í˜¸í•´ì•¼ í•  ì•„êµ° ì˜ì›…ë“¤
    range: number,
    currentTime: number
  ): { unit: any, type: 'HERO' | 'MINION' } | null {
    
    // 1. ì‚¬ê±°ë¦¬ ë‚´ ì  ì‹ë³„
    const nearbyMinions = enemies.minions.filter(m => 
        m.hp > 0 && getDistance(m, towerPos) <= range
    );
    const nearbyEnemyHeroes = enemies.heroes.filter(h => 
        h.currentHp > 0 && h.respawnTimer <= 0 && getDistance(h, towerPos) <= range
    );

    if (nearbyMinions.length === 0 && nearbyEnemyHeroes.length === 0) return null;

    // 2. [ì–´ê·¸ë¡œ 0ìˆœìœ„] ì•„êµ° ì˜ì›…ì„ ê³µê²©í•œ ì  ì˜ì›… ì‹ë³„ (Call for Help)
    const AGGRO_DURATION = 2.0; // ìµœê·¼ 2ì´ˆ ë‚´ ê³µê²©
    
    const aggroTarget = nearbyEnemyHeroes.find(enemy => {
        if (!enemy.lastAttackTime || !enemy.lastAttackedTargetId) return false;
        
        const timeSinceAttack = currentTime - enemy.lastAttackTime;
        if (timeSinceAttack > AGGRO_DURATION) return false;

        // ì ì´ ë•Œë¦° ëŒ€ìƒì´ 'ë‚´ ì‚¬ê±°ë¦¬ ì•ˆ' í˜¹ì€ 'ê·¼ì²˜'ì— ìˆëŠ” ì•„êµ°ì¸ì§€ í™•ì¸
        // (ë‹¨ìˆœí™”: ë§µ ì „ì²´ ì•„êµ° ì¤‘ ID ë§¤ì¹­)
        const victim = allies.find(a => a.heroId === enemy.lastAttackedTargetId);
        return !!victim;
    });

    if (aggroTarget) {
        return { unit: aggroTarget, type: 'HERO' };
    }

    // 3. [ì¼ë°˜ ìš°ì„ ìˆœìœ„] ë¯¸ë‹ˆì–¸ > ì˜ì›… (ê±°ë¦¬ìˆœ)
    if (nearbyMinions.length > 0) {
        nearbyMinions.sort((a, b) => getDistance(a, towerPos) - getDistance(b, towerPos));
        return { unit: nearbyMinions[0], type: 'MINION' };
    } 
    else {
        nearbyEnemyHeroes.sort((a, b) => getDistance(a, towerPos) - getDistance(b, towerPos));
        return { unit: nearbyEnemyHeroes[0], type: 'HERO' };
    }
  }

  /**
   * íƒ€ì›Œ ë°ë¯¸ì§€ë¥¼ ê³„ì‚°í•˜ê³  ì ìš©í•©ë‹ˆë‹¤.
   */
  static applyDamage(
    target: { unit: any, type: 'HERO' | 'MINION' },
    towerStats: any,
    dt: number,
    isNexus: boolean,
    hasMinionsNearby: boolean // ë°±ë„ì–´ ë°©ì§€ìš©
  ) {
    const atk = towerStats.atk || (isNexus ? 500 : 250);
    // ì´ˆë‹¹ ë°ë¯¸ì§€ (Simulation Step ë³´ì •)
    let damage = atk * dt;

    // [ë°±ë„ì–´ ë°©ì§€] ë¯¸ë‹ˆì–¸ ì—†ì´ ì˜ì›…ë§Œ ìˆìœ¼ë©´ ë°ë¯¸ì§€ 3ë°°
    if (target.type === 'HERO' && !hasMinionsNearby) {
        damage *= 3.0;
    }

    // ë°©ì–´ë ¥ ì ìš©
    let armor = 0;
    if (target.type === 'HERO') {
        // ì˜ì›…ì€ ë ˆë²¨ ë¹„ë¡€ ë°©ì–´ë ¥ (ì•„ì´í…œì€ ë³µì¡í•´ì„œ ì•½ì‹ ì ìš©)
        armor = (target.unit.level * 3) + 30;
    } else {
        // ë¯¸ë‹ˆì–¸ì€ ê¸°ë³¸ ë°©ì–´ë ¥ì´ ë‚®ìŒ
        armor = 0; 
    }

    const realDamage = calcMitigatedDamage(damage, armor);

    // ì²´ë ¥ ì°¨ê°
    if (target.type === 'HERO') {
        target.unit.currentHp -= realDamage;
    } else {
        target.unit.hp -= realDamage;
    }
  }
}


--- FILE: src/engine/match/utils/Collision.ts ---
// ==========================================
// FILE PATH: /src/engine/match/utils/Collision.ts
// ==========================================

export interface Point { x: number; y: number; }

export class Collision {
  // [ìµœì í™”] ê±°ë¦¬ ì œê³± ê³„ì‚° (ë£¨íŠ¸ ì—°ì‚° ì œê±°)
  static distSq(p1: Point, p2: Point): number {
    const dx = p1.x - p2.x;
    const dy = p1.y - p2.y;
    return dx * dx + dy * dy;
  }

  // [ìµœì í™”] ì›í˜• ì¶©ëŒ ì²´í¬
  static checkCircle(p1: Point, r1: number, p2: Point, r2: number): boolean {
    const d2 = this.distSq(p1, p2);
    const radSum = r1 + r2;
    return d2 <= radSum * radSum;
  }

  // [ìµœì í™”] ì‚¬ê±°ë¦¬ ì²´í¬ (ê±°ë¦¬ ì œê³± ë¹„êµ)
  static inRange(attacker: Point, target: Point, range: number): boolean {
    return this.distSq(attacker, target) <= (range * range);
  }

  // [ìµœì í™”] ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
  static findNearest<T extends Point>(me: Point, targets: T[], maxRange: number = 999): T | null {
    let nearest: T | null = null;
    let minDistSq = maxRange * maxRange;

    for (let i = 0; i < targets.length; i++) {
      const t = targets[i];
      const dSq = this.distSq(me, t);
      
      if (dSq < minDistSq) {
        minDistSq = dSq;
        nearest = t;
      }
    }
    return nearest;
  }
}


--- FILE: src/engine/match/utils/StatUtils.ts ---
import { HeroStats, Item, Hero } from '../../../types';

export const getLevelScaledStats = (baseStats: HeroStats, level: number): HeroStats => {
  const scale = (val: number, rate: number) => Math.floor(val * (1 + (level - 1) * rate));
  return {
    ...baseStats,
    hp: scale(baseStats.hp, 0.05),        
    ad: scale(baseStats.ad, 0.15),        
    ap: scale(baseStats.ap, 0.15),        
    armor: scale(baseStats.armor, 0.03),  
    baseAtk: scale(baseStats.baseAtk, 0.04),
    regen: scale(baseStats.regen, 0.02),
    pen: scale(baseStats.pen, 0.03),      
  };
};

export const calculateTotalStats = (hero: Hero, items: Item[]): HeroStats => {
  let stats = { ...hero.stats };
  
  items.forEach(item => {
    stats.ad += (item.ad || 0);
    stats.ap += (item.ap || 0);
    stats.hp += (item.hp || 0);
    stats.mp += (item.mp || 0);
    stats.armor += (item.armor || 0);
    stats.crit += (item.crit || 0);
    stats.speed += (item.speed || 0);
    stats.regen += (item.regen || 0);
    stats.mpRegen += (item.mpRegen || 0);
    stats.pen += (item.pen || 0);
  });
  
  return stats;
};


--- FILE: src/engine/match/utils/Vector.ts ---
export interface Vector2 { x: number; y: number; }

export class Vector {
  static add(v1: Vector2, v2: Vector2): Vector2 { return { x: v1.x + v2.x, y: v1.y + v2.y }; }
  static sub(v1: Vector2, v2: Vector2): Vector2 { return { x: v1.x - v2.x, y: v1.y - v2.y }; }
  static mult(v: Vector2, n: number): Vector2 { return { x: v.x * n, y: v.y * n }; }
  static div(v: Vector2, n: number): Vector2 { return n === 0 ? v : { x: v.x / n, y: v.y / n }; }
  
  static mag(v: Vector2): number { return Math.sqrt(v.x * v.x + v.y * v.y); }
  
  static normalize(v: Vector2): Vector2 {
    const m = Vector.mag(v);
    return m === 0 ? { x: 0, y: 0 } : Vector.div(v, m);
  }

  static dist(v1: Vector2, v2: Vector2): number {
    return Math.sqrt(Math.pow(v1.x - v2.x, 2) + Math.pow(v1.y - v2.y, 2));
  }

  static limit(v: Vector2, max: number): Vector2 {
    const m = Vector.mag(v);
    return m > max ? Vector.mult(Vector.normalize(v), max) : v;
  }
  
  // ì„ í˜• ë³´ê°„ (ë¶€ë“œëŸ¬ìš´ ì›€ì§ì„)
  static lerp(v1: Vector2, v2: Vector2, t: number): Vector2 {
    return {
      x: v1.x + (v2.x - v1.x) * t,
      y: v1.y + (v2.y - v1.y) * t
    };
  }
}


--- FILE: src/engine/match/utils/SpatialGrid.ts ---
// ==========================================
// FILE PATH: /src/engine/match/utils/SpatialGrid.ts
// ==========================================
import { Vector2 } from '../Vector';

// ë§µ í¬ê¸° 100x100 ê¸°ì¤€
const MAP_SIZE = 100;
// ì…€ í•˜ë‚˜ë‹¹ í¬ê¸° (ì‚¬ê±°ë¦¬ì™€ ë¹„ìŠ·í•œ 10~15 ì •ë„ê°€ ì ë‹¹)
const CELL_SIZE = 10;
// í–‰/ì—´ ê°œìˆ˜ (100 / 10 = 10ê°œ)
const COLS = Math.ceil(MAP_SIZE / CELL_SIZE);

export class SpatialGrid {
  private cells: Map<number, any[]> = new Map();

  constructor(units: any[]) {
    // ìƒì„±ê³¼ ë™ì‹œì— ê·¸ë¦¬ë“œ êµ¬ì¶• (O(N) - ë§¤ìš° ë¹ ë¦„)
    this.build(units);
  }

  private build(units: any[]) {
    this.cells.clear();
    for (const unit of units) {
      if (unit.currentHp <= 0) continue; // ì£½ì€ ìœ ë‹› ì œì™¸
      
      const index = this.getCellIndex(unit.x, unit.y);
      if (!this.cells.has(index)) {
        this.cells.set(index, []);
      }
      this.cells.get(index)!.push(unit);
    }
  }

  // ì¢Œí‘œë¥¼ ì…€ ì¸ë±ìŠ¤ë¡œ ë³€í™˜
  private getCellIndex(x: number, y: number): number {
    const col = Math.floor(Math.max(0, Math.min(MAP_SIZE - 1, x)) / CELL_SIZE);
    const row = Math.floor(Math.max(0, Math.min(MAP_SIZE - 1, y)) / CELL_SIZE);
    return row * COLS + col;
  }

  // ë‚´ ì£¼ë³€(ìì‹ ì´ ì†í•œ ì…€ + ì¸ì ‘ 8ê°œ ì…€)ì— ìˆëŠ” ìœ ë‹›ë“¤ë§Œ ë°˜í™˜
  public getNearbyUnits(me: Vector2): any[] {
    const centerIndex = this.getCellIndex(me.x, me.y);
    const result: any[] = [];

    const row = Math.floor(centerIndex / COLS);
    const col = centerIndex % COLS;

    // ì¸ì ‘ 3x3 ì…€ íƒìƒ‰
    for (let r = row - 1; r <= row + 1; r++) {
      for (let c = col - 1; c <= col + 1; c++) {
        if (r >= 0 && r < COLS && c >= 0 && c < COLS) {
          const idx = r * COLS + c;
          const unitsInCell = this.cells.get(idx);
          if (unitsInCell) {
            // for ë£¨í”„ê°€ concatë³´ë‹¤ ë¹ ë¦„
            for (let i = 0; i < unitsInCell.length; i++) {
                result.push(unitsInCell[i]);
            }
          }
        }
      }
    }
    return result;
  }
}


--- FILE: src/engine/match/MatchCreator.ts ---
import { Hero, LiveMatch, LivePlayer, TierConfig } from '../../types';
import { userPool, getTierNameHelper } from '../system/UserManager';
import { useGameStore } from '../../store/useGameStore';

export function createLiveMatches(heroes: Hero[], ccu: number, currentTime: number, config: TierConfig): LiveMatch[] {
  const idleUsers = userPool.filter(u => u.status === 'IDLE');
  if (idleUsers.length < 10) return [];

  const matchesToMake = Math.min(Math.floor(idleUsers.length / 10), 100); 
  const newMatches: LiveMatch[] = [];
  const candidates = [...idleUsers].sort(() => Math.random() - 0.5);

  const state = useGameStore.getState().gameState;
  const positions = state.fieldSettings.positions; 

  const blueBase = positions.towers.blue.nexus;
  const redBase = positions.towers.red.nexus;
  
  // 1ì°¨ íƒ€ì›Œ ì²´ë ¥ ë° ë„¥ì„œìŠ¤ ì²´ë ¥ ë¡œë“œ
  const t1Hp = state.fieldSettings.towers?.t1?.hp || 10000;
  const nexusHp = state.fieldSettings.towers?.nexus?.hp || 30000;

  for (let i = 0; i < matchesToMake; i++) {
    const batch = candidates.slice(i * 10, (i + 1) * 10);

    const createPlayer = (user: any, idx: number, isBlue: boolean): LivePlayer => {
      const lanes = ['TOP', 'JUNGLE', 'MID', 'BOT', 'BOT']; 
      const lane = lanes[idx] as any;
      const base = isBlue ? blueBase : redBase;

      return {
        name: user.name, heroId: '', 
        kills: 0, deaths: 0, assists: 0, gold: 500, cs: 0, totalDamageDealt: 0, 
        currentHp: 1000, maxHp: 1000, currentMp: 300, maxMp: 300, mpRegen: 5,
        level: 1, items: [], 
        x: base.x, y: base.y, 
        lane: lane, buffs: [], mmr: user.hiddenMmr, respawnTimer: 0,
        stats: { brain: user.brain || 50, mechanics: user.mechanics || 50 }
      };
    };

    const blueUsers = batch.slice(0, 5);
    const redUsers = batch.slice(5, 10);
    batch.forEach(u => u.status = 'INGAME');

    const jungleMobs = positions.jungle.map((pos, idx) => ({
        id: `jungle_${idx}`, campId: idx, type: idx % 2 === 0 ? 'WOLF' : 'GOLEM',
        x: pos.x, y: pos.y, 
        hp: 1000, maxHp: 1000, atk: 50, respawnTimer: 0, isAlive: true
    }));

    newMatches.push({
      id: `m_${currentTime}_${Math.random().toString(36).substr(2, 5)}`,
      status: 'DRAFTING', 
      draft: { isBlueTurn: true, turnIndex: 0, timer: 10, decisionTime: 5, phase: 'BAN' },
      bans: { blue: [], red: [] }, 
      blueTeam: blueUsers.map((u, i) => createPlayer(u, i, true)),
      redTeam: redUsers.map((u, i) => createPlayer(u, i, false)),
      startTime: currentTime, duration: 3600, currentDuration: 0, 
      score: { blue: 0, red: 0 }, 
      stats: {
        // [ì¤‘ìš”] laneHealth ì´ˆê¸°ê°’ ì„¤ì •
        blue: { 
            towers: {top:0,mid:0,bot:0}, laneHealth: {top:t1Hp, mid:t1Hp, bot:t1Hp},
            colossus: 0, watcher: 0, fury: 0, nexusHp: nexusHp, maxNexusHp: nexusHp, activeBuffs: { siegeUnit: false, voidPower: false } 
        },
        red: { 
            towers: {top:0,mid:0,bot:0}, laneHealth: {top:t1Hp, mid:t1Hp, bot:t1Hp},
            colossus: 0, watcher: 0, fury: 0, nexusHp: nexusHp, maxNexusHp: nexusHp, activeBuffs: { siegeUnit: false, voidPower: false } 
        }
      },
      timeline: [], avgTier: getTierNameHelper(batch[0].score, config), logs: [], 
      
      nextColossusSpawnTime: state.fieldSettings.colossus.initialSpawnTime, 
      nextWatcherSpawnTime: state.fieldSettings.watcher.initialSpawnTime,
      objectives: {
        colossus: { hp: 0, maxHp: 10000, status: 'DEAD', nextSpawnTime: state.fieldSettings.colossus.initialSpawnTime },
        watcher: { hp: 0, maxHp: 10000, status: 'DEAD', nextSpawnTime: state.fieldSettings.watcher.initialSpawnTime }
      },
      minions: [], projectiles: [], 
      jungleMobs: jungleMobs as any 
    });
  }
  return newMatches;
}


--- FILE: src/engine/match/MatchSettlement.ts ---
import { Hero, LiveMatch, LivePlayer, TierConfig } from '../../types';
import { userPool } from '../system/UserManager';

const getNextTierInfo = (currentScore: number, config: TierConfig) => {
  // Configê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©
  if (!config) return null;
  if (currentScore < config.bronze) return { name: 'ë¸Œë¡ ì¦ˆ', cut: config.bronze, key: 'bronze' };
  if (currentScore < config.silver) return { name: 'ì‹¤ë²„', cut: config.silver, key: 'silver' };
  if (currentScore < config.gold) return { name: 'ê³¨ë“œ', cut: config.gold, key: 'gold' };
  if (currentScore < config.joker) return { name: 'ì¡°ì»¤', cut: config.joker, key: 'joker' };
  if (currentScore < config.ace) return { name: 'ì—ì´ìŠ¤', cut: config.ace, key: 'ace' };
  if (currentScore < config.master) return { name: 'ë§ˆìŠ¤í„°', cut: config.master, key: 'master' };
  return null; 
};

export function finishMatch(
  match: LiveMatch, 
  heroes: Hero[], 
  day: number, 
  hour: number, 
  battleSettings: any,
  tierConfig: TierConfig
) {
  // [Safety] í•„ìˆ˜ ë°ì´í„° ê²€ì¦
  if (!match || !match.stats || !match.score) return { isBlueWin: false, blueKills: 0, redKills: 0, duration: 0 };

  let isBlueWin = match.score.blue > match.score.red;
  if (match.stats.red.nexusHp <= 0) isBlueWin = true;       
  else if (match.stats.blue.nexusHp <= 0) isBlueWin = false; 

  const blueKills = match.blueTeam.reduce((sum, p) => sum + (p.kills || 0), 0);
  const redKills = match.redTeam.reduce((sum, p) => sum + (p.kills || 0), 0);

  // [Safety] ìœ ì € í’€ì´ ë¹„ì–´ìˆìœ¼ë©´ ì •ì‚° ì¤‘ë‹¨
  if (!userPool) return { isBlueWin, blueKills, redKills, duration: match.currentDuration };

  const participantNames = new Set([...match.blueTeam, ...match.redTeam].map(p => p.name));

  userPool.forEach(u => {
    if (u && participantNames.has(u.name)) {
      u.status = 'RESTING';
      u.restTimer = 5 + Math.floor(Math.random() * 5); 
    }
  });

  // ë°´ í†µê³„
  const allBans = [...(match.bans?.blue || []), ...(match.bans?.red || [])];
  allBans.forEach(banId => {
    if (banId) {
        const hero = heroes.find(h => h.id === banId);
        if (hero && hero.record) hero.record.totalBans++; 
    }
  });

  const processTeam = (team: LivePlayer[], win: boolean) => {
    if (!Array.isArray(team)) return;

    team.forEach(player => {
      const hero = heroes.find(h => h.id === player.heroId);
      // ìœ ì € ì°¾ê¸° (ì—†ì–´ë„ ì£½ì§€ ì•Šê²Œ ì²˜ë¦¬)
      const user = userPool.find(u => u && u.name === player.name) as any;

      if (hero && hero.record) {
        hero.record.totalMatches++; 
        hero.record.totalPicks++; 
        if (win) hero.record.totalWins++;

        hero.record.totalKills += (player.kills || 0); 
        hero.record.totalDeaths += (player.deaths || 0); 
        hero.record.totalAssists += (player.assists || 0); 

        const itemsValue = (player.items || []).reduce((sum, item) => sum + (item.cost || 0), 0);
        hero.record.totalGold += ((player.gold || 0) + itemsValue);
        hero.record.totalDamage += (player.totalDamageDealt || 0); 
        hero.record.totalCs += (player.cs || 0);

        if (!hero.record.recentResults) hero.record.recentResults = [];
        hero.record.recentResults.push(win); 
        if (hero.record.recentResults.length > 1000) hero.record.recentResults.shift();
      }

      if (user) {
        // [Safety] ìœ ì € ë°ì´í„° êµ¬ì¡° ë³´ì¥
        if (!user.history) user.history = [];
        if (!user.heroStats) user.heroStats = {};

        user.wins += win ? 1 : 0; 
        user.losses += win ? 0 : 1;

        let lpChange = win ? 25 : -20;
        let kdaStr = `${player.kills}/${player.deaths}/${player.assists}`;
        let historyMsg = win ? 'WIN' : 'LOSE';

        if (user.promoStatus) {
            lpChange = 0; 
            if (win) {
                user.promoStatus.wins++;
                historyMsg = 'PROMO WIN';
                if (user.promoStatus.wins >= user.promoStatus.targetWins) {
                    const nextTier = getNextTierInfo(user.score, tierConfig);
                    if (nextTier) {
                        user.score = nextTier.cut + 50; 
                        historyMsg = `ğŸ‰ ìŠ¹ê¸‰! (${nextTier.name})`;
                    }
                    user.promoStatus = null;
                }
            } else {
                user.promoStatus.losses++;
                historyMsg = 'PROMO LOSS';
                const totalGames = user.promoStatus.targetWins * 2 - 1;
                const maxLosses = totalGames - user.promoStatus.targetWins + 1;
                if (user.promoStatus.losses >= maxLosses) {
                    user.score -= 40; 
                    historyMsg = 'âŒ ìŠ¹ê¸‰ ì‹¤íŒ¨';
                    user.promoStatus = null;
                }
            }
        } else {
            const oldScore = user.score || 0;
            user.score = Math.max(0, oldScore + lpChange);
            const nextTier = getNextTierInfo(oldScore, tierConfig);
            if (nextTier && user.score >= nextTier.cut) {
                user.score = nextTier.cut - 1; 
                const promoMatches = tierConfig.promos ? (tierConfig.promos[nextTier.key as keyof typeof tierConfig.promos] || 3) : 3;
                user.promoStatus = {
                    targetTier: nextTier.name,
                    wins: 0,
                    losses: 0,
                    targetWins: Math.ceil(promoMatches / 2)
                };
                historyMsg = `ğŸ”¥ ${nextTier.name} ìŠ¹ê¸‰ì „!`;
            }
        }

        user.history.unshift({ 
          season: 1, 
          result: historyMsg, 
          heroName: hero?.name || 'Unknown', 
          kda: kdaStr, 
          lpChange: lpChange, 
          date: `Day ${day} ${hour}:00` 
        });
        if (user.history.length > 20) user.history.pop();

        if (!user.heroStats[player.heroId]) user.heroStats[player.heroId] = { matches:0, wins:0, kills:0, deaths:0, assists:0 };
        const st = user.heroStats[player.heroId];
        st.matches++; if(win) st.wins++; st.kills+=player.kills; st.deaths+=player.deaths; st.assists+=player.assists;
      }
    });
  };

  try {
    processTeam(match.blueTeam, isBlueWin);
    processTeam(match.redTeam, !isBlueWin);
  } catch (err) {
    console.error("Error in match settlement:", err);
  }

  return { isBlueWin, blueKills, redKills, duration: match.currentDuration };
}


--- FILE: src/engine/match/MatchUpdater.ts ---
// ==========================================
// FILE PATH: /src/engine/match/MatchUpdater.ts
// ==========================================
import { Hero, LiveMatch } from '../../types';
import { useGameStore } from '../../store/useGameStore';

import { processDraftTurn } from './systems/BanPickEngine'; 
import { updatePlayerBehavior } from './systems/PlayerSystem'; 
import { updateNeutralObjectives } from './systems/ObjectiveSystem'; 
import { processGrowthPhase } from './phases/GrowthPhase';
import { processSiegePhase } from './phases/SiegePhase';
import { processCombatPhase } from './phases/CombatPhase';
import { updateLivePlayerStats } from './systems/ItemManager'; 
import { BASES } from '../data/MapData';

import { MinionSystem } from './systems/MinionSystem';
import { JungleSystem } from './systems/JungleSystem';
import { ProjectileSystem } from './systems/ProjectileSystem';
import { ColossusLogic } from './logics/ColossusLogic';

export function updateLiveMatches(matches: LiveMatch[], heroes: Hero[], delta: number): LiveMatch[] {
  const state = useGameStore.getState();
  const shopItems = state.shopItems || []; 
  
  const { battleSettings, fieldSettings, roleSettings } = state.gameState;

  const safeField = fieldSettings || { 
    colossus: { hp: 15000, armor: 80, rewardGold: 100, respawnTime: 300, attack: 50 },
    watcher: { hp: 20000, armor: 120, rewardGold: 150, buffType: 'COMBAT', buffAmount: 20, buffDuration: 180, respawnTime: 420 }, 
    tower: { hp: 30000, armor: 200, rewardGold: 150 }, 
    jungle: { density: 50, yield: 50, attack: 30, defense: 20, threat: 0, xp: 160, gold: 80 }
  };

  const safeRole = roleSettings || {
    executor: { damage: 15, defense: 15 },
    tracker: { gold: 20, smiteChance: 1.5 },
    prophet: { cdrPerLevel: 2 },
    slayer: { structureDamage: 30 },
    guardian: { survivalRate: 20 }
  };

  return matches.map(m => {
    if (!Array.isArray(m.minions)) m.minions = [];
    if (!Array.isArray(m.projectiles)) m.projectiles = [];
    if (!Array.isArray(m.jungleMobs)) m.jungleMobs = [];
    if (!Array.isArray(m.logs)) m.logs = [];

    const match = { ...m, logs: [...m.logs], blueTeam: [...m.blueTeam], redTeam: [...m.redTeam] };

    if (match.stats.blue.nexusHp <= 0 || match.stats.red.nexusHp <= 0) {
        return match;
    }

    if (match.status === 'DRAFTING') {
       if (!match.draft) return match;
       match.draft.timer -= delta;
       let loopGuard = 0;
       
       while (match.draft.timer <= 0 && match.status === 'DRAFTING' && loopGuard < 25) {
           loopGuard++;
           processDraftTurn(match, heroes, 50);
           match.draft.turnIndex++;
           const nextDecisionTime = 2 + Math.random() * 8;
           match.draft.timer += (30 + nextDecisionTime);
           match.draft.decisionTime = nextDecisionTime; 

           if (match.draft.turnIndex >= 20) {
               match.status = 'PLAYING';
               match.logs.push({ time: 0, message: "ë¯¸ë‹ˆì–¸ ìƒì„±! ì „êµ° ì¶œê²©!", type: 'START' });

               const initPlayer = (p: any, isBlue: boolean) => {
                   const h = heroes.find(x => x.id === p.heroId);
                   if(h) { 
                       p.level = 1; p.items = []; (p as any).exp = 0;
                       updateLivePlayerStats(p, h);
                       p.currentHp = p.maxHp; p.currentMp = p.maxMp; p.respawnTimer = 0;
                       p.totalDamageDealt = 0;
                       p.x = isBlue ? BASES.BLUE.x : BASES.RED.x;
                       p.y = isBlue ? BASES.BLUE.y : BASES.RED.y;
                       (p as any).pathIdx = 0;
                   }
               };
               match.blueTeam.forEach(p => initPlayer(p, true));
               match.redTeam.forEach(p => initPlayer(p, false));
               
               match.minions = []; match.projectiles = []; match.jungleMobs = [];
               break; 
           }
       }
       return match;
    }

    match.currentDuration += delta;

    processGrowthPhase(match, battleSettings, safeField, heroes, delta);
    updateNeutralObjectives(match, safeField, delta);

    [...match.blueTeam, ...match.redTeam].forEach(player => {
        updatePlayerBehavior(player, match, heroes, shopItems, safeRole, delta);
    });

    processSiegePhase(match, heroes, safeField, safeRole, battleSettings, delta);

    const watcherSettings = safeField.watcher;
    processCombatPhase(
        match, heroes, battleSettings, safeRole, 
        watcherSettings?.buffType || 'COMBAT', 
        watcherSettings?.buffAmount || 20, 
        delta
    );

    if (match.minions) {
        match.minions.forEach(m => {
            if (m.type === 'SUMMONED_COLOSSUS') {
                ColossusLogic.update(m, match, battleSettings, delta);
            }
        });
    }

    // [ìˆ˜ì •] heroes íŒŒë¼ë¯¸í„° ì „ë‹¬
    MinionSystem.update(match, battleSettings, delta, heroes);
    
    JungleSystem.update(match, delta);
    ProjectileSystem.update(match, delta);

    return match;
  });
}


--- FILE: src/engine/match/actions/FarmAction.ts ---
// ==========================================
// FILE PATH: /src/engine/match/actions/FarmAction.ts
// ==========================================
import { LiveMatch, Hero, LivePlayer, Minion, BattleSettings } from '../../../types';
import { TargetEvaluator } from '../ai/evaluators/TargetEvaluator';
import { calculateUnitDamage } from '../systems/DamageCalculator'; // [ìˆ˜ì •]
import { distributeRewards, MINION_REWARD } from '../systems/RewardSystem'; // [ìˆ˜ì •]

export class FarmAction {
  static tryFarm(
    attacker: LivePlayer,
    attackerHero: Hero,
    match: LiveMatch,
    enemies: { minions: Minion[] },
    atkStats: any,
    isBlue: boolean,
    settings: BattleSettings,
    heroes: Hero[]
  ): boolean {
    
    if (!enemies.minions || enemies.minions.length === 0) return false;

    // 1. ë‚´ ë°ë¯¸ì§€ ê³„ì‚°
    const myDamage = calculateUnitDamage(attacker, atkStats, 5, isBlue, settings);

    // 2. ì²˜í˜• ì„ê³„ê°’ ì„¤ì •
    let executeThreshold = myDamage * 2.5; 

    if (attackerHero.role === 'ìˆ˜í˜¸ê¸°ì‚¬') {
        if (Math.random() < 0.05) { 
            executeThreshold = myDamage * 6.0; 
        } else {
            return false; 
        }
    }

    // 3. íƒ€ê²Ÿ ì„ ì •
    const targetMinion = TargetEvaluator.selectFarmTarget(attacker, enemies.minions, executeThreshold);

    if (targetMinion) {
        if (targetMinion.hp <= executeThreshold) {
            targetMinion.hp = 0;
        } else {
            targetMinion.hp -= myDamage;
        }
        
        attacker.totalDamageDealt += myDamage;

        if (targetMinion.hp <= 0) {
            const reward = (MINION_REWARD as any)[targetMinion.type] || MINION_REWARD.MELEE;
            
            // [ì¤‘ìš”] RewardSystem ì‚¬ìš©
            distributeRewards(match, targetMinion, attacker, isBlue ? 'BLUE' : 'RED', reward, heroes);

            if (targetMinion.type === 'SUMMONED_COLOSSUS') {
                match.logs.push({ 
                    time: Math.floor(match.currentDuration), 
                    message: `âš”ï¸ [${attackerHero.name}]ê°€ ì ì˜ ê±°ì‹ ë³‘ì„ ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤!`, 
                    type: 'KILL', team: isBlue ? 'BLUE' : 'RED' 
                });
            }
        }
        return true; 
    }

    return false; 
  }
}


--- FILE: src/engine/match/actions/HeroCombatAction.ts ---
// ==========================================
// FILE PATH: /src/engine/match/actions/HeroCombatAction.ts
// ==========================================
import { LiveMatch, Hero, LivePlayer, BattleSettings, RoleSettings } from '../../../types';
import { TargetEvaluator } from '../ai/evaluators/TargetEvaluator';
import { calculateHeroDamage } from '../systems/DamageCalculator'; // [ìˆ˜ì •]
import { distributeAssist } from '../systems/RewardSystem'; // [ìˆ˜ì •]

export class HeroCombatAction {
  static tryCombat(
    attacker: LivePlayer,
    attackerHero: Hero,
    match: LiveMatch,
    enemies: { heroes: LivePlayer[] },
    atkStats: any,
    isBlue: boolean,
    settings: BattleSettings,
    roleSettings: RoleSettings,
    watcherBuffType: string,
    heroes: Hero[]
  ): boolean {
    if (!enemies.heroes || enemies.heroes.length === 0) return false;

    // 1. íƒ€ê²Ÿ ì„ ì •
    const defender = TargetEvaluator.selectBestTarget(attacker, attackerHero, enemies.heroes, heroes);
    
    if (defender) {
        attacker.lastAttackTime = match.currentDuration;
        attacker.lastAttackedTargetId = defender.heroId;

        const defenderHero = heroes.find(h => h.id === defender.heroId);
        if (defenderHero) {
            // 2. ë°ë¯¸ì§€ ê³„ì‚°
            const defArmor = (defender.level * 3) + (defenderHero.stats.armor || 30);
            const defStats = { ...defenderHero.stats, armor: defArmor };

            const damage = calculateHeroDamage(
                attacker, defender, atkStats, defStats, attackerHero, 
                isBlue, settings, roleSettings, watcherBuffType
            );
            
            defender.currentHp -= damage;
            attacker.totalDamageDealt += damage;

            // 3. ì²˜ì¹˜ ì²˜ë¦¬
            if (defender.currentHp <= 0) {
                attacker.kills++; 
                defender.deaths++; 
                attacker.gold += 300;
                
                // [ì¤‘ìš”] RewardSystem ì‚¬ìš©
                distributeAssist(match, attacker, defender, isBlue);

                if (isBlue) match.score.blue++; else match.score.red++;
                
                match.logs.push({ 
                    time: Math.floor(match.currentDuration), 
                    message: `ğŸ’€ [${attackerHero.name}]ê°€ [${defenderHero.name}] ì²˜ì¹˜!`, 
                    type: 'KILL', team: isBlue ? 'BLUE' : 'RED' 
                });
                
                defender.currentHp = 0;
                defender.respawnTimer = 10 + (defender.level * 2);
            }
        }
        return true; 
    }

    return false;
  }
}


--- FILE: src/engine/SaveLoadSystem.ts ---
import { userPool, replaceUserPool, initUserPool, getTopRankers } from './system/UserManager';
import { analyzeHeroMeta, calculateUserEcosystem } from './system/RankingSystem';
import { useGameStore } from '../store/useGameStore';
import { Hero, GameState, SaveMeta, UserProfile, LiveMatch, LivePlayer, Item } from '../types';
import { IDBStorage } from '../utils/IDBStorage';

const META_KEY = 'GW_SAVE_META';
const PENDING_LOAD_KEY = 'GW_PENDING_LOAD';

// [ì €ì¥]
export const saveToSlot = async (slotId: string): Promise<boolean> => {
  const store = useGameStore.getState();
  const state = store.gameState;

  // ì €ì¥ ìš©ëŸ‰ ìµœì í™” (ë¶ˆí•„ìš”í•œ ë¡œê·¸/ì˜¤ë¸Œì íŠ¸ ì œì™¸)
  const optimizedMatches = state.liveMatches.map(m => ({
    ...m, 
    logs: [], timeline: [], minions: [], projectiles: [], jungleMobs: []    
  }));

  const saveData = {
    version: 20, // ë²„ì „ ë³€ê²½ (êµ¬ë²„ì „ ë°ì´í„°ì™€ êµ¬ë¶„)
    time: { season: state.season, day: state.day, hour: state.hour, minute: state.minute },
    config: {
      battle: state.battleSettings,
      field: state.fieldSettings,
      role: state.roleSettings,
      tier: state.tierConfig,
      ai: state.aiConfig
    },
    customImages: state.customImages,
    // ì˜ì›… ë°ì´í„°ëŠ” ë³€ë™ì‚¬í•­ë§Œ ì €ì¥
    heroes: store.heroes.map(h => ({
      id: h.id, record: h.record, concept: h.concept, name: h.name
    })),
    // [ì¤‘ìš”] í˜„ì¬ ìœ ì € í’€ ì „ì²´ë¥¼ ì›ë³¸ ê·¸ëŒ€ë¡œ ì €ì¥
    users: userPool, 
    itemStats: state.itemStats,
    shopItems: store.shopItems,
    godStats: state.godStats, 
    liveMatches: optimizedMatches,
    timestamp: Date.now()
  };

  try {
    await IDBStorage.setItem(slotId, saveData);
    const now = new Date();
    const meta: SaveMeta = {
      slotId, timestamp: Date.now(), realDateStr: now.toLocaleString(), 
      gameTimeDisplay: `S${state.season} D${state.day}`, totalUsers: userPool.length
    };
    const json = localStorage.getItem(META_KEY);
    const allMeta = json ? JSON.parse(json) : {};
    allMeta[slotId] = meta;
    localStorage.setItem(META_KEY, JSON.stringify(allMeta));
    return true;
  } catch (e: any) {
    alert(`ì €ì¥ ì‹¤íŒ¨: ${e.message}`);
    return false;
  }
};

// [ë¡œë“œ íŠ¸ë¦¬ê±°]
export const loadFromSlot = async (slotId: string, defaultHeroes: Hero[]): Promise<boolean> => {
  try {
    let data = await IDBStorage.getItem(slotId);
    if (!data) {
        const legacyJson = localStorage.getItem(`GW_SAVE_DATA_${slotId}`);
        if(legacyJson) data = JSON.parse(legacyJson);
        else return false;
    }
    localStorage.setItem(PENDING_LOAD_KEY, slotId);
    window.location.reload();
    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
};

// [ì´ˆê¸°í™”]
export const initializeGame = async (heroes: Hero[]) => {
  const pendingSlot = localStorage.getItem(PENDING_LOAD_KEY);
  if (pendingSlot) {
    console.log("ğŸ”„ [System] ë°ì´í„° ë¡œë“œ ë° ë¬´ê²°ì„± ê²€ì‚¬ ì‹œì‘:", pendingSlot);
    localStorage.removeItem(PENDING_LOAD_KEY); 
    try {
        let data = await IDBStorage.getItem(pendingSlot);
        if (data) {
            applyLoadedData(data, heroes);
            return;
        }
    } catch (e) {
        console.error("Critical Load Error:", e);
    }
  }
  // ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ìƒˆ ê²Œì„ ì‹œì‘
  if (userPool.length === 0) initUserPool(heroes, 3000);
};

// [í•µì‹¬] ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦ ë° ì ìš© (Data Integrity Check)
const applyLoadedData = (data: any, defaultHeroes: Hero[]) => {
    const store = useGameStore.getState();
    
    // 1. ì˜ì›… ë°ì´í„° ë³µêµ¬
    const loadedHeroMap = new Map(data.heroes?.map((h: any) => [h.id, h]) || []);
    const restoredHeroes = defaultHeroes.map(def => {
        const saved = loadedHeroMap.get(def.id);
        return saved ? { ...def, ...saved } : def;
    });

    // 2. ìœ ì € í’€(Master Data) ë³µêµ¬
    // - ì €ì¥ëœ ìœ ì €ê°€ ìˆìœ¼ë©´ ê·¸ê±¸ ì“°ê³ , ì—†ìœ¼ë©´ ìƒˆë¡œ ë§Œë“­ë‹ˆë‹¤.
    // - ì¼ë‹¨ ëª¨ë“  ìœ ì € ìƒíƒœë¥¼ 'OFFLINE'ìœ¼ë¡œ ì´ˆê¸°í™”í•©ë‹ˆë‹¤. (ë§¤ì¹˜ ê²€ì¦ í›„ INGAMEìœ¼ë¡œ ë³€ê²½)
    let restoredUsers: UserProfile[] = [];
    if (data.users && Array.isArray(data.users)) {
        restoredUsers = data.users.map((u: any) => ({
            ...u,
            heroStats: u.heroStats || {},
            history: u.history || [],
            status: 'OFFLINE' // ì´ˆê¸°í™”
        }));
    } else {
        // ìœ ì € ë°ì´í„° ìœ ì‹¤ ì‹œ ìƒˆ ìœ ì € ìƒì„± (ë¹„ìƒ ì¡°ì¹˜)
        initUserPool(restoredHeroes, 3000);
        restoredUsers = [...userPool];
    }

    // [ê²€ì¦ìš©] ì‹¤ì œ ì¡´ì¬í•˜ëŠ” ìœ ì € ì´ë¦„ Set
    const validUserNames = new Set(restoredUsers.map(u => u.name));

    // 3. ë§¤ì¹˜ ë°ì´í„° ê²€ì¦ (ê°€ì§œ ë§¤ì¹˜ ë°•ë©¸)
    const validMatches: LiveMatch[] = [];
    let droppedMatches = 0;

    const rawMatches = (data.liveMatches || []);
    
    rawMatches.forEach((m: any) => {
        // ë§¤ì¹˜ì— í¬í•¨ëœ 10ëª…ì˜ í”Œë ˆì´ì–´ ì´ë¦„
        const participants = [...(m.blueTeam || []), ...(m.redTeam || [])];
        
        // [ì—„ê²© ê²€ì¦] 10ëª… ì „ì›ì´ ì‹¤ì œ ìœ ì € í’€ì— ì¡´ì¬í•˜ëŠ”ê°€?
        const isValidMatch = participants.length === 10 && participants.every((p: any) => validUserNames.has(p.name));

        if (isValidMatch) {
            // ìœ íš¨í•œ ë§¤ì¹˜ë§Œ ë³µêµ¬ (í•„ìˆ˜ ë°°ì—´ ì´ˆê¸°í™” í¬í•¨)
            validMatches.push({
                ...m,
                minions: [], projectiles: [], jungleMobs: [], logs: [], timeline: [],
                blueTeam: m.blueTeam.map((p:any)=>({...p, items: p.items||[], cooldowns: {q:0,w:0,e:0,r:0}})),
                redTeam: m.redTeam.map((p:any)=>({...p, items: p.items||[], cooldowns: {q:0,w:0,e:0,r:0}})),
                stats: {
                    blue: { ...m.stats?.blue, nexusHp: Number(m.stats?.blue?.nexusHp||5000), towers: m.stats?.blue?.towers||{top:0,mid:0,bot:0}, activeBuffs: m.stats?.blue?.activeBuffs||{siegeUnit:false,voidPower:false} },
                    red: { ...m.stats?.red, nexusHp: Number(m.stats?.red?.nexusHp||5000), towers: m.stats?.red?.towers||{top:0,mid:0,bot:0}, activeBuffs: m.stats?.red?.activeBuffs||{siegeUnit:false,voidPower:false} }
                },
                objectives: {
                    colossus: { hp: 0, maxHp: 10000, status: 'DEAD', nextSpawnTime: m.currentDuration+60 },
                    watcher: { hp: 0, maxHp: 10000, status: 'DEAD', nextSpawnTime: m.currentDuration+120 }
                }
            });

            // ê²€ì¦ëœ ìœ ì €ë“¤ì˜ ìƒíƒœë¥¼ 'INGAME'ìœ¼ë¡œ ë³€ê²½
            participants.forEach((p: any) => {
                const u = restoredUsers.find(user => user.name === p.name);
                if (u) u.status = 'INGAME';
            });
        } else {
            // ìœ ë ¹ ë§¤ì¹˜(ê°€ì§œ ë°ì´í„°)ëŠ” ë²„ë¦¼
            droppedMatches++;
        }
    });

    console.log(`ğŸ§¹ [Integrity Check] ìœ íš¨ ë§¤ì¹˜: ${validMatches.length} / ì‚­ì œëœ ê°€ì§œ ë§¤ì¹˜: ${droppedMatches}`);

    // ìœ ì € í’€ ì „ì—­ êµì²´
    replaceUserPool(restoredUsers);

    // 4. ìŠ¤í† ì–´ ìƒíƒœ ì ìš©
    useGameStore.setState({ 
        gameState: {
            ...store.gameState,
            ...data.time,
            tierConfig: { ...store.gameState.tierConfig, ...data.config?.tier },
            battleSettings: { ...store.gameState.battleSettings, ...data.config?.battle },
            fieldSettings: { ...store.gameState.fieldSettings, ...data.config?.field },
            roleSettings: { ...store.gameState.roleSettings, ...data.config?.role },
            aiConfig: { ...store.gameState.aiConfig, ...data.config?.ai },
            itemStats: data.itemStats || {},
            godStats: data.godStats || store.gameState.godStats,
            customImages: { ...store.gameState.customImages, ...(data.customImages || {}) },
            liveMatches: validMatches, // ê²€ì¦ëœ ë§¤ì¹˜ë§Œ íˆ¬ì…
            totalUsers: restoredUsers.length, // [ì¤‘ìš”] ì‹¤ì œ ìœ ì € ìˆ˜ë¡œ ë®ì–´ì”€
            topRankers: getTopRankers(restoredHeroes, data.config?.tier),
            userStatus: calculateUserEcosystem(validMatches.length * 10, restoredUsers.length, data.config?.tier),
            isPlaying: false 
        },
        heroes: analyzeHeroMeta(restoredHeroes),
        shopItems: data.shopItems || store.shopItems
    });
};

export const getSlotsMeta = (): Record<string, SaveMeta> => {
  try {
    const json = localStorage.getItem(META_KEY);
    return json ? JSON.parse(json) : {};
  } catch { return {}; }
};

export const deleteSlot = async (slotId: string) => {
  await IDBStorage.removeItem(slotId); 
  const meta = getSlotsMeta();
  delete meta[slotId];
  localStorage.setItem(META_KEY, JSON.stringify(meta));
};

export const exportSaveFile = async () => {};
export const importSaveFile = (file: File, heroes: Hero[]) => { return new Promise<boolean>((r)=>r(false)); };


--- FILE: src/engine/CoreEngine.ts ---
// ==========================================
// FILE PATH: /src/engine/CoreEngine.ts
// ==========================================
import { GameState, Hero, Post } from '../types';
import { updateLiveMatches } from './match/MatchUpdater';
import { createLiveMatches } from './match/MatchCreator';
import { finishMatch } from './match/MatchSettlement';
import { initUserPool, userPool, getTopRankers } from './system/UserManager'; 
import { UserActivitySystem } from './system/UserActivitySystem';
import { analyzeHeroMeta, calculateUserEcosystem } from './system/RankingSystem';
import { updatePostInteractions, generatePostAsync } from './system/CommunityEngine';
import { calculateTargetSentiment, smoothSentiment } from './system/SentimentEngine';

const MAX_STEPS_PER_FRAME = 10; 

export class CoreEngine {
  static processTick(
    initialState: GameState,
    initialHeroes: Hero[],
    initialPosts: Post[],
    totalDelta: number,
    updateStateCallback: (updates: Partial<GameState>, newHeroes?: Hero[], newPosts?: Post[]) => void
  ) {
    try {
      let currentState = { ...initialState };
      let currentHeroes = initialHeroes;
      let currentPosts = [...initialPosts];
      
      let remainingTime = totalDelta;
      
      // ë°°ì†ì— ë”°ë¥¸ dt ì¡°ì •
      let stepSize = 0.5; 
      if (initialState.gameSpeed >= 600) stepSize = 5.0;     
      else if (initialState.gameSpeed >= 60) stepSize = 3.0; 
      else if (initialState.gameSpeed >= 10) stepSize = 1.5; 

      let loopCount = 0;

      while (remainingTime > 0 && loopCount < MAX_STEPS_PER_FRAME) {
        const dt = Math.min(remainingTime, stepSize);
        
        const result = this.executeSingleStep(currentState, currentHeroes, currentPosts, dt);
        
        currentState = { ...currentState, ...result.stateUpdates };
        if (result.newHeroes) currentHeroes = result.newHeroes;
        if (result.newPosts) currentPosts = result.newPosts;

        remainingTime -= dt;
        loopCount++;
      }

      updateStateCallback(currentState, currentHeroes, currentPosts);

    } catch (err) {
      console.error("Critical Engine Error:", err);
    }
  }

  private static executeSingleStep(
    state: GameState,
    heroes: Hero[],
    posts: Post[],
    deltaSeconds: number
  ) {
    let { hour, minute, second, day, totalUsers, tierConfig, liveMatches, godStats, itemStats } = state;

    // A. ì‹œê°„ íë¦„
    second += deltaSeconds;
    if (second >= 60) {
      const extraMinutes = Math.floor(second / 60);
      second %= 60;
      minute += extraMinutes;
      if (minute >= 60) {
        const extraHours = Math.floor(minute / 60);
        minute %= 60;
        hour += extraHours;
        if (hour >= 24) {
          const extraDays = Math.floor(hour / 24);
          hour %= 24;
          day += extraDays;
        }
      }
    }

    const currentTotalMinutes = day * 1440 + hour * 60 + Math.floor(minute);
    const isNewMinute = Math.floor(minute) !== Math.floor(state.minute);

    if (!userPool || userPool.length === 0) {
      if (heroes.length > 0) initUserPool(heroes, totalUsers);
      return { stateUpdates: { second, minute, hour, day }, newHeroes: heroes, newPosts: posts };
    }

    // B. ìœ ì € í™œë™
    if (Math.floor(second) % 5 === 0) {
       UserActivitySystem.updateTraffic(hour + (minute/60), userPool);
    }

    // C. ë§¤ì¹˜ ì—…ë°ì´íŠ¸ (ë¶„ì‚° ì²˜ë¦¬ ì œê±° -> ë§¤ í”„ë ˆì„ ì „ì²´ ì—…ë°ì´íŠ¸)
    let updatedMatches = [...liveMatches];
    const nextGodStats = { ...godStats };
    const nextItemStats = { ...itemStats }; 

    try {
      // [ìˆ˜ì •] ëª¨ë“  ë§¤ì¹˜ë¥¼ ë§¤ í”„ë ˆì„ ì—…ë°ì´íŠ¸ (ë¶€ë“œëŸ¬ì›€ í™•ë³´)
      const processedMatches = updateLiveMatches(updatedMatches, heroes, deltaSeconds);
      
      updatedMatches = processedMatches.map(m => ({
          ...m,
          logs: m.logs.length > 15 ? m.logs.slice(-15) : [...m.logs],
      }));

      // ì¢…ë£Œ ì²˜ë¦¬
      const isMatchEnded = (m: any) => (m.stats.blue.nexusHp <= 0 || m.stats.red.nexusHp <= 0);
      const endedMatches = updatedMatches.filter(m => isMatchEnded(m));
      updatedMatches = updatedMatches.filter(m => !isMatchEnded(m));

      endedMatches.forEach(match => {
        try {
          const result = finishMatch(match, heroes, day, hour, state.battleSettings, tierConfig);
          nextGodStats.totalMatches++;
          if (result.isBlueWin) nextGodStats.danteWins++; else nextGodStats.izmanWins++;

          [...match.blueTeam, ...match.redTeam].forEach(p => {
              if(!p.items) return;
              p.items.forEach((item: any) => {
                  if (!nextItemStats[item.id]) nextItemStats[item.id] = { itemId: item.id, totalPicks: 0, totalWins: 0, totalKills: 0, totalDeaths: 0, totalAssists: 0 };
                  const st = nextItemStats[item.id];
                  st.totalPicks++;
                  const isWin = (match.blueTeam.includes(p) && result.isBlueWin) || (match.redTeam.includes(p) && !result.isBlueWin);
                  if (isWin) st.totalWins++;
                  st.totalKills += p.kills; st.totalDeaths += p.deaths; st.totalAssists += p.assists;
              });
          });
        } catch (settleError) {
            console.error("Match Settlement Failed:", settleError);
        }
      });

    } catch (matchError) {
      console.warn("Match Update Skipped:", matchError);
    }

    // D. ë§¤ì¹˜ ìƒì„± (ìµœëŒ€ 60ê°œ ìœ ì§€)
    const onlineUsers = userPool.filter(u => u && u.status !== 'OFFLINE').length;
    let finalMatches = updatedMatches;
    
    if ((Math.floor(second) % 10 === 0) && updatedMatches.length < 60) { 
        const idleUsers = userPool.filter(u => u && u.status === 'IDLE');
        if (idleUsers.length >= 10) {
            const newMatches = createLiveMatches(heroes, onlineUsers, Date.now(), tierConfig);
            finalMatches = [...updatedMatches, ...newMatches.slice(0, 3)];
        }
    }

    // E. í†µê³„ ì—…ë°ì´íŠ¸
    let finalHeroes = heroes;
    let finalPosts = posts;
    let nextUserStatus = state.userStatus;
    let nextTopRankers = state.topRankers;
    let nextSentiment = state.userSentiment;

    if (isNewMinute && Math.floor(minute) % 5 === 0) { 
      if (userPool.length > 0) {
          try {
            finalHeroes = analyzeHeroMeta([...heroes]);
            nextUserStatus = calculateUserEcosystem(onlineUsers, userPool.length, tierConfig);
            userPool.sort((a, b) => (b.score || 0) - (a.score || 0));
            userPool.forEach((u, idx) => { if(u) { u.rank = idx + 1; u.isChallenger = (u.score >= tierConfig.master && u.rank <= tierConfig.challengerRank); } });
            nextTopRankers = getTopRankers(finalHeroes, tierConfig);
            nextSentiment = smoothSentiment(nextSentiment, calculateTargetSentiment(state, finalHeroes, finalPosts));
            finalPosts = updatePostInteractions(finalPosts, currentTotalMinutes);

            if (state.aiConfig && state.aiConfig.enabled && Math.random() < 0.1) {
                generatePostAsync(Date.now(), finalHeroes, tierConfig, currentTotalMinutes, state.aiConfig, userPool, state.battleSettings, state.fieldSettings).then(()=>{}).catch(()=>{});
            }
          } catch (updateError) {}
      }
    }

    return {
      stateUpdates: {
        second, minute, hour, day,
        ccu: onlineUsers,
        totalUsers: userPool.length, 
        userStatus: nextUserStatus,
        topRankers: nextTopRankers,
        godStats: nextGodStats, 
        itemStats: nextItemStats, 
        liveMatches: finalMatches,
        userSentiment: nextSentiment
      },
      newHeroes: finalHeroes,
      newPosts: finalPosts
    };
  }
}


--- FILE: src/hooks/useGameEngine.ts ---
import { useEffect, useRef, useState } from 'react';
import { useGameStore } from '../store/useGameStore';
import { saveToSlot, initializeGame } from '../engine/SaveLoadSystem';

export const useGameEngine = () => {
  const store = useGameStore();
  const { gameState, tick, heroes } = store;
  const { isPlaying, gameSpeed } = gameState;

  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
  const [isGameReady, setIsGameReady] = useState(false);
  const [runtimeError, setRuntimeError] = useState<Error | null>(null);

  const requestRef = useRef<number>(0);
  const previousTimeRef = useRef<number | undefined>(undefined);
  
  // ì—ëŸ¬ ë°œìƒ ì‹œ ErrorBoundaryë¡œ ì „íŒŒ
  if (runtimeError) {
    throw runtimeError;
  }

  useEffect(() => {
    const init = async () => {
      try {
        await initializeGame(heroes);
      } catch (e: any) {
        console.error("Init Error:", e);
        setRuntimeError(e instanceof Error ? e : new Error(String(e)));
      } finally {
        setIsGameReady(true);
      }
    };
    init();
  }, []);

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // [ìµœì í™”ëœ ë©”ì¸ ê²Œì„ ë£¨í”„]
  useEffect(() => {
    if (!isPlaying || !isGameReady || runtimeError) {
      if (requestRef.current) cancelAnimationFrame(requestRef.current);
      previousTimeRef.current = undefined; 
      return;
    }

    const loop = (time: number) => {
      if (previousTimeRef.current !== undefined) {
        // 1. ì‹¤ì œ ê²½ê³¼ ì‹œê°„ ê³„ì‚° (ìµœëŒ€ 0.1ì´ˆë¡œ ì œí•œí•˜ì—¬ íƒ­ ë¹„í™œì„± í›„ ë³µê·€ ì‹œ ê¸‰ë°œì§„ ë°©ì§€)
        const realDelta = Math.min((time - previousTimeRef.current) / 1000, 0.1);
        
        // 2. ê²Œì„ ì†ë„ ì ìš©
        const gameDelta = realDelta * (gameSpeed || 1);

        try {
          // [í•µì‹¬ ë³€ê²½] ì—¬ê¸°ì„œ ë£¨í”„ë¥¼ ëŒì§€ ì•Šê³ , ì „ì²´ ì‹œê°„ì„ í•œ ë²ˆì— ì—”ì§„ìœ¼ë¡œ ë„˜ê¹ë‹ˆë‹¤.
          // ì—”ì§„ ë‚´ë¶€ì—ì„œ í•„ìš”í•œ ë§Œí¼ ìª¼ê°œì„œ ì—°ì‚°í•˜ê³ , ë Œë”ë§ì€ 1íšŒë§Œ ë°œìƒì‹œí‚µë‹ˆë‹¤.
          tick(gameDelta);
        } catch (e: any) {
          console.error("CRITICAL TICK ERROR:", e);
          store.togglePlay(); 
          if (requestRef.current) cancelAnimationFrame(requestRef.current);
          setRuntimeError(e instanceof Error ? e : new Error("Game Loop Error: " + String(e)));
          return;
        }
      }
      previousTimeRef.current = time;
      requestRef.current = requestAnimationFrame(loop);
    };

    requestRef.current = requestAnimationFrame(loop);
    return () => { if (requestRef.current) cancelAnimationFrame(requestRef.current); };
  }, [isPlaying, isGameReady, runtimeError, gameSpeed]); // gameSpeed ì˜ì¡´ì„± ì¶”ê°€

  // ìë™ ì €ì¥ (1ë¶„ ê°„ê²©)
  useEffect(() => {
    const autoSaveInterval = setInterval(() => { 
      if (isPlaying && isGameReady && !runtimeError) saveToSlot('auto'); 
    }, 60000);
    return () => clearInterval(autoSaveInterval);
  }, [isPlaying, isGameReady, runtimeError]);

  return { isMobile, store, isGameReady };
};


--- FILE: src/index.css ---
/* src/index.css */
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@700&family=Pretendard:wght@400;600;700;800&display=swap');

:root {
  --bg-main: #0f1115;
  --bg-panel: #161b22;
  --border: #30363d;
  --text-main: #f0f6fc;
  --text-sub: #8b949e;
  --primary: #58a6ff;
  --success: #238636;
  --danger: #da3633;
}

body {
  margin: 0;
  background-color: var(--bg-main);
  color: var(--text-main);
  font-family: 'Pretendard', sans-serif;
  -webkit-font-smoothing: antialiased;
}

/* ìŠ¤í¬ë¡¤ë°” ì»¤ìŠ¤í…€ */
::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: var(--bg-main); }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: #555; }

/* ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤ */
.panel {
  background: var(--bg-panel);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
}

.btn {
  padding: 10px 16px;
  border-radius: 6px;
  font-weight: 600;
  cursor: pointer;
  border: none;
  transition: 0.2s;
}
.btn-primary { background: var(--primary); color: #000; }
.btn-primary:hover { opacity: 0.9; }
.btn-danger { background: var(--danger); color: #fff; }

.text-mono { font-family: 'JetBrains Mono', monospace; }

@media (max-width: 768px) {
  /* í…Œì´ë¸” í—¤ë” ìˆ¨ê¹€ */
  thead { display: none; }

  /* í…Œì´ë¸” í–‰ì„ ë¸”ë¡ìœ¼ë¡œ, ì¹´ë“œì²˜ëŸ¼ ìŠ¤íƒ€ì¼ë§ */
  tr {
    display: flex;
    flex-direction: column;
    background: #1c1c1f;
    margin-bottom: 10px;
    border: 1px solid #333;
    border-radius: 8px;
    padding: 10px;
  }

  td {
    display: flex;
    justify-content: space-between;
    text-align: right;
    padding: 5px 0;
    border-bottom: 1px solid #222;
  }

  /* td ì•ì— ë¼ë²¨ ë¶™ì—¬ì£¼ê¸° (ê°€ìƒ ìš”ì†Œ í™œìš© ê°€ëŠ¥í•˜ì§€ë§Œ, ë¦¬ì•¡íŠ¸ ì»´í¬ë„ŒíŠ¸ ìˆ˜ì •ì´ ë” ì‰¬ì›€) */
}


--- FILE: src/store/slices/communitySlice.ts ---
import { StateCreator } from 'zustand';
import { GameStore, CommunitySlice } from '../types';

export const createCommunitySlice: StateCreator<GameStore, [], [], CommunitySlice> = (set) => ({
  communityPosts: [],
  selectedPost: null,

  openPost: (post) => set({ selectedPost: post }),
  closePost: () => set({ selectedPost: null }),
  setCommunityPosts: (posts) => set({ communityPosts: posts }),
});

--- FILE: src/store/slices/heroSlice.ts ---
import { StateCreator } from 'zustand';
import { GameStore, HeroSlice } from '../types';
import { INITIAL_HEROES } from '../../data/heroes';
import { Hero } from '../../types';

export const createHeroSlice: StateCreator<GameStore, [], [], HeroSlice> = (set) => ({
  heroes: INITIAL_HEROES,

  addHero: (hero: Hero) => set((state) => ({ 
    heroes: [hero, ...state.heroes] 
  })),

  deleteHero: (heroId: string) => set((state) => ({
    heroes: state.heroes.filter((h) => h.id !== heroId)
  })),

  updateHero: (id: string, updates: Partial<Hero>) => set((state) => ({ 
    heroes: state.heroes.map((h) => h.id === id ? { ...h, ...updates } : h) 
  })),

  resetHeroStats: () => set((state) => {
    const resetHeroes = state.heroes.map((hero) => ({
      ...hero,
      record: { 
        totalMatches: 0, totalWins: 0, totalPicks: 0, totalBans: 0, 
        totalKills: 0, totalDeaths: 0, totalAssists: 0, 
        totalDamage: 0, totalDamageTaken: 0, totalCs: 0, totalGold: 0, 
        recentResults: [] 
      },
      tier: '3' as const, rank: 0, rankChange: 0, 
      recentWinRate: 0, pickRate: 0, banRate: 0, 
      avgKda: '0.0/0.0/0.0', kdaRatio: '0.00', 
      avgDpm: '0', avgDpg: '0', avgCs: '0', avgGold: '0'
    }));
    return { heroes: resetHeroes };
  }),
});


--- FILE: src/store/slices/itemSlice.ts ---
import { StateCreator } from 'zustand';
import { GameStore, ItemSlice } from '../types';
import { INITIAL_ITEMS } from '../../data/items';
import { Item } from '../../types';

export const createItemSlice: StateCreator<GameStore, [], [], ItemSlice> = (set) => ({
  shopItems: INITIAL_ITEMS,

  addItem: (item: Item) => set((state) => ({ shopItems: [...state.shopItems, item] })),
  
  deleteItem: (id: string) => set((state) => ({ shopItems: state.shopItems.filter((i) => i.id !== id) })),
  
  updateItem: (id: string, updates: Partial<Item>) => set((state) => ({
    shopItems: state.shopItems.map((i) => i.id === id ? { ...i, ...updates } : i)
  })),
});


--- FILE: src/store/slices/settingSlice.ts ---
// ==========================================
// FILE PATH: /src/store/slices/settingSlice.ts
// ==========================================
import { StateCreator } from 'zustand';
import { GameStore, SettingSlice } from '../types';
import { Hero } from '../../types';

export const createSettingSlice: StateCreator<GameStore, [], [], SettingSlice> = (set) => ({

  updateBattleSettings: (s) => set((state) => ({ 
    gameState: { ...state.gameState, battleSettings: { ...state.gameState.battleSettings, ...s } } 
  })),

  updateFieldSettings: (s) => set((state) => ({ 
    gameState: { ...state.gameState, fieldSettings: { ...state.gameState.fieldSettings, ...s } } 
  })),

  updateTierConfig: (c) => set((state) => ({ 
    gameState: { ...state.gameState, tierConfig: c } 
  })),

  updateAIConfig: (c) => set((state) => {
    const newConfig = { ...state.gameState.aiConfig, ...c };
    localStorage.setItem('GW_AI_CONFIG', JSON.stringify(newConfig));
    return { gameState: { ...state.gameState, aiConfig: newConfig } };
  }),

  updateRoleSettings: (s) => set((state) => ({ 
    gameState: { ...state.gameState, roleSettings: { ...state.gameState.roleSettings, ...s } } 
  })),

  setCustomImage: (id, imageData) => set((state) => ({
    gameState: { ...state.gameState, customImages: { ...state.gameState.customImages, [id]: imageData } }
  })),

  removeCustomImage: (id) => set((state) => {
    const newImages = { ...state.gameState.customImages };
    delete newImages[id];
    return { gameState: { ...state.gameState, customImages: newImages } };
  }),

  loadModData: (modData: any) => set((state) => {
    // (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
    return { ...state }; 
  }),

  // [ì‹ ê·œ] ì¢Œí‘œ ì—…ë°ì´íŠ¸ ë¡œì§ (ë§¤ìš° ì¤‘ìš”: ì¤‘ì²© ê°ì²´ ì—…ë°ì´íŠ¸)
  updateObjectPosition: (key: string, x: number, y: number) => set((state) => {
    const positions = { ...state.gameState.fieldSettings.positions };
    
    // key ì˜ˆì‹œ: "colossus", "jungle.0", "towers.blue.top.0"
    const parts = key.split('.');
    
    if (parts.length === 1) {
        (positions as any)[parts[0]] = { x, y };
    } else if (parts[0] === 'jungle') {
        const idx = parseInt(parts[1]);
        if (positions.jungle[idx]) positions.jungle[idx] = { x, y };
    } else if (parts[0] === 'towers') {
        // towers.blue.top.0
        const side = parts[1] as 'blue'|'red';
        const lane = parts[2]; // top, mid, bot, nexus
        
        if (lane === 'nexus') {
            positions.towers[side].nexus = { x, y };
        } else {
            const idx = parseInt(parts[3]);
            // @ts-ignore
            if (positions.towers[side][lane][idx]) {
                // @ts-ignore
                positions.towers[side][lane][idx] = { x, y };
            }
        }
    }

    return { 
        gameState: { 
            ...state.gameState, 
            fieldSettings: { 
                ...state.gameState.fieldSettings, 
                positions 
            } 
        } 
    };
  }),
});


--- FILE: src/store/slices/gameSlice.ts ---
// ==========================================
// FILE PATH: /src/store/slices/gameSlice.ts
// ==========================================
import { StateCreator } from 'zustand';
import { GameStore, GameSlice } from '../types';
import { INITIAL_CUSTOM_IMAGES } from '../../data/initialImages';
import { GameState } from '../../types';
import { CoreEngine } from '../../engine/CoreEngine';
import { userPool } from '../../engine/system/UserManager'; 
import { INITIAL_HEROES } from '../../data/heroes';
import { INITIAL_ITEMS } from '../../data/items';

const loadSavedAIConfig = () => {
  try {
    const saved = localStorage.getItem('GW_AI_CONFIG');
    return saved ? JSON.parse(saved) : null;
  } catch (e) { return null; }
};

const savedAI = loadSavedAIConfig();

const initialPositions = {
  colossus: { x: 25, y: 28 }, 
  watcher: { x: 78, y: 72 },  
  jungle: [
    { x: 15, y: 42 }, 
    { x: 50, y: 82 }, 
    { x: 58, y: 22 }, 
    { x: 82, y: 55 }  
  ],
  towers: {
    blue: {
        top: [{x: 8, y: 35}, {x: 8, y: 55}, {x: 10, y: 75}], 
        mid: [{x: 40, y: 60}, {x: 30, y: 70}, {x: 22, y: 78}],
        bot: [{x: 75, y: 92}, {x: 50, y: 90}, {x: 25, y: 88}],
        nexus: { x: 12, y: 88 }
    },
    red: {
        top: [{x: 45, y: 10}, {x: 65, y: 12}, {x: 80, y: 15}],
        mid: [{x: 60, y: 40}, {x: 70, y: 30}, {x: 78, y: 22}],
        bot: [{x: 92, y: 65}, {x: 92, y: 45}, {x: 88, y: 25}],
        nexus: { x: 88, y: 12 }
    }
  }
};

const initialGameState: GameState = {
  season: 1, day: 1, hour: 12, minute: 0, second: 0,
  isPlaying: false, gameSpeed: 1,
  userSentiment: 60, ccu: 0, totalUsers: 3000, 
  userStatus: { totalGames: 0, playingUsers: 0, queuingUsers: 0, avgWaitTime: 0, tierDistribution: [] },
  topRankers: [],
  godStats: { totalMatches: 0, izmanWins: 0, izmanAvgKills: '0.0', izmanAvgTime: '00:00', danteWins: 0, danteAvgKills: '0.0', danteAvgTime: '00:00', avgGameDuration: 0, guardianDeathRate: 0, godAwakenRate: 0 },
  itemStats: {},
  liveMatches: [],
  tierConfig: { 
    challengerRank: 200, 
    master: 4800, ace: 3800, joker: 3200, gold: 2100, silver: 1300, bronze: 300,
    promos: { master: 5, ace: 5, joker: 5, gold: 3, silver: 3, bronze: 3 }
  },
  battleSettings: {
    izman: { name: 'ì´ì¦ˆë§ˆí•œ', atkRatio: 1.5, defRatio: 1, hpRatio: 10000, guardianHp: 25000, towerAtk: 100, trait: 'ê´‘ë€', servantGold: 14, servantXp: 30, minions: { melee: { label: 'ê´‘ì‹ ë„', hp: 550, def: 10, atk: 25, gold: 21, xp: 60 }, ranged: { label: 'ì•”í‘ ì‚¬ì œ', hp: 350, def: 0, atk: 45, gold: 14, xp: 30 }, siege: { label: 'ì•”í‘ê¸°ì‚¬', hp: 950, def: 40, atk: 70, gold: 60, xp: 90 } } },
    dante: { name: 'ë‹¨í…Œ', atkRatio: 1.5, defRatio: 1, hpRatio: 10000, guardianHp: 25000, towerAtk: 100, trait: 'ê°€í˜¸', servantGold: 14, servantXp: 30, minions: { melee: { label: 'ìˆ˜ë„ì‚¬', hp: 550, def: 10, atk: 25, gold: 21, xp: 60 }, ranged: { label: 'êµ¬ë„ì', hp: 350, def: 0, atk: 45, gold: 14, xp: 30 }, siege: { label: 'ì„±ì „ì‚¬', hp: 950, def: 40, atk: 70, gold: 60, xp: 90 } } },
    economy: { minionGold: 14, minionXp: 30 },
    siege: { 
        minionDmg: 1.0, cannonDmg: 1.0, superDmg: 1.0,
        dmgToHero: 1.0, dmgToT1: 0.3, dmgToT2: 0.25, dmgToT3: 0.2, dmgToNexus: 0.1,
        colossusToHero: 0.3, colossusToT1: 0.4, colossusToT2: 0.2, colossusToT3: 0.1, colossusToNexus: 0.05
    }
  },
  
  // [ìˆ˜ì • ì™„ë£Œ] íƒ€ì›ŒëŠ” í•˜í–¥, ë„¥ì„œìŠ¤ëŠ” ì›ë³¸ ìœ ì§€
  fieldSettings: {
    towers: {
        // [í•˜í–¥] íƒ€ì›Œ: 50% ìˆ˜ì¤€ (ì˜ ë¶€ì„œì§)
        t1: { hp: 5000, armor: 40, rewardGold: 300, atk: 350 },
        t2: { hp: 7500, armor: 60, rewardGold: 450, atk: 450 },
        t3: { hp: 10000, armor: 75, rewardGold: 600, atk: 550 },
        
        // [ìœ ì§€] ë„¥ì„œìŠ¤: ì›ë³¸ ìˆ˜ì¹˜ (ê°•ë ¥í•¨) - HP 30000, ë°©ì–´ 200
        nexus: { hp: 30000, armor: 200, rewardGold: 0, atk: 1000 }
    },
    colossus: { hp: 15000, armor: 80, rewardGold: 100, attack: 50, initialSpawnTime: 300, respawnTime: 300 },
    watcher: { hp: 20000, armor: 120, rewardGold: 150, buffType: 'COMBAT', buffAmount: 20, buffDuration: 180, initialSpawnTime: 420, respawnTime: 420 },
    jungle: { density: 50, yield: 50, attack: 30, defense: 20, threat: 0, xp: 160, gold: 80, initialSpawnTime: 90, respawnTime: 90 },
    positions: initialPositions
  },
  roleSettings: {
    executor: { damage: 10, defense: 10 },
    tracker: { gold: 20, smiteChance: 1.5 },
    prophet: { cdrPerLevel: 2 },
    slayer: { structureDamage: 30 },
    guardian: { survivalRate: 20 }
  },
  aiConfig: savedAI || { provider: 'GEMINI', apiKey: '', model: 'gemini-2.5-flash', enabled: false },
  customImages: INITIAL_CUSTOM_IMAGES 
};

export const createGameSlice: StateCreator<GameStore, [], [], GameSlice> = (set, get) => ({
  gameState: initialGameState,

  setSpeed: (s) => set((state) => ({ gameState: { ...state.gameState, gameSpeed: s } })),
  togglePlay: () => set((state) => ({ gameState: { ...state.gameState, isPlaying: !state.gameState.isPlaying } })),
  
  setGameState: (updates) => set((state) => {
    const newImages = updates.customImages || state.gameState.customImages;
    let newField = updates.fieldSettings || state.gameState.fieldSettings;
    let newBattle = updates.battleSettings || state.gameState.battleSettings;

    if (newField && !newField.positions) {
        newField = { ...newField, positions: initialPositions };
    }
    
    if (newBattle) {
        const defaultSiege = initialGameState.battleSettings.siege;
        const currentSiege = (newBattle as any).siege || {};
        newBattle.siege = { ...defaultSiege, ...currentSiege };
        
        if (newBattle.siege.dmgToT1 === undefined) {
             newBattle.siege = defaultSiege;
        }
    }

    // [ê°•ì œ íŒ¨ì¹˜] ê¸°ì¡´ ì„¸ì´ë¸Œ ë¡œë“œ ì‹œì—ë„ ì ìš©
    if ((newField as any).towers) {
        const t = (newField as any).towers;
        
        // 1. íƒ€ì›ŒëŠ” ë„ˆí”„ (50%)
        if (t.t1.hp > 6000) { t.t1.hp = 5000; t.t1.armor = 40; }
        if (t.t2.hp > 9000) { t.t2.hp = 7500; t.t2.armor = 60; }
        if (t.t3.hp > 12000) { t.t3.hp = 10000; t.t3.armor = 75; }
        
        // 2. [ë³µêµ¬] ë„¥ì„œìŠ¤ëŠ” ë‹¤ì‹œ ê°•ë ¥í•˜ê²Œ ë³µêµ¬ (ì´ì „ ë„ˆí”„ ì·¨ì†Œ)
        // ë§Œì•½ HPê°€ 25000 ì´í•˜ë¼ë©´(ì´ì „ ì‹¤ìˆ˜ë¡œ ë‚®ì¶°ì§„ ê²½ìš°) -> 30000ìœ¼ë¡œ ë³µêµ¬
        if (t.nexus.hp < 25000) { t.nexus.hp = 30000; t.nexus.armor = 200; }
    }

    return { 
        gameState: { ...state.gameState, ...updates, fieldSettings: newField, battleSettings: newBattle, customImages: newImages } 
    };
  }),

  tick: (deltaSeconds: number) => {
    const state = get();
    if (!state.gameState || !state.gameState.isPlaying) return;

    CoreEngine.processTick(
      state.gameState,
      state.heroes,
      state.communityPosts,
      deltaSeconds,
      (updates, newHeroes, newPosts) => {
        set((current) => ({
          gameState: { ...current.gameState, ...updates },
          heroes: newHeroes || current.heroes,
          communityPosts: newPosts || current.communityPosts
        }));
      }
    );
  },

  hardReset: () => {
    const currentAI = get().gameState.aiConfig;
    userPool.length = 0; 
    set({
      gameState: { ...initialGameState, aiConfig: currentAI },
      heroes: INITIAL_HEROES,
      shopItems: INITIAL_ITEMS,
      communityPosts: [],     
      selectedPost: null
    });
  }
});


--- FILE: src/store/types.ts ---
// ==========================================
// FILE PATH: /src/store/types.ts
// ==========================================

import { 
  Hero, Post, GameState, Item, 
  BattleSettings, BattlefieldSettings, TierConfig, AIConfig, RoleSettings, 
  ItemStatData 
} from '../types';

// 1. Hero Slice (ì˜ì›… ê´€ë¦¬)
export interface HeroSlice {
  heroes: Hero[];
  addHero: (hero: Hero) => void;
  deleteHero: (heroId: string) => void;
  updateHero: (id: string, updates: Partial<Hero>) => void;
  resetHeroStats: () => void;
}

// 2. Community Slice (ì»¤ë®¤ë‹ˆí‹°)
export interface CommunitySlice {
  communityPosts: Post[];
  selectedPost: Post | null;
  openPost: (post: Post) => void;
  closePost: () => void;
  setCommunityPosts: (posts: Post[]) => void;
}

// 3. Setting Slice (ì„¤ì • ê´€ë¦¬) - [ì‹ ê·œ ë¶„ë¦¬ë¨]
export interface SettingSlice {
  updateBattleSettings: (settings: Partial<BattleSettings['izman'] | BattleSettings['dante']>) => void;
  updateFieldSettings: (settings: Partial<BattlefieldSettings>) => void;
  updateTierConfig: (config: TierConfig) => void;
  updateAIConfig: (config: Partial<AIConfig>) => void;
  updateRoleSettings: (settings: Partial<RoleSettings>) => void;
  setCustomImage: (id: string, imageData: string) => void;
  removeCustomImage: (id: string) => void;
  loadModData: (modData: any) => void;
}

// 4. Game Slice (ê²Œì„ ì§„í–‰/ë©”ì¸ ë£¨í”„)
export interface GameSlice {
  gameState: GameState;
  setSpeed: (speed: number) => void;
  togglePlay: () => void;
  setGameState: (updates: Partial<GameState>) => void;
  tick: (deltaSeconds: number) => void; // í•µì‹¬ ë£¨í”„
  hardReset: () => void;
}

// 5. Item Slice (ì•„ì´í…œ ìƒì )
export interface ItemSlice {
  shopItems: Item[];
  addItem: (item: Item) => void;
  deleteItem: (id: string) => void;
  updateItem: (id: string, updates: Partial<Item>) => void;
}

// í†µí•© Store íƒ€ì…
export type GameStore = HeroSlice & CommunitySlice & SettingSlice & GameSlice & ItemSlice;

--- FILE: src/store/useGameStore.ts ---
// ==========================================
// FILE PATH: /src/store/useGameStore.ts
// ==========================================

import { create } from 'zustand';
import { GameStore } from './types';

// ìŠ¬ë¼ì´ìŠ¤ë“¤ ë¶ˆëŸ¬ì˜¤ê¸°
import { createHeroSlice } from './slices/heroSlice';
import { createCommunitySlice } from './slices/communitySlice';
import { createGameSlice } from './slices/gameSlice';
import { createItemSlice } from './slices/itemSlice';
import { createSettingSlice } from './slices/settingSlice'; // [ì¶”ê°€ë¨]

export const useGameStore = create<GameStore>()((...a) => ({
  ...createHeroSlice(...a),
  ...createCommunitySlice(...a),
  ...createGameSlice(...a),
  ...createItemSlice(...a),
  ...createSettingSlice(...a), // [ì¶”ê°€ë¨]
}));

--- FILE: src/types/jungle.ts ---
// ==========================================
// FILE PATH: /src/types/jungle.ts
// ==========================================

export type JungleCampType = 'TOP_BLUE' | 'BOT_BLUE' | 'TOP_RED' | 'BOT_RED';

export type BuffType = 'ATK' | 'DEF' | 'SPEED' | 'REGEN' | 'HASSTE' | 'GOLD';

// [ì‹ ê·œ] ê°œë³„ ë²„í”„ ì •ì˜
export interface MonsterBuff {
  type: BuffType;
  value: number;
}

export interface JungleMonsterStats {
  name: string;
  hp: number;
  atk: number;
  def: number;
  gold: number;
  xp: number;
  respawnTime: number;
  isBuffMob: boolean;
  
  // [ìˆ˜ì •] ë‹¤ì¤‘ ë²„í”„ ì§€ì›ì„ ìœ„í•´ ë°°ì—´ë¡œ ë³€ê²½
  buffs: MonsterBuff[]; 
}

export interface JungleCampConfig {
  id: string;
  name: string;
  monsters: {
    spotId: string;
    x: number;
    y: number;
    stats: JungleMonsterStats;
  }[];
}

export interface JungleSettings {
  density: number;
  camps: Record<JungleCampType, JungleCampConfig>;
}


--- FILE: src/types/user.ts ---
export interface MatchHistory {
  season: number; result: 'WIN' | 'LOSE' | 'PROMO WIN' | 'PROMO LOSS'; 
  heroName: string; kda: string; lpChange: number; date: string;
}

export interface UserHeroStat {
  matches: number; wins: number; kills: number; deaths: number; assists: number;
}

// [ì‹ ê·œ] ìœ ì € ì„±í–¥ íƒ€ì… ì •ì˜
export type PlayStyle = 'WORKER' | 'STUDENT' | 'NIGHT_OWL' | 'HARDCORE';

export interface UserProfile {
  id: number; name: string; 
  score: number; tier: string; rank: number; isChallenger: boolean;
  promoStatus: { targetTier: string; wins: number; losses: number; targetWins: number; } | null;

  winRate: number; totalGames: number; wins: number; losses: number;
  
  mainHeroId: string; preferredLane: 'TOP' | 'JUNGLE' | 'MID' | 'BOT'; preferredHeroes: string[];
  brain: number; mechanics: number; hiddenMmr: number; 
  
  // [ì‹ ê·œ ì†ì„±: AI í–‰ë™ íŒ¨í„´ìš©]
  playStyle: PlayStyle;      // ìœ ì € ì„±í–¥ (ì ‘ì† ì‹œê°„ëŒ€ ê²°ì •)
  activityBias: number;      // ì ‘ì† ë¹ˆë„ ê°€ì¤‘ì¹˜ (ë†’ì„ìˆ˜ë¡ ìì£¼ ì ‘ì†)
  tiredness: number;         // í˜„ì¬ ì„¸ì…˜ì—ì„œ í”Œë ˆì´í•œ ê²Œì„ ìˆ˜
  sessionTarget: number;     // ì´ë²ˆ ì ‘ì†ì—ì„œ í”Œë ˆì´í•  ëª©í‘œ ê²Œì„ ìˆ˜

  status: 'IDLE' | 'QUEUE' | 'INGAME' | 'OFFLINE' | 'RESTING';
  restTimer: number;

  history: MatchHistory[]; heroStats: Record<string, UserHeroStat>;
  mostChamps?: any[]; laneStats?: any[];
}

export interface TierConfig {
  challengerRank: number; master: number; ace: number; joker: number;
  gold: number; silver: number; bronze: number;
  promos?: { master: number; ace: number; joker: number; gold: number; silver: number; bronze: number; };
}

export interface TierStat { name: string; minScore: number; count: number; percent: number; color: string; }
export interface UserStatus {
  totalGames: number; playingUsers: number; queuingUsers: number; avgWaitTime: number; tierDistribution: TierStat[];
}


--- FILE: src/types/index.ts ---
// ==========================================
// FILE PATH: /src/types/index.ts
// ==========================================
export * from './user';
export * from './hero';
export * from './match';

import { TierConfig, AIConfig } from './user';
export { TierConfig, AIConfig };

export interface Item {
  id: string; name: string; cost: number;
  ad: number; ap: number; hp: number; armor: number; crit: number; speed: number;
  mp?: number; regen?: number; mpRegen?: number; pen?: number;
  type: 'WEAPON' | 'ARMOR' | 'ACCESSORY' | 'POWER' | 'BOOTS' | 'ARTIFACT'; 
  description?: string;
}

export interface ItemStatData { itemId: string; totalPicks: number; totalWins: number; totalKills: number; totalDeaths: number; totalAssists: number; }

export interface ObjectStats { hp: number; armor: number; rewardGold: number; atk?: number; }
export interface ColossusSettings extends ObjectStats { attack: number; initialSpawnTime: number; respawnTime: number; }
export interface WatcherSettings extends ObjectStats { buffType: 'COMBAT' | 'GOLD'; buffAmount: number; buffDuration: number; initialSpawnTime: number; respawnTime: number; }
export interface JungleSettings { density: number; threat: number; yield: number; attack: number; defense: number; xp: number; gold: number; initialSpawnTime: number; respawnTime: number; }

export interface Vector2 { x: number; y: number; }
export interface MapPositions {
  colossus: Vector2;
  watcher: Vector2;
  jungle: Vector2[];
  towers: {
    blue: { top: Vector2[]; mid: Vector2[]; bot: Vector2[]; nexus: Vector2; };
    red: { top: Vector2[]; mid: Vector2[]; bot: Vector2[]; nexus: Vector2; };
  };
}

export interface BattlefieldSettings { 
  towers: { t1: ObjectStats; t2: ObjectStats; t3: ObjectStats; nexus: ObjectStats; };
  colossus: ColossusSettings; 
  watcher: WatcherSettings; 
  jungle: JungleSettings; 
  positions: MapPositions;
}

export interface RoleSettings { executor: { damage: number; defense: number }; tracker: { gold: number; smiteChance: number }; prophet: { cdrPerLevel: number }; slayer: { structureDamage: number }; guardian: { survivalRate: number }; }
export interface MinionStats { label: string; hp: number; def: number; atk: number; gold: number; xp: number; }
export interface GodSettings {
  name: string; atkRatio: number; defRatio: number; hpRatio: number;
  guardianHp: number; towerAtk: number; trait: string;
  minions: { melee: MinionStats; ranged: MinionStats; siege: MinionStats; };
  servantGold: number; servantXp: number; 
}
export interface EconomySettings { minionGold: number; minionXp: number; }

export interface SiegeSettings {
  minionDmg: number; cannonDmg: number; superDmg: number;
  dmgToHero: number; dmgToT1: number; dmgToT2: number; dmgToT3: number; dmgToNexus: number;
  colossusToHero: number; colossusToT1: number; colossusToT2: number; colossusToT3: number; colossusToNexus: number;
}

export interface BattleSettings { 
  izman: GodSettings; 
  dante: GodSettings; 
  economy: EconomySettings; 
  siege: SiegeSettings; 
}

export interface AIConfig { provider: 'GEMINI' | 'OPENAI'; apiKey: string; model: string; enabled: boolean; }
export interface GodStats { totalMatches: number; izmanWins: number; izmanAvgKills: string; izmanAvgTime: string; danteWins: number; danteAvgKills: string; danteAvgTime: string; avgGameDuration: number; guardianDeathRate: number; godAwakenRate: number; }
export interface Comment { id: number; author: string; authorTier: string; content: string; timestamp: string; }
export interface Post { id: number; author: string; authorTier: string; title: string; content: string; category: 'ê³µëµ' | 'ìœ ë¨¸' | 'ì§•ì§•' | 'ë¶„ì„' | 'ì¡ë‹´' | 'ì§ˆë¬¸' | 'ìë‘' | 'ê³µì§€'; views: number; upvotes: number; downvotes: number; comments: number; commentList: Comment[]; createdAt: number; potential: number; isBest: boolean; displayTime: string; }

import { UserProfile, UserStatus } from './user';
import { LiveMatch } from './match';

export interface TeamStats {
  towers: { top: number; mid: number; bot: number };
  laneHealth: { top: number; mid: number; bot: number };
  colossus: number;
  watcher: number;
  fury: number;
  nexusHp: number;
  maxNexusHp: number;
  activeBuffs: { siegeUnit: boolean; voidPower: boolean; voidBuffEndTime?: number; };
}

export interface GameState { 
  season: number; day: number; hour: number; minute: number; second: number; 
  isPlaying: boolean; gameSpeed: number; userSentiment: number; 
  ccu: number; totalUsers: number; 
  userStatus: UserStatus; topRankers: UserProfile[]; godStats: GodStats; 
  liveMatches: LiveMatch[]; 
  tierConfig: TierConfig; battleSettings: BattleSettings; fieldSettings: BattlefieldSettings; roleSettings: RoleSettings; aiConfig: AIConfig; 
  itemStats: Record<string, ItemStatData>; customImages: Record<string, string>; 
}

// [ìˆ˜ì •] Minion ì¸í„°í˜ì´ìŠ¤ì— targetId ì¶”ê°€ (ê¸°ì–µë ¥)
export interface Minion {
  id: string;
  team: 'BLUE' | 'RED';
  lane: 'TOP' | 'MID' | 'BOT';
  type: 'MELEE' | 'RANGED' | 'SIEGE' | 'SUMMONED_COLOSSUS';
  x: number;
  y: number;
  hp: number;
  maxHp: number;
  atk: number;
  pathIdx: number;
  targetId?: string; // ë‚´ê°€ ë•Œë¦¬ê³  ìˆëŠ” ëŒ€ìƒ ID
}

export interface HeroSlice { heroes: any[]; addHero: (hero: any) => void; deleteHero: (heroId: string) => void; updateHero: (id: string, updates: any) => void; resetHeroStats: () => void; }
export interface ItemSlice { shopItems: Item[]; addItem: (item: Item) => void; deleteItem: (id: string) => void; updateItem: (id: string, updates: Partial<Item>) => void; }
export interface CommunitySlice { communityPosts: Post[]; selectedPost: Post | null; openPost: (post: Post) => void; closePost: () => void; setCommunityPosts: (posts: Post[]) => void; }
export interface SettingSlice { 
  updateBattleSettings: (settings: any) => void; 
  updateFieldSettings: (settings: any) => void; 
  updateTierConfig: (config: TierConfig) => void; 
  updateAIConfig: (config: Partial<AIConfig>) => void; 
  updateRoleSettings: (settings: Partial<RoleSettings>) => void; 
  setCustomImage: (id: string, imageData: string) => void; 
  removeCustomImage: (id: string) => void; 
  loadModData: (modData: any) => void; 
  updateObjectPosition: (key: string, x: number, y: number) => void;
}
export interface GameSlice { gameState: GameState; setSpeed: (speed: number) => void; togglePlay: () => void; setGameState: (updates: Partial<GameState>) => void; tick: (deltaSeconds: number) => void; hardReset: () => void; }
export type GameStore = HeroSlice & ItemSlice & CommunitySlice & GameSlice & SettingSlice;


--- FILE: src/utils/AIService.ts ---
// ==========================================
// FILE PATH: /src/utils/AIService.ts
// ==========================================

import { generateAIPost } from './ai/PostGenerator';
import { generateAIComment } from './ai/CommentGenerator';

// ê¸°ì¡´ ì½”ë“œì™€ì˜ í˜¸í™˜ì„±ì„ ìœ„í•´ í•¨ìˆ˜ ì´ë¦„ì„ ìœ ì§€í•˜ë©° ì—°ê²°í•©ë‹ˆë‹¤.
export const fetchAIPost = generateAIPost;
export const fetchAIComment = generateAIComment;

--- FILE: src/utils/GeminiService.ts ---
// src/utils/GeminiService.ts

// [ì¤‘ìš”] Google AI Studio API Key í•„ìš”
const API_KEY = ""; 
const MODEL_VERSION = "gemini-2.5-flash"; // or gemini-2.0-flash-exp

export async function fetchGeminiPost(context: string, topic: string): Promise<{title: string, content: string} | null> {
  if (!API_KEY) {
    console.warn("Gemini API Key Missing");
    return null;
  }

  try {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_VERSION}:generateContent?key=${API_KEY}`;
    
    // [í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§]
    // AIì—ê²Œ êµ¬ì²´ì ì¸ í˜ë¥´ì†Œë‚˜ì™€ ìƒí™©ì„ ë¶€ì—¬í•˜ì—¬ ê¸€ì˜ í€„ë¦¬í‹°ë¥¼ ë†’ì„
    const prompt = `
      ë„ˆëŠ” 'ì‹ ë“¤ì˜ ì „ìŸ(Gods' War)'ì´ë¼ëŠ” AOS(MOBA) ê²Œì„ ì»¤ë®¤ë‹ˆí‹°ì˜ ìœ ì €ì•¼.
      ì§€ê¸ˆë¶€í„° ì•„ë˜ ì£¼ì–´ì§„ [ìƒí™©]ê³¼ [ì£¼ì œ]ì— ë§ì¶°ì„œ ì»¤ë®¤ë‹ˆí‹° ê²Œì‹œê¸€ì„ ì‘ì„±í•´.
      
      [ì£¼ì œ]: ${topic}
      [í˜„ì¬ ê²Œì„ ë©”íƒ€ ìƒí™©]:
      ${context}

      [ì‘ì„± ì§€ì¹¨]:
      1. ë§íˆ¬: ë””ì‹œì¸ì‚¬ì´ë“œ, í¨ì½”, ì•„ì¹´ë¼ì´ë¸Œ ë“± í•œêµ­ ê²Œì„ ì»¤ë®¤ë‹ˆí‹° ë§íˆ¬ë¥¼ ì‚¬ìš©í•´. (ë°˜ë§, ì€ì–´ ì‚¬ìš© ê°€ëŠ¥)
      2. ë‚´ìš©: ë¬´ì¡°ê±´ì ì¸ ìš•ì„¤ì´ë‚˜ ë¹„ë‚œë§Œ í•˜ì§€ ë§ˆ.
         - 'ë¶„ì„' ì£¼ì œë¼ë©´ ì§„ì§€í•˜ê²Œ ìŠ¤íƒ¯ì´ë‚˜ ì•„ì´í…œ íŠ¸ë¦¬ë¥¼ ë…¼í•´.
         - 'ì§ˆë¬¸' ì£¼ì œë¼ë©´ ë‰´ë¹„ì²˜ëŸ¼ ëª¨ë¥´ëŠ” ê±¸ ë¬¼ì–´ë´.
         - 'ìœ ë¨¸' ì£¼ì œë¼ë©´ ê²Œì„ ìƒí™©ì„ ë¹„ê¼¬ê±°ë‚˜ ë“œë¦½ì„ ì³.
      3. ê¸¸ì´: ì œëª©ì€ ì„íŒ©íŠ¸ ìˆê²Œ í•œ ì¤„, ë‚´ìš©ì€ 2~3ë¬¸ì¥ ì •ë„ë¡œ ì§§ê³  êµµê²Œ.
      
      [ì¶œë ¥ í˜•ì‹ (JSON)]:
      ë°˜ë“œì‹œ ë§ˆí¬ë‹¤ìš´ ì—†ì´ ìˆœìˆ˜ JSONë§Œ ì¶œë ¥í•´.
      {
        "title": "ê²Œì‹œê¸€ ì œëª©",
        "content": "ê²Œì‹œê¸€ ë³¸ë¬¸ ë‚´ìš©"
      }
    `;

    const response = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
    });

    const data = await response.json();
    if (data.error) throw new Error(data.error.message);

    const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
    if (!text) return null;
    
    const jsonStr = text.replace(/```json|```/g, "").trim();
    return JSON.parse(jsonStr);

  } catch (e) {
    console.error("Gemini Post Error:", e);
    return null;
  }
}

export async function fetchGeminiComment(postContent: string): Promise<string | null> {
  if (!API_KEY) return null;

  try {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_VERSION}:generateContent?key=${API_KEY}`;
    
    const prompt = `
      AOS ê²Œì„ ì»¤ë®¤ë‹ˆí‹° ê¸€ì— ë‹¬ë¦´ ëŒ“ê¸€ í•˜ë‚˜ë¥¼ ì‘ì„±í•´.
      ê¸€ ë‚´ìš©: "${postContent}"
      
      ì§€ì¹¨:
      - ê¸€ ë‚´ìš©ì— ë™ì¡°í•˜ê±°ë‚˜, ë°˜ë°•í•˜ê±°ë‚˜, ë¹„ê¼¬ëŠ” ë“± ë¦¬ì–¼í•œ ë°˜ì‘ì„ ë³´ì—¬ì¤˜.
      - "ã…‹ã…‹ã…‹ã…‹" ê°™ì€ ì´ˆì„±ì²´ë‚˜ ì€ì–´ë¥¼ ì ì ˆíˆ ì„ì–´.
      - ì„¤ëª… ì—†ì´ ëŒ“ê¸€ ë‚´ìš© í…ìŠ¤íŠ¸ë§Œ ì¶œë ¥í•´.
    `;

    const response = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
    });

    const data = await response.json();
    return data.candidates?.[0]?.content?.parts?.[0]?.text.trim();
  } catch (e) {
    return null;
  }
}

--- FILE: src/utils/OpenAIService.ts ---
// src/utils/OpenAIService.ts

// 1. ì—¬ê¸°ì— OpenAI API í‚¤ë¥¼ ë„£ìœ¼ë©´ ì§„ì§œ AIê°€ ì‘ë™í•©ë‹ˆë‹¤. (ì—†ìœ¼ë©´ ê°€ì§œ AI ì‘ë™)
const API_KEY = ""; // ì˜ˆ: "sk-proj-..."

export async function fetchAIPost(context: string): Promise<{title: string, content: string} | null> {
  if (!API_KEY) return null; // í‚¤ ì—†ìœ¼ë©´ null ë°˜í™˜ -> í…œí”Œë¦¿ ì—”ì§„ ì‚¬ìš©

  try {
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${API_KEY}`
      },
      body: JSON.stringify({
        model: "gpt-3.5-turbo", // or gpt-4
        messages: [
          { role: "system", content: "ë„ˆëŠ” 'ì‹ ë“¤ì˜ ì „ìŸ'ì´ë¼ëŠ” AOS ê²Œì„ì˜ ì•…ì§ˆ ìœ ì €ì•¼. ë””ì‹œì¸ì‚¬ì´ë“œë‚˜ í¨ì½” ë§íˆ¬ë¡œ ì§§ê³  ê°„ê²°í•˜ê²Œ ê¸€ì„ ì¨. ë°˜ë§ì„ ì‚¬ìš©í•´." },
          { role: "user", content: `ë‹¤ìŒ ìƒí™©ì„ ë³´ê³  ê²Œì‹œê¸€ ì œëª©ê³¼ ë‚´ìš©ì„ JSON í˜•ì‹ìœ¼ë¡œ ë§Œë“¤ì–´ì¤˜: ${context}` }
        ],
        temperature: 0.8,
      })
    });

    const data = await response.json();
    const content = data.choices[0].message.content;
    // JSON íŒŒì‹± ì‹œë„ (AIê°€ í…ìŠ¤íŠ¸ë¡œ ì¤„ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ)
    try {
      return JSON.parse(content);
    } catch {
      return { title: "AI ê¸€ì‘ì„± ì˜¤ë¥˜", content: content };
    }
  } catch (e) {
    console.error("AI API Error:", e);
    return null;
  }
}

export async function fetchAIComment(postContent: string): Promise<string | null> {
  if (!API_KEY) return null;

  try {
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${API_KEY}`
      },
      body: JSON.stringify({
        model: "gpt-3.5-turbo",
        messages: [
          { role: "system", content: "ë„ˆëŠ” AOS ê²Œì„ ì»¤ë®¤ë‹ˆí‹° ìœ ì €ì•¼. ê±°ì¹ ê³  ì§§ì€ ë§íˆ¬ë¡œ ëŒ“ê¸€ì„ ë‹¬ì•„." },
          { role: "user", content: `ë‹¤ìŒ ê¸€ì— ë‹¬ë¦´ ëŒ“ê¸€ í•˜ë‚˜ë§Œ ì¨ì¤˜: "${postContent}"` }
        ],
        max_tokens: 50
      })
    });
    const data = await response.json();
    return data.choices[0].message.content;
  } catch (e) {
    return null;
  }
}

--- FILE: src/utils/ai/AIClient.ts ---
import { AIConfig } from '../../types';

// ê³µí†µ JSON ì‘ë‹µìš©
export async function callAI(config: AIConfig, prompt: string) {
  try {
    if (config.provider === 'GEMINI') {
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${config.model}:generateContent?key=${config.apiKey}`;
      const response = await fetch(url, {
        method: "POST", headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
      });
      const data = await response.json();
      if (data.error) throw new Error(data.error.message);
      const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
      const jsonStr = text.replace(/```json|```/g, "").trim();
      return JSON.parse(jsonStr);
    }

    if (config.provider === 'OPENAI') {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST", headers: { "Content-Type": "application/json", "Authorization": `Bearer ${config.apiKey}` },
        body: JSON.stringify({
          model: config.model,
          messages: [{ role: "system", content: "Reply in JSON only." }, { role: "user", content: prompt }],
          temperature: 0.9,
        })
      });
      const data = await response.json();
      return JSON.parse(data.choices[0].message.content);
    }
  } catch (e) {
    console.error("AI Error:", e);
    return null;
  }
  return null;
}

// ê³µí†µ í…ìŠ¤íŠ¸ ì‘ë‹µìš©
export async function callAIString(config: AIConfig, prompt: string) {
  try {
    if (config.provider === 'GEMINI') {
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${config.model}:generateContent?key=${config.apiKey}`;
      const response = await fetch(url, {
        method: "POST", headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
      });
      const data = await response.json();
      return data.candidates?.[0]?.content?.parts?.[0]?.text.trim();
    } 

    if (config.provider === 'OPENAI') {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST", headers: { "Content-Type": "application/json", "Authorization": `Bearer ${config.apiKey}` },
        body: JSON.stringify({
          model: config.model,
          messages: [
            { role: "system", content: "You are a user of a Korean gaming community." }, 
            { role: "user", content: prompt }
          ],
          temperature: 1.0,
          max_tokens: 100
        })
      });
      const data = await response.json();
      return data.choices[0].message.content.trim();
    }
  } catch (e) { return null; }
  return null;
}

--- FILE: src/utils/ai/CommentGenerator.ts ---
import { AIConfig } from '../../types';
import { callAIString } from './AIClient';

const FALLBACK_COMMENTS = ["ã…‹ã…‹ã…‹ã…‹", "ã„¹ã…‡ã…‹ã…‹", "ê°œì›ƒê¸°ë„¤", "???", "ã„´ã„´ ì•„ë‹˜"];
const pickRandom = (arr: string[]) => arr[Math.floor(Math.random() * arr.length)];

export async function generateAIComment(config: AIConfig, postTitle: string, postContent: string): Promise<string | null> {
  if (!config.apiKey || !config.enabled) return pickRandom(FALLBACK_COMMENTS);

  const personas = [
    { type: "íŒ©íŠ¸í­ê²©ê¸°", desc: "ê¸€ ë‚´ìš©ì˜ ëª¨ìˆœì„ ì°¾ì•„ë‚´ì„œ ë…¼ë¦¬ì ìœ¼ë¡œ ë°˜ë°•í•¨. í‹°ì–´ ë¶€ì‹¬ì´ ì‹¬í•¨." },
    { type: "ê³µê°ëŸ¬", desc: "ê¸€ì“´ì´ì˜ ìƒí™©ì— ê¹Šì´ ê³µê°í•˜ë©° ê°™ì´ ìš•í•´ì¤Œ." },
    { type: "ë¹„ê¼¬ê¸° ì¥ì¸", desc: "ì§ì ‘ì ì¸ ìš•ì„¤ ì—†ì´ ëŒë ¤ì„œ ê¹Œê±°ë‚˜, 'ê·¸ë˜ì„œ í‹°ì–´ê°€?' ì‹œì „." },
    { type: "ë‹¨ë‹µí˜• ì¿¨ì°", desc: "ì•„ì£¼ ì§§ê²Œ í•œë§ˆë”” íˆ­ ë˜ì§. ì´ˆì„±ì²´(ã„¹ã…‡ã…‹ã…‹, ã„´ã„´, ã„·ã„·) ì• ìš©." },
    { type: "ë“œë¦½ì¶©", desc: "ìƒí™©ì— ë§ëŠ” ë“œë¦½ì„ ì¹¨." }
  ];

  const selected = personas[Math.floor(Math.random() * personas.length)];

  const systemPrompt = `
    ë„ˆëŠ” ê²Œì„ ì»¤ë®¤ë‹ˆí‹° ëŒ“ê¸€ ì‘ì„±ìì•¼. 
    [ê²Œì‹œê¸€]ì„ ë³´ê³  [ì»¨ì…‰]ì— ë§ì¶° **ì•„ì£¼ ì§§ì€ ëŒ“ê¸€ í•˜ë‚˜**ë¥¼ ì¨.

    [ê²Œì‹œê¸€ ì œëª©]: ${postTitle}
    [ê²Œì‹œê¸€ ë‚´ìš©]: ${postContent}
    [ë„ˆì˜ ì»¨ì…‰]: ${selected.type} (${selected.desc})

    [ê·œì¹™]:
    1. ë¬´ì¡°ê±´ ë°˜ë§/ìŒìŠ´ì²´.
    2. ê¸¸ì´ëŠ” 5~20ì ì´ë‚´. (ê¸¸ë©´ ì•ˆ ì½ìŒ)
    3. JSON ê¸ˆì§€. í…ìŠ¤íŠ¸ë§Œ ì¶œë ¥.
    4. "ë‹ˆê°€ ëª»í•´ì„œ ê·¸ë˜" ê¸ˆì§€. ì°½ì˜ì ìœ¼ë¡œ ì¨.
  `;

  try {
    const aiResponse = await callAIString(config, systemPrompt);
    return aiResponse || pickRandom(FALLBACK_COMMENTS);
  } catch (e) {
    return pickRandom(FALLBACK_COMMENTS);
  }
}

--- FILE: src/utils/ai/PostGenerator.ts ---
// ==========================================
// FILE PATH: /src/utils/ai/PostGenerator.ts
// ==========================================

import { AIConfig } from '../../types';
import { callAI } from './AIClient';

export async function generateAIPost(config: AIConfig, context: string, category: string): Promise<{title: string, content: string} | null> {
  // AI ì„¤ì •ì´ ì—†ê±°ë‚˜ êº¼ì ¸ìˆìœ¼ë©´ ì¤‘ë‹¨
  if (!config.apiKey || !config.enabled) return null;

  // 1. ì¹´í…Œê³ ë¦¬ ë° ë¬¸ë§¥ì— ë”°ë¥¸ í˜ë¥´ì†Œë‚˜(ì„±ê²©) ì„¤ì •
  let persona = "ì¼ë°˜ì ì¸ ê²Œì„ ìœ ì €";
  let extraInstruction = "";

  // ë¬¸ë§¥ì— 'ì €ê²©'ì´ í¬í•¨ë˜ì–´ ìˆìœ¼ë©´ ì¹´í…Œê³ ë¦¬ë³´ë‹¤ ìš°ì„ í•˜ì—¬ ì €ê²©ëŸ¬ í˜ë¥´ì†Œë‚˜ ì ìš©
  if (context.includes('ì €ê²©') || context.includes('SNIPING')) {
    persona = "ì§‘ìš”í•œ ì €ê²©ëŸ¬. ì¦ê±°ë¥¼ ëŒ€ë¼ëŠ” ì‹ì˜ ë§íˆ¬ë‚˜ ë¹„ê¼¬ëŠ” ë§íˆ¬ ì‚¬ìš©.";
    extraInstruction = "ìƒëŒ€ ë‹‰ë„¤ì„ì„ ê±°ë¡ í•˜ë©° ê³µê°œì ìœ¼ë¡œ ë§ì‹ ì„ ì£¼ë ¤ëŠ” í†¤ìœ¼ë¡œ ì‘ì„±í•´. 'ëŒ€ë¦¬ëƒ?', 'ì‚¬ëŒì´ëƒ?' ê°™ì€ ê³µê²©ì ì¸ ì§ˆë¬¸ì„ ë˜ì ¸.";
  } 
  else if (category === 'ê³µëµ' || category === 'ë¶„ì„') {
    persona = "ë…¼ë¦¬ì ì´ê³  ë¶„ì„ì ì¸ ì²™í•˜ëŠ” 'ê²œì˜ì•Œ' ìœ ì €. ìˆ˜ì¹˜ì™€ ë°ì´í„°ë¥¼ ì–¸ê¸‰í•˜ê¸¸ ì¢‹ì•„í•¨.";
    extraInstruction = "ë§ˆì¹˜ ìì‹ ì´ í”„ë¡œê²Œì´ë¨¸ì¸ ê²ƒì²˜ëŸ¼ í›ˆìˆ˜ ë‘ëŠ” ë§íˆ¬ë¥¼ ì‚¬ìš©í•´. 'ì´ê±´ íŒ©íŠ¸ì„', 'ë°˜ë°•ì‹œ ë‹ˆë§ë§' ê°™ì€ í‘œí˜„ ì‚¬ìš©.";
  } 
  else if (category === 'ì§•ì§•') {
    persona = "í™”ê°€ ì”ëœ© ë‚œ ë‹¤í˜ˆì§ˆ ìœ ì €. ì–µìš¸í•¨ì„ í˜¸ì†Œí•˜ê±°ë‚˜ ìš´ì˜ì§„/íŒ€ì›ì„ íƒ“í•¨.";
    extraInstruction = "ê±°ì¹œ ì–´ì¡°ë¥¼ ì‚¬ìš©í•˜ê³ , 'ë§ê²œ', 'ì–µê¹Œ', 'ë°¸ëŸ°ìŠ¤ ê¼¬ë¼ì§€' ê°™ì€ ë‹¨ì–´ë¥¼ ì‚¬ìš©í•´ ë¶„ë…¸ë¥¼ í‘œì¶œí•´.";
  } 
  else if (category === 'ìœ ë¨¸') {
    persona = "ì»¤ë®¤ë‹ˆí‹° ë“œë¦½ ì¥ì¸. ì§§ê³  ê°•ë ¬í•œ 'ë»˜ê¸€'ì´ë‚˜ 'ë“œë¦½'ì„ ì˜ ì¹¨.";
    extraInstruction = "ì§„ì§€í•œ ë‚´ìš©ì€ ë¹¼ê³ , í”¼ì‹í•˜ê²Œ ë§Œë“œëŠ” ì§§ì€ ë¬¸ì¥ ìœ„ì£¼ë¡œ ì¨. ì´ˆì„±ì²´(ã…‹ã…‹ã…‹ã…‹, ã„¹ã…‡ã…‹ã…‹)ë¥¼ ì ê·¹ í™œìš©í•´.";
  } 
  else if (category === 'ì§ˆë¬¸') {
    persona = "ê²Œì„ì„ ê°“ ì‹œì‘í•œ ë‰´ë¹„ í˜¹ì€ ëª¨ë¥´ëŠ”ê²Œ ìƒê¸´ ìœ ì €.";
    extraInstruction = "ê²¸ì†í•˜ê²Œ ë¬¼ì–´ë³´ê±°ë‚˜, í˜¹ì€ í•‘í”„(ê²€ìƒ‰ ì•ˆí•˜ê³  ë¬¼ì–´ë³´ëŠ”) ì»¨ì…‰ìœ¼ë¡œ ì§ˆë¬¸í•´.";
  }
  else {
    persona = "ì‹¬ì‹¬í•œ ìœ ì €. ì˜ì‹ì˜ íë¦„ëŒ€ë¡œ ê¸€ì„ ì”€.";
    extraInstruction = "ì¼ìƒì ì¸ ë§íˆ¬ë¡œ ì‘ì„±í•´. ë³„ ë‚´ìš© ì—†ëŠ” ì¡ë‹´ì²˜ëŸ¼.";
  }

  // 2. AIì—ê²Œ ë³´ë‚¼ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ êµ¬ì„±
  const systemPrompt = `
    ë„ˆëŠ” 'ì‹ ë“¤ì˜ ì „ìŸ(Gods' War)'ì´ë¼ëŠ” ê°€ìƒì˜ AOS(MOBA) ê²Œì„ ì»¤ë®¤ë‹ˆí‹°(í•œêµ­ì˜ ë””ì‹œì¸ì‚¬ì´ë“œ ë¡¤ê°¤, í¨ì½”, ì•„ì¹´ë¼ì´ë¸Œ ëŠë‚Œ)ì˜ ìœ ì €ì•¼.
    ì£¼ì–´ì§„ [ìƒí™© ì •ë³´]ë¥¼ ë°”íƒ•ìœ¼ë¡œ, [ì¹´í…Œê³ ë¦¬]ì— ë§ëŠ” **ë‹¨ í•˜ë‚˜ì˜ ê²Œì‹œê¸€**ì„ ì‘ì„±í•´.

    [ì¹´í…Œê³ ë¦¬]: ${category}
    [ì‘ì„±ì ì»¨ì…‰]: ${persona}
    [ê¸€ê° ë° ìƒí™© ì •ë³´]: ${context}

    [ì‘ì„± ì§€ì¹¨]:
    1. **ë§íˆ¬**: í•œêµ­ ì¸í„°ë„· ì»¤ë®¤ë‹ˆí‹° ë§íˆ¬(ìŒìŠ´ì²´, ë°˜ë§, ì€ì–´, ì´ˆì„±ì²´ 'ã…‹ã…‹', 'ã„¹ã…‡', 'ã„·ã„·', 'ã„´ã„´')ë¥¼ ìì—°ìŠ¤ëŸ½ê²Œ ì‚¬ìš©í•´.
    2. **ë‚´ìš©**: 
       - ì œëª©ì€ í´ë¦­ì„ ìœ ë„í•˜ë„ë¡ ìê·¹ì ì´ê±°ë‚˜(ì–´ê·¸ë¡œ), ì•„ì£¼ ë¬´ì‹¬í•˜ê²Œ(ì¿¨ì°) ì§€ì–´.
       - ë³¸ë¬¸ì€ 1~4ë¬¸ì¥ ë‚´ì™¸ë¡œ ì§§ê²Œ. ë„ˆë¬´ ê¸¸ë©´ ì•ˆ ì½ìŒ.
       - ${extraInstruction}
    3. **í˜•ì‹**: ì˜¤ì§ JSONë§Œ ì¶œë ¥í•´. (ë§ˆí¬ë‹¤ìš´ ì½”ë“œë¸”ëŸ­ ì—†ì´).
    
    Example Input: ì§•ì§• / ì•¼ìŠ¤ì˜¤ Q ë„ˆí”„ì¢€
    Example Output: {"title": "ì•„ë‹ˆ ì•¼ìŠ¤ì˜¤ Q ë”œ ì‹¤í™”ëƒ?", "content": "ìŠ¤ì¹˜ë©´ ë°˜í”¼ ë‚˜ê°€ëŠ”ê²Œ ê²Œì„ì´ëƒ? ìš´ì˜ì ì¼ ì•ˆí•¨? ã…¡ã…¡"}
  `;

  // 3. AI í˜¸ì¶œ ë° ê²°ê³¼ ë°˜í™˜
  return await callAI(config, systemPrompt);
}

--- FILE: src/utils/nameGenerator.ts ---
// src/utils/nameGenerator.ts

// 1. [í•œê¸€] í˜•ìš©ì‚¬ (ìˆ˜ì‹ì–´)
const KR_PREFIXES = [
  "ë§›ìˆëŠ”", "ì¦ê±°ìš´", "ìš°ìš¸í•œ", "ê°•ë ¥í•œ", "ë°°ê³ í”ˆ", "ì§€ë‚˜ê°€ë˜", "ì „ì„¤ì˜", "ìˆ˜ìƒí•œ", 
  "ê·€ì—¬ìš´", "ì‚¬ì•…í•œ", "íˆ¬ëª…í•œ", "ë„ë§ì¹œ", "ì ìëŠ”", "í™”ë‚œ", "í–‰ë³µí•œ", "ê°€ë‚œí•œ",
  "ë¶€ì", "ì²œì¬", "ë°”ë³´", "ë¯¸ì¹œ", "ì•¼ìƒì˜", "ì§‘ë‚˜ê°„", "ëŒì•„ì˜¨", "ë§ˆì§€ë§‰",
  "íƒ‘ì‹ ë³‘ì", "ì •ê¸€ì°¨ì´", "ë¯¸ë“œì˜¤í”ˆ", "ì„œí¿ìœ ì €", "ì›ë”œì™•", "ì¥ì¸", "ê³ ìˆ˜", "ì´ˆë³´",
  "í•‘í¬", "ë¸”ë™", "í™©ê¸ˆ", "ë¯¼íŠ¸ì´ˆì½”", "í•˜ì™€ì´ì•ˆ", "ë¶ˆíƒ€ëŠ”", "ì–¼ì–´ë¶™ì€", "ì‹ ì†í•œ",
  "ì¹˜ëª…ì ì¸", "ì—„ë§ˆëª°ë˜", "í•™êµì§¸ê³ ", "ë°¤ìƒ˜í•˜ëŠ”", "ë¼ë©´ë¨¹ëŠ”", "ì¹˜í‚¨ë¨¹ëŠ”", "ë‹¤ì´ì–´íŠ¸",
  "ë¬´ì ì˜", "íŒ¨ë°°ì˜", "ìŠ¹ë¦¬ì˜", "ê¸°ì ì˜", "ì¹¨ë¬µì˜", "ì˜ê´‘ì˜", "ì‹¬ì—°ì˜", "ê³µí—ˆì˜",
  "ì „ê´‘ì„í™”", "ë¹›ì˜", "ì–´ë‘ ì˜", "í­í’ì˜", "ëŒ€ì§€ì˜", "ê°•ì² ì˜", "ì‹ ì„±í•œ", "íƒ€ë½í•œ"
];

// 2. [í•œê¸€] ëª…ì‚¬ (ë³¸ì²´)
const KR_SUFFIXES = [
  "ë‹¤ëŒì¥", "í˜¸ë‘ì´", "ì‚¬ì", "ê³ ì–‘ì´", "ê°•ì•„ì§€", "í­ê·„", "ìŠ¬ë¼ì„", "ë“œë˜ê³¤",
  "ë–¡ë³¶ì´", "ì¹˜í‚¨", "í”¼ì", "í–„ë²„ê±°", "êµ­ë°¥", "ê¹€ì¹˜ì°Œê°œ", "ë¼ë©´", "ì½œë¼",
  "ê¸°ì‚¬", "ë§ˆë²•ì‚¬", "ì•”ì‚´ì", "ê¶ìˆ˜", "ì „ì‚¬", "ì‚¬ì œ", "ë„ì ", "ì„±ê¸°ì‚¬",
  "ì•¼ìŠ¤ì˜¤", "í‹°ëª¨", "ë¦¬ì‹ ", "ë² ì¸", "ì œë“œ", "ì´ì¦ˆë¦¬ì–¼", "ëŸ­ìŠ¤", "ì•„ë¦¬",
  "ì£¼ë¨¹", "ë°œì°¨ê¸°", "ê²€", "ë°©íŒ¨", "ì§€íŒ¡ì´", "í™œ", "ë„ë¼", "ë§ì¹˜",
  "ì»´í“¨í„°", "í‚¤ë³´ë“œ", "ë§ˆìš°ìŠ¤", "ëª¨ë‹ˆí„°", "ì™€ì´íŒŒì´", "ë°ì´í„°", "ë°°í„°ë¦¬",
  "í•™ìƒ", "ì•„ì €ì”¨", "í˜•", "ëˆ„ë‚˜", "ë™ìƒ", "ì‚¬ì¥ë‹˜", "ì•Œë°”ìƒ", "ë°±ìˆ˜",
  "ìœ ì €", "í”Œë ˆì´ì–´", "ì†Œí™˜ì‚¬", "ì±”í”¼ì–¸", "ë¯¸ë‹ˆì–¸", "ì •ê¸€ëŸ¬", "ë¼ì´ë„ˆ"
];

// 3. [ì˜ì–´] ë‹¨ì–´
const EN_WORDS = [
  "Shadow", "Light", "Dark", "Fire", "Ice", "Wind", "Storm", "Thunder",
  "Killer", "Slayer", "Hunter", "Sniper", "Assassin", "Knight", "Warrior",
  "God", "King", "Queen", "Prince", "Princess", "Lord", "Master", "Boss",
  "Faker", "Chovy", "ShowMaker", "Ruler", "Deft", "Viper", "Zeus", "Keria",
  "Alpha", "Beta", "Omega", "Zero", "One", "Infinite", "Eternal", "Final",
  "Crazy", "Mad", "Super", "Ultra", "Hyper", "Mega", "Giga", "Tera",
  "Ghost", "Phantom", "Spirit", "Soul", "Dragon", "Tiger", "Lion", "Wolf"
];

const CLAN_TAGS = ["T1", "GEN", "DK", "KT", "HLE", "DRX", "NS", "BRO", "LSB", "KDF", "SKT", "DWG", "GRF"];
const pick = (arr: string[]) => arr[Math.floor(Math.random() * arr.length)];
const chance = (percent: number) => Math.random() < (percent / 100);

export function generateUserName(seedId: number): string {
  const rand = Math.random();

  // [Fix] ëª¨ë“  íŒ¨í„´ì— ëœë¤ ìˆ«ì(2~4ìë¦¬)ë¥¼ ê°•ì œë¡œ ë¶™ì…ë‹ˆë‹¤.
  // 1000 ~ 9999 ì‚¬ì´ì˜ ë‚œìˆ˜ ìƒì„±
  const num = Math.floor(100 + Math.random() * 9900); 

  // íŒ¨í„´ 1: [í•œê¸€] í˜•ìš©ì‚¬ + ëª…ì‚¬ (50%)
  if (rand < 0.5) {
    const prefix = pick(KR_PREFIXES);
    const suffix = pick(KR_SUFFIXES);
    // ì˜ˆ: ê°€ë‚œí•œê²€392, ì¹¨ë¬µì˜ë–¡ë³¶ì´1024
    return `${prefix}${suffix}${num}`;
  }

  // íŒ¨í„´ 2: [ì˜ì–´] (30%)
  else if (rand < 0.8) {
    // í´ëœ íƒœê·¸í˜•: SKT Faker 01
    if (chance(30)) {
      return `${pick(CLAN_TAGS)} ${pick(EN_WORDS)} ${Math.floor(Math.random() * 99)}`;
    }

    // ì˜ë‹¨ì–´ ì¡°í•©í˜•: ShadowKiller9999
    if (chance(50)) {
      return `${pick(EN_WORDS)}${pick(EN_WORDS)}${num}`;
    } else {
      // ë‹¨ì¼ ë‹¨ì–´í˜•: Zeus1024
      return `${pick(EN_WORDS)}${num}`;
    }
  }

  // íŒ¨í„´ 3: [ì»¨ì…‰] ë¦¬ì–¼í•œ ë¬¸ì¥í˜• (10%)
  else if (rand < 0.9) {
    const sentences = [
      "ë˜ì§€ë©´ë°”ë¡œë‚˜ê°", "í•œíƒ€ë§Œí•¨", "ì±„íŒ…ì°¨ë‹¨í•¨", "ì¦ê²œìœ ì €", "ë¹¡ê²œëŸ¬",
      "ì—„ë§ˆê°€ë°¥ë¨¹ìœ¼ë˜", "ë‚´ê¿ˆì€ì±Œë¦°ì €", "ë¸Œë¡ ì¦ˆíƒˆì¶œê¸°", "ë²„ìŠ¤ì ìš”", "ì„œí¿ì°¨ì´",
      "ë¯¸ë“œë‹¬ë ¤", "ì •ê¸€íƒ“ì•ˆí•¨", "ì˜¤ë¹ ë‹¬ë ¤", "ëˆ„ë‚˜ë‚˜ì£½ì–´", "í˜•ë¯¿ì–´",
      "í‰ì 1ì ëŒ€", "ìŠ¹ë¥ 9í• ", "ë¶€ìºì…ë‹ˆë‹¤", "í˜„ì§€ì¸ì…ë‹ˆë‹¤"
    ];
    // ì˜ˆ: ì—„ë§ˆê°€ë°¥ë¨¹ìœ¼ë˜512
    return `${pick(sentences)}${num}`;
  }

  // íŒ¨í„´ 4: ë§‰ì¹œ ì•„ì´ë”” (10%)
  else {
    const keys = ["qwer", "asdf", "zxcv", "user", "player", "guest"];
    return `${pick(keys)}${Math.floor(Math.random() * 99999)}`;
  }
}

--- FILE: src/utils/GlobalErrorBoundary.tsx ---
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { CrashScreen } from '../components/common/CrashScreen';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class GlobalErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("React Error Boundary Caught:", error, errorInfo);
  }

  resetErrorBoundary = () => {
    this.setState({ hasError: false, error: null });
    window.location.reload();
  };

  render() {
    if (this.state.hasError) {
      // CrashScreen ì»´í¬ë„ŒíŠ¸ê°€ ë Œë”ë§ë˜ë‹¤ê°€ ì£½ì„ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ ì•ˆì „ì¥ì¹˜
      try {
        return <CrashScreen error={this.state.error} resetErrorBoundary={this.resetErrorBoundary} />;
      } catch (e) {
        return <div style={{color:'white', padding:20}}>Double Crash: Error Boundary failed. Check Console.</div>;
      }
    }
    return this.props.children;
  }
}


--- FILE: src/utils/IDBStorage.ts ---
// ==========================================
// FILE PATH: /src/utils/IDBStorage.ts
// ==========================================

const DB_NAME = 'GodsWar_DB_V1';
const STORE_NAME = 'SaveData';

export const IDBStorage = {
  // DB ì—´ê¸° (ì—†ìœ¼ë©´ ìƒì„±)
  openDB: (): Promise<IDBDatabase> => {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, 1);

      request.onupgradeneeded = (event: any) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          db.createObjectStore(STORE_NAME);
        }
      };

      request.onsuccess = (event: any) => resolve(event.target.result);
      request.onerror = (event: any) => reject(event.target.error);
    });
  },

  // ë°ì´í„° ì €ì¥ (Key-Value)
  setItem: async (key: string, value: any): Promise<void> => {
    const db = await IDBStorage.openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      const req = store.put(value, key);

      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  },

  // ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
  getItem: async (key: string): Promise<any> => {
    const db = await IDBStorage.openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readonly');
      const store = tx.objectStore(STORE_NAME);
      const req = store.get(key);

      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  },

  // ë°ì´í„° ì‚­ì œ
  removeItem: async (key: string): Promise<void> => {
    const db = await IDBStorage.openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      const req = store.delete(key);

      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }
};


--- FILE: src/utils/ImageLoader.ts ---
// ==========================================
// FILE PATH: src/utils/ImageLoader.ts
// ==========================================
import { INITIAL_CUSTOM_IMAGES } from '../data/initialImages';

export const preloadGameImages = async (
  onProgress: (percent: number) => void
): Promise<void> => {
  // 1. ì‚¬ìš©ì ëŒ€ê¸° ì‹œê°„ 0ì´ˆ (ì¦‰ì‹œ ì‹œì‘)
  onProgress(100);

  // 2. ë°±ê·¸ë¼ìš´ë“œ ìºì‹± (ì†ë„ ì¡°ì ˆ)
  const imageUrls = Array.from(new Set(Object.values(INITIAL_CUSTOM_IMAGES))).filter(url => !!url);
  if (imageUrls.length === 0) return;

  let index = 0;
  
  const loadNext = () => {
    if (index >= imageUrls.length) return;

    // [í•µì‹¬] ë™ì‹œì— ì—¬ëŸ¬ ê°œë¥¼ ìš”ì²­í•˜ì§€ ì•Šê³ , í•˜ë‚˜ì”© ìˆœì°¨ì ìœ¼ë¡œ ìš”ì²­í•©ë‹ˆë‹¤.
    const img = new Image();
    img.src = imageUrls[index];
    
    index++;
    
    // [ìˆ˜ì •] 50ms -> 200msë¡œ í…€ì„ ëŠ˜ë ¤ì„œ
    // í™”ë©´ì— ìˆëŠ” 'ì§„ì§œ í•„ìš”í•œ ì´ë¯¸ì§€'ê°€ ë‹¤ìš´ë¡œë“œë  ëŒ€ì—­í­ì„ í™•ë³´í•´ì¤ë‹ˆë‹¤.
    setTimeout(loadNext, 200);
  };

  // ê²Œì„ ì‹œì‘ í›„ 2ì´ˆ ë’¤ë¶€í„° ì²œì²œíˆ ë°›ê¸° ì‹œì‘
  setTimeout(loadNext, 2000);
};


--- FILE: src/utils/ResourceDownloader.ts ---
// ==========================================
// FILE PATH: /src/utils/ResourceDownloader.ts
// ==========================================
import { INITIAL_CUSTOM_IMAGES } from '../data/initialImages';

const CACHE_NAME = 'gods-war-assets-v1';

export const downloadAllResources = async (
  onProgress: (current: number, total: number) => void
): Promise<boolean> => {
  // 1. ë‹¤ìš´ë¡œë“œí•  ì´ë¯¸ì§€ ëª©ë¡ í™•ë³´
  const urls = Array.from(new Set(Object.values(INITIAL_CUSTOM_IMAGES))).filter(url => !!url);
  const total = urls.length;
  let count = 0;

  try {
    // 2. ë¸Œë¼ìš°ì € ìºì‹œ ì €ì¥ì†Œ ì—´ê¸°
    const cache = await caches.open(CACHE_NAME);

    // 3. ë³‘ë ¬ ì²˜ë¦¬ ëŒ€ì‹  ì•ˆì •ì„±ì„ ìœ„í•´ 5ê°œì”© ëŠì–´ì„œ ë‹¤ìš´ë¡œë“œ (ë°°ì¹˜ ì²˜ë¦¬)
    const BATCH_SIZE = 5;
    
    for (let i = 0; i < total; i += BATCH_SIZE) {
      const batch = urls.slice(i, i + BATCH_SIZE);
      
      await Promise.all(batch.map(async (url) => {
        try {
          // ì´ë¯¸ ìºì‹œì— ìˆëŠ”ì§€ í™•ì¸
          const match = await cache.match(url);
          if (!match) {
            // ì—†ìœ¼ë©´ ë„¤íŠ¸ì›Œí¬ ìš”ì²­í•´ì„œ ì €ì¥
            await cache.add(url);
          }
        } catch (e) {
          console.warn(`ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨ (${url}):`, e);
        } finally {
          count++;
          onProgress(count, total);
        }
      }));
    }
    
    return true;
  } catch (e) {
    console.error("ë¦¬ì†ŒìŠ¤ ë‹¤ìš´ë¡œë“œ ì‹œìŠ¤í…œ ì˜¤ë¥˜:", e);
    alert("ì´ ë¸Œë¼ìš°ì €ëŠ” ë¦¬ì†ŒìŠ¤ ì €ì¥ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
    return false;
  }
};

export const checkCachedStatus = async (): Promise<number> => {
  try {
    const cache = await caches.open(CACHE_NAME);
    const keys = await cache.keys();
    return keys.length;
  } catch {
    return 0;
  }
};


--- FILE: src/App.tsx ---
import React, { useState, useEffect, Component, ErrorInfo } from 'react';
import { useGameEngine } from './hooks/useGameEngine';
import { preloadGameImages } from './utils/ImageLoader';
import { GlobalErrorBoundary } from './utils/GlobalErrorBoundary';

import { Header } from './components/layout/Header';
import { GameStats } from './components/dashboard/GameStats';
import { SystemMenu } from './components/common/SystemMenu'; 
import { HeroStatsView } from './components/hero/HeroStatsView';
import { PatchModal } from './components/hero/PatchModal';
import { UserDashboard } from './components/user/UserDashboard';
import { UserDetailModal } from './components/user/UserDetailModal';
import { BattleDashboard } from './components/battle/BattleDashboard';
import { BattlefieldTab } from './components/battle/BattlefieldTab';
import { CommunityBoard } from './components/community/CommunityBoard';
import { PostDetailModal } from './components/community/PostDetailModal';
import { LiveGameListModal } from './components/battle/LiveGameListModal';
import { SpectateModal } from './components/battle/SpectateModal';
import { ShopTab } from './components/shop/ShopTab';

import { Swords, User, MessageSquare, Map, Crown, ShoppingBag, Loader2 } from 'lucide-react';
import { Hero, UserProfile, LiveMatch } from './types';

const TABS = [
  { id: 'hero-stats', label: 'ì˜ì›… í†µê³„', icon: Swords },
  { id: 'shop', label: 'ì•„ì´í…œ ìƒì ', icon: ShoppingBag }, 
  { id: 'user', label: 'ìœ ì € í˜„í™©', icon: User },
  { id: 'gods', label: 'ì‹ (Gods)', icon: Crown },
  { id: 'battlefield', label: 'ì „ì¥', icon: Map },
  { id: 'community', label: 'ì»¤ë®¤ë‹ˆí‹°', icon: MessageSquare },
];

function GameContent() {
  const { isMobile, store, isGameReady } = useGameEngine();
  const { gameState, selectedPost, closePost } = store;

  const [isImageLoading, setIsImageLoading] = useState(true);
  const [loadProgress, setLoadProgress] = useState(0);

  useEffect(() => {
    preloadGameImages((percent) => {
      setLoadProgress(percent);
      if (percent >= 100) {
        setTimeout(() => setIsImageLoading(false), 100);
      }
    });
  }, []);

  const [selectedHero, setSelectedHero] = useState<Hero | null>(null);
  const [selectedUser, setSelectedUser] = useState<UserProfile | null>(null);
  const [showSystemMenu, setShowSystemMenu] = useState(false);
  const [showGameList, setShowGameList] = useState(false);
  const [spectatingMatch, setSpectatingMatch] = useState<LiveMatch | null>(null);
  const [activeTab, setActiveTab] = useState('hero-stats');

  // [ìˆ˜ì •] ë¬¸ë²• ì˜¤ë¥˜ê°€ ìˆë˜ ë¶€ë¶„ (width ìŠ¤íƒ€ì¼)
  if (isImageLoading || !isGameReady) {
    return (
      <div style={{ height: '100vh', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', background: '#0f1115', color: '#fff' }}>
        <div style={{ position: 'relative' }}>
          <Loader2 size={60} color="#58a6ff" style={{ animation: 'spin 1s linear infinite' }} />
          <style>{`@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }`}</style>
        </div>
        <h2 style={{ marginTop: '20px', fontSize: '18px', fontWeight: 'bold' }}>
          {!isGameReady ? "ì„¸ì´ë¸Œ ë°ì´í„° ë³µêµ¬ ì¤‘..." : "ë¦¬ì†ŒìŠ¤ ë¡œë”© ì¤‘..."}
        </h2>
        {isImageLoading && (
          <div style={{ width: '300px', height: '6px', background: '#333', borderRadius: '3px', marginTop: '15px', overflow: 'hidden' }}>
            {/* ì—¬ê¸°ì˜ ë°±í‹±ê³¼ $ ê¸°í˜¸ ì•ì˜ ì—­ìŠ¬ë˜ì‹œ ì œê±°ë¨ */}
            <div style={{ width: `${loadProgress}%`, height: '100%', background: '#58a6ff', transition: 'width 0.1s' }}></div>
          </div>
        )}
      </div>
    );
  }

  if (!gameState) return <div style={{ color: '#fff', padding: '20px' }}>ë°ì´í„° ì´ˆê¸°í™” ì‹¤íŒ¨. ìƒˆë¡œê³ ì¹¨ í•´ì£¼ì„¸ìš”.</div>;

  return (
    <div style={{ maxWidth: '1400px', margin: '0 auto', padding: isMobile ? '10px' : '20px', paddingBottom: '100px' }}>
      <Header isMobile={isMobile} onOpenSystemMenu={() => setShowSystemMenu(true)} />
      <GameStats isMobile={isMobile} onOpenGameList={() => setShowGameList(true)} />

      {!isMobile && (
        <div style={{ display: 'flex', gap: '10px', marginBottom: '20px', flexWrap:'wrap' }}>
          {TABS.map(tab => (
            <button key={tab.id} onClick={() => setActiveTab(tab.id)} style={{ padding: '12px 24px', borderRadius: '8px', border: 'none', cursor: 'pointer', background: activeTab === tab.id ? '#58a6ff' : '#161b22', color: activeTab === tab.id ? '#000' : '#8b949e', fontWeight: 'bold', display: 'flex', gap: '8px', alignItems: 'center' }}>
              <tab.icon size={16} /> {tab.label}
            </button>
          ))}
        </div>
      )}

      <div style={{ minHeight: '600px' }}>
        <div style={{ display: activeTab === 'hero-stats' ? 'block' : 'none' }}>
          <HeroStatsView />
        </div>
        <div style={{ display: activeTab === 'shop' ? 'block' : 'none' }}>
          <ShopTab />
        </div>
        <div style={{ display: activeTab === 'user' ? 'block' : 'none' }}>
          <UserDashboard onUserClick={setSelectedUser} />
        </div>
        <div style={{ display: activeTab === 'gods' ? 'block' : 'none' }}>
          <BattleDashboard />
        </div>
        <div style={{ display: activeTab === 'battlefield' ? 'block' : 'none' }}>
          <BattlefieldTab />
        </div>
        <div style={{ display: activeTab === 'community' ? 'block' : 'none' }}>
          <CommunityBoard />
        </div>
      </div>

      {isMobile && (
        <nav style={{ position: 'fixed', bottom: 0, left: 0, width: '100%', background: '#161b22', borderTop: '1px solid #333', display: 'flex', justifyContent: 'space-around', padding: '10px 0', zIndex: 9000, paddingBottom: '20px', overflowX:'auto' }}>
          {TABS.map(tab => (
            <button key={tab.id} onClick={() => setActiveTab(tab.id)} style={{ background: 'none', border: 'none', color: activeTab === tab.id ? '#58a6ff' : '#8b949e', display: 'flex', flexDirection: 'column', alignItems: 'center', fontSize: '11px', gap: '4px', minWidth:'60px' }}>
              <tab.icon size={20} />
              {tab.label.split(' ')[0]}
            </button>
          ))}
        </nav>
      )}

      {showSystemMenu && <SystemMenu onClose={() => setShowSystemMenu(false)} />}
      {selectedHero && <PatchModal hero={selectedHero} onClose={() => setSelectedHero(null)} />}
      {selectedUser && <UserDetailModal user={selectedUser} onClose={() => setSelectedUser(null)} />}
      {showGameList && <LiveGameListModal onClose={() => setShowGameList(false)} onSpectate={(m) => { setShowGameList(false); setSpectatingMatch(m); }} />}
      {spectatingMatch && <SpectateModal match={spectatingMatch} onClose={() => { setSpectatingMatch(null); setShowGameList(true); }} />}
      {selectedPost && <PostDetailModal post={selectedPost} onClose={closePost} onUserClick={(user) => setSelectedUser(user)} />}
    </div>
  );
}

function App() {
  return (
    <GlobalErrorBoundary>
      <GameContent />
    </GlobalErrorBoundary>
  );
}

export default App;


--- FILE: src/index.tsx ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

// [ìµœí›„ì˜ ì•ˆì „ì¥ì¹˜]
// Reactê°€ ë Œë”ë§ì— ì‹¤íŒ¨í–ˆì„ ë•Œ, ë¸Œë¼ìš°ì € DOMì„ ì§ì ‘ ì¡°ì‘í•˜ì—¬ ì—ëŸ¬ í™”ë©´ì„ ë„ìš°ëŠ” í•¨ìˆ˜
function showPanicScreen(errorMsg: string, errorStack: string = '') {
  console.error("CRITICAL FAILURE:", errorMsg);

  const root = document.getElementById('root');
  if (!root) return;

  // ê¸°ì¡´ í™”ë©´ í´ë¦¬ì–´
  root.innerHTML = '';

  // ë¹„ìƒìš© ìŠ¤íƒ€ì¼
  document.body.style.backgroundColor = '#0f1115';
  document.body.style.color = '#fff';
  document.body.style.margin = '0';
  document.body.style.overflow = 'hidden';

  const container = document.createElement('div');
  container.style.cssText = 'position:fixed; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; padding:20px; z-index:99999; font-family:sans-serif; text-align:center;';

  const icon = document.createElement('div');
  icon.innerHTML = 'âš ï¸';
  icon.style.fontSize = '48px';
  icon.style.marginBottom = '20px';

  const title = document.createElement('h1');
  title.innerText = 'ê²Œì„ ì‹¤í–‰ ì‹¤íŒ¨ (Panic Mode)';
  title.style.color = '#da3633';
  title.style.margin = '0 0 10px 0';

  const desc = document.createElement('p');
  desc.innerText = 'ì¹˜ëª…ì ì¸ ì˜¤ë¥˜ë¡œ ì¸í•´ React ì•±ì„ ì‹¤í–‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
  desc.style.color = '#8b949e';

  const errorBox = document.createElement('pre');
  errorBox.innerText = errorMsg + '\n\n' + errorStack;
  errorBox.style.cssText = 'background:#161b22; border:1px solid #da3633; padding:15px; border-radius:8px; color:#ff7b72; text-align:left; width:100%; max-width:600px; overflow:auto; max-height:300px; font-size:12px; margin-bottom:20px; white-space:pre-wrap;';

  const btnContainer = document.createElement('div');
  btnContainer.style.display = 'flex';
  btnContainer.style.gap = '10px';

  // ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼
  const reloadBtn = document.createElement('button');
  reloadBtn.innerText = 'ğŸ”„ ë‹¤ì‹œ ì‹œë„';
  reloadBtn.style.cssText = 'padding:10px 20px; background:#238636; border:none; color:white; border-radius:6px; cursor:pointer; font-weight:bold;';
  reloadBtn.onclick = () => window.location.reload();

  // ì´ˆê¸°í™” ë²„íŠ¼ (í•µì‹¬)
  const resetBtn = document.createElement('button');
  resetBtn.innerText = 'ğŸ—‘ï¸ ë°ì´í„° ì´ˆê¸°í™” (ë³µêµ¬)';
  resetBtn.style.cssText = 'padding:10px 20px; background:#3f1515; border:1px solid #da3633; color:#ff7b72; border-radius:6px; cursor:pointer; font-weight:bold;';
  resetBtn.onclick = () => {
    if (confirm('ì •ë§ ëª¨ë“  ë°ì´í„°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')) {
        localStorage.clear();
        // IndexedDB ì‚­ì œ
        const req = indexedDB.deleteDatabase('GodsWar_DB_V1');
        req.onsuccess = () => window.location.reload();
        req.onerror = () => window.location.reload();
        req.onblocked = () => window.location.reload();
        
        // í˜¹ì‹œ ëª¨ë¥´ë‹ˆ Legacy í‚¤ë“¤ë„ ì‚­ì œ
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('GW_')) {
                localStorage.removeItem(key);
            }
        }
        alert('ì´ˆê¸°í™” ì™„ë£Œ. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•©ë‹ˆë‹¤.');
        window.location.reload();
    }
  };

  btnContainer.appendChild(reloadBtn);
  btnContainer.appendChild(resetBtn);

  container.appendChild(icon);
  container.appendChild(title);
  container.appendChild(desc);
  container.appendChild(errorBox);
  container.appendChild(btnContainer);

  root.appendChild(container);
}

// 1. ì „ì—­ ì—ëŸ¬ í•¸ë“¤ëŸ¬ (ìŠ¤í¬ë¦½íŠ¸ ì—ëŸ¬)
window.onerror = function(message, source, lineno, colno, error) {
  showPanicScreen(String(message), error?.stack || `${source}:${lineno}:${colno}`);
  return true; // ë¸Œë¼ìš°ì € ê¸°ë³¸ ì—ëŸ¬ ì¶œë ¥ ë°©ì§€
};

// 2. Promise ì—ëŸ¬ í•¸ë“¤ëŸ¬ (Async ì—ëŸ¬)
window.onunhandledrejection = function(event) {
  showPanicScreen("Unhandled Promise Rejection", String(event.reason));
};

// 3. React ë§ˆìš´íŠ¸ ì‹œë„
try {
  const rootElement = document.getElementById('root');
  if (rootElement) {
    const root = ReactDOM.createRoot(rootElement);
    root.render(
      <React.StrictMode>
        <App />
      </React.StrictMode>
    );
  } else {
    throw new Error("Root element not found");
  }
} catch (e: any) {
  showPanicScreen(e.message, e.stack);
}
