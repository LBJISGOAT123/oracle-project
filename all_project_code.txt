==========================================
FILE PATH: src/App.tsx
==========================================
import React, { useState, useEffect } from 'react';
import { useGameEngine } from './hooks/useGameEngine';
import { preloadGameImages } from './utils/ImageLoader';
import { GlobalErrorBoundary } from './utils/GlobalErrorBoundary';

import { Header } from './components/layout/Header';
import { GameStats } from './components/dashboard/GameStats';
import { SystemMenu } from './components/common/SystemMenu'; 
import { HeroStatsView } from './components/hero/HeroStatsView';
import { PatchModal } from './components/hero/PatchModal';
import { UserDashboard } from './components/user/UserDashboard';
import { UserDetailModal } from './components/user/UserDetailModal';
import { BattleDashboard } from './components/battle/BattleDashboard';
import { BattlefieldTab } from './components/battle/BattlefieldTab';
import { CommunityBoard } from './components/community/CommunityBoard';
import { PostDetailModal } from './components/community/PostDetailModal';
import { LiveGameListModal } from './components/battle/LiveGameListModal';
import { SpectateModal } from './components/battle/SpectateModal';
import { ShopTab } from './components/shop/ShopTab';

import { Swords, User, MessageSquare, Map, Crown, ShoppingBag, Loader2 } from 'lucide-react';
import { Hero, UserProfile, LiveMatch } from './types';

const TABS = [
  { id: 'hero-stats', label: 'ì˜ì›… í†µê³„', icon: Swords },
  { id: 'shop', label: 'ì•„ì´í…œ ìƒì ', icon: ShoppingBag }, 
  { id: 'user', label: 'ìœ ì € í˜„í™©', icon: User },
  { id: 'gods', label: 'ì‹ (Gods)', icon: Crown },
  { id: 'battlefield', label: 'ì „ì¥', icon: Map },
  { id: 'community', label: 'ì»¤ë®¤ë‹ˆí‹°', icon: MessageSquare },
];

function GameContent() {
  const { isMobile, store, isGameReady } = useGameEngine();
  const { gameState, selectedPost, closePost } = store;

  const [isImageLoading, setIsImageLoading] = useState(true);
  const [loadProgress, setLoadProgress] = useState(0);

  useEffect(() => {
    preloadGameImages((percent) => {
      setLoadProgress(percent);
      if (percent >= 100) {
        setTimeout(() => setIsImageLoading(false), 100);
      }
    });
  }, []);

  const [selectedHero, setSelectedHero] = useState<Hero | null>(null);
  const [selectedUser, setSelectedUser] = useState<UserProfile | null>(null);
  const [showSystemMenu, setShowSystemMenu] = useState(false);
  const [showGameList, setShowGameList] = useState(false);
  const [spectatingMatch, setSpectatingMatch] = useState<LiveMatch | null>(null);
  const [activeTab, setActiveTab] = useState('hero-stats');

  if (isImageLoading || !isGameReady) {
    return (
      <div style={{ height: '100vh', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', background: '#0f1115', color: '#fff' }}>
        <div style={{ position: 'relative' }}>
          <Loader2 size={60} color="#58a6ff" style={{ animation: 'spin 1s linear infinite' }} />
          <style>{`@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }`}</style>
        </div>
        <h2 style={{ marginTop: '20px', fontSize: '18px', fontWeight: 'bold' }}>
          {!isGameReady ? "ì„¸ì´ë¸Œ ë°ì´í„° ë³µêµ¬ ì¤‘..." : "ë¦¬ì†ŒìŠ¤ ë¡œë”© ì¤‘..."}
        </h2>
        {isImageLoading && (
          <div style={{ width: '300px', height: '6px', background: '#333', borderRadius: '3px', marginTop: '15px', overflow: 'hidden' }}>
            <div style={{ width: `${loadProgress}%`, height: '100%', background: '#58a6ff', transition: 'width 0.1s' }}></div>
          </div>
        )}
      </div>
    );
  }

  if (!gameState) return <div style={{ color: '#fff', padding: '20px' }}>ë°ì´í„° ì´ˆê¸°í™” ì‹¤íŒ¨. ìƒˆë¡œê³ ì¹¨ í•´ì£¼ì„¸ìš”.</div>;

  return (
    <div className="notranslate" translate="no" style={{ maxWidth: '1400px', margin: '0 auto', padding: isMobile ? '10px' : '20px', paddingBottom: '100px' }}>
      <Header isMobile={isMobile} onOpenSystemMenu={() => setShowSystemMenu(true)} />
      <GameStats isMobile={isMobile} onOpenGameList={() => setShowGameList(true)} />

      {!isMobile && (
        <div style={{ display: 'flex', gap: '10px', marginBottom: '20px', flexWrap:'wrap' }}>
          {TABS.map(tab => (
            <button key={tab.id} onClick={() => setActiveTab(tab.id)} style={{ padding: '12px 24px', borderRadius: '8px', border: 'none', cursor: 'pointer', background: activeTab === tab.id ? '#58a6ff' : '#161b22', color: activeTab === tab.id ? '#000' : '#8b949e', fontWeight: 'bold', display: 'flex', gap: '8px', alignItems: 'center' }}>
              <tab.icon size={16} /> {tab.label}
            </button>
          ))}
        </div>
      )}

      {/* ì¡°ê±´ë¶€ ë Œë”ë§ (ìµœì í™”) */}
      <div style={{ minHeight: '600px' }}>
        {activeTab === 'hero-stats' && <HeroStatsView />}
        {activeTab === 'shop' && <ShopTab />}
        {activeTab === 'user' && <UserDashboard onUserClick={setSelectedUser} />}
        {activeTab === 'gods' && <BattleDashboard />}
        {activeTab === 'battlefield' && <BattlefieldTab />}
        {activeTab === 'community' && <CommunityBoard />}
      </div>

      {isMobile && (
        <nav style={{ position: 'fixed', bottom: 0, left: 0, width: '100%', background: '#161b22', borderTop: '1px solid #333', display: 'flex', justifyContent: 'space-around', padding: '10px 0', zIndex: 9000, paddingBottom: '20px', overflowX:'auto' }}>
          {TABS.map(tab => (
            <button key={tab.id} onClick={() => setActiveTab(tab.id)} style={{ background: 'none', border: 'none', color: activeTab === tab.id ? '#58a6ff' : '#8b949e', display: 'flex', flexDirection: 'column', alignItems: 'center', fontSize: '11px', gap: '4px', minWidth:'60px' }}>
              <tab.icon size={20} />
              {tab.label.split(' ')[0]}
            </button>
          ))}
        </nav>
      )}

      {showSystemMenu && <SystemMenu onClose={() => setShowSystemMenu(false)} />}
      {selectedHero && <PatchModal hero={selectedHero} onClose={() => setSelectedHero(null)} />}
      {selectedUser && <UserDetailModal user={selectedUser} onClose={() => setSelectedUser(null)} />}
      {showGameList && <LiveGameListModal onClose={() => setShowGameList(false)} onSpectate={(m) => { setShowGameList(false); setSpectatingMatch(m); }} />}
      {spectatingMatch && <SpectateModal match={spectatingMatch} onClose={() => { setSpectatingMatch(null); setShowGameList(true); }} />}
      {selectedPost && <PostDetailModal post={selectedPost} onClose={closePost} onUserClick={(user) => setSelectedUser(user)} />}
    </div>
  );
}

function App() {
  return (
    <GlobalErrorBoundary>
      <GameContent />
    </GlobalErrorBoundary>
  );
}

export default App;



==========================================
FILE PATH: src/components/battle/BattleDashboard.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/BattleDashboard.tsx
// ==========================================

import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { Sword, Shield, Settings } from 'lucide-react';

// [ì¤‘ìš”] ìƒˆë¡œ ìƒì„±í•œ ëª¨ë“ˆ íŒŒì¼ë“¤ import
import { SiegeSettingsPanel } from './dashboard/SiegeSettingsPanel';
import { MinionCard } from './dashboard/MinionCard'; // (GodPanel ë‚´ë¶€ì—ì„œ ì‚¬ìš©ë¨, ì—¬ê¸°ì„œ ì§ì ‘ ì“°ì§„ ì•ŠìŒ)
import { GodPanel } from './dashboard/GodPanel';
import { GlobalBattleStats } from './dashboard/GlobalBattleStats';

export const BattleDashboard: React.FC = () => {
  const { gameState, updateBattleSettings } = useGameStore();
  const { battleSettings, godStats } = gameState;

  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  if (!battleSettings) return <div className="panel">ì‹œìŠ¤í…œ ë¡œë”© ì¤‘...</div>;

  const handleGodChange = (god: 'izman' | 'dante', field: string, value: any) => {
    updateBattleSettings({ [god]: { ...battleSettings[god], [field]: value } });
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '25px', paddingBottom: '80px' }}>
      
      {/* í—¤ë” ì˜ì—­ */}
      <div style={{ display: 'flex', alignItems: 'center', gap: '12px', padding: isMobile ? '0 5px' : '0' }}>
        <div style={{ background: '#58a6ff22', padding: '10px', borderRadius: '12px', border: '1px solid #58a6ff44' }}>
          <Settings size={24} color="#58a6ff" />
        </div>
        <div>
          <h2 style={{ margin: 0, fontSize: isMobile ? '18px' : '22px', fontWeight: '800', letterSpacing: '-0.5px', color:'#fff' }}>ì „ì¥ ì˜¤ë²„ë¼ì´ë“œ</h2>
          <p style={{ margin: 0, fontSize: isMobile ? '11px' : '13px', color: '#8b949e' }}>
            ì§„ì˜ë³„ ë°¸ëŸ°ìŠ¤ ë° í•˜ìˆ˜ì¸ ìŠ¤í™ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ì œì–´í•©ë‹ˆë‹¤.
          </p>
        </div>
      </div>

      {/* ì „ì²´ í†µê³„ */}
      <GlobalBattleStats stats={godStats} isMobile={isMobile} />

      {/* [í™•ì¸] ê³µì„± ì„¤ì • íŒ¨ë„ - í†µê³„ ë°”ë¡œ ì•„ë˜ì— ë°°ì¹˜ */}
      <SiegeSettingsPanel />

      {/* ì–‘ ì§„ì˜ íŒ¨ë„ */}
      <div style={{ display: 'grid', gridTemplateColumns: isMobile ? '1fr' : '1fr 1fr', gap: '25px' }}>
        <GodPanel 
          side="RED" settings={battleSettings.izman} stats={godStats}
          color="#ff4d4d" glowColor="rgba(255, 77, 77, 0.1)"
          onChange={(field: string, val: any) => handleGodChange('izman', field, val)}
          icon={<Sword size={20} />} isMobile={isMobile}
        />
        <GodPanel 
          side="BLUE" settings={battleSettings.dante} stats={godStats}
          color="#4d94ff" glowColor="rgba(77, 148, 255, 0.1)"
          onChange={(field: string, val: any) => handleGodChange('dante', field, val)}
          icon={<Shield size={20} />} isMobile={isMobile}
        />
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/BattlefieldPatchModal.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/BattlefieldPatchModal.tsx
// ==========================================

import React, { useState } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { X, Save, Sliders, Zap, Shield, Sword, Heart, Coins, Layers, Star } from 'lucide-react';
// [ëª¨ë“ˆí™”] ë¶„ë¦¬ëœ ì…ë ¥ ì»´í¬ë„ŒíŠ¸ ì„í¬íŠ¸
import { RangeInput, TimeInput } from './ui/PatchInputs';

interface Props {
  targetKey: string;
  title: string;
  color: string;
  onClose: () => void;
}

export const BattlefieldPatchModal: React.FC<Props> = ({ targetKey, title, color, onClose }) => {
  const { gameState, updateFieldSettings } = useGameStore();

  // ì¤‘ì²©ëœ í‚¤(towers.t1) ì²˜ë¦¬ ë¡œì§
  const getInitialSettings = () => {
    if (targetKey.startsWith('towers.')) {
        const subKey = targetKey.split('.')[1];
        return (gameState.fieldSettings.towers as any)[subKey];
    }
    return (gameState.fieldSettings as any)[targetKey];
  };

  const [localSettings, setLocalSettings] = useState({ ...getInitialSettings() });

  const handleChange = (field: string, value: any) => {
    setLocalSettings((prev: any) => ({ ...prev, [field]: value }));
  };

  const handleSave = () => {
    if (targetKey.startsWith('towers.')) {
        const subKey = targetKey.split('.')[1];
        updateFieldSettings({
            towers: {
                ...gameState.fieldSettings.towers,
                [subKey]: localSettings
            }
        });
    } else {
        updateFieldSettings({ [targetKey]: localSettings });
    }
    alert(`[${title}] íŒ¨ì¹˜ê°€ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.`);
    onClose();
  };

  const renderInputs = () => {
    // 1. í¬íƒ‘ ì„¤ì • (í‹°ì–´ë³„ ê³µí†µ)
    if (targetKey.startsWith('towers.')) {
        return (
            <>
                <RangeInput label="ìµœëŒ€ ì²´ë ¥" icon={<Heart size={14}/>} value={localSettings.hp} onChange={(v) => handleChange('hp', v)} min={1000} max={50000} step={100} unit=" HP" color={color} />
                <RangeInput label="ë°©ì–´ë ¥" icon={<Shield size={14}/>} value={localSettings.armor} onChange={(v) => handleChange('armor', v)} min={0} max={500} step={5} unit=" DEF" color={color} />
                <RangeInput label="ê³µê²©ë ¥" icon={<Sword size={14}/>} value={localSettings.atk} onChange={(v) => handleChange('atk', v)} min={0} max={1000} step={10} unit=" DMG" color={color} />
                <RangeInput label="íŒŒê´´ ë³´ìƒ" icon={<Coins size={14}/>} value={localSettings.rewardGold} onChange={(v) => handleChange('rewardGold', v)} min={0} max={2000} step={10} unit=" G" color={color} />
            </>
        );
    }

    // 2. ì˜¤ë¸Œì íŠ¸ë³„ ì„¤ì •
    switch(targetKey) {
      case 'jungle':
        return (
          <>
            <TimeInput label="ìµœì´ˆ ìƒì„± ì‹œê°„" value={localSettings.initialSpawnTime} onChange={(v) => handleChange('initialSpawnTime', v)} color={color} />
            <TimeInput label="ë¦¬ì   ì£¼ê¸°" value={localSettings.respawnTime} onChange={(v) => handleChange('respawnTime', v)} color={color} />
            <div style={{borderTop:'1px dashed #444', margin:'15px 0'}}></div>
            <RangeInput label="ìƒíƒœê³„ ë°€ë„" icon={<Layers size={14}/>} value={localSettings.density} onChange={(v) => handleChange('density', v)} min={0} max={500} step={1} unit="%" color={color} />
            <RangeInput label="ìì› í’ìš”ë„" icon={<Zap size={14}/>} value={localSettings.yield} onChange={(v) => handleChange('yield', v)} min={0} max={500} step={1} unit="%" color={color} />
            <RangeInput label="ì²˜ì¹˜ ê³¨ë“œ" icon={<Coins size={14}/>} value={localSettings.gold} onChange={(v) => handleChange('gold', v)} min={1} max={500} step={1} unit=" G" color={color} />
            <RangeInput label="ì²˜ì¹˜ ê²½í—˜ì¹˜" icon={<Star size={14}/>} value={localSettings.xp} onChange={(v) => handleChange('xp', v)} min={1} max={1000} step={1} unit=" XP" color={color} />
            <RangeInput label="ê³µê²©ë ¥" icon={<Sword size={14}/>} value={localSettings.attack} onChange={(v) => handleChange('attack', v)} min={0} max={1000} step={1} unit=" DMG" color={color} />
            <RangeInput label="ë°©ì–´ë ¥" icon={<Shield size={14}/>} value={localSettings.defense} onChange={(v) => handleChange('defense', v)} min={0} max={500} step={1} unit=" DEF" color={color} />
          </>
        );
      case 'colossus':
        return (
          <>
            <TimeInput label="ìµœì´ˆ ì¶œí˜„ ì‹œê°„" value={localSettings.initialSpawnTime} onChange={(v) => handleChange('initialSpawnTime', v)} color={color} />
            <TimeInput label="ë¦¬ì   ì£¼ê¸°" value={localSettings.respawnTime} onChange={(v) => handleChange('respawnTime', v)} color={color} />
            <div style={{borderTop:'1px dashed #444', margin:'15px 0'}}></div>
            <RangeInput label="ìµœëŒ€ ì²´ë ¥" icon={<Heart size={14}/>} value={localSettings.hp} onChange={(v) => handleChange('hp', v)} min={1000} max={100000} step={500} unit=" HP" color={color} />
            <RangeInput label="ë°©ì–´ë ¥" icon={<Shield size={14}/>} value={localSettings.armor} onChange={(v) => handleChange('armor', v)} min={0} max={500} step={5} unit=" DEF" color={color} />
            <RangeInput label="ê³µê²©ë ¥" icon={<Sword size={14}/>} value={localSettings.attack} onChange={(v) => handleChange('attack', v)} min={1} max={1000} step={10} unit=" DMG" color={color} />
            <RangeInput label="ì²˜ì¹˜ ë³´ìƒ" icon={<Coins size={14}/>} value={localSettings.rewardGold} onChange={(v) => handleChange('rewardGold', v)} min={0} max={5000} step={50} unit=" G" color={color} />
          </>
        );
      case 'watcher':
        return (
          <>
            <TimeInput label="ìµœì´ˆ ì¶œí˜„ ì‹œê°„" value={localSettings.initialSpawnTime} onChange={(v) => handleChange('initialSpawnTime', v)} color={color} />
            <TimeInput label="ë¦¬ì   ì£¼ê¸°" value={localSettings.respawnTime} onChange={(v) => handleChange('respawnTime', v)} color={color} />
            <div style={{borderTop:'1px dashed #444', margin:'15px 0'}}></div>
            <RangeInput label="ìµœëŒ€ ì²´ë ¥" icon={<Heart size={14}/>} value={localSettings.hp} onChange={(v) => handleChange('hp', v)} min={1000} max={100000} step={500} unit=" HP" color={color} />
            <RangeInput label="ë°©ì–´ë ¥" icon={<Shield size={14}/>} value={localSettings.armor} onChange={(v) => handleChange('armor', v)} min={0} max={500} step={5} unit=" DEF" color={color} />
            <div style={{ marginBottom:'25px' }}>
              <div style={{ fontSize:'13px', color:'#ccc', marginBottom:'10px', display:'flex', gap:'6px' }}><Zap size={14}/> ë²„í”„ ì¢…ë¥˜</div>
              <select 
                value={localSettings.buffType} 
                onChange={(e) => handleChange('buffType', e.target.value)}
                style={{ width:'100%', padding:'12px', background:'#0d1117', border:`1px solid ${color}`, color:'#fff', borderRadius:'8px', outline:'none', fontSize:'14px' }}
              >
                <option value="COMBAT">âš”ï¸ ì „íˆ¬ë ¥ ê°•í™”</option>
                <option value="GOLD">ğŸ’° í™©ê¸ˆì˜ ì†</option>
              </select>
            </div>
            <RangeInput label="ë²„í”„ ìˆ˜ì¹˜" icon={<Zap size={14}/>} value={localSettings.buffAmount} onChange={(v) => handleChange('buffAmount', v)} min={1} max={200} step={1} unit="%" color={color} />
            <TimeInput label="ë²„í”„ ì§€ì† ì‹œê°„" value={localSettings.buffDuration} onChange={(v) => handleChange('buffDuration', v)} color={color} />
          </>
        );
      default: return null;
    }
  };

  return (
    <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.85)', zIndex: 9999, display: 'flex', justifyContent: 'center', alignItems: 'center', backdropFilter:'blur(5px)', padding:'20px' }}>
      <div style={{ width: '100%', maxWidth: '450px', background: '#161b22', border: '1px solid #30363d', borderRadius: '16px', overflow: 'hidden', boxShadow: '0 20px 60px rgba(0,0,0,0.8)', display:'flex', flexDirection:'column', maxHeight:'90vh' }}>
        <div style={{ padding: '15px 20px', background: '#21262d', borderBottom: '1px solid #30363d', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <h3 style={{ margin: 0, color: color, display: 'flex', alignItems: 'center', gap: '8px', fontSize: '16px' }}>
            <Sliders size={18}/> {title} ì¡°ì •
          </h3>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#888', cursor: 'pointer' }}><X size={24}/></button>
        </div>
        <div style={{ padding: '20px', overflowY:'auto', flex:1 }}>
          {renderInputs()}
        </div>
        <div style={{ padding: '15px', borderTop: '1px solid #30363d', display: 'flex', justifyContent: 'flex-end', background:'#0d1117' }}>
          <button onClick={handleSave} style={{ width:'100%', background: '#238636', color: '#fff', border: 'none', padding: '14px', borderRadius: '8px', fontWeight: 'bold', fontSize:'15px', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent:'center', gap: '6px' }}>
            <Save size={18}/> íŒ¨ì¹˜ ì ìš©
          </button>
        </div>
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/BattlefieldTab.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/BattlefieldTab.tsx
// ==========================================

import React, { useState, useRef } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { Skull, Ghost, Shield, Zap, Info, Move } from 'lucide-react';
import { BattlefieldPatchModal } from './BattlefieldPatchModal';
import { SpectateMap } from './spectate/SpectateMap'; 
import { MapObjectIcon } from './ui/MapObjectIcon';
import { JunglePatchModal } from './jungle/JunglePatchModal';
import { JungleCampType } from '../../types/jungle';

export const BattlefieldTab: React.FC = () => {
  const { gameState, updateObjectPosition } = useGameStore();
  const positions = gameState.fieldSettings.positions;

  // [ëª¨ë‹¬ ìƒíƒœ]
  const [editingTarget, setEditingTarget] = useState<{ key: string, title: string, color: string } | null>(null);
  const [jungleModal, setJungleModal] = useState<JungleCampType | null>(null);

  // [ë“œë˜ê·¸ ìƒíƒœ]
  const [isDragging, setIsDragging] = useState<string | null>(null);
  const [dragPos, setDragPos] = useState({ x: 0, y: 0 });
  const longPressTimer = useRef<NodeJS.Timeout | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  // ë“œë˜ê·¸ ì¢…ë£Œ (ì €ì¥)
  const handlePointerUp = () => {
    if (longPressTimer.current) clearTimeout(longPressTimer.current);
    if (isDragging) {
        updateObjectPosition(isDragging, dragPos.x, dragPos.y);
        setIsDragging(null);
    }
  };

  // ë“œë˜ê·¸ ì¤‘ ì´ë™
  const handlePointerMove = (e: React.PointerEvent) => {
    if (isDragging && containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        const x = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
        const y = Math.max(0, Math.min(100, ((e.clientY - rect.top) / rect.height) * 100));
        setDragPos({ x, y });
    }
  };

  // [í•µì‹¬] ë“œë˜ê·¸ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ ë˜í¼
  const DraggableObject = ({ objKey, x, y, icon, color, size, label, title, isJungle = false, jungleType }: any) => {
    const isTarget = isDragging === objKey;
    const displayX = isTarget ? dragPos.x : x;
    const displayY = isTarget ? dragPos.y : y;

    const handleDown = (e: React.PointerEvent) => {
        // í…ìŠ¤íŠ¸ ì„ íƒ ë°©ì§€ ë° ì´ë²¤íŠ¸ ì „íŒŒ ì°¨ë‹¨
        e.preventDefault(); 
        
        longPressTimer.current = setTimeout(() => {
            setIsDragging(objKey);
            setDragPos({ x, y });
        }, 300); // 0.3ì´ˆ ê¾¹ ëˆ„ë¥´ë©´ ë“œë˜ê·¸ ì‹œì‘
    };

    const handleClick = () => {
        if (!isTarget) {
            if (isJungle && jungleType) {
                setJungleModal(jungleType);
            } else {
                // [ë²„ê·¸ ìˆ˜ì •] í¬íƒ‘ ê°œë³„ í‚¤(towers.blue.mid.0)ë¥¼ ê³µí†µ ì„¤ì • í‚¤(towers.t1)ë¡œ ë³€í™˜
                let settingKey = objKey;
                
                if (objKey.startsWith('towers.')) {
                    if (objKey.includes('nexus')) {
                        settingKey = 'towers.nexus';
                    } else {
                        // ì˜ˆ: towers.blue.mid.0 -> parts[3]ì´ ì¸ë±ìŠ¤(0, 1, 2)
                        const parts = objKey.split('.');
                        const tierIdx = parseInt(parts[3]); 
                        // ì¸ë±ìŠ¤ 0 -> t1, 1 -> t2, 2 -> t3
                        settingKey = `towers.t${tierIdx + 1}`;
                    }
                }
                
                // ë³€í™˜ëœ í‚¤ë¡œ ëª¨ë‹¬ ì—´ê¸° (ì´ì œ ê°’ì´ ì •ìƒì ìœ¼ë¡œ ëœ¹ë‹ˆë‹¤)
                setEditingTarget({ key: settingKey, title, color });
            }
        }
    };

    return (
        <div onPointerDown={handleDown} style={{ position:'absolute', left:0, top:0, width:'100%', height:'100%', pointerEvents:'none' }}>
            <div style={{ pointerEvents:'auto' }}>
                <MapObjectIcon 
                    x={displayX} y={displayY} 
                    size={size} color={isTarget ? '#fff' : color} 
                    icon={isTarget ? <Move size={20}/> : icon} 
                    label={isTarget ? 'ì´ë™ ì¤‘...' : label}
                    onClick={handleClick}
                />
            </div>
        </div>
    );
  };

  const renderTowers = (side: 'blue' | 'red') => {
    const isBlue = side === 'blue';
    const color = isBlue ? '#58a6ff' : '#e84057';
    const coords = positions.towers[side];

    return (
      <>
        {(['top', 'mid', 'bot'] as const).map(lane => (
          coords[lane].map((pos: any, index: number) => {
            const tier = index + 1; 
            const showLabel = isBlue && lane === 'top' ? `${tier}ì°¨` : undefined;
            return (
              <DraggableObject 
                key={`towers.${side}.${lane}.${index}`}
                objKey={`towers.${side}.${lane}.${index}`}
                x={pos.x} y={pos.y} size={24} color={color} 
                icon={<Shield size={12}/>} label={showLabel}
                title={`${tier}ì°¨ í¬íƒ‘ (${lane.toUpperCase()})`}
              />
            );
          })
        ))}
        {/* ë„¥ì„œìŠ¤ */}
        <DraggableObject 
            key={`towers.${side}.nexus`}
            objKey={`towers.${side}.nexus`}
            x={coords.nexus.x} y={coords.nexus.y} size={36} color={color} 
            icon={<Shield size={18}/>} label={isBlue ? "ìˆ˜í˜¸ì" : undefined}
            title="ìˆ˜í˜¸ì (ë„¥ì„œìŠ¤)"
        />
      </>
    );
  };

  const jungleTypes: JungleCampType[] = ['TOP_BLUE', 'BOT_BLUE', 'TOP_RED', 'BOT_RED'];

  return (
    <div style={{ height: 'calc(100vh - 200px)', minHeight: '600px', display: 'flex', flexDirection: 'column', background: '#0d1117' }}
         onPointerUp={handlePointerUp} // ë“œë˜ê·¸ í•´ì œ (í™”ë©´ ì „ì²´ ê°ì§€)
    >
      <div style={{ padding: '15px 20px', background: '#161b22', borderBottom: '1px solid #30363d', display: 'flex', alignItems: 'center', gap: '10px' }}>
        <Info size={18} color="#58a6ff" />
        <div style={{ fontSize: '13px', color: '#ccc' }}>
          <strong style={{ color: '#fff' }}>ì „ì¥ ì—ë””í„°:</strong> ì•„ì´ì½˜ì„ <strong style={{color:'#f1c40f'}}>ê¸¸ê²Œ ëˆŒëŸ¬</strong> ìœ„ì¹˜ ì´ë™, í´ë¦­í•˜ì—¬ ìŠ¤íƒ¯/ëª¬ìŠ¤í„°ë¥¼ ì„¤ì •í•˜ì„¸ìš”.
        </div>
      </div>

      <div style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '20px', overflow: 'hidden' }}>
        <div 
            ref={containerRef}
            onPointerMove={handlePointerMove}
            style={{ 
              position: 'relative', width: '100%', maxWidth: '700px', aspectRatio: '1/1',
              border: '1px solid #30363d', borderRadius: '12px', overflow: 'hidden',
              boxShadow: '0 0 50px rgba(0,0,0,0.5)', touchAction: 'none' 
            }}
        >
          <SpectateMap />

          {/* íƒ€ì›Œ */}
          {renderTowers('blue')}
          {renderTowers('red')}

          {/* ê±°ì‹ ë³‘ & ì£¼ì‹œì */}
          <DraggableObject objKey="colossus" x={positions.colossus.x} y={positions.colossus.y} size={40} color="#a658ff" label="ê±°ì‹ ë³‘" title="ê±°ì‹ ë³‘" icon={<Skull/>} />
          <DraggableObject objKey="watcher" x={positions.watcher.x} y={positions.watcher.y} size={40} color="#e67e22" label="ì£¼ì‹œì" title="ì£¼ì‹œì" icon={<Zap/>} />

          {/* ì •ê¸€ 4ê³³ */}
          {positions.jungle.map((pos, idx) => (
             <DraggableObject 
                key={`jungle.${idx}`} 
                objKey={`jungle.${idx}`} 
                x={pos.x} y={pos.y} 
                size={28} color="#2ecc71" icon={<Ghost/>} 
                label={idx < 2 ? (idx === 0 ? "ì‹¬ì—°(Top)" : "ì‹¬ì—°(Bot)") : undefined}
                title="ì •ê¸€ ìº í”„"
                isJungle={true}
                jungleType={jungleTypes[idx]}
             />
          ))}

        </div>
      </div>

      {editingTarget && (
        <BattlefieldPatchModal 
          targetKey={editingTarget.key} 
          title={editingTarget.title} 
          color={editingTarget.color} 
          onClose={() => setEditingTarget(null)} 
        />
      )}

      {jungleModal && (
        <JunglePatchModal 
            campType={jungleModal} 
            onClose={() => setJungleModal(null)} 
        />
      )}
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/dashboard/GlobalBattleStats.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/dashboard/GlobalBattleStats.tsx
// ==========================================
import React from 'react';
import { Activity } from 'lucide-react';

const StatBox = ({ label, value, color, align }: any) => (
  <div style={{ textAlign: align || 'left' }}>
    <div style={{ fontSize: '10px', color: '#8b949e', marginBottom: '2px' }}>{label}</div>
    <div style={{ fontSize: '16px', fontWeight: 'bold', color: color || '#fff', fontFamily: 'JetBrains Mono' }}>{value}</div>
  </div>
);

export const GlobalBattleStats = ({ stats, isMobile }: any) => {
  const total = stats.totalMatches || 1;
  const redWinRate = ((stats.izmanWins / total) * 100).toFixed(1);
  const blueWinRate = ((stats.danteWins / total) * 100).toFixed(1);
  return (
    <div style={{ background: '#161b22', padding: '20px', borderRadius: '16px', border: '1px solid #30363d', boxShadow: '0 10px 30px -10px rgba(0,0,0,0.5)' }}>
      <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:'15px', fontSize:'12px', color:'#8b949e', fontWeight:'bold' }}>
        <div style={{ display:'flex', alignItems:'center', gap:'6px' }}><Activity size={14}/> ì‹œë®¬ë ˆì´ì…˜ ì§‘ê³„</div>
        <div>ì´ {total.toLocaleString()} ë§¤ì¹˜ ë¶„ì„ë¨</div>
      </div>
      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '8px' }}>
        <span style={{ color: '#ff4d4d', fontWeight: '900', fontSize: '18px' }}>{redWinRate}%</span>
        <span style={{ color: '#555', fontSize: '12px', fontWeight: 'bold' }}>WIN RATE</span>
        <span style={{ color: '#4d94ff', fontWeight: '900', fontSize: '18px' }}>{blueWinRate}%</span>
      </div>
      <div style={{ width: '100%', height: '12px', background: '#21262d', borderRadius: '6px', overflow: 'hidden', display: 'flex', marginBottom:'20px' }}>
        <div style={{ width: `${redWinRate}%`, background: 'linear-gradient(90deg, #8a1c1c, #ff4d4d)', height: '100%' }}></div>
        <div style={{ width: '2px', background: '#000' }}></div>
        <div style={{ flex: 1, background: 'linear-gradient(90deg, #4d94ff, #1c4b8a)', height: '100%' }}></div>
      </div>
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1px 1fr', gap: '10px', alignItems: 'center' }}>
        <div style={{ display: 'flex', justifyContent: 'space-around' }}>
          <StatBox label="í‰ê·  KDA" value={stats.izmanAvgKills} color="#ff4d4d" align="center" />
          <StatBox label="ìŠ¹ë¦¬" value={stats.izmanWins} color="#ff4d4d" align="center" />
        </div>
        <div style={{ width: '1px', height: '30px', background: '#30363d' }}></div>
        <div style={{ display: 'flex', justifyContent: 'space-around' }}>
          <StatBox label="ìŠ¹ë¦¬" value={stats.danteWins} color="#4d94ff" align="center" />
          <StatBox label="í‰ê·  KDA" value={stats.danteAvgKills} color="#4d94ff" align="center" />
        </div>
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/dashboard/GodPanel.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/dashboard/GodPanel.tsx
// ==========================================
import React, { useState } from 'react';
import { useGameStore } from '../../../store/useGameStore';
import { GameIcon } from '../../common/GameIcon';
import { Crown, Camera, Crosshair, Shield, Heart, Monitor, Users } from 'lucide-react';
import { MinionCard } from './MinionCard';

const CustomSlider = ({ label, icon, value, min, max, step, onChange, color, suffix }: any) => (
  <div>
    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
      <div style={{ display: 'flex', alignItems: 'center', gap: '8px', color: '#ccc', fontSize: '12px', fontWeight:'bold' }}>{icon} {label}</div>
      <span style={{ color: color, fontFamily: 'JetBrains Mono', fontWeight: '800', fontSize: '14px', background:`${color}11`, padding:'2px 6px', borderRadius:'4px' }}>
        {suffix === 'x' ? 'x' : ''}{value.toLocaleString()}{suffix !== 'x' ? suffix : ''}
      </span>
    </div>
    <div style={{ position: 'relative', display: 'flex', alignItems: 'center' }}>
      <input type="range" min={min} max={max} step={step} value={value} onChange={(e)=>onChange(parseFloat(e.target.value))} style={{ width: '100%', accentColor: color, height: '6px', cursor: 'pointer', background: '#1c1c1f', borderRadius: '3px', outline: 'none' }} />
    </div>
  </div>
);

const SectionLabel = ({ icon, label, color }: any) => (
  <div style={{ display: 'flex', alignItems: 'center', gap: '6px', fontSize: '10px', fontWeight: '800', color: color, letterSpacing: '1px' }}>
    {icon} {label}
  </div>
);

const TechInput = ({ label, value, onChange, icon, unit }: any) => (
  <div style={{ background: '#0d1117', borderRadius: '12px', border: '1px solid #30363d', padding: '12px 15px', display: 'flex', flexDirection: 'column', gap: '6px', transition: 'all 0.2s' }}
  onMouseEnter={e => e.currentTarget.style.borderColor = '#58a6ff'} onMouseLeave={e => e.currentTarget.style.borderColor = '#30363d'}>
    <div style={{ display: 'flex', alignItems: 'center', gap: '6px', fontSize: '11px', color: '#8b949e', fontWeight:'600' }}>{icon} {label}</div>
    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
      <input type="number" value={value} onChange={(e)=>onChange(Number(e.target.value))} style={{ background: 'none', border: 'none', color: '#fff', fontSize: '18px', fontWeight: '800', outline: 'none', width: '100%', fontFamily: 'JetBrains Mono' }} />
      {unit && <span style={{ fontSize: '10px', color: '#555', fontWeight: 'bold' }}>{unit}</span>}
    </div>
  </div>
);

export const GodPanel = ({ side, settings, color, glowColor, onChange, icon }: any) => {
  const isRed = side === 'RED';
  const { setCustomImage } = useGameStore();
  const godId = isRed ? 'god_izman' : 'god_dante';
  const [isCrownHover, setIsCrownHover] = useState(false);

  const handleUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if(file) {
        const reader = new FileReader();
        reader.onloadend = () => { if(typeof reader.result === 'string') setCustomImage(godId, reader.result); };
        reader.readAsDataURL(file);
    }
  };

  return (
    <div style={{ background: 'linear-gradient(145deg, #121418 0%, #0d1117 100%)', borderRadius: '24px', border: `1px solid ${isRed ? '#4a1e1e' : '#1e3a5f'}`, boxShadow: `0 20px 40px rgba(0,0,0,0.3), inset 0 0 60px ${glowColor}`, overflow: 'hidden' }}>
      <div style={{ padding: '25px', borderBottom: `1px solid ${color}22`, display: 'flex', justifyContent: 'space-between', alignItems: 'center', background: `linear-gradient(90deg, ${color}11, transparent)` }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '20px' }}>
          <div style={{ position: 'relative' }}>
            <GameIcon id={godId} size={64} fallback={icon} border={`2px solid ${color}44`} shape="rounded" />
          </div>
          <div>
            <div style={{ display:'flex', alignItems:'center', gap:'8px', marginBottom:'4px' }}>
              <span style={{ fontSize: '10px', fontWeight: '900', color: '#fff', background: color, padding:'2px 8px', borderRadius:'10px' }}>
                {side} FACTION
              </span>
            </div>
            <h3 style={{ margin: 0, fontSize: '24px', fontWeight: '900', color: '#fff', letterSpacing:'-0.5px' }}>{settings.name}</h3>
          </div>
        </div>
        <div onMouseEnter={() => setIsCrownHover(true)} onMouseLeave={() => setIsCrownHover(false)} style={{ position: 'relative' }}>
          <label style={{ cursor: 'pointer', display:'flex', alignItems:'center', justifyContent:'center' }}>
            {isCrownHover && <span style={{ position: 'absolute', right: '45px', fontSize: '11px', color: color, fontWeight: 'bold', whiteSpace: 'nowrap', background: '#161b22', padding: '4px 8px', borderRadius: '4px', border: `1px solid ${color}44` }}>ì‚¬ì§„ ë³€ê²½</span>}
            <Crown size={32} color={color} style={{ opacity: isCrownHover ? 1 : 0.3, transform: isCrownHover ? 'scale(1.1) rotate(15deg)' : 'rotate(15deg)', transition: 'all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275)' }} />
            <div style={{ position: 'absolute', bottom: -2, right: -2, background: '#161b22', borderRadius: '50%', padding: '3px', border: `1px solid ${color}44`, opacity: isCrownHover ? 1 : 0.5 }}><Camera size={10} color={color}/></div>
            <input type="file" style={{display:'none'}} accept="image/*" onChange={handleUpload}/>
          </label>
        </div>
      </div>
      <div style={{ padding: '25px', display: 'flex', flexDirection: 'column', gap: '30px' }}>
        <div style={{ display: 'flex', flexDirection: 'column', gap: '20px' }}>
          <CustomSlider label="ì „íˆ¬ ê³µê²©ë ¥ ë³´ì •" icon={<Crosshair size={14}/>} value={settings.atkRatio} min={0.5} max={2.0} step={0.01} onChange={(v: number)=>onChange('atkRatio', v)} color={color} suffix="x" />
          <CustomSlider label="ë°©ì–´/ì²´ë ¥ íš¨ìœ¨" icon={<Shield size={14}/>} value={settings.defRatio} min={0.5} max={2.0} step={0.01} onChange={(v: number)=>onChange('defRatio', v)} color={color} suffix="x" />
          <CustomSlider label="ë„¥ì„œìŠ¤ ìµœëŒ€ ë‚´êµ¬ë„" icon={<Heart size={14}/>} value={settings.hpRatio} min={5000} max={50000} step={1000} onChange={(v: number)=>onChange('hpRatio', v)} color={color} />
        </div>
        <div style={{ height: '1px', background: '#30363d' }} />
        <div>
          <SectionLabel icon={<Monitor size={12}/>} label="STRUCTURAL INTEGRITY" color="#8b949e" />
          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px', marginTop:'10px' }}>
            <TechInput label="ìˆ˜í˜¸ì ìƒëª…ë ¥" value={settings.guardianHp} onChange={(v: number)=>onChange('guardianHp', v)} icon={<Crown size={14} color={color}/>} unit="HP" />
            <TechInput label="ë°©ì–´ íƒ€ì›Œ ìœ„ë ¥" value={settings.towerAtk} onChange={(v: number)=>onChange('towerAtk', v)} icon={<Crosshair size={14} color={color}/>} unit="DMG" />
          </div>
        </div>
        <div>
          <SectionLabel icon={<Users size={12}/>} label="MINION WAVES" color="#8b949e" />
          <div style={{ marginTop:'10px' }}>
            {settings.minions && (
              <>
                <MinionCard type="melee" data={settings.minions.melee} color={color} onChange={(t: string, f: string, v: number) => onChange('minions', { ...settings.minions, [t]: { ...settings.minions[t], [f]: v } })} />
                <MinionCard type="ranged" data={settings.minions.ranged} color={color} onChange={(t: string, f: string, v: number) => onChange('minions', { ...settings.minions, [t]: { ...settings.minions[t], [f]: v } })} />
                <MinionCard type="siege" data={settings.minions.siege} color={color} onChange={(t: string, f: string, v: number) => onChange('minions', { ...settings.minions, [t]: { ...settings.minions[t], [f]: v } })} />
              </>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/dashboard/MinionCard.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/dashboard/MinionCard.tsx
// ==========================================
import React from 'react';
import { Sword, Shield, Heart, Zap, Crosshair, Coins } from 'lucide-react';

const MiniInput = ({ label, icon, value, onChange }: any) => (
  <div style={{ background: '#0d1117', border: '1px solid #30363d', borderRadius: '4px', padding: '4px 8px', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
    <div style={{ display: 'flex', alignItems: 'center', gap: '4px', fontSize: '10px', color: '#888' }}>{icon} {label}</div>
    <input type="number" value={value} onChange={(e) => onChange(Number(e.target.value))} style={{ width: '40px', background: 'transparent', border: 'none', color: '#fff', fontSize: '11px', fontWeight: 'bold', textAlign: 'right', outline: 'none', padding: 0 }} />
  </div>
);

export const MinionCard = ({ type, data, onChange, color }: any) => {
  let typeIcon = <Sword size={14} />;
  let typeLabel = "ê·¼ê±°ë¦¬";
  if (type === 'ranged') { typeIcon = <Crosshair size={14}/>; typeLabel = "ì›ê±°ë¦¬"; }
  if (type === 'siege') { typeIcon = <Shield size={14}/>; typeLabel = "ê³µì„±"; }

  return (
    <div style={{ background: 'rgba(0,0,0,0.3)', border: `1px solid ${color}33`, borderRadius: '8px', padding: '10px', marginBottom: '10px' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px', borderBottom:`1px dashed ${color}33`, paddingBottom:'5px' }}>
        <div style={{ fontWeight: 'bold', color: color, fontSize: '13px', display:'flex', alignItems:'center', gap:'6px' }}>{typeIcon} {data.label}</div>
        <span style={{ fontSize: '10px', color: '#666', background:'rgba(255,255,255,0.05)', padding:'2px 6px', borderRadius:'4px' }}>{typeLabel} TYPE</span>
      </div>
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '8px', marginBottom:'8px' }}>
        <MiniInput label="ì²´ë ¥" icon={<Heart size={10} color="#2ecc71"/>} value={data.hp} onChange={(v:number) => onChange(type, 'hp', v)} />
        <MiniInput label="ë°©ì–´" icon={<Shield size={10} color="#3498db"/>} value={data.def} onChange={(v:number) => onChange(type, 'def', v)} />
        <MiniInput label="ê³µê²©" icon={<Sword size={10} color="#e74c3c"/>} value={data.atk} onChange={(v:number) => onChange(type, 'atk', v)} />
      </div>
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
        <MiniInput label="ê³¨ë“œ" icon={<Coins size={10} color="#f1c40f"/>} value={data.gold} onChange={(v:number) => onChange(type, 'gold', v)} />
        <MiniInput label="ê²½í—˜ì¹˜" icon={<Zap size={10} color="#9b59b6"/>} value={data.xp} onChange={(v:number) => onChange(type, 'xp', v)} />
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/dashboard/SiegeSettingsPanel.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/dashboard/SiegeSettingsPanel.tsx
// ==========================================
import React from 'react';
import { Hammer, Target, Skull } from 'lucide-react';
import { useGameStore } from '../../../store/useGameStore';

export const SiegeSettingsPanel: React.FC = () => {
  const { gameState, updateBattleSettings } = useGameStore();
  
  // [ìˆ˜ì •] ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ë¹ˆ ê°ì²´ë¡œ ì²˜ë¦¬í•˜ê³  ì•„ë˜ì—ì„œ ê°œë³„ì ìœ¼ë¡œ ê¸°ë³¸ê°’ í• ë‹¹
  const rawSiege = gameState.battleSettings.siege || {};

  // [ì•ˆì „ì¥ì¹˜] ê°’ì´ ì—†ê±°ë‚˜ NaNì´ë©´ ê¸°ë³¸ê°’ ì‚¬ìš© (?? ì—°ì‚°ì í™œìš©)
  const siege = {
    minionDmg: rawSiege.minionDmg ?? 1.0,
    cannonDmg: rawSiege.cannonDmg ?? 1.0,
    superDmg: rawSiege.superDmg ?? 1.0,
    
    dmgToHero: rawSiege.dmgToHero ?? 1.0,
    dmgToT1: rawSiege.dmgToT1 ?? 0.3,
    dmgToT2: rawSiege.dmgToT2 ?? 0.25,
    dmgToT3: rawSiege.dmgToT3 ?? 0.2,
    dmgToNexus: rawSiege.dmgToNexus ?? 0.1,

    colossusToHero: rawSiege.colossusToHero ?? 1.0,
    colossusToT1: rawSiege.colossusToT1 ?? 0.4,
    colossusToT2: rawSiege.colossusToT2 ?? 0.35,
    colossusToT3: rawSiege.colossusToT3 ?? 0.3,
    colossusToNexus: rawSiege.colossusToNexus ?? 0.15
  };

  const handleChange = (field: string, value: number) => {
    // ê¸°ì¡´ ê°’ ìœ ì§€í•˜ë©´ì„œ ì—…ë°ì´íŠ¸
    updateBattleSettings({ 
        siege: { ...siege, [field]: value } 
    } as any);
  };

  const CustomSlider = ({ label, value, onChange, max = 2 }: { label: string, value: number, onChange: (v: number) => void, max?: number }) => {
    // í•œë²ˆ ë” ì•ˆì „ì¥ì¹˜: valueê°€ ìˆ«ìê°€ ì•„ë‹ˆë©´ 0 ì²˜ë¦¬
    const safeValue = isNaN(value) ? 0 : value;
    
    return (
      <div style={{ marginBottom: '15px' }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '6px', fontSize: '11px', color: '#ccc' }}>
          <span>{label}</span>
          <span style={{ fontWeight: 'bold', color: '#f1c40f', fontFamily: 'monospace' }}>{(safeValue * 100).toFixed(0)}%</span>
        </div>
        <input 
          type="range" min={0} max={max} step={0.05} 
          value={safeValue} onChange={(e) => onChange(parseFloat(e.target.value))} 
          style={{ width: '100%', accentColor: '#f1c40f', height: '6px', cursor: 'pointer', background: '#30363d', borderRadius: '3px' }} 
        />
      </div>
    );
  };

  return (
    <div style={{ background: '#1c1c1f', padding: '20px', borderRadius: '16px', border: '1px solid #30363d', marginTop: '20px' }}>
      <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '20px', color: '#fff', fontSize: '14px', fontWeight: 'bold', borderBottom:'1px solid #333', paddingBottom:'10px' }}>
        <Hammer size={16} color="#f1c40f" />
        <span>ê³µì„±/í•˜ìˆ˜ì¸ ìƒì„¸ ë°ë¯¸ì§€ ì„¤ì •</span>
      </div>
      
      {/* 1. ê³µê²©ì íƒ€ì… */}
      <div style={{ marginBottom:'25px' }}>
        <div style={{ fontSize:'12px', color:'#58a6ff', fontWeight:'bold', marginBottom:'10px' }}>[ê³µê²©ì] í•˜ìˆ˜ì¸ ì¢…ë¥˜ë³„ ê¸°ë³¸ íŒŒì›Œ</div>
        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '20px' }}>
            <CustomSlider label="ì¼ë°˜ ë¯¸ë‹ˆì–¸" value={siege.minionDmg} onChange={(v) => handleChange('minionDmg', v)} />
            <CustomSlider label="ëŒ€í¬ ë¯¸ë‹ˆì–¸" value={siege.cannonDmg} onChange={(v) => handleChange('cannonDmg', v)} />
            <CustomSlider label="ê±°ì‹ ë³‘ (ì†Œí™˜)" value={siege.superDmg} onChange={(v) => handleChange('superDmg', v)} />
        </div>
      </div>

      {/* 2. ì¼ë°˜ ë¯¸ë‹ˆì–¸ ëŒ€ìƒ ê³„ìˆ˜ */}
      <div style={{ marginBottom:'25px' }}>
        <div style={{ fontSize:'12px', color:'#da3633', fontWeight:'bold', marginBottom:'10px', display:'flex', gap:'5px', alignItems:'center' }}>
            <Target size={12}/> [ë¯¸ë‹ˆì–¸] ëŒ€ìƒë³„ ë°ë¯¸ì§€ ë¹„ìœ¨
        </div>
        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr 1fr 1fr', gap: '15px' }}>
            <CustomSlider label="vs ì˜ì›…" value={siege.dmgToHero} onChange={(v) => handleChange('dmgToHero', v)} />
            <CustomSlider label="vs 1ì°¨" value={siege.dmgToT1} onChange={(v) => handleChange('dmgToT1', v)} />
            <CustomSlider label="vs 2ì°¨" value={siege.dmgToT2} onChange={(v) => handleChange('dmgToT2', v)} />
            <CustomSlider label="vs 3ì°¨" value={siege.dmgToT3} onChange={(v) => handleChange('dmgToT3', v)} />
            <CustomSlider label="vs ìˆ˜í˜¸ì" value={siege.dmgToNexus} onChange={(v) => handleChange('dmgToNexus', v)} />
        </div>
      </div>

      {/* 3. ê±°ì‹ ë³‘ ì „ìš© ëŒ€ìƒ ê³„ìˆ˜ */}
      <div>
        <div style={{ fontSize:'12px', color:'#9b59b6', fontWeight:'bold', marginBottom:'10px', display:'flex', gap:'5px', alignItems:'center' }}>
            <Skull size={12}/> [ê±°ì‹ ë³‘] ëŒ€ìƒë³„ ë°ë¯¸ì§€ ë¹„ìœ¨
        </div>
        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr 1fr 1fr', gap: '15px' }}>
            <CustomSlider label="vs ì˜ì›…" value={siege.colossusToHero} onChange={(v) => handleChange('colossusToHero', v)} />
            <CustomSlider label="vs 1ì°¨" value={siege.colossusToT1} onChange={(v) => handleChange('colossusToT1', v)} />
            <CustomSlider label="vs 2ì°¨" value={siege.colossusToT2} onChange={(v) => handleChange('colossusToT2', v)} />
            <CustomSlider label="vs 3ì°¨" value={siege.colossusToT3} onChange={(v) => handleChange('colossusToT3', v)} />
            <CustomSlider label="vs ìˆ˜í˜¸ì" value={siege.colossusToNexus} onChange={(v) => handleChange('colossusToNexus', v)} />
        </div>
      </div>
      
      <div style={{ fontSize: '11px', color: '#8b949e', marginTop: '15px', textAlign:'center' }}>
        * ìµœì¢… ë°ë¯¸ì§€ = (ê³µê²©ë ¥) Ã— (ê³µê²©ì ê³„ìˆ˜) Ã— (ëŒ€ìƒ ê³„ìˆ˜)
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/jungle/DraggableMob.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/jungle/DraggableMob.tsx
// ==========================================
import React, { useRef } from 'react';
import { JungleSpot } from './JungleSpot';

interface Props {
  spotId: string;
  x: number;
  y: number;
  name: string;
  isBuff: boolean;
  isSelected: boolean;
  isDragging: boolean;
  dragPos: { x: number, y: number };
  onSelect: () => void;
  onDragStart: (spotId: string, clientX: number, clientY: number) => void;
}

export const DraggableMob: React.FC<Props> = ({ 
  spotId, x, y, name, isBuff, isSelected, isDragging, dragPos, onSelect, onDragStart 
}) => {
  const longPressTimer = useRef<NodeJS.Timeout | null>(null);
  const isMoved = useRef(false);

  // í˜„ì¬ í‘œì‹œë  ìœ„ì¹˜ (ë“œë˜ê·¸ ì¤‘ì´ë©´ dragPos, ì•„ë‹ˆë©´ ì›ë˜ ì¢Œí‘œ)
  const displayX = isDragging ? dragPos.x : x;
  const displayY = isDragging ? dragPos.y : y;

  const handlePointerDown = (e: React.PointerEvent) => {
    // ì´ë²¤íŠ¸ ë²„ë¸”ë§ ë§‰ì•„ì„œ ë§µ ìŠ¤í¬ë¡¤ê³¼ ê°„ì„­ ë°©ì§€
    e.stopPropagation();
    e.currentTarget.setPointerCapture(e.pointerId);
    
    isMoved.current = false;

    // 0.2ì´ˆ ì´ìƒ ëˆ„ë¥´ë©´ ë“œë˜ê·¸ ì‹œì‘ìœ¼ë¡œ ê°„ì£¼
    longPressTimer.current = setTimeout(() => {
      onDragStart(spotId, e.clientX, e.clientY);
    }, 200);
  };

  const handlePointerUp = (e: React.PointerEvent) => {
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current);
      longPressTimer.current = null;
      
      // ë“œë˜ê·¸ê°€ ì‹œì‘ë˜ì§€ ì•Šì•˜ê³ , ì›€ì§ì´ì§€ ì•Šì•˜ë‹¤ë©´ 'í´ë¦­(ì„ íƒ)'ìœ¼ë¡œ ê°„ì£¼
      if (!isDragging && !isMoved.current) {
        onSelect();
      }
    }
    e.currentTarget.releasePointerCapture(e.pointerId);
  };

  const handlePointerMove = () => {
    // ì•„ì£¼ ë¯¸ì„¸í•œ ì›€ì§ì„ì€ ë¬´ì‹œí•˜ë„ë¡ í•  ìˆ˜ ìˆìœ¼ë‚˜, ì—¬ê¸°ì„  ë‹¨ìˆœí™”
    isMoved.current = true;
  };

  return (
    <div
      onPointerDown={handlePointerDown}
      onPointerUp={handlePointerUp}
      onPointerMove={handlePointerMove}
      style={{
        position: 'absolute',
        left: `${displayX}%`,
        top: `${displayY}%`,
        transform: 'translate(-50%, -50%)',
        zIndex: isDragging ? 100 : 10,
        // ë“œë˜ê·¸ ì¤‘ì´ ì•„ë‹ˆë©´ ìŠ¤í¬ë¡¤ í—ˆìš©, ëª¹ ìì²´ëŠ” í„°ì¹˜ ì•¡ì…˜ ë§‰ìŒ
        touchAction: 'none', 
        cursor: isDragging ? 'grabbing' : 'pointer'
      }}
    >
      <JungleSpot 
        x={0} y={0} // ì¢Œí‘œëŠ” ìƒìœ„ divê°€ ì œì–´í•¨
        name={name}
        isBuff={isBuff}
        isSelected={isSelected}
        onClick={() => {}} // Pointer ì´ë²¤íŠ¸ë¡œ í†µí•© ì²˜ë¦¬í•˜ë¯€ë¡œ ë¹ˆ í•¨ìˆ˜
      />
      {isDragging && (
        <div style={{
          position:'absolute', top:'-30px', left:'50%', transform:'translateX(-50%)',
          background:'#58a6ff', color:'#000', fontSize:'10px', fontWeight:'bold',
          padding:'2px 6px', borderRadius:'4px', whiteSpace:'nowrap', pointerEvents:'none'
        }}>
          ì´ë™ ì¤‘
        </div>
      )}
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/jungle/JungleCampMap.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/jungle/JungleCampMap.tsx
// ==========================================
import React, { useRef } from 'react';
import { JungleCampConfig } from '../../../types/jungle';
import { JungleSpot } from './JungleSpot';
import { useGameStore } from '../../../store/useGameStore';

interface Props {
  config: JungleCampConfig;
  selectedSpotId: string | null;
  onSelectSpot: (spotId: string) => void;
  onDragStart: (spotId: string, x: number, y: number) => void;
  dragTargetId: string | null;
  dragPos: { x: number, y: number };
}

// ì¹´ë©”ë¼ ì¤‘ì‹¬ì  (ë°°ê²½ ì´ë¯¸ì§€ ìœ„ì¹˜ ë§ì¶¤)
const CAMP_CENTERS: Record<string, {x: number, y: number}> = {
  'TOP_BLUE': { x: 22, y: 38 },
  'BOT_BLUE': { x: 38, y: 77 },
  'TOP_RED':  { x: 63, y: 22 },
  'BOT_RED':  { x: 77, y: 62 }  
};

export const JungleCampMap: React.FC<Props> = ({ config, selectedSpotId, onSelectSpot, onDragStart, dragTargetId, dragPos }) => {
  const { gameState } = useGameStore();
  const mapImage = gameState.customImages?.['map_bg'];
  const center = CAMP_CENTERS[config.id] || { x: 50, y: 50 };

  const containerRef = useRef<HTMLDivElement>(null);
  const longPressTimer = useRef<NodeJS.Timeout | null>(null);
  const startTouchPos = useRef<{x: number, y: number} | null>(null);

  // [ìˆ˜ì •] ë“œë˜ê·¸ ì‹œì‘ ë¡œì§ ê°•í™”
  const handleSpotDown = (spotId: string, e: React.PointerEvent | React.TouchEvent) => {
    // ì´ë²¤íŠ¸ ì „íŒŒ ë°©ì§€ (ìƒìœ„ ìŠ¤í¬ë¡¤ ë§‰ê¸°)
    e.stopPropagation();
    
    let clientX, clientY;
    if ('touches' in e) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else {
        clientX = (e as React.PointerEvent).clientX;
        clientY = (e as React.PointerEvent).clientY;
    }

    startTouchPos.current = { x: clientX, y: clientY };

    if (longPressTimer.current) clearTimeout(longPressTimer.current);

    // 0.2ì´ˆ ê¾¹ ëˆ„ë¥´ë©´ ë“œë˜ê·¸ ì‹œì‘ (ì‹œê°„ ì•½ê°„ ëŠ˜ë ¤ì„œ ì˜¤ë™ì‘ ë°©ì§€)
    longPressTimer.current = setTimeout(() => {
        // ë“œë˜ê·¸ ì‹œì‘ ì‹œ í˜„ì¬ ì¢Œí‘œë¡œ ì´ˆê¸°í™”
        if (containerRef.current) {
            const rect = containerRef.current.getBoundingClientRect();
            const x = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
            const y = Math.max(0, Math.min(100, ((clientY - rect.top) / rect.height) * 100));
            onDragStart(spotId, x, y);
        }
        startTouchPos.current = null; // ë“œë˜ê·¸ ëª¨ë“œ ì§„ì… ì™„ë£Œ
    }, 200); 
  };

  // [ìˆ˜ì •] í„°ì¹˜ ì´ë™ ì¤‘ ë¡œì§ (ë¯¼ê°ë„ ì™„í™”)
  const handleMove = (clientX: number, clientY: number) => {
    // 1. ë¡±í”„ë ˆìŠ¤ ëŒ€ê¸° ì¤‘ì¼ ë•Œ (ì•„ì§ ë“œë˜ê·¸ ì‹œì‘ ì•ˆí•¨)
    if (longPressTimer.current && startTouchPos.current) {
        const moveDist = Math.sqrt(
            Math.pow(clientX - startTouchPos.current.x, 2) + 
            Math.pow(clientY - startTouchPos.current.y, 2)
        );
        // 15px ì´ìƒ ì›€ì§ì´ë©´ 'ìŠ¤í¬ë¡¤' ì˜ë„ë¡œ ê°„ì£¼í•˜ê³  íƒ€ì´ë¨¸ ì·¨ì†Œ
        if (moveDist > 15) { 
            clearTimeout(longPressTimer.current);
            longPressTimer.current = null;
            startTouchPos.current = null;
        }
        return;
    }

    // 2. ì´ë¯¸ ë“œë˜ê·¸ ì¤‘ì¼ ë•Œ (ì¢Œí‘œ ì—…ë°ì´íŠ¸)
    if (dragTargetId && containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        // ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šê²Œ í´ë¨í•‘ (5% ~ 95%)
        const x = Math.max(5, Math.min(95, ((clientX - rect.left) / rect.width) * 100));
        const y = Math.max(5, Math.min(95, ((clientY - rect.top) / rect.height) * 100));
        
        // onDragStartë¥¼ ì¬í™œìš©í•˜ì—¬ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ìƒìœ„ ì»´í¬ë„ŒíŠ¸ state ê°±ì‹ )
        onDragStart(dragTargetId, x, y);
    }
  };

  const onPointerMove = (e: React.PointerEvent) => {
      e.preventDefault();
      handleMove(e.clientX, e.clientY);
  };
  
  const onTouchMove = (e: React.TouchEvent) => {
      // í„°ì¹˜ ìŠ¤í¬ë¡¤ ë°©ì§€ (ë“œë˜ê·¸ ì¤‘ì¼ ë•Œë§Œ)
      if (dragTargetId) e.preventDefault();
      handleMove(e.touches[0].clientX, e.touches[0].clientY);
  };

  const handleEnd = () => {
    if (longPressTimer.current) {
        clearTimeout(longPressTimer.current);
        longPressTimer.current = null;
    }
    startTouchPos.current = null;
    // ë“œë˜ê·¸ ì¢…ë£Œ ì²˜ë¦¬ëŠ” ìƒìœ„ ì»´í¬ë„ŒíŠ¸(JunglePatchModal)ì˜ onPointerUpì—ì„œ ìˆ˜í–‰ë¨
  };

  return (
    <div 
      ref={containerRef}
      onPointerMove={onPointerMove}
      onTouchMove={onTouchMove}
      onPointerUp={handleEnd}
      onPointerLeave={handleEnd}
      onTouchEnd={handleEnd}
      onContextMenu={(e) => e.preventDefault()}
      style={{ 
        position: 'relative', width: '100%', height: '100%', 
        background: '#15191f', 
        border: '2px solid #30363d', borderRadius: '12px',
        overflow: 'hidden', boxShadow: 'inset 0 0 30px rgba(0,0,0,0.8)',
        touchAction: 'none', // ë§µ ë‚´ë¶€ì—ì„œëŠ” ë¸Œë¼ìš°ì € ìŠ¤í¬ë¡¤ ë¹„í™œì„±í™” (ë“œë˜ê·¸ ìš°ì„ )
        userSelect: 'none',
        WebkitUserSelect: 'none'
      }}
    >
      {mapImage ? (
        <div style={{
          position: 'absolute', inset: 0,
          backgroundImage: `url(${mapImage})`,
          backgroundSize: '160%', 
          backgroundPosition: `${center.x}% ${center.y}%`,
          opacity: 0.9, 
          filter: 'contrast(1.15) brightness(0.9)', 
          zIndex: 0, pointerEvents: 'none'
        }} />
      ) : (
        <div style={{ position: 'absolute', inset: 0, background: '#222', zIndex: 0 }} />
      )}

      <div style={{ position: 'absolute', top: 10, left: 10, fontSize: '12px', fontWeight: 'bold', color: '#fff', background:'rgba(0,0,0,0.7)', padding:'4px 10px', borderRadius:'6px', zIndex: 5, pointerEvents: 'none' }}>
        {config.name}
      </div>

      <div style={{ position: 'relative', width: '100%', height: '100%', zIndex: 10 }}>
        {config.monsters.map((mob) => {
            const isDragging = dragTargetId === mob.spotId;
            const displayX = isDragging ? dragPos.x : mob.x;
            const displayY = isDragging ? dragPos.y : mob.y;

            return (
              <div 
                key={mob.spotId}
                style={{ 
                    position: 'absolute', 
                    left: `${displayX}%`, top: `${displayY}%`, 
                    transform: 'translate(-50%, -50%)', 
                    zIndex: isDragging ? 100 : 10, // ë“œë˜ê·¸ ì¤‘ì¸ ê±´ ìµœìƒìœ„ë¡œ
                    cursor: 'grab',
                    touchAction: 'none'
                }}
                onPointerDown={(e) => handleSpotDown(mob.spotId, e)}
                onClick={(e) => { e.stopPropagation(); onSelectSpot(mob.spotId); }}
              >
                <JungleSpot 
                    x={0} y={0} // CSS left/topìœ¼ë¡œ ì œì–´í•˜ë¯€ë¡œ 0
                    name={mob.stats.name}
                    isBuff={mob.stats.isBuffMob}
                    isSelected={selectedSpotId === mob.spotId}
                    onClick={() => {}} // ìœ„ìª½ onClickì—ì„œ ì²˜ë¦¬
                />
              </div>
            );
        })}
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/jungle/JungleMapArea.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/jungle/JungleMapArea.tsx
// ==========================================
import React, { useRef, useState } from 'react';
import { JungleCampConfig } from '../../../types/jungle';
import { DraggableMob } from './DraggableMob';
import { useGameStore } from '../../../store/useGameStore';

interface Props {
  config: JungleCampConfig;
  selectedSpotId: string | null;
  onSelectSpot: (spotId: string) => void;
  onUpdatePos: (spotId: string, x: number, y: number) => void;
  isMobile: boolean;
}

// ë‘¥ì§€ë³„ ì¹´ë©”ë¼ ì¤‘ì‹¬ì  (ì´ë¯¸ì§€ ë§¤ì¹­ìš©)
const CAMP_CENTERS: Record<string, {x: number, y: number}> = {
  'TOP_BLUE': { x: 22, y: 38 },
  'BOT_BLUE': { x: 38, y: 77 },
  'TOP_RED':  { x: 63, y: 22 },
  'BOT_RED':  { x: 77, y: 62 }  
};

export const JungleMapArea: React.FC<Props> = ({ config, selectedSpotId, onSelectSpot, onUpdatePos, isMobile }) => {
  const { gameState } = useGameStore();
  const mapImage = gameState.customImages?.['map_bg'];
  const center = CAMP_CENTERS[config.id] || { x: 50, y: 50 };

  const containerRef = useRef<HTMLDivElement>(null);
  
  // ë“œë˜ê·¸ ìƒíƒœ ê´€ë¦¬ (ìƒìœ„ì—ì„œ ë¶„ë¦¬ë¨)
  const [dragTargetId, setDragTargetId] = useState<string | null>(null);
  const [dragPos, setDragPos] = useState({ x: 0, y: 0 });

  const handleDragStart = (spotId: string, clientX: number, clientY: number) => {
    setDragTargetId(spotId);
    updateDragPos(clientX, clientY);
  };

  const updateDragPos = (clientX: number, clientY: number) => {
    if (containerRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      // ì¢Œí‘œ ë³€í™˜ (0~100%)
      const x = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
      const y = Math.max(0, Math.min(100, ((clientY - rect.top) / rect.height) * 100));
      setDragPos({ x, y });
    }
  };

  const handlePointerMove = (e: React.PointerEvent) => {
    if (dragTargetId) {
      e.preventDefault(); // ë“œë˜ê·¸ ì¤‘ì—ëŠ” ìŠ¤í¬ë¡¤ ë°©ì§€
      updateDragPos(e.clientX, e.clientY);
    }
  };

  const handlePointerUp = () => {
    if (dragTargetId) {
      onUpdatePos(dragTargetId, dragPos.x, dragPos.y);
      setDragTargetId(null);
    }
  };

  return (
    <div 
      ref={containerRef}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      onPointerLeave={handlePointerUp}
      style={{ 
        position: 'relative', width: '100%', height: '100%', 
        background: '#15191f', 
        overflow: 'hidden', // ë‚´ë¶€ ìš”ì†Œê°€ íŠ€ì–´ë‚˜ì˜¤ì§€ ì•Šê²Œ
        touchAction: dragTargetId ? 'none' : 'pan-y', // ë“œë˜ê·¸ ì¤‘ì—” ìŠ¤í¬ë¡¤ ë§‰ê³ , í‰ì†Œì—” í—ˆìš©
        userSelect: 'none'
      }}
    >
      {/* ë§µ ë°°ê²½ */}
      {mapImage ? (
        <div style={{
          position: 'absolute', inset: 0,
          backgroundImage: `url(${mapImage})`,
          backgroundSize: '160%', 
          backgroundPosition: `${center.x}% ${center.y}%`,
          opacity: 0.9, 
          filter: 'contrast(1.15) brightness(0.9)', 
          zIndex: 0, pointerEvents: 'none'
        }} />
      ) : (
        <div style={{ position: 'absolute', inset: 0, background: '#222', zIndex: 0 }} />
      )}

      {/* ì•ˆë‚´ ë¬¸êµ¬ */}
      <div style={{ position: 'absolute', bottom: 10, left: '50%', transform: 'translateX(-50%)', 
        fontSize: '11px', fontWeight: 'bold', color: '#888', background:'rgba(0,0,0,0.8)', 
        padding:'4px 12px', borderRadius:'12px', zIndex: 5, pointerEvents: 'none', whiteSpace:'nowrap' 
      }}>
        {dragTargetId ? 'ì›í•˜ëŠ” ìœ„ì¹˜ì— ë†“ìœ¼ì„¸ìš”' : 'ê¾¹ ëˆŒëŸ¬ì„œ ì´ë™ / í„°ì¹˜í•˜ì—¬ ì„ íƒ'}
      </div>

      {/* ëª¬ìŠ¤í„°ë“¤ */}
      {config.monsters.map((mob) => (
        <DraggableMob
          key={mob.spotId}
          spotId={mob.spotId}
          x={mob.x}
          y={mob.y}
          name={mob.stats.name}
          isBuff={mob.stats.isBuffMob}
          isSelected={selectedSpotId === mob.spotId}
          isDragging={dragTargetId === mob.spotId}
          dragPos={dragPos}
          onSelect={() => onSelectSpot(mob.spotId)}
          onDragStart={handleDragStart}
        />
      ))}
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/jungle/JunglePatchModal.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/jungle/JunglePatchModal.tsx
// ==========================================
import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../../store/useGameStore';
import { JungleCampType, JungleCampConfig, JungleMonsterStats } from '../../../types/jungle';
import { DEFAULT_JUNGLE_CONFIG } from '../../../data/jungle/jungleDefaults';
import { X, Save, RotateCcw } from 'lucide-react';
import { MonsterEditor } from './MonsterEditor';
import { JungleMapArea } from './JungleMapArea'; 

interface Props { campType: JungleCampType; onClose: () => void; }

export const JunglePatchModal: React.FC<Props> = ({ campType, onClose }) => {
  const { gameState, updateFieldSettings } = useGameStore();
  
  const currentJungle = gameState.fieldSettings.jungle as any;
  // ê¸°ì¡´ ì„¤ì •ì´ ìˆìœ¼ë©´ ê°€ì ¸ì˜¤ê³ , ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš© (ê¹Šì€ ë³µì‚¬ë¡œ ì°¸ì¡° ëŠê¸°)
  const currentCamp = currentJungle?.camps?.[campType] || JSON.parse(JSON.stringify(DEFAULT_JUNGLE_CONFIG.camps[campType]));

  // [ìˆ˜ì •] ì´ˆê¸° ìƒíƒœ ë¡œë“œ ì‹œ ì¢Œí‘œ ë³´ì • ë¡œì§ ì œê±° (ìˆëŠ” ê·¸ëŒ€ë¡œ ë¡œë“œ)
  const [campConfig, setCampConfig] = useState<JungleCampConfig>(currentCamp);
  const [selectedSpotId, setSelectedSpotId] = useState<string | null>(campConfig.monsters[0]?.spotId || null);
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const selectedMonster = campConfig.monsters.find(m => m.spotId === selectedSpotId);

  const handleMonsterChange = (field: keyof JungleMonsterStats, value: any) => {
    if (!selectedSpotId) return;
    setCampConfig(prev => ({
      ...prev,
      monsters: prev.monsters.map(m => m.spotId === selectedSpotId ? { ...m, stats: { ...m.stats, [field]: value } } : m)
    }));
  };

  const handlePosUpdate = (spotId: string, x: number, y: number) => {
    // [ìˆ˜ì •] ì¢Œí‘œ ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ì €ì¥ (ë„ˆë¬´ ê¸´ ì†Œìˆ˜ì  ë°©ì§€)
    const fixedX = Number(x.toFixed(1));
    const fixedY = Number(y.toFixed(1));

    setCampConfig(prev => ({
        ...prev,
        monsters: prev.monsters.map(m => m.spotId === spotId ? { ...m, x: fixedX, y: fixedY } : m)
    }));
    setSelectedSpotId(spotId);
  };

  const handleSave = () => {
    const newJungleSettings = {
        ...currentJungle,
        camps: { ...(currentJungle.camps || DEFAULT_JUNGLE_CONFIG.camps), [campType]: campConfig }
    };
    updateFieldSettings({ jungle: newJungleSettings });
    alert(`${campConfig.name} ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.\n(ë‹¤ìŒ ê²Œì„ë¶€í„° ì ìš©ë©ë‹ˆë‹¤)`);
    onClose();
  };

  const handleReset = () => {
    if(confirm('ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ìœ„ì¹˜ í¬í•¨)')) {
        // ê¸°ë³¸ê°’ ê¹Šì€ ë³µì‚¬
        const resetData = JSON.parse(JSON.stringify(DEFAULT_JUNGLE_CONFIG.camps[campType]));
        setCampConfig(resetData);
        setSelectedSpotId(resetData.monsters[0]?.spotId);
    }
  };

  return (
    <div 
        style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.95)', zIndex: 9999, display: 'flex', justifyContent: 'center', alignItems: 'center', backdropFilter:'blur(5px)', padding: isMobile ? '0' : '20px' }}
        onContextMenu={(e) => e.preventDefault()}
    >
      <div style={{ 
          width: '100%', maxWidth: '900px', height: isMobile ? '100vh' : '700px', 
          background: '#161b22', border: isMobile ? 'none' : '1px solid #30363d', 
          borderRadius: isMobile ? '0' : '16px', overflow: 'hidden', display:'flex', flexDirection:'column', boxShadow: '0 20px 60px rgba(0,0,0,0.8)' 
      }}>
        
        <div style={{ padding: '15px 20px', background: '#21262d', borderBottom: '1px solid #30363d', display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexShrink: 0 }}>
          <h3 style={{ margin: 0, color: '#2ecc71', fontSize: '16px', display:'flex', alignItems:'center', gap:'8px' }}>
            ğŸŒ² {isMobile ? campConfig.name.split('(')[0] : campConfig.name}
          </h3>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#888', cursor: 'pointer', padding:'5px' }}><X size={24}/></button>
        </div>

        <div style={{ flex: 1, overflowY: 'auto', WebkitOverflowScrolling: 'touch', display: 'flex', flexDirection: isMobile ? 'column' : 'row' }}>
            
            {/* 1. ë§µ ì˜ì—­ */}
            <div style={{ 
                flex: isMobile ? 'none' : 1, 
                height: isMobile ? '45vh' : 'auto',
                borderRight: isMobile ? 'none' : '1px solid #30363d', borderBottom: isMobile ? '1px solid #30363d' : 'none',
                background:'#0d1117', position: 'relative'
            }}>
              <JungleMapArea 
                config={campConfig}
                selectedSpotId={selectedSpotId}
                onSelectSpot={setSelectedSpotId}
                onUpdatePos={handlePosUpdate}
                isMobile={isMobile}
              />
            </div>

            {/* 2. ì—ë””í„° ì˜ì—­ */}
            <div style={{ flex: isMobile ? 'none' : 1, background: '#161b22', minHeight: isMobile ? 'auto' : '100%', paddingBottom: isMobile ? '80px' : '0' }}>
              {selectedMonster ? (
                <MonsterEditor key={selectedSpotId} stats={selectedMonster.stats} onChange={handleMonsterChange} />
              ) : (
                <div style={{ padding:'40px', color:'#555', textAlign:'center' }}>ì„ íƒëœ ëª¬ìŠ¤í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>
              )}
            </div>

        </div>

        <div style={{ padding: '15px', borderTop: '1px solid #30363d', display: 'flex', gap:'10px', flexShrink: 0, background:'#161b22' }}>
          <button onClick={handleReset} style={{ flex:1, background: '#3f1515', color: '#ff6b6b', border: '1px solid #5a1e1e', padding: '12px', borderRadius: '8px', fontWeight: 'bold', cursor: 'pointer', display:'flex', justifyContent:'center', alignItems:'center', gap:'6px', fontSize:'14px' }}>
            <RotateCcw size={16}/> ì´ˆê¸°í™”
          </button>
          <button onClick={handleSave} style={{ flex:2, background: '#238636', color: '#fff', border: 'none', padding: '12px', borderRadius: '8px', fontWeight: 'bold', cursor: 'pointer', display:'flex', justifyContent:'center', alignItems:'center', gap:'6px', fontSize:'14px' }}>
            <Save size={16}/> ì €ì¥
          </button>
        </div>

      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/jungle/JungleSpot.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/jungle/JungleSpot.tsx
// ==========================================
import React from 'react';
import { Skull, Star } from 'lucide-react';

interface Props {
  x: number; // ì‚¬ìš© ì•ˆ í•¨ (ìƒìœ„ì—ì„œ ì œì–´)
  y: number; // ì‚¬ìš© ì•ˆ í•¨
  isSelected: boolean;
  isBuff: boolean;
  name: string;
  onClick: () => void;
}

export const JungleSpot: React.FC<Props> = ({ isSelected, isBuff, name, onClick }) => {
  return (
    <div 
      onClick={(e) => { e.stopPropagation(); onClick(); }}
      style={{
        cursor: 'pointer',
        display: 'flex', flexDirection: 'column', alignItems: 'center',
        // [ì¤‘ìš”] í„°ì¹˜ ì˜ì—­ì„ í™•ì‹¤íˆ í™•ë³´
        padding: '10px' 
      }}
    >
      <div style={{
        width: isBuff ? '36px' : '28px', 
        height: isBuff ? '36px' : '28px',
        borderRadius: '50%',
        background: isSelected ? '#fff' : '#161b22',
        border: isSelected ? '2px solid #58a6ff' : (isBuff ? '2px solid #f1c40f' : '2px solid #8b949e'),
        display: 'flex', alignItems: 'center', justifyContent: 'center',
        boxShadow: isSelected ? '0 0 15px #58a6ff' : '0 0 5px rgba(0,0,0,0.5)',
        transition: 'transform 0.1s',
        transform: isSelected ? 'scale(1.1)' : 'scale(1)'
      }}>
        {isBuff ? <Star size={18} color={isSelected ? '#58a6ff' : '#f1c40f'} /> : <Skull size={14} color={isSelected ? '#58a6ff' : '#8b949e'} />}
      </div>
      <div style={{
        marginTop: '2px', fontSize: '9px', fontWeight: 'bold',
        color: isSelected ? '#58a6ff' : '#ccc',
        background: 'rgba(0,0,0,0.7)', padding: '2px 6px', borderRadius: '4px',
        whiteSpace: 'nowrap', pointerEvents: 'none'
      }}>
        {name}
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/jungle/MonsterEditor.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/jungle/MonsterEditor.tsx
// ==========================================
import React from 'react';
import { JungleMonsterStats, BuffType } from '../../../types/jungle';
import { Sword, Shield, Heart, Coins, Clock, Zap, Type, Plus, Trash2, TrendingUp } from 'lucide-react';
import { RangeInput } from '../ui/PatchInputs';

interface Props {
  stats: JungleMonsterStats;
  onChange: (field: keyof JungleMonsterStats, value: any) => void;
}

export const MonsterEditor: React.FC<Props> = ({ stats, onChange }) => {
  
  // ë²„í”„ ì¶”ê°€
  const addBuff = () => {
    const newBuffs = [...(stats.buffs || []), { type: 'ATK' as BuffType, value: 10 }];
    onChange('buffs', newBuffs);
  };

  // ë²„í”„ ì‚­ì œ
  const removeBuff = (index: number) => {
    const newBuffs = [...(stats.buffs || [])];
    newBuffs.splice(index, 1);
    onChange('buffs', newBuffs);
  };

  // ë²„í”„ ìˆ˜ì •
  const updateBuff = (index: number, field: 'type' | 'value', val: any) => {
    const newBuffs = [...(stats.buffs || [])];
    newBuffs[index] = { ...newBuffs[index], [field]: val };
    onChange('buffs', newBuffs);
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '20px', padding: '20px 15px' }}>
      
      {/* 1. ê¸°ë³¸ ì •ë³´ */}
      <div style={{ background: '#1f242e', padding: '15px', borderRadius: '8px', border: '1px solid #30363d' }}>
        <div style={{ marginBottom: '15px' }}>
          <label style={{ fontSize: '11px', color: '#8b949e', marginBottom: '6px', display: 'flex', alignItems:'center', gap:'4px' }}>
            <Type size={12}/> ëª¬ìŠ¤í„° ì´ë¦„
          </label>
          <input 
            type="text" value={stats.name} 
            onChange={(e) => onChange('name', e.target.value)}
            style={{ width: '100%', background: '#0d1117', border: '1px solid #444', color: '#fff', padding: '10px', borderRadius: '6px', fontWeight: 'bold', fontSize:'14px', boxSizing:'border-box' }}
          />
        </div>

        <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: stats.isBuffMob ? '15px' : '0' }}>
          <input 
            type="checkbox" checked={stats.isBuffMob} 
            onChange={(e) => onChange('isBuffMob', e.target.checked)}
            id="buffCheck"
            style={{ width: '18px', height: '18px', cursor:'pointer', accentColor: '#f1c40f' }}
          />
          <label htmlFor="buffCheck" style={{ flex: 1, cursor:'pointer' }}>
            <div style={{ fontSize: '13px', fontWeight: 'bold', color: stats.isBuffMob ? '#f1c40f' : '#ccc' }}>ë²„í”„ ëª¬ìŠ¤í„° ì—¬ë¶€</div>
            <div style={{ fontSize: '11px', color: '#666' }}>ì²´í¬ ì‹œ ì²˜ì¹˜ìì—ê²Œ íŠ¹ë³„ íš¨ê³¼ ë¶€ì—¬</div>
          </label>
        </div>

        {/* [ìˆ˜ì •] ë‹¤ì¤‘ ë²„í”„ ë¦¬ìŠ¤íŠ¸ UI */}
        {stats.isBuffMob && (
          <div style={{ animation: 'fadeIn 0.2s', background: '#2d2b18', padding:'10px', borderRadius:'6px', border:'1px solid #f1c40f' }}>
            <div style={{ fontSize:'12px', fontWeight:'bold', color:'#f1c40f', marginBottom:'10px', display:'flex', justifyContent:'space-between', alignItems:'center' }}>
                <span>ë¶€ì—¬í•  ë²„í”„ ëª©ë¡ ({stats.buffs?.length || 0})</span>
                <button onClick={addBuff} style={{ background:'#f1c40f', color:'#000', border:'none', borderRadius:'4px', padding:'4px 8px', fontSize:'11px', fontWeight:'bold', cursor:'pointer', display:'flex', alignItems:'center', gap:'4px' }}>
                    <Plus size={12}/> ì¶”ê°€
                </button>
            </div>

            {(!stats.buffs || stats.buffs.length === 0) && (
                <div style={{ fontSize:'11px', color:'#aaa', textAlign:'center', padding:'10px' }}>ë²„í”„ë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”.</div>
            )}

            {stats.buffs?.map((buff, idx) => (
                <div key={idx} style={{ marginBottom:'10px', paddingBottom:'10px', borderBottom: idx < stats.buffs.length-1 ? '1px dashed #555' : 'none' }}>
                    <div style={{ display:'flex', gap:'5px', marginBottom:'5px' }}>
                        <select 
                            value={buff.type}
                            onChange={(e) => updateBuff(idx, 'type', e.target.value)}
                            style={{ flex:1, background: '#161b22', border: '1px solid #f1c40f', color: '#fff', padding: '6px', borderRadius: '4px', fontSize:'11px' }}
                        >
                            <option value="ATK">âš”ï¸ ê³µê²©ë ¥</option>
                            <option value="DEF">ğŸ›¡ï¸ ë°©ì–´ë ¥</option>
                            <option value="SPEED">ğŸ’¨ ì´ë™ì†ë„</option>
                            <option value="REGEN">ğŸ’– ì¬ìƒ</option>
                            <option value="HASSTE">âš¡ ìŠ¤í‚¬ê°€ì†</option>
                            <option value="GOLD">ğŸ’° ê³¨ë“œ</option>
                        </select>
                        <button onClick={() => removeBuff(idx)} style={{ background:'#3f1515', border:'1px solid #5a1e1e', color:'#ff6b6b', borderRadius:'4px', padding:'6px', cursor:'pointer' }}>
                            <Trash2 size={12}/>
                        </button>
                    </div>
                    <RangeInput 
                      label="ìˆ˜ì¹˜" icon={<TrendingUp size={10}/>} 
                      value={buff.value} onChange={(v) => updateBuff(idx, 'value', v)} 
                      min={1} max={100} step={1} unit={buff.type === 'HASSTE' ? '' : '%'} color="#f1c40f" 
                    />
                </div>
            ))}
          </div>
        )}
      </div>

      {/* 2. ì „íˆ¬ ìŠ¤íƒ¯ */}
      <div style={{ background: '#1f242e', padding: '15px', borderRadius: '8px', border: '1px solid #30363d' }}>
        <h4 style={{ margin:'0 0 15px 0', fontSize:'12px', color:'#ccc' }}>ê¸°ë³¸ ëŠ¥ë ¥ì¹˜</h4>
        <RangeInput label="ì²´ë ¥" icon={<Heart size={12}/>} value={stats.hp} onChange={(v) => onChange('hp', v)} min={100} max={20000} step={100} unit="" color="#2ecc71" />
        <RangeInput label="ê³µê²©ë ¥" icon={<Sword size={12}/>} value={stats.atk} onChange={(v) => onChange('atk', v)} min={0} max={1000} step={10} unit="" color="#e74c3c" />
        <RangeInput label="ë°©ì–´ë ¥" icon={<Shield size={12}/>} value={stats.def} onChange={(v) => onChange('def', v)} min={0} max={300} step={5} unit="" color="#3498db" />
      </div>

      {/* 3. ë³´ìƒ */}
      <div style={{ background: '#1f242e', padding: '15px', borderRadius: '8px', border: '1px solid #30363d' }}>
        <h4 style={{ margin:'0 0 15px 0', fontSize:'12px', color:'#e89d40' }}>ë³´ìƒ ë° ìƒì„±</h4>
        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '15px' }}>
          <RangeInput label="ê³¨ë“œ" icon={<Coins size={12}/>} value={stats.gold} onChange={(v) => onChange('gold', v)} min={0} max={1000} step={10} unit=" G" color="#f1c40f" />
          <RangeInput label="ê²½í—˜ì¹˜" icon={<Zap size={12}/>} value={stats.xp} onChange={(v) => onChange('xp', v)} min={0} max={1000} step={10} unit=" XP" color="#9b59b6" />
        </div>
        <div style={{ marginTop: '10px' }}>
          <RangeInput label="ë¦¬ì   ì‹œê°„" icon={<Clock size={12}/>} value={stats.respawnTime} onChange={(v) => onChange('respawnTime', v)} min={10} max={600} step={10} unit=" ì´ˆ" color="#ccc" />
        </div>
      </div>

      <style>{`
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }
      `}</style>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/LiveGameListModal.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/LiveGameListModal.tsx
// ==========================================

import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { X, Eye, Swords, Clock, User, ChevronDown, ChevronUp, Target } from 'lucide-react';
import { LiveMatch } from '../../types';
import { GameIcon } from '../common/GameIcon';

interface Props { onClose: () => void; onSpectate: (match: LiveMatch) => void; }

export const LiveGameListModal: React.FC<Props> = ({ onClose, onSpectate }) => {
  const { gameState, heroes } = useGameStore();
  const matches = gameState.liveMatches;

  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
  const [selectedMatchId, setSelectedMatchId] = useState<string | null>(null);

  useEffect(() => {
    const handleResize = () => {
      const mobile = window.innerWidth <= 768;
      setIsMobile(mobile);
      if (!mobile && !selectedMatchId && matches.length > 0) {
        setSelectedMatchId(matches[0].id);
      }
    };
    window.addEventListener('resize', handleResize);
    if (!isMobile && matches.length > 0 && !selectedMatchId) {
      setSelectedMatchId(matches[0].id);
    }
    return () => window.removeEventListener('resize', handleResize);
  }, [isMobile, matches, selectedMatchId]);

  const getHeroName = (id: string) => heroes.find(h => h.id === id)?.name || id;

  const formatDuration = (seconds: number) => {
    const totalSeconds = Math.floor(seconds); 
    const m = Math.floor(totalSeconds / 60);
    const s = totalSeconds % 60;
    return `${m}ë¶„ ${String(s).padStart(2, '0')}ì´ˆ`;
  };

  const MatchListItem = ({ match, isSelected, onClick }: { match: LiveMatch, isSelected: boolean, onClick: () => void }) => (
    <div 
      onClick={onClick}
      style={{ 
        padding: '12px 15px', 
        borderBottom: '1px solid #2c2c2f', 
        cursor: 'pointer',
        background: isSelected ? '#2a2a2e' : '#1c1c1f',
        borderLeft: isSelected ? '4px solid #58a6ff' : '4px solid transparent',
        transition: 'background 0.2s'
      }}
    >
      <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '4px', fontSize: '11px', color: '#888' }}>
        <span style={{ fontWeight:'bold', color:'#ccc' }}>{match.avgTier}</span>
        <span style={{ display:'flex', alignItems:'center', gap:'4px', fontFamily:'monospace' }}>
          <Clock size={10}/> {formatDuration(match.currentDuration)}
        </span>
      </div>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <div style={{ display:'flex', gap:'8px', alignItems:'center', width:'40%' }}>
          <span style={{ color: '#58a6ff', fontSize: '16px', fontWeight:'900' }}>{match.score.blue}</span>
          <span style={{ fontSize:'10px', color:'#58a6ff55', fontWeight:'bold' }}>BLUE</span>
        </div>
        <div style={{ fontSize: '11px', color: '#555', fontWeight:'bold' }}>VS</div>
        <div style={{ display:'flex', gap:'8px', alignItems:'center', width:'40%', justifyContent:'flex-end' }}>
          <span style={{ fontSize:'10px', color:'#e8405755', fontWeight:'bold' }}>RED</span>
          <span style={{ color: '#e84057', fontSize: '16px', fontWeight:'900' }}>{match.score.red}</span>
        </div>
      </div>
      {isMobile && (
        <div style={{ textAlign:'center', marginTop:'-5px', opacity:0.5 }}>
          {isSelected ? <ChevronUp size={14}/> : <ChevronDown size={14}/>}
        </div>
      )}
    </div>
  );

  const MatchDetailView = ({ match }: { match: LiveMatch | undefined }) => {
    if (!match) {
        return (
            <div style={{ padding: '50px', textAlign: 'center', color: '#666', fontSize:'13px' }}>
                ì„ íƒëœ ê²Œì„ì´ ì¢…ë£Œë˜ì—ˆê±°ë‚˜ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
            </div>
        );
    }

    return (
      <div style={{ background: '#0d1117', height:'100%', display:'flex', flexDirection:'column' }}>
        <div style={{ padding: '15px', textAlign: 'center', background: '#161b22', borderBottom: '1px solid #333', flexShrink:0 }}>
          <button 
            onClick={() => onSpectate(match)}
            style={{ 
              padding: '10px 40px', borderRadius: '8px', 
              background: '#238636', color: '#fff', border: 'none', 
              fontSize: '14px', fontWeight: 'bold', cursor: 'pointer',
              display: 'inline-flex', alignItems: 'center', gap: '8px',
              boxShadow: '0 4px 15px rgba(35,134,54,0.3)',
              transition: '0.2s'
            }}
          >
            <Eye size={18} /> ì‹¤ì‹œê°„ ê´€ì „ ì…ì¥
          </button>
        </div>

        <div style={{ padding: '15px', overflowY:'auto', flex:1 }}>
          <div style={{ display: 'grid', gridTemplateColumns: isMobile ? '1fr' : '1fr 1fr', gap: '15px' }}>
            <div>
              <h4 style={{ color: '#58a6ff', margin: '0 0 10px 0', fontSize:'12px', borderBottom: '2px solid #58a6ff', paddingBottom:'6px', display:'flex', justifyContent:'space-between' }}>
                <span>BLUE TEAM (ë‹¨í…Œ)</span>
                <span style={{ color:'#fff' }}>{match.score.blue}</span>
              </h4>
              {match.blueTeam && match.blueTeam.map((p, i) => (
                <PlayerCard key={i} p={p} color="#58a6ff" heroName={getHeroName(p.heroId)} />
              ))}
            </div>

            <div style={{ marginTop: isMobile ? '20px' : '0' }}>
              <h4 style={{ color: '#e84057', margin: '0 0 10px 0', fontSize:'12px', borderBottom: '2px solid #e84057', paddingBottom:'6px', textAlign: isMobile ? 'left' : 'right', display:'flex', flexDirection: isMobile ? 'row' : 'row-reverse', justifyContent:'space-between' }}>
                <span>RED TEAM (ì´ì¦ˆë§ˆí•œ)</span>
                <span style={{ color:'#fff' }}>{match.score.red}</span>
              </h4>
              {match.redTeam && match.redTeam.map((p, i) => (
                <PlayerCard key={i} p={p} color="#e84057" heroName={getHeroName(p.heroId)} alignRight={!isMobile} />
              ))}
            </div>
          </div>
        </div>
      </div>
    );
  };

  return (
    <div style={{
      position: 'fixed', top: 0, left: 0, width: '100%', height: '100%',
      backgroundColor: 'rgba(0,0,0,0.85)', zIndex: 9000,
      backdropFilter: 'blur(5px)',
      display: 'flex', justifyContent: 'center', 
      alignItems: 'center',
      padding: isMobile ? '0' : '40px'
    }}>

      <div className="panel" style={{ 
        width: isMobile ? '100%' : '1100px', 
        height: isMobile ? '100%' : '85vh', 
        background: '#1c1c1f', 
        border: isMobile ? 'none' : '1px solid #30363d', 
        display: 'flex', flexDirection: 'column', 
        borderRadius: isMobile ? '0' : '16px',
        boxShadow: '0 20px 60px rgba(0,0,0,0.9)',
        overflow: 'hidden'
      }}>

        <div style={{ 
          padding: '15px 20px', borderBottom: '1px solid #333', 
          display: 'flex', justifyContent: 'space-between', alignItems: 'center', 
          background:'#252528', zIndex: 50 
        }}>
          <h3 style={{ margin: 0, color:'#fff', display:'flex', alignItems:'center', gap:'10px', fontSize:'16px' }}>
            <Swords size={20} color="#f1c40f"/> ì§„í–‰ ì¤‘ì¸ ê²Œì„ ({matches.length})
          </h3>
          <button onClick={onClose} style={{ background:'none', border:'none', color:'#ccc', cursor:'pointer' }}><X size={24}/></button>
        </div>

        {isMobile ? (
          <div style={{ flex: 1, overflowY:'auto' }}>
            {matches.map(match => (
              <div key={match.id}>
                <MatchListItem 
                  match={match} 
                  isSelected={selectedMatchId === match.id} 
                  onClick={() => setSelectedMatchId(selectedMatchId === match.id ? null : match.id)} 
                />
                {selectedMatchId === match.id && (
                  <div style={{ height:'500px', borderBottom:'1px solid #333' }}>
                    <MatchDetailView match={match} />
                  </div>
                )}
              </div>
            ))}
            {matches.length === 0 && <div style={{padding:'40px', textAlign:'center', color:'#555'}}>ì§„í–‰ ì¤‘ì¸ ê²Œì„ì´ ì—†ìŠµë‹ˆë‹¤.</div>}
          </div>
        ) : (
          <div style={{ flex: 1, display: 'flex', overflow: 'hidden' }}>
            <div style={{ width: '300px', borderRight: '1px solid #333', overflowY: 'auto', background: '#161b22' }}>
              {matches.map(match => (
                <MatchListItem 
                  key={match.id} 
                  match={match} 
                  isSelected={selectedMatchId === match.id} 
                  onClick={() => setSelectedMatchId(match.id)} 
                />
              ))}
            </div>
            <div style={{ flex: 1, overflow: 'hidden' }}>
              <MatchDetailView match={matches.find(m => m.id === selectedMatchId)} />
            </div>
          </div>
        )}

      </div>
    </div>
  );
};

// [ìˆ˜ì •] PlayerCard: KDA, ê³¨ë“œ, CS, ë”œëŸ‰ í‘œì‹œ
const PlayerCard = ({ p, color, heroName, alignRight = false }: any) => {
  const isDead = p.currentHp <= 0;

  return (
    <div style={{ 
      display: 'flex', 
      flexDirection: alignRight ? 'row-reverse' : 'row',
      alignItems: 'center', 
      justifyContent: 'space-between',
      padding: '8px 12px', 
      marginBottom: '6px', 
      background: '#1c1c1f', 
      borderRadius: '6px', 
      borderLeft: alignRight ? 'none' : `3px solid ${color}`,
      borderRight: alignRight ? `3px solid ${color}` : 'none',
      boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
      opacity: isDead ? 0.6 : 1,
      filter: isDead ? 'grayscale(0.8)' : 'none'
    }}>
      {/* 1. ì˜ì›… ì •ë³´ */}
      <div style={{ display: 'flex', alignItems: 'center', gap: '10px', flexDirection: alignRight ? 'row-reverse' : 'row' }}>
        <div style={{ position:'relative' }}>
          <GameIcon id={p.heroId} size={38} shape="rounded" border={`1px solid ${color}44`} />
          <div style={{ position:'absolute', bottom:-3, right:-3, background:'#0d1117', color:'#fff', fontSize:'10px', fontWeight:'bold', padding:'0 3px', borderRadius:'3px', border:'1px solid #333' }}>
            {p.level}
          </div>
        </div>

        <div style={{ textAlign: alignRight ? 'right' : 'left' }}>
          <div style={{ color: '#fff', fontWeight:'bold', fontSize:'13px', lineHeight:'1.2' }}>{heroName}</div>
          <div style={{ color: '#8b949e', fontSize:'11px', display:'flex', alignItems:'center', gap:'3px', justifyContent: alignRight ? 'flex-end' : 'flex-start' }}>
            <User size={10}/> {p.name}
          </div>
        </div>
      </div>

      {/* 2. ìƒì„¸ ìŠ¤íƒ¯ (KDA / ê³¨ë“œ / CS / ë”œëŸ‰) */}
      <div style={{ textAlign: alignRight ? 'left' : 'right', display:'flex', flexDirection:'column', alignItems: alignRight ? 'flex-start' : 'flex-end', gap:'2px' }}>

        {/* KDA */}
        <div style={{ color: '#fff', fontWeight:'bold', fontSize:'13px', fontFamily:'monospace', letterSpacing:'-0.5px' }}>
          {p.kills}/<span style={{color:'#da3633'}}>{p.deaths}</span>/{p.assists}
        </div>

        {/* ê³¨ë“œ & CS */}
        <div style={{ fontSize: '10px', fontWeight:'bold', display:'flex', gap:'6px' }}>
          <span style={{ color: '#e89d40' }}>{(p.gold / 1000).toFixed(1)}k</span>
          <span style={{ color: '#444' }}>|</span>
          <span style={{ color: '#ccc' }}>{p.cs} CS</span>
        </div>

        {/* ë”œëŸ‰ (ë¹¨ê°„ìƒ‰) */}
        <div style={{ fontSize: '9px', fontWeight:'bold', color: '#ff6b6b', display:'flex', alignItems:'center', gap:'3px' }}>
          <Swords size={9}/> {(p.totalDamageDealt || 0).toLocaleString()}
        </div>

      </div>
    </div>
  );
};


==========================================
FILE PATH: src/components/battle/spectate/DraftScreen.tsx
==========================================
import React from 'react';
import { X, Shield, Swords, Zap, Crosshair, Skull } from 'lucide-react';
import { GameIcon } from '../../common/GameIcon';
import { SpeedButton, BanCard } from './SpectateUI';

export const DraftScreen: React.FC<any> = ({ match, heroes, onClose, setSpeed, gameState, onBanClick }) => {
  const { blueTeam, redTeam, draft, bans } = match;
  const timer = Math.ceil(draft?.timer || 0);
  const turn = draft?.turnIndex || 0;
  const isBanPhase = turn < 10;

  // ë°´ ëª©ë¡ ì±„ìš°ê¸°
  const fillBans = (arr: string[]) => {
    const res = [...(arr || [])];
    while(res.length < 5) res.push('');
    return res;
  };
  const blueBans = fillBans(bans?.blue);
  const redBans = fillBans(bans?.red);

  // í”½ ìˆœì„œ (ìŠ¤ë„¤ì´í¬)
  const PICK_ORDER = [
    {team: 0, slot: 0}, {team: 1, slot: 0}, {team: 1, slot: 1}, {team: 0, slot: 1}, 
    {team: 0, slot: 2}, {team: 1, slot: 2}, {team: 1, slot: 3}, {team: 0, slot: 3}, 
    {team: 0, slot: 4}, {team: 1, slot: 4}
  ];

  let activeTeam = -1; 
  let activeSlot = -1; 

  if (!isBanPhase && (turn - 10) < PICK_ORDER.length) {
    const order = PICK_ORDER[turn - 10];
    activeTeam = order.team;
    activeSlot = order.slot;
  }

  const activeBanSlot = isBanPhase ? Math.floor(turn / 2) : -1;
  const activeBanTeam = isBanPhase ? (turn % 2) : -1;
  const getHeroName = (id: string) => heroes.find((h: any) => h.id === id)?.name || '';

  // [í•µì‹¬] ê²Œì„ ì»¨ì…‰ì— ë§ëŠ” í¬ì§€ì…˜ ëª…ì¹­ ë° ì•„ì´ì½˜ ë³€í™˜
  const getRoleDisplay = (lane: string) => {
    switch(lane) {
      case 'TOP': return { label: 'ì§‘í–‰ê´€', icon: <Shield size={10}/>, color: '#e74c3c' };
      case 'JUNGLE': return { label: 'ì¶”ì ì', icon: <Swords size={10}/>, color: '#2ecc71' };
      case 'MID': return { label: 'ì„ ì§€ì', icon: <Zap size={10}/>, color: '#3498db' };
      case 'BOT': return { label: 'ì‹ ì‚´ì', icon: <Crosshair size={10}/>, color: '#f1c40f' };
      default: return { label: 'ìˆ˜í˜¸ê¸°ì‚¬', icon: <Skull size={10}/>, color: '#9b59b6' };
    }
  };

  // ëª¨ë°”ì¼ ìµœì í™” í”½ ìŠ¬ë¡¯
  const PickSlot = ({ player, side, isActive }: any) => {
    const roleInfo = getRoleDisplay(player.lane);
    const borderColor = side === 'BLUE' ? '#58a6ff' : '#e84057';
    
    return (
      <div style={{ 
        display:'flex', alignItems:'center', gap:'8px', 
        background: isActive ? '#1f242e' : '#161b22', 
        border: isActive ? `1px solid ${borderColor}` : '1px solid #333',
        padding:'6px', borderRadius:'6px', 
        height: '48px', overflow:'hidden', position:'relative',
        marginBottom: '6px'
      }}>
        {/* ì˜ì›… ì•„ì´ì½˜ */}
        <div style={{ position:'relative', width:'36px', height:'36px', flexShrink:0 }}>
          {player.heroId ? (
            <GameIcon id={player.heroId} size={36} shape="rounded" />
          ) : (
            <div style={{ width:'100%', height:'100%', background:'#222', borderRadius:'8px', border:'1px dashed #444' }} />
          )}
          {isActive && (
            <div style={{ position:'absolute', inset:0, border:`2px solid ${borderColor}`, borderRadius:'8px', animation:'pulse 1s infinite' }} />
          )}
        </div>

        {/* ì •ë³´ í…ìŠ¤íŠ¸ */}
        <div style={{ flex:1, minWidth:0, display:'flex', flexDirection:'column', justifyContent:'center' }}>
          {/* ì˜ì›… ì´ë¦„ / ìƒíƒœ */}
          <div style={{ fontSize:'12px', fontWeight:'bold', color: player.heroId ? '#fff' : '#666', whiteSpace:'nowrap', overflow:'hidden', textOverflow:'ellipsis' }}>
            {player.heroId ? getHeroName(player.heroId) : (isActive ? 'ì„ íƒ ì¤‘...' : 'ëŒ€ê¸° ì¤‘')}
          </div>
          
          {/* ìœ ì € ë‹‰ë„¤ì„ (ìš”ì²­í•˜ì‹  ë¶€ë¶„) */}
          <div style={{ fontSize:'10px', color:'#ccc', whiteSpace:'nowrap', overflow:'hidden', textOverflow:'ellipsis', marginTop:'1px' }}>
            {player.name}
          </div>

          {/* í¬ì§€ì…˜ (ê²Œì„ ì»¨ì…‰ ì ìš©) */}
          <div style={{ fontSize:'9px', color: roleInfo.color, display:'flex', alignItems:'center', gap:'3px', marginTop:'2px', fontWeight:'bold' }}>
            {roleInfo.icon} {roleInfo.label}
          </div>
        </div>
      </div>
    );
  };

  return (
    <div style={{ 
      position: 'fixed', inset: 0, background: '#0f0f0f', zIndex: 10000,
      display: 'flex', flexDirection: 'column'
    }}>
      
      {/* 1. ìƒë‹¨ ì»¨íŠ¸ë¡¤ & íƒ€ì´ë¨¸ */}
      <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', padding:'10px', background:'#1a1a1a', borderBottom:'1px solid #333' }}>
        <div style={{ display:'flex', gap:'4px' }}>
           {[1, 10, 60].map(s => <SpeedButton key={s} label={`${s}x`} speed={s} currentSpeed={gameState.gameSpeed} setSpeed={setSpeed} />)}
        </div>
        <div style={{ textAlign:'center' }}>
          <div style={{ fontSize:'24px', fontWeight:'900', color: timer <= 5 ? '#da3633' : '#fff' }}>{timer}</div>
          <div style={{ fontSize:'10px', color: isBanPhase ? '#e84057' : '#58a6ff', fontWeight:'bold' }}>
            {isBanPhase ? 'ê¸ˆì§€ ë‹¨ê³„ (BAN)' : 'ì„ íƒ ë‹¨ê³„ (PICK)'}
          </div>
        </div>
        <button onClick={onClose} style={{ background:'none', border:'none', color:'#888', cursor:'pointer' }}><X size={24}/></button>
      </div>

      {/* 2. ë°´ ì¹´ë“œ ì˜ì—­ */}
      <div style={{ display:'flex', justifyContent:'space-between', padding:'10px 15px', background:'#1a1a1a', borderBottom:'1px solid #333' }}>
        <div style={{ display:'flex', gap:'4px' }}>
          {blueBans.map((id, i) => (
            <BanCard key={i} heroId={id} heroes={heroes} isActive={isBanPhase && activeBanTeam === 0 && activeBanSlot === i} onClick={onBanClick} />
          ))}
        </div>
        <div style={{ display:'flex', gap:'4px' }}>
          {redBans.map((id, i) => (
            <BanCard key={i} heroId={id} heroes={heroes} isActive={isBanPhase && activeBanTeam === 1 && activeBanSlot === i} onClick={onBanClick} />
          ))}
        </div>
      </div>

      {/* 3. í”½ ë¦¬ìŠ¤íŠ¸ (ì¢Œìš° 2ë¶„í• , ìŠ¤í¬ë¡¤ ê°€ëŠ¥) */}
      <div style={{ flex: 1, overflowY:'auto', padding:'10px', display:'flex', gap:'10px' }}>
        {/* BLUE TEAM */}
        <div style={{ flex: 1, display:'flex', flexDirection:'column' }}>
          <div style={{ textAlign:'center', fontSize:'12px', fontWeight:'bold', color:'#58a6ff', marginBottom:'8px', borderBottom:'2px solid #58a6ff', paddingBottom:'4px' }}>BLUE TEAM</div>
          {blueTeam.map((p:any, i:number) => (
            <PickSlot key={i} player={p} side="BLUE" isActive={!isBanPhase && activeTeam === 0 && activeSlot === i} />
          ))}
        </div>

        {/* RED TEAM */}
        <div style={{ flex: 1, display:'flex', flexDirection:'column' }}>
          <div style={{ textAlign:'center', fontSize:'12px', fontWeight:'bold', color:'#e84057', marginBottom:'8px', borderBottom:'2px solid #e84057', paddingBottom:'4px' }}>RED TEAM</div>
          {redTeam.map((p:any, i:number) => (
            <PickSlot key={i} player={p} side="RED" isActive={!isBanPhase && activeTeam === 1 && activeSlot === i} />
          ))}
        </div>
      </div>

      <style>{`
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
      `}</style>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/spectate/GlobalLogPanel.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/spectate/GlobalLogPanel.tsx
// ==========================================
import React, { useMemo, useRef, useEffect } from 'react';

export const GlobalLogPanel = ({ logs, gameSpeed, formatTime }: any) => {
  const scrollRef = useRef<HTMLDivElement>(null);

  const visibleLogs = useMemo(() => {
    // 1ë°°ì†ì¼ ë•ŒëŠ” ëª¨ë“  ë¡œê·¸ í‘œì‹œ, ë°°ì†ì¼ ë•ŒëŠ” ì¤‘ìš” ë¡œê·¸ë§Œ í‘œì‹œ (ì„±ëŠ¥ ìµœì í™”)
    const filtered = logs.filter((log: any) => {
      if (gameSpeed === 1) return true; 
      return log.type !== 'DEBUG';      
    });
    return [...filtered].reverse().slice(0, 150); 
  }, [logs, gameSpeed]); 

  // ìƒˆ ë¡œê·¸ ì˜¤ë©´ ìŠ¤í¬ë¡¤ ë§¨ ìœ„ë¡œ
  useEffect(() => {
    if (scrollRef.current) scrollRef.current.scrollTop = 0;
  }, [visibleLogs.length]); 

  return (
    <div ref={scrollRef} style={{ flex: 1, overflowY: 'auto', padding: '10px', background: '#050505', maxHeight: '400px', display:'flex', flexDirection:'column', gap:'6px' }}>
      {visibleLogs.map((log: any, i: number) => {
        let badgeColor = '#888'; let badgeText = 'INFO'; 
        if (log.type === 'KILL') { badgeColor = '#ff4d4d'; badgeText = 'KILL'; }
        else if (log.type === 'DEBUG') { badgeColor = '#333'; badgeText = 'BTL'; } 
        else if (log.type === 'TOWER') { badgeColor = '#e89d40'; badgeText = 'OBJ'; }
        else if (log.type === 'START') { badgeColor = '#f1c40f'; badgeText = 'SYS'; }
        else if (log.type === 'DODGE') { badgeColor = '#7ee787'; badgeText = 'MISS'; }

        return (
          <div key={i} style={{ display: 'flex', gap: '8px', padding: '2px 0', borderBottom: '1px solid #1a1a1c', alignItems: 'flex-start' }}>
            <span style={{ fontSize: '10px', color: '#555', fontFamily: 'monospace', minWidth: '40px' }}>{formatTime(log.time)}</span>
            <div style={{ flex: 1 }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                <span style={{ fontSize: '8px', fontWeight: '900', color: badgeColor, background: `${badgeColor}15`, padding: '0px 4px', borderRadius: '2px', border: `1px solid ${badgeColor}33`, minWidth:'28px', textAlign:'center' }}>{badgeText}</span>
                <span style={{ fontSize: log.type === 'DEBUG' ? '11px' : '12px', color: log.type === 'DEBUG' ? '#aaa' : '#fff', lineHeight: '1.4' }}>{log.message}</span>
              </div>
            </div>
          </div>
        );
      })}
    </div>
  );
};


==========================================
FILE PATH: src/components/battle/spectate/InGameScreen.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/spectate/InGameScreen.tsx
// ==========================================
import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../../store/useGameStore';
import { SpectateHeader } from './views/SpectateHeader';
import { SpectateMapView } from './views/SpectateMapView';
import { SpectateListView } from './views/SpectateListView';
import { HeroDetailPopup } from './modals/HeroDetailPopup'; // ì‹ ê·œ íŒì—… import

export const InGameScreen: React.FC<any> = ({ match: initialMatch, onClose }) => {
  const match = useGameStore(state => state.gameState.liveMatches.find(m => m.id === initialMatch.id));
  const { heroes, gameState, setSpeed, togglePlay } = useGameStore();

  // selectedHeroIdëŠ” ì´ì œ íŒì—…ì„ ë„ìš°ëŠ” ìš©ë„ë¡œë„ ì‚¬ìš©ë©ë‹ˆë‹¤.
  const [selectedHeroId, setSelectedHeroId] = useState<string | null>(null);
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
  const [mobileTab, setMobileTab] = useState<'LIST' | 'MAP'>('MAP'); // ê¸°ë³¸ê°’ì„ ë§µìœ¼ë¡œ ë³€ê²½ (ìš”ì²­ì‚¬í•­ íë¦„ìƒ ìì—°ìŠ¤ëŸ¬ì›€)

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    setSpeed(1); 
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  if (!match) return <div style={{color:'white', padding:50, textAlign:'center'}}>ê²Œì„ ì¢…ë£Œë¨</div>;

  const isGameEnded = match.stats.blue.nexusHp <= 0 || match.stats.red.nexusHp <= 0;
  
  const formatTime = (s: number) => {
    const m = Math.floor(s / 60);
    const sec = Math.floor(s % 60);
    return `${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
  };

  const getHeroName = (id: string) => heroes.find((h:any) => h.id === id)?.name || id;

  // ì„ íƒëœ í”Œë ˆì´ì–´ ê°ì²´ ì°¾ê¸°
  const selectedPlayer = selectedHeroId 
    ? [...match.blueTeam, ...match.redTeam].find(p => p.heroId === selectedHeroId) 
    : null;
  
  const selectedHeroData = selectedPlayer 
    ? heroes.find(h => h.id === selectedPlayer.heroId) 
    : null;

  return (
    <div style={{ 
      position: 'fixed', inset: 0, background: '#0f0f0f', zIndex: 10000,
      display: 'flex', flexDirection: 'column'
    }}>
      
      {/* 1. ìƒë‹¨ë°” */}
      <SpectateHeader 
        score={match.score}
        timeStr={isGameEnded ? 'END' : formatTime(match.currentDuration)}
        isGameEnded={isGameEnded}
        isPlaying={gameState.isPlaying}
        gameSpeed={gameState.gameSpeed}
        onTogglePlay={togglePlay}
        onSetSpeed={setSpeed}
        onClose={onClose}
        isMobile={isMobile}
        mobileTab={mobileTab}
        setMobileTab={setMobileTab}
      />

      {/* 2. ë©”ì¸ ì»¨í…ì¸  */}
      <div style={{ flex: 1, overflowY: 'hidden', position:'relative' }}>
        
        {/* [MAP] ë§µ ë·° (í•˜ë‹¨ì— ì˜¤ë¸Œì íŠ¸ ì •ë³´ í¬í•¨ë¨) */}
        <SpectateMapView 
          match={match}
          isMobile={isMobile}
          mobileTab={mobileTab}
          selectedHeroId={null} // ë§µì—ì„œëŠ” í•˜ì´ë¼ì´íŠ¸ë§Œ í•˜ê³ , í´ë¦­ ì‹œ íŒì—… ë„ì›€
          onSelectHero={(id) => setSelectedHeroId(id)}
          setMobileTab={setMobileTab}
        />

        {/* [LIST] ë¦¬ìŠ¤íŠ¸ ë·° */}
        <SpectateListView 
          match={match}
          heroes={heroes}
          isMobile={isMobile}
          mobileTab={mobileTab}
          selectedHeroId={selectedHeroId}
          onSelectHero={setSelectedHeroId}
          gameSpeed={gameState.gameSpeed}
          formatTime={formatTime}
          getHeroName={getHeroName}
        />

      </div>

      {/* 3. ì˜ì›… ìƒì„¸ íŒì—… (ëª¨ë“ˆí™”ë¨) */}
      {selectedPlayer && selectedHeroData && (
        <HeroDetailPopup 
          player={selectedPlayer}
          hero={selectedHeroData}
          onClose={() => setSelectedHeroId(null)}
        />
      )}

    </div>
  );
};



==========================================
FILE PATH: src/components/battle/spectate/map/EffectLayer.tsx
==========================================
import React from 'react';
import { VisualEffect } from '../../../../../types';

interface Props {
  effects: VisualEffect[];
}

export const EffectLayer: React.FC<Props> = () => {
  // [ìµœì í™”] ì‹œê° ì´í™íŠ¸ ë Œë”ë§ ì™„ì „ ì œê±°
  return null;
};



==========================================
FILE PATH: src/components/battle/spectate/map/MapConstants.ts
==========================================
// ==========================================
// FILE PATH: /src/components/battle/spectate/map/MapConstants.ts
// ==========================================

// [í•µì‹¬] ë·°(View) ì „ìš© ìƒìˆ˜ë¥¼ ë”°ë¡œ ë§Œë“¤ì§€ ì•Šê³ , ì—”ì§„ì˜ ìƒìˆ˜ë¥¼ ê·¸ëŒ€ë¡œ ë‚´ë³´ëƒ…ë‹ˆë‹¤.
// ì´ì œ í™”ë©´ì— ê·¸ë¦¬ëŠ” ì¢Œí‘œì™€ AIê°€ ê³„ì‚°í•˜ëŠ” ì¢Œí‘œëŠ” ì™„ë²½í•˜ê²Œ ë™ì¼í•©ë‹ˆë‹¤.
export { TOWER_COORDS, BASES, POI } from '../../../../engine/match/constants/MapConstants';



==========================================
FILE PATH: src/components/battle/spectate/map/MapObjects.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/spectate/map/MapObjects.tsx
// ==========================================
import React from 'react';
import { Skull, Zap, Shield } from 'lucide-react';
import { POI } from '../../../../engine/data/MapData';
import { TOWER_COORDS } from './MapConstants';

const TOWER_RANGE_DIA = 24; 
const NEXUS_RANGE_DIA = 30;

// --- íƒ€ì›Œ ë Œë”ë§ ---
export const TowerRender = ({ side, lane, tier, stats }: any) => {
  const isBlue = side === 'BLUE';
  const teamStats = isBlue ? stats.blue : stats.red;
  const brokenCount = teamStats.towers[lane.toLowerCase()];
  const isBroken = brokenCount >= tier;

  const isActive = brokenCount === tier - 1;
  const currentHp = teamStats.laneHealth ? teamStats.laneHealth[lane.toLowerCase()] : 0;
  
  const maxHpMap = { 1: 5000, 2: 7500, 3: 10000 };
  const maxHp = (maxHpMap as any)[tier] || 5000;
  const hpPercent = isActive ? (currentHp / maxHp) * 100 : 0;

  const laneCoords = isBlue ? TOWER_COORDS.BLUE : TOWER_COORDS.RED;
  const pos = (laneCoords as any)[lane][tier - 1];
  const color = isBlue ? '#58a6ff' : '#e84057';

  // [ìˆ˜ì •] ë Œë”ë§ ì•ˆì •ì„±ì„ ìœ„í•´ React.Fragment ëŒ€ì‹  divë¡œ ê°ì‹¸ê±°ë‚˜,
  // ì¡°ê±´ë¶€ ë Œë”ë§ ì‹œ nullì„ ëª…í™•íˆ ë°˜í™˜
  
  if (isBroken) {
    return (
      <div style={{
        position: 'absolute', left: `${pos.x}%`, top: `${pos.y}%`,
        transform: 'translate(-50%, -50%)',
        width: '12px', height: '12px',
        background: 'rgba(0,0,0,0.5)', border: '1px dashed #555', borderRadius: '50%',
        zIndex: 2, display: 'flex', alignItems: 'center', justifyContent: 'center'
      }}>
        <div style={{width:'4px', height:'4px', background:'#333', borderRadius:'50%'}}/>
      </div>
    );
  }

  // ì‚´ì•„ìˆëŠ” íƒ€ì›Œ (ë²”ìœ„ í‘œì‹œ + ë³¸ì²´)
  return (
    <div style={{ position: 'absolute', left: 0, top: 0, width: '100%', height: '100%', pointerEvents: 'none' }}>
      {/* 1. ì‚¬ê±°ë¦¬ í‘œì‹œ */}
      {isActive && (
        <div style={{
          position: 'absolute', 
          left: `${pos.x}%`, top: `${pos.y}%`,
          width: `${TOWER_RANGE_DIA}%`, 
          height: `${TOWER_RANGE_DIA}%`, 
          transform: 'translate(-50%, -50%)',
          borderRadius: '50%',
          border: `1px dashed ${color}AA`, 
          backgroundColor: `${color}1A`,   
          zIndex: 1 
        }} />
      )}

      {/* 2. íƒ€ì›Œ ì•„ì´ì½˜ */}
      <div style={{
        position: 'absolute', left: `${pos.x}%`, top: `${pos.y}%`,
        transform: 'translate(-50%, -50%)',
        display: 'flex', flexDirection: 'column', alignItems: 'center', zIndex: 5,
        pointerEvents: 'auto'
      }}>
        <div style={{
          width: '18px', height: '18px', background: '#161b22', border: `2px solid ${color}`,
          borderRadius: '4px', display: 'flex', alignItems: 'center', justifyContent: 'center',
          boxShadow: `0 0 8px ${color}66`, position: 'relative'
        }}>
          <Shield size={10} color={color} fill={color} />
        </div>
        
        {isActive && (
          <div style={{ width: '24px', height: '3px', background: '#000', marginTop: '2px', borderRadius: '2px', overflow: 'hidden', border:'1px solid #000' }}>
              <div style={{ width: `${Math.max(0, hpPercent)}%`, height: '100%', background: hpPercent < 30 ? '#da3633' : color, transition:'width 0.2s' }} />
          </div>
        )}
      </div>
    </div>
  );
};

// --- ë„¥ì„œìŠ¤ ë Œë”ë§ ---
export const NexusRender = ({ side, stats }: any) => {
  const isBlue = side === 'BLUE';
  const pos = isBlue ? TOWER_COORDS.BLUE.NEXUS : TOWER_COORDS.RED.NEXUS;
  const teamStats = isBlue ? stats.blue : stats.red;
  const color = isBlue ? '#58a6ff' : '#e84057';
  
  const currentHp = Math.max(0, teamStats.nexusHp);
  const maxHp = Math.max(1, teamStats.maxNexusHp);
  const hpPercent = (currentHp / maxHp) * 100;

  return (
    <div style={{ position: 'absolute', left: 0, top: 0, width: '100%', height: '100%', pointerEvents: 'none' }}>
      {/* 1. ë„¥ì„œìŠ¤ ì‚¬ê±°ë¦¬ */}
      {currentHp > 0 && (
        <div style={{
            position: 'absolute', 
            left: `${pos.x}%`, top: `${pos.y}%`,
            width: `${NEXUS_RANGE_DIA}%`, 
            height: `${NEXUS_RANGE_DIA}%`,
            transform: 'translate(-50%, -50%)',
            borderRadius: '50%',
            border: `1px solid ${color}66`,
            backgroundColor: `${color}10`,
            zIndex: 1
        }} />
      )}

      {/* 2. ë„¥ì„œìŠ¤ ë³¸ì²´ */}
      <div style={{
        position: 'absolute', left: `${pos.x}%`, top: `${pos.y}%`,
        transform: 'translate(-50%, -50%)', zIndex: 6,
        display: 'flex', flexDirection: 'column', alignItems: 'center', pointerEvents: 'auto'
      }}>
        <div style={{
          width: '36px', height: '36px', background: '#161b22', border: `3px solid ${color}`,
          borderRadius: '50%', display: 'flex', alignItems: 'center', justifyContent: 'center',
          boxShadow: `0 0 20px ${color}44`, position: 'relative'
        }}>
          <Zap size={18} color={color} fill={color} />
          {hpPercent <= 0 && (
             <div style={{ position:'absolute', inset:0, background:'#000000aa', borderRadius:'50%', display:'flex', alignItems:'center', justifyContent:'center' }}>
               <Skull size={20} color="#fff"/>
             </div>
          )}
        </div>
        <div style={{ marginTop:'4px', width:'50px', height:'5px', background:'#111', borderRadius:'3px', border:'1px solid #333', overflow:'hidden' }}>
           <div style={{ width: `${hpPercent}%`, height:'100%', background: hpPercent < 30 ? '#da3633' : color, transition: 'width 0.2s' }}/>
        </div>
        <span style={{ fontSize:'9px', fontWeight:'900', color:'#fff', textShadow:'0 0 2px #000', marginTop:'1px' }}>
          {Math.ceil(hpPercent)}%
        </span>
      </div>
    </div>
  );
};

export const MonsterRender = ({ type, objectives }: { type: 'colossus' | 'watcher', objectives: any }) => {
  if (!objectives || !objectives[type]) return null;
  const obj = objectives[type];
  
  if (obj.status !== 'ALIVE') return null;

  const pos = type === 'colossus' ? POI.BARON : POI.DRAGON;
  const color = type === 'colossus' ? '#a658ff' : '#e67e22'; 
  const icon = type === 'colossus' ? <Skull size={16} color="#fff"/> : <Zap size={16} color="#fff"/>;
  const hpPercent = (obj.hp / obj.maxHp) * 100;

  return (
    <div style={{
      position: 'absolute', left: `${pos.x}%`, top: `${pos.y}%`,
      transform: 'translate(-50%, -50%)', zIndex: 7,
      display: 'flex', flexDirection: 'column', alignItems: 'center'
    }}>
      <div style={{
        width: '32px', height: '32px', background: color, borderRadius: '50%',
        border: '3px solid #fff', display: 'flex', alignItems: 'center', justifyContent: 'center',
        boxShadow: `0 0 15px ${color}`
      }}>
        {icon}
      </div>
      <div style={{ 
        width:'40px', height:'5px', background:'#000', marginTop:'-10px', 
        borderRadius:'2px', overflow:'hidden', border:'1px solid #fff', zIndex:8 
      }}>
         <div style={{ width: `${hpPercent}%`, height:'100%', background: '#fff' }}/>
      </div>
      <span style={{ 
        marginTop:'2px', fontSize:'9px', fontWeight:'900', color:'#fff', 
        textShadow:'0 0 3px #000', background:'rgba(0,0,0,0.5)', padding:'0 4px', borderRadius:'4px'
      }}>
        {type === 'colossus' ? 'ê±°ì‹ ë³‘' : 'ì£¼ì‹œì'}
      </span>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/spectate/map/objects/JungleRender.tsx
==========================================
import React from 'react';
import { JungleMob } from '../../../../../../types';

export const JungleRender = ({ mobs }: { mobs?: JungleMob[] }) => {
  if (!mobs) return null;

  return (
    <>
      {mobs.map((mob) => {
        if (!mob.isAlive) return null;

        const color = mob.type === 'GOLEM' ? '#d35400' : '#7f8c8d';
        const size = mob.type === 'GOLEM' ? 14 : 10;

        return (
          <div
            key={mob.id}
            style={{
              position: 'absolute',
              left: `${mob.x}%`,
              top: `${mob.y}%`,
              width: `${size}px`,
              height: `${size}px`,
              backgroundColor: '#161b22',
              border: `2px solid ${color}`,
              borderRadius: '50%',
              transform: 'translate(-50%, -50%)',
              zIndex: 3,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: '8px',
              color: color,
              fontWeight: 'bold',
              pointerEvents: 'none'
            }}
          >
            {mob.type[0]}
          </div>
        );
      })}
    </>
  );
};



==========================================
FILE PATH: src/components/battle/spectate/map/objects/MinionRender.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/spectate/map/objects/MinionRender.tsx
// ==========================================
import React from 'react';
import { Minion } from '../../../../../../types';
import { Skull } from 'lucide-react';

export const MinionRender = ({ minions }: { minions?: Minion[] }) => {
  if (!minions) return null;

  return (
    <>
      {minions.map((m) => {
        const isBlue = m.team === 'BLUE';
        const color = isBlue ? '#58a6ff' : '#e84057';
        
        // [ìˆ˜ì •] ê±°ì‹ ë³‘ ë Œë”ë§ (ì²´ë ¥ë°” ì¶”ê°€)
        if (m.type === 'SUMMONED_COLOSSUS') {
            const hpPercent = (m.hp / m.maxHp) * 100;
            return (
                <div
                    key={m.id}
                    id={`minion-${m.id}`}
                    style={{
                        position: 'absolute',
                        left: `${m.x}%`,
                        top: `${m.y}%`,
                        transform: 'translate(-50%, -50%)',
                        zIndex: 15,
                        display: 'flex', flexDirection: 'column', alignItems: 'center',
                        transition: 'none'
                    }}
                >
                    {/* ì²´ë ¥ë°” */}
                    <div style={{ width: '40px', height: '6px', background: '#000', borderRadius: '3px', marginBottom: '4px', border: '1px solid #fff', overflow:'hidden' }}>
                        <div style={{ width: `${hpPercent}%`, height: '100%', background: '#a658ff', transition: 'width 0.2s' }} />
                    </div>

                    {/* ë³¸ì²´ ì•„ì´ì½˜ */}
                    <div style={{
                        width: '28px',
                        height: '28px',
                        backgroundColor: isBlue ? '#a658ff' : '#ff5858', 
                        borderRadius: '50%',
                        border: '2px solid #fff',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        boxShadow: '0 0 15px #a658ff'
                    }}>
                        <Skull size={18} color="#fff" />
                    </div>
                </div>
            );
        }

        // ì¼ë°˜ ë¯¸ë‹ˆì–¸
        const size = m.type === 'SIEGE' ? 14 : (m.type === 'MELEE' ? 10 : 8);
        const shape = m.type === 'RANGED' ? '50%' : '3px';
        const border = m.type === 'SIEGE' ? '2px solid #fff' : '1px solid #000';

        return (
          <div
            key={m.id}
            id={`minion-${m.id}`}
            style={{
              position: 'absolute',
              left: `${m.x}%`,
              top: `${m.y}%`,
              width: `${size}px`,
              height: `${size}px`,
              backgroundColor: color,
              borderRadius: shape,
              border: border,
              transform: 'translate(-50%, -50%)',
              zIndex: 4,
              boxShadow: m.type === 'SIEGE' ? '0 0 5px rgba(255,255,255,0.5)' : 'none',
              pointerEvents: 'none',
              transition: 'none' 
            }}
          />
        );
      })}
    </>
  );
};



==========================================
FILE PATH: src/components/battle/spectate/map/objects/ProjectileRender.tsx
==========================================
import React from 'react';
import { Projectile } from '../../../../../../types';

export const ProjectileRender = ({ projectiles }: { projectiles?: Projectile[] }) => {
  if (!projectiles) return null;

  return (
    <>
      {projectiles.map((p) => (
        <div
          key={p.id}
          style={{
            position: 'absolute',
            left: `${p.x}%`,
            top: `${p.y}%`,
            width: '6px',
            height: '6px',
            backgroundColor: '#f1c40f',
            borderRadius: '50%',
            boxShadow: '0 0 4px #f1c40f',
            transform: 'translate(-50%, -50%)',
            zIndex: 20,
            pointerEvents: 'none'
          }}
        />
      ))}
    </>
  );
};



==========================================
FILE PATH: src/components/battle/spectate/map/objects/SkillBubble.tsx
==========================================
import React from 'react';

interface Props {
  activeSkill?: {
    key: 'q' | 'w' | 'e' | 'r';
    timestamp: number;
  };
  currentTime: number;
  isDead: boolean;
}

export const SkillBubble: React.FC<Props> = ({ activeSkill, currentTime, isDead }) => {
  // 1.5ì´ˆ ë™ì•ˆë§Œ í‘œì‹œ
  const SHOW_DURATION = 1.5;
  
  if (!activeSkill || isDead) return null;
  if (currentTime - activeSkill.timestamp > SHOW_DURATION) return null;

  // ìŠ¤í‚¬ë³„ ìƒ‰ìƒ (Rì€ ë¹¨ê°•, QëŠ” ë…¸ë‘, ë‚˜ë¨¸ì§€ëŠ” í°ìƒ‰)
  const getSkillColor = (key: string) => {
    if (key === 'r') return '#ff4d4d'; // ê¶ê·¹ê¸°
    if (key === 'q') return '#f1c40f';
    return '#ffffff';
  };

  const color = getSkillColor(activeSkill.key);

  return (
    <div className="skill-bubble-anim" style={{
      position: 'absolute', 
      top: '-35px', 
      left: '50%', 
      transform: 'translateX(-50%)',
      background: color, 
      color: '#000',
      padding: '2px 6px', 
      borderRadius: '4px',
      fontSize: '12px', 
      fontWeight: '900', 
      zIndex: 30,
      boxShadow: '0 2px 5px rgba(0,0,0,0.5)',
      border: '1px solid #000',
      pointerEvents: 'none', // í´ë¦­ ë°©í•´ ê¸ˆì§€
      whiteSpace: 'nowrap'
    }}>
      {activeSkill.key.toUpperCase()}!
      
      {/* ê°„ë‹¨í•œ CSS ì• ë‹ˆë©”ì´ì…˜ ì£¼ì… */}
      <style>{`
        .skill-bubble-anim {
          animation: skillPop 0.3s ease-out forwards;
        }
        @keyframes skillPop {
          0% { transform: translate(-50%, 5px) scale(0.5); opacity: 0; }
          60% { transform: translate(-50%, -5px) scale(1.2); opacity: 1; }
          100% { transform: translate(-50%, 0) scale(1); opacity: 1; }
        }
      `}</style>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/SpectateMap.tsx
==========================================
import React from 'react';
import { useGameStore } from '../../store/useGameStore';

export const SpectateMap: React.FC = () => {
  const { gameState } = useGameStore();
  
  // ì—…ë¡œë“œëœ ë§µ ì´ë¯¸ì§€ê°€ ìˆëŠ”ì§€ í™•ì¸ ('map_bg' í‚¤ ì‚¬ìš©)
  const mapImage = gameState.customImages?.['map_bg'];

  return (
    <div style={{
      position: 'absolute',
      inset: 0,
      background: '#0a0f0a', // ê¸°ë³¸ ë°°ê²½ìƒ‰ (ì´ë¯¸ì§€ ì—†ì„ ë•Œ)
      overflow: 'hidden',
      zIndex: 0
    }}>
      {/* 1. ë§µ ë°°ê²½ ì´ë¯¸ì§€ ë ˆì´ì–´ */}
      {mapImage ? (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundImage: `url(${mapImage})`,
          backgroundSize: '100% 100%', // ë§µì„ ê½‰ ì±„ì›€
          backgroundPosition: 'center',
          backgroundRepeat: 'no-repeat',
          opacity: 0.8, // ìœ ë‹› ì‹œì¸ì„±ì„ ìœ„í•´ ì•½ê°„ ì–´ë‘¡ê²Œ
          filter: 'contrast(1.1) saturate(1.1)' // ê²Œì„ ëŠë‚Œ ë³´ì •
        }} />
      ) : (
        /* ì´ë¯¸ì§€ê°€ ì—†ì„ ë•Œ ë³´ì—¬ì¤„ ê¸°ë³¸ ê²©ì íŒ¨í„´ */
        <div style={{
          width: '100%', height: '100%',
          backgroundImage: 'linear-gradient(#1a1a1c 1px, transparent 1px), linear-gradient(90deg, #1a1a1c 1px, transparent 1px)',
          backgroundSize: '5% 5%',
          opacity: 0.3
        }} />
      )}

      {/* 2. ë¼ì¸ ê°€ì´ë“œ (ì´ë¯¸ì§€ê°€ ìˆì–´ë„ í¬ë¯¸í•˜ê²Œ í‘œì‹œí•˜ì—¬ ê²½ë¡œ í™•ì¸) */}
      <svg width="100%" height="100%" viewBox="0 0 100 100" style={{ position: 'absolute', top: 0, left: 0, opacity: mapImage ? 0.15 : 0.4, pointerEvents:'none' }}>
        <defs>
          <linearGradient id="riverGrad" x1="0%" y1="100%" x2="100%" y2="0%">
            <stop offset="0%" stopColor="#3498db" stopOpacity="0" />
            <stop offset="50%" stopColor="#3498db" stopOpacity="0.5" />
            <stop offset="100%" stopColor="#3498db" stopOpacity="0" />
          </linearGradient>
        </defs>
        
        {/* ê°• (River) */}
        <line x1="0" y1="100" x2="100" y2="0" stroke="url(#riverGrad)" strokeWidth="8" />

        {/* ë¼ì¸ ê²½ë¡œ */}
        <g stroke="rgba(255,255,255,0.3)" strokeWidth="0.5" fill="none" strokeDasharray="2,2">
          {/* TOP */}
          <path d="M 5 95 L 5 20 Q 5 5 20 5 L 95 5" />
          {/* MID */}
          <line x1="5" y1="95" x2="95" y2="5" /> 
          {/* BOT */}
          <path d="M 5 95 L 80 95 Q 95 95 95 80 L 95 5" />
        </g>

        {/* ë³¸ì§„ êµ¬ì—­ í‘œì‹œ */}
        <circle cx="5" cy="95" r="3" fill="#58a6ff" fillOpacity="0.2" />
        <circle cx="95" cy="5" r="3" fill="#e84057" fillOpacity="0.2" />
      </svg>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/spectate/map/UnitRender.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/spectate/map/UnitRender.tsx
// ==========================================
import React from 'react';
import { GameIcon } from '../../../common/GameIcon';
import { Plane, Skull } from 'lucide-react';
import { useGameStore } from '../../../../store/useGameStore';
// [ì‹ ê·œ] ëª¨ë“ˆí™”ëœ ìŠ¤í‚¬ ë§í’ì„  ê°€ì ¸ì˜¤ê¸°
import { SkillBubble } from './objects/SkillBubble';

export const UnitRender = ({ player, isBlue, isSelected, onClick, currentTime }: any) => {
  const { gameState } = useGameStore();
  const maxRecallTime = gameState.growthSettings?.recallTime || 10.0;

  const isDead = player.respawnTimer > 0;
  
  const recallTime = (player as any).currentRecallTime || 0;
  const isRecalling = recallTime > 0 && !isDead;
  
  const remainingRecall = Math.max(0, maxRecallTime - recallTime).toFixed(1);

  const deathTimer = Math.ceil(player.respawnTimer);
  const hasWatcherBuff = player.buffs && player.buffs.includes('WATCHER_BUFF');

  const teamColor = isBlue ? '#58a6ff' : '#e84057';

  return (
    <div 
      id={`unit-${player.heroId}`}
      onClick={onClick}
      style={{
        position: 'absolute',
        left: `${player.x}%`, 
        top: `${player.y}%`,
        transition: (isDead || isRecalling) ? 'none' : 'left 0.5s linear, top 0.5s linear',
        width: '32px', height: '32px', 
        zIndex: isDead ? 5 : 10,
        cursor: 'pointer',
        transform: 'translate(-50%, -50%)',
        opacity: isDead ? 0.6 : 1,
        filter: isDead ? 'grayscale(100%) brightness(0.7)' : 'none'
      }}
    >
      {/* [ëª¨ë“ˆ ì‚¬ìš©] ìŠ¤í‚¬ ë§í’ì„  (ì•ˆì „í•˜ê²Œ ë¶„ë¦¬ë¨) */}
      <SkillBubble activeSkill={player.activeSkill} currentTime={currentTime} isDead={isDead} />

      {/* ê·€í™˜ ì¸ë””ì¼€ì´í„° */}
      {isRecalling && (
        <div style={{
          position: 'absolute', top: -25, left: '50%', transform: 'translateX(-50%)',
          background: 'rgba(0, 0, 0, 0.8)', color: '#3498db',
          padding: '2px 6px', borderRadius: '10px',
          fontSize: '10px', fontWeight: 'bold', whiteSpace: 'nowrap',
          display: 'flex', alignItems: 'center', gap: '2px',
          border: '1px solid #3498db', zIndex: 20
        }}>
          <Plane size={8} style={{ transform:'rotate(-45deg)' }}/> 
          <span>{remainingRecall}s</span>
        </div>
      )}

      {/* ì‚¬ë§ ì¸ë””ì¼€ì´í„° */}
      {isDead && (
        <div style={{
          position: 'absolute', top: -28, left: '50%', transform: 'translateX(-50%)',
          background: 'rgba(218, 54, 51, 0.9)', color: '#fff',
          padding: '2px 8px', borderRadius: '12px',
          fontSize: '11px', fontWeight: '900', whiteSpace: 'nowrap',
          display: 'flex', alignItems: 'center', gap: '4px',
          border: '1px solid #fff', zIndex: 20, boxShadow: '0 0 10px #da3633'
        }}>
          <Skull size={10} /> 
          <span>{deathTimer}s</span>
        </div>
      )}

      {/* ìœ ë‹› ë³¸ì²´ */}
      <div style={{
        width: '100%', height: '100%',
        borderRadius: '50%',
        border: isDead ? '2px solid #555' : `2px solid ${teamColor}`,
        background: '#161b22',
        overflow: 'hidden',
        boxShadow: hasWatcherBuff 
            ? '0 0 15px 5px #a371f7' 
            : (isRecalling ? '0 0 10px rgba(255,255,255,0.5)' : (isSelected ? '0 0 0 2px white' : 'none')),
        boxSizing: 'border-box'
      }}>
         <GameIcon id={player.heroId} size="100%" shape="circle" border="none" />
      </div>

      <div style={{ 
        position: 'absolute', top: -5, right: -5, 
        background: '#000', color: '#fff', 
        fontSize: '9px', fontWeight: 'bold',
        padding: '1px 4px', borderRadius: '4px', 
        border: '1px solid #555', zIndex: 2 
      }}>
        {player.level}
      </div>

      {!isDead && (
        <div style={{ 
          position: 'absolute', bottom: -6, left: '50%', transform: 'translateX(-50%)', 
          width: '36px', height: '5px', 
          background: '#222', border: '1px solid #000', borderRadius: '2px', overflow: 'hidden'
        }}>
           <div style={{ 
             width: `${(player.currentHp / player.maxHp) * 100}%`, 
             height: '100%', 
             background: teamColor,
             transition: 'width 0.2s'
           }} />
        </div>
      )}
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/spectate/modals/HeroDetailPopup.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/spectate/modals/HeroDetailPopup.tsx
// ==========================================
import React, { useMemo, useState } from 'react';
import { X, Sword, Shield, Zap, Activity, Crosshair, Brain, Target, TrendingUp } from 'lucide-react';
import { LivePlayer, Hero, Item } from '../../../../types';
import { GameIcon } from '../../../common/GameIcon';
import { getLevelScaledStats } from '../../../../engine/match/utils/StatUtils';
import { userPool } from '../../../../engine/system/UserManager'; 

interface Props {
  player: LivePlayer;
  hero: Hero;
  onClose: () => void;
}

const ItemDetailBox = ({ item, onClose }: { item: Item, onClose: () => void }) => (
  <div style={{
    position: 'absolute', bottom: '10px', left: '10px', right: '10px',
    background: 'rgba(20, 20, 25, 0.95)', border: '1px solid #58a6ff',
    borderRadius: '8px', padding: '12px', zIndex: 50,
    boxShadow: '0 5px 20px rgba(0,0,0,0.8)', backdropFilter: 'blur(5px)'
  }}>
    <div style={{ display: 'flex', gap: '10px', marginBottom: '8px' }}>
      <GameIcon id={item.id} size={40} shape="square" border="1px solid #555" />
      <div>
        <div style={{ color: '#fff', fontWeight: 'bold', fontSize: '14px' }}>{item.name}</div>
        <div style={{ color: '#f1c40f', fontSize: '11px', fontWeight: 'bold' }}>{item.cost} Gold</div>
        <div style={{ color: '#888', fontSize: '10px' }}>{item.type}</div>
      </div>
      <button onClick={onClose} style={{ position: 'absolute', top: '8px', right: '8px', background: 'none', border: 'none', color: '#666', cursor: 'pointer' }}><X size={16}/></button>
    </div>
    
    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px', marginBottom: '8px' }}>
      {item.ad > 0 && <span className="stat-badge" style={{color:'#ff6b6b'}}>AD +{item.ad}</span>}
      {item.ap > 0 && <span className="stat-badge" style={{color:'#a371f7'}}>AP +{item.ap}</span>}
      {item.hp > 0 && <span className="stat-badge" style={{color:'#2ecc71'}}>HP +{item.hp}</span>}
      {item.armor > 0 && <span className="stat-badge" style={{color:'#58a6ff'}}>DEF +{item.armor}</span>}
      {item.crit > 0 && <span className="stat-badge" style={{color:'#e67e22'}}>CRI +{item.crit}%</span>}
      {item.speed > 0 && <span className="stat-badge" style={{color:'#f1c40f'}}>SPD +{item.speed}</span>}
    </div>
    
    <div style={{ fontSize: '11px', color: '#ccc', lineHeight: '1.4' }}>
      {item.description || "ì„¤ëª…ì´ ì—†ìŠµë‹ˆë‹¤."}
    </div>
    
    <style>{`
      .stat-badge { font-size: 10px; background: rgba(255,255,255,0.1); padding: 2px 5px; borderRadius: 4px; }
    `}</style>
  </div>
);

// ... (PlayerAnalysisPanel ì»´í¬ë„ŒíŠ¸ëŠ” ê¸°ì¡´ê³¼ ë™ì¼, ìƒëµ ì—†ì´ ì „ì²´ í¬í•¨)
const PlayerAnalysisPanel = ({ name, liveStats }: { name: string, liveStats: { brain: number, mechanics: number } }) => {
  const user = userPool.find(u => u.name === name);
  const winRate = user?.winRate || 50;
  const playStyle = user?.playStyle || 'WORKER';
  
  const combat = Math.min(100, winRate + 40);
  const brain = liveStats.brain;
  const mechanics = liveStats.mechanics;
  const potential = user ? Math.min(100, (user.hiddenMmr / 3000) * 100) : 50;

  const getBarColor = (val: number) => {
    if (val >= 80) return '#e74c3c';
    if (val >= 60) return '#f1c40f';
    if (val >= 40) return '#2ecc71';
    return '#8b949e';
  };

  const tags = [];
  if (playStyle === 'HARDCORE') tags.push({ label: 'ğŸ”¥ íì¸', color: '#da3633' });
  if (playStyle === 'WORKER') tags.push({ label: 'ğŸ’¼ ì§ì¥ì¸', color: '#3498db' });
  
  if (winRate >= 55) tags.push({ label: 'ğŸ† ìŠ¹ë¦¬ì™•', color: '#e74c3c' });
  else if (winRate <= 45) tags.push({ label: 'ğŸ“‰ ì—°íŒ¨ì¤‘', color: '#7f8c8d' });

  if (brain > 70) tags.push({ label: 'ğŸ§  ë‡Œì§€ì»¬', color: '#2ecc71' });
  if (mechanics > 70) tags.push({ label: 'âš¡ í”¼ì§€ì»¬', color: '#e67e22' });

  const StatBar = ({ label, value, icon }: any) => (
    <div style={{ marginBottom: '6px' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '10px', color: '#ccc', marginBottom: '2px' }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>{icon} {label}</div>
        <span style={{ fontWeight: 'bold', color: getBarColor(value) }}>{value.toFixed(0)}</span>
      </div>
      <div style={{ width: '100%', height: '5px', background: '#30363d', borderRadius: '3px', overflow: 'hidden' }}>
        <div style={{ width: `${value}%`, height: '100%', background: getBarColor(value) }} />
      </div>
    </div>
  );

  return (
    <div style={{ background: '#161b22', padding: '12px', borderRadius: '8px', border: '1px solid #30363d', marginBottom: '15px' }}>
      <div style={{ fontSize:'11px', fontWeight:'bold', color:'#fff', marginBottom:'8px', display:'flex', alignItems:'center', gap:'4px' }}>
        <Activity size={12} color="#58a6ff"/> í”Œë ˆì´ì–´ ë¶„ì„
      </div>
      <div style={{ display: 'flex', flexWrap: 'wrap', gap: '4px', marginBottom: '12px' }}>
        {tags.map((t, i) => (
          <span key={i} style={{ fontSize: '10px', color: t.color, border: `1px solid ${t.color}44`, background: `${t.color}11`, padding: '1px 6px', borderRadius: '4px', fontWeight: 'bold' }}>
            {t.label}
          </span>
        ))}
      </div>
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px' }}>
        <StatBar label="ì „íˆ¬ë ¥" value={combat} icon={<TrendingUp size={10}/>} />
        <StatBar label="ìš´ì˜ëŠ¥ë ¥" value={brain} icon={<Brain size={10}/>} />
        <StatBar label="ì»¨íŠ¸ë¡¤" value={mechanics} icon={<Zap size={10}/>} />
        <StatBar label="ì„±ì¥ë ¥" value={potential} icon={<Target size={10}/>} />
      </div>
    </div>
  );
};

export const HeroDetailPopup: React.FC<Props> = ({ player, hero, onClose }) => {
  const [viewingItem, setViewingItem] = useState<Item | null>(null);

  const stats = useMemo(() => {
    const base = getLevelScaledStats(hero.stats, player.level);
    const bonus = { ad: 0, ap: 0, armor: 0, hp: 0, speed: 0, crit: 0 };
    player.items.forEach(item => {
      bonus.ad += (item.ad || 0);
      bonus.ap += (item.ap || 0);
      bonus.armor += (item.armor || 0);
      bonus.hp += (item.hp || 0);
      bonus.speed += (item.speed || 0);
      bonus.crit += (item.crit || 0);
    });
    return { base, bonus };
  }, [player, hero]);

  const hpPercent = (player.currentHp / player.maxHp) * 100;
  const mpPercent = player.maxMp > 0 ? (player.currentMp / player.maxMp) * 100 : 0;

  const StatRow = ({ label, icon, baseVal, bonusVal, unit = '' }: any) => (
    <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', background:'#1c1c1f', padding:'6px 10px', borderRadius:'4px', marginBottom:'4px', border:'1px solid #30363d' }}>
      <div style={{ display:'flex', alignItems:'center', gap:'6px', fontSize:'11px', color:'#aaa' }}>{icon} {label}</div>
      <div style={{ fontSize:'12px', fontWeight:'bold', fontFamily:'monospace' }}>
        <span style={{ color:'#fff' }}>{Math.floor(baseVal)}</span>
        {bonusVal > 0 && <span style={{ color:'#a371f7' }}> +{Math.floor(bonusVal)}</span>}
        <span style={{ color:'#666', fontSize:'10px' }}>{unit}</span>
      </div>
    </div>
  );

  return (
    <div style={{
      position: 'fixed', inset: 0, zIndex: 20000,
      background: 'rgba(0,0,0,0.85)', backdropFilter: 'blur(5px)',
      display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '20px'
    }}>
      <div style={{ 
        width: '100%', maxWidth: '380px', maxHeight: '90vh',
        background: '#0d1117', border: '1px solid #30363d', borderRadius: '16px',
        display: 'flex', flexDirection: 'column', overflow: 'hidden', position:'relative',
        boxShadow: '0 20px 50px rgba(0,0,0,0.9)'
      }}>
        <div style={{ padding: '12px 15px', background: '#161b22', borderBottom: '1px solid #30363d', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <h3 style={{ margin: 0, color: '#fff', fontSize: '14px', fontWeight:'bold' }}>ì„ ìˆ˜ ìƒì„¸ ì •ë³´</h3>
          <button onClick={onClose} style={{ background:'none', border:'none', color:'#ccc', cursor:'pointer' }}><X size={18}/></button>
        </div>

        <div style={{ overflowY: 'auto', padding: '15px' }}>
          <div style={{ display: 'flex', gap: '15px', marginBottom: '20px' }}>
            <div style={{ position:'relative' }}>
              <GameIcon id={player.heroId} size={64} shape="rounded" border="2px solid #58a6ff" />
              <div style={{ position:'absolute', bottom:-6, left:'50%', transform:'translateX(-50%)', background:'#000', color:'#fff', fontSize:'10px', fontWeight:'bold', padding:'1px 5px', borderRadius:'4px', border:'1px solid #444', whiteSpace:'nowrap' }}>Lv.{player.level}</div>
            </div>
            <div style={{ flex: 1, display:'flex', flexDirection:'column', justifyContent:'center' }}>
              <div style={{ fontSize:'16px', fontWeight:'bold', color:'#fff', marginBottom:'2px' }}>{player.name}</div>
              <div style={{ fontSize:'12px', color:'#888', marginBottom:'6px' }}>{hero.name} ({hero.role})</div>
              <div style={{ display:'flex', justifyContent:'space-between', fontSize:'9px', color:'#2ecc71', fontWeight:'bold', marginBottom:'2px' }}><span>HP</span><span>{Math.floor(player.currentHp)}/{player.maxHp}</span></div>
              <div style={{ width:'100%', height:'6px', background:'#1a1a1c', borderRadius:'3px', overflow:'hidden', marginBottom:'4px' }}><div style={{ width:`${hpPercent}%`, height:'100%', background:'#2ecc71', transition:'width 0.2s' }} /></div>
              <div style={{ display:'flex', justifyContent:'space-between', fontSize:'9px', color:'#3498db', fontWeight:'bold', marginBottom:'2px' }}><span>MP</span><span>{Math.floor(player.currentMp)}/{player.maxMp}</span></div>
              <div style={{ width:'100%', height:'6px', background:'#1a1a1c', borderRadius:'3px', overflow:'hidden' }}><div style={{ width:`${mpPercent}%`, height:'100%', background:'#3498db', transition:'width 0.2s' }} /></div>
            </div>
          </div>

          <PlayerAnalysisPanel name={player.name} liveStats={player.stats} />

          <div style={{ marginBottom: '15px' }}>
            <div style={{ fontSize:'11px', fontWeight:'bold', color:'#8b949e', marginBottom:'6px' }}>ì „íˆ¬ ìŠ¤íƒ¯</div>
            <StatRow label="ê³µê²©ë ¥" icon={<Sword size={12} color="#e74c3c"/>} baseVal={stats.base.ad} bonusVal={stats.bonus.ad} />
            <StatRow label="ì£¼ë¬¸ë ¥" icon={<Zap size={12} color="#9b59b6"/>} baseVal={stats.base.ap} bonusVal={stats.bonus.ap} />
            <StatRow label="ë°©ì–´ë ¥" icon={<Shield size={12} color="#3498db"/>} baseVal={stats.base.armor} bonusVal={stats.bonus.armor} />
            <StatRow label="ì´ë™ì†ë„" icon={<Activity size={12} color="#f1c40f"/>} baseVal={stats.base.speed} bonusVal={stats.bonus.speed} />
            <StatRow label="ì¹˜ëª…íƒ€" icon={<Crosshair size={12} color="#e67e22"/>} baseVal={stats.base.crit} bonusVal={stats.bonus.crit} unit="%" />
          </div>

          <div>
            <div style={{ fontSize:'11px', fontWeight:'bold', color:'#8b949e', marginBottom:'6px', display:'flex', justifyContent:'space-between' }}>
                <span>ì•„ì´í…œ</span>
                <span style={{ color:'#f1c40f' }}>{(player.gold/1000).toFixed(1)}k G</span>
            </div>
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(6, 1fr)', gap: '6px' }}>
              {[0,1,2,3,4,5].map(idx => {
                const item = player.items[idx];
                return (
                  <div key={idx} onClick={() => item && setViewingItem(item)} style={{ aspectRatio:'1/1', background:'#161b22', border:'1px solid #333', borderRadius:'4px', display:'flex', alignItems:'center', justifyContent:'center', overflow:'hidden', position:'relative', cursor: item ? 'pointer' : 'default', boxShadow: item && viewingItem?.id === item.id ? '0 0 0 2px #58a6ff' : 'none' }}>
                    {item ? (
                        <>
                            <GameIcon id={item.id} size="100%" shape="square" border="none" />
                            {item.type === 'POWER' && <div style={{position:'absolute', inset:0, border:'2px solid #a371f7', borderRadius:'4px'}}/>}
                        </>
                    ) : <div style={{ fontSize:'8px', color:'#333' }}>-</div>}
                  </div>
                );
              })}
            </div>
          </div>
        </div>

        {viewingItem && <ItemDetailBox item={viewingItem} onClose={() => setViewingItem(null)} />}
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/SpectateModal.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/SpectateModal.tsx
// ==========================================
import React, { Component, ErrorInfo, useState } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { DraftScreen } from './spectate/DraftScreen';
import { InGameScreen } from './spectate/InGameScreen';
import { AlertTriangle } from 'lucide-react';
import { Hero } from '../../types';

// ì—ëŸ¬ ë°”ìš´ë”ë¦¬ (ê·¸ëŒ€ë¡œ ìœ ì§€)
class ErrorBoundary extends Component<{ children: React.ReactNode }, { hasError: boolean, errorMsg: string }> {
  constructor(props: any) { super(props); this.state = { hasError: false, errorMsg: "" }; }
  static getDerivedStateFromError(error: any) { return { hasError: true, errorMsg: error.toString() }; }
  render() {
    if (this.state.hasError) {
      return (
        <div style={{ padding: '40px', color: '#ff6b6b', textAlign: 'center', background:'#111', height:'100%', display:'flex', flexDirection:'column', justifyContent:'center', alignItems:'center' }}>
          <AlertTriangle size={40} style={{ marginBottom: '20px' }} />
          <h3>í™”ë©´ ë¡œë“œ ì‹¤íŒ¨</h3>
          <p style={{ fontSize: '12px', color: '#888' }}>{this.state.errorMsg}</p>
          <button onClick={() => window.location.reload()} style={{ marginTop:'20px', padding:'10px', cursor:'pointer' }}>ìƒˆë¡œê³ ì¹¨</button>
        </div>
      );
    }
    return this.props.children;
  }
}

// ë©”ì¸ ì»¨í…ì¸  ë¶„ê¸° ì²˜ë¦¬
const SpectateContent: React.FC<any> = ({ match: initialMatch, onClose }) => {
  // Store êµ¬ë… (ì‹¤ì‹œê°„ ë°ì´í„°)
  const match = useGameStore(state => state.gameState.liveMatches.find(m => m.id === initialMatch.id));
  const { heroes, setSpeed, gameState } = useGameStore();

  const [viewingBanHero, setViewingBanHero] = useState<Hero | null>(null);

  if (!match) {
    return (
      <div style={{color:'white', padding:'20px', textAlign:'center', display:'flex', flexDirection:'column', height:'100%', justifyContent:'center', alignItems:'center'}}>
        <h3 style={{marginBottom:'20px'}}>ê²Œì„ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.</h3>
        <button onClick={onClose} style={{padding:'10px 30px', cursor:'pointer', background:'#333', color:'#fff', border:'1px solid #555', borderRadius:'8px'}}>ë‚˜ê°€ê¸°</button>
      </div>
    );
  }

  // ë°´í”½ í™”ë©´
  if (match.status === 'DRAFTING' && (match.draft?.turnIndex || 0) < 20) {
    return (
      <DraftScreen 
        match={match} heroes={heroes} onClose={onClose} 
        setSpeed={setSpeed} gameState={gameState}
        onBanClick={setViewingBanHero}
      />
    );
  }

  // ì¸ê²Œì„ í™”ë©´
  return <InGameScreen match={match} onClose={onClose} />;
};

export const SpectateModal: React.FC<any> = (props) => {
  return (
    <div style={{ position: 'fixed', inset: 0, background: '#050505', zIndex: 30000 }}>
      <ErrorBoundary>
        <SpectateContent {...props} />
      </ErrorBoundary>
    </div>
  );
};


==========================================
FILE PATH: src/components/battle/spectate/PersonalLogView.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/spectate/PersonalLogView.tsx
// ==========================================
import React, { useMemo, useRef, useEffect } from 'react';
import { Activity } from 'lucide-react';

export const PersonalLogView = ({ logs, heroName, summonerName, formatTime }: any) => {
  const scrollRef = useRef<HTMLDivElement>(null);

  const filteredLogs = useMemo(() => {
    return logs.filter((log: any) => 
      log.message.includes(heroName) || log.message.includes(summonerName)
    ).reverse().slice(0, 50); 
  }, [logs, heroName, summonerName]);

  useEffect(() => {
    if (scrollRef.current) scrollRef.current.scrollTop = 0;
  }, [filteredLogs.length]);

  return (
    <div style={{ width: '100%', maxWidth: '450px', background: '#08080a', borderRadius: '8px', border: '1px solid #222', marginTop: '15px', overflow: 'hidden' }}>
      <div style={{ padding: '8px 12px', background: '#121214', borderBottom: '1px solid #222', display: 'flex', alignItems: 'center', gap: '6px' }}>
        <Activity size={12} color="#58a6ff" />
        <span style={{ fontSize: '11px', color: '#fff', fontWeight: 'bold' }}>{heroName} í™œë™ ë‚´ì—­</span>
      </div>
      <div ref={scrollRef} style={{ height: '200px', overflowY: 'auto', padding: '8px' }}>
        {filteredLogs.length > 0 ? filteredLogs.map((log: any, i: number) => (
          <div key={i} style={{ fontSize: '11px', padding: '5px 0', borderBottom: '1px solid #1a1a1c', display: 'flex', gap: '8px' }}>
            <span style={{ color: '#555', fontFamily: 'monospace', flexShrink: 0 }}>{formatTime(log.time)}</span>
            <span style={{ color: log.type === 'KILL' ? '#ff4d4d' : '#ccc', lineHeight: '1.4' }}>{log.message}</span>
          </div>
        )) : (
          <div style={{ padding: '40px 0', textAlign: 'center', color: '#444', fontSize: '11px' }}>ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>
        )}
      </div>
    </div>
  );
};


==========================================
FILE PATH: src/components/battle/spectate/SmallComponents.tsx
==========================================
// === FILE: /src/components/battle/spectate/SmallComponents.tsx ===

// ==========================================
// FILE PATH: /src/components/battle/spectate/SmallComponents.tsx
// ==========================================
import React from 'react';
import { X, Ban, Skull, Eye } from 'lucide-react'; 
import { GameIcon } from '../../common/GameIcon';

export const SpeedButton = ({ label, speed, currentSpeed, setSpeed }: any) => (
  <button 
    onClick={() => setSpeed(speed)} 
    style={{ 
      flex: 1, padding: '4px 0', 
      background: currentSpeed === speed ? '#58a6ff' : '#1c1c1f', 
      border: `1px solid ${currentSpeed === speed ? '#58a6ff' : '#333'}`, 
      borderRadius: '4px', color: currentSpeed === speed ? '#000' : '#888', 
      fontSize: '10px', fontWeight: '800', cursor: 'pointer', height: '24px'
    }}
  >
    {label}
  </button>
);

export const BanCard = ({ heroId, heroes, onClick }: any) => {
  const isValid = heroId && typeof heroId === 'string' && heroId.length > 0;
  return (
    <div 
      onClick={() => isValid && onClick && onClick(heroId)} 
      style={{ position: 'relative', width: '22px', height: '22px', borderRadius: '3px', overflow: 'hidden', background:'#111', border:'1px solid #333', cursor: isValid ? 'pointer' : 'default' }}
    >
      {isValid ? (
        <>
          <div style={{ filter: 'grayscale(100%) brightness(0.5)' }}><GameIcon id={heroId} size={22} shape="square" /></div>
          <div style={{ position: 'absolute', top: '50%', left: '50%', width: '140%', height: '2px', backgroundColor: '#da3633', transform: 'translate(-50%, -50%) rotate(45deg)' }} />
        </>
      ) : <div style={{ width:'100%', height:'100%', display:'flex', alignItems:'center', justifyContent:'center' }}><Ban size={10} color="#333"/></div>}
    </div>
  );
};

export const NeutralObjBar = ({ obj, label, color, icon }: any) => {
  if (!obj) return null;
  const isAlive = obj.status === 'ALIVE';
  const percent = isAlive ? (obj.hp / obj.maxHp) * 100 : 0;
  return (
    <div style={{ flex: 1, background: '#121214', padding: '6px 10px', borderRadius: '4px', border: '1px solid #333' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '3px', fontSize: '9px', fontWeight: 'bold' }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '4px', color: color }}>{icon} {label}</div>
        <span style={{ color: isAlive ? '#fff' : '#666' }}>{isAlive ? `${Math.ceil(obj.hp).toLocaleString()}` : 'SPAWN'}</span>
      </div>
      <div style={{ width: '100%', height: '3px', background: '#000', borderRadius: '1px', overflow: 'hidden' }}>
         <div style={{ width: `${percent}%`, height: '100%', background: isAlive ? color : '#333', transition: 'width 0.3s' }} />
      </div>
    </div>
  );
};

export const ObjectStatBox = ({ stats, color, side }: any) => {
  if (!stats) return null;
  const hpPercent = (stats.nexusHp / stats.maxNexusHp) * 100;
  const TowerIndicator = ({ label, brokenCount }: any) => (
    <div style={{ display: 'flex', alignItems: 'center', gap: '4px', fontSize: '9px', color:'#555' }}>
      <span style={{ width:'18px' }}>{label}</span>
      <div style={{ display: 'flex', gap: '1px' }}>
        {[1, 2, 3].map(tier => (
          <div key={tier} style={{ width: '6px', height: '6px', borderRadius: '1px', background: tier <= brokenCount ? '#222' : color, opacity: tier <= brokenCount ? 0.2 : 1 }} />
        ))}
      </div>
    </div>
  );
  return (
    <div style={{ background: '#121214', border: `1px solid ${color}22`, borderRadius: '6px', padding: '8px', flex: 1 }}>
      <div style={{ display:'flex', justifyContent:'space-between', alignItems:'flex-start' }}>
        <div>
          <div style={{ fontSize:'9px', color: color, fontWeight:'900', marginBottom:'2px' }}>{side}</div>
          <TowerIndicator label="TOP" brokenCount={stats.towers?.top || 0} />
          <TowerIndicator label="MID" brokenCount={stats.towers?.mid || 0} />
          <TowerIndicator label="BOT" brokenCount={stats.towers?.bot || 0} />
        </div>
        <div style={{ display:'flex', flexDirection:'column', gap:'4px', marginTop:'15px' }}>
           <div style={{ display:'flex', alignItems:'center', gap:'4px', fontSize:'11px', color:'#ccc', fontWeight:'bold' }}><Skull size={10} color="#7ee787"/> {stats.colossus || 0}</div>
           <div style={{ display:'flex', alignItems:'center', gap:'4px', fontSize:'11px', color:'#ccc', fontWeight:'bold' }}><Eye size={10} color="#a371f7"/> {stats.watcher || 0}</div>
        </div>
        <div style={{ textAlign:'right' }}>
           <div style={{ fontSize:'8px', color:'#666' }}>NEXUS</div>
           <div style={{ fontSize:'12px', fontWeight:'900', color: hpPercent < 30 ? '#da3633' : '#fff' }}>{Math.max(0, Math.ceil(stats.nexusHp)).toLocaleString()}</div>
           <div style={{ width:'50px', height:'3px', background:'#222', borderRadius:'1px', marginTop:'2px', overflow:'hidden' }}>
              <div style={{ width:`${hpPercent}%`, height:'100%', background: hpPercent < 30 ? '#da3633' : color }} />
           </div>
        </div>
      </div>
    </div>
  );
};

export const PlayerCard = ({ p, isSelected, onClick, heroName, teamColor }: any) => {
  if (!p) return null;
  const currentHp = p.currentHp || 0;
  const maxHp = p.maxHp || 1;
  const hpPercent = (currentHp / maxHp) * 100;
  const isDead = currentHp <= 0;
  
  return (
    <div onClick={onClick} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '4px 8px', background: isSelected ? `${teamColor}15` : '#161b22', borderRadius: '4px', border: isSelected ? `1px solid ${teamColor}` : '1px solid #30363d', marginBottom: '4px', cursor: 'pointer', height: '34px', opacity: isDead ? 0.6 : 1, filter: isDead ? 'grayscale(0.8)' : 'none', position: 'relative', overflow:'hidden' }}>
      <div style={{ position: 'relative', display:'flex', alignItems:'center', gap:'8px' }}>
        <GameIcon id={p.heroId || ''} size={28} shape="rounded" />
        <div>
          <div style={{ fontSize: '11px', fontWeight: 'bold', color: '#fff' }}>{heroName}</div>
          <div style={{ fontSize: '9px', color: '#8b949e' }}>{p.name}</div>
        </div>
      </div>
      <div style={{ textAlign: 'right' }}>
        <div style={{ fontSize: '11px', fontWeight: 'bold', color: '#fff' }}>{p.kills}/{p.deaths}/{p.assists}</div>
        <div style={{ fontSize: '9px', color: '#8b949e' }}>{((p.gold||0)/1000).toFixed(1)}k | {p.cs||0}cs</div>
      </div>
      <div style={{ position: 'absolute', bottom: 0, left: 0, width: '100%', height: '2px', background: 'rgba(0,0,0,0.3)' }}>
        <div style={{ width: `${hpPercent}%`, height: '100%', background: hpPercent < 30 ? '#da3633' : teamColor }} />
      </div>
    </div>
  );
};

export const DraftScreen = ({ match, heroes, onClose }: { match: any, heroes: any[], onClose: () => void }) => {
  // [Safety] matchê°€ nullì¼ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ê¸°ë³¸ê°’ ì„¤ì •
  const safeMatch = match || {};
  const blueTeam = safeMatch.blueTeam || [];
  const redTeam = safeMatch.redTeam || [];
  
  // draft ê°ì²´ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ì ìœ¼ë¡œ 0ìœ¼ë¡œ ì²˜ë¦¬ (Crash ë°©ì§€)
  const timer = Math.ceil(safeMatch.draft?.timer || 0);
  const turn = safeMatch.draft?.turnIndex || 0;
  
  const isPickPhase = turn >= 10;
  const isBanPhase = turn < 10;

  // í˜„ì¬ í”½ ìˆœì„œ ê³„ì‚° (í•˜ì´ë¼ì´íŠ¸ìš©)
  const pickIndex = isPickPhase ? turn - 10 : -1;
  const currentPickTeam = pickIndex >= 0 && pickIndex % 2 === 0 ? 'BLUE' : 'RED';
  const currentPickSlot = pickIndex >= 0 ? Math.floor(pickIndex / 2) : -1;

  const DraftPlayerSlot = ({ player, index, side }: { player: any, index: number, side: 'BLUE' | 'RED' }) => {
    if (!player) return <div style={{ height:'50px' }}></div>; // í”Œë ˆì´ì–´ ë°ì´í„° ì—†ìœ¼ë©´ ë¹ˆ ê³µê°„

    const isPicking = isPickPhase && currentPickTeam === side && currentPickSlot === index;
    const isPicked = !!player.heroId; // ì´ë¯¸ í”½ì´ ë˜ì—ˆëŠ”ì§€

    return (
      <div style={{
        marginBottom:'8px', 
        display:'flex', gap:'10px', alignItems:'center', 
        flexDirection: side === 'RED' ? 'row-reverse' : 'row',
        opacity: isPicked ? 1 : 0.5, // í”½ ì „ì—ëŠ” ë°˜íˆ¬ëª…
        transition: '0.2s',
        transform: isPicking ? 'scale(1.05)' : 'scale(1)'
      }}>
        <div style={{
          border: isPicking ? `2px solid ${side === 'BLUE' ? '#58a6ff' : '#e84057'}` : '1px solid #333',
          borderRadius: '12px',
          boxShadow: isPicking ? `0 0 15px ${side === 'BLUE' ? '#58a6ff' : '#e84057'}44` : 'none',
          position: 'relative'
        }}>
          {/* ì˜ì›… IDê°€ ì—†ìœ¼ë©´ ë¬¼ìŒí‘œ ë Œë”ë§ (GameIcon ë‚´ë¶€ ì²˜ë¦¬) */}
          <GameIcon id={player.heroId || ''} size={50} shape="square"/>
          
          {/* í”½ ì¤‘ì¼ ë•Œ ë¡œë”© ì¸ë””ì¼€ì´í„° */}
          {isPicking && (
            <div style={{ position:'absolute', inset:0, border:'2px solid #fff', borderRadius:'10px', animation:'pulse 1s infinite' }} />
          )}
        </div>
        <div style={{ textAlign: side === 'RED' ? 'right' : 'left' }}>
          <div style={{ fontSize:'12px', fontWeight:'bold', color: isPicking ? '#fff' : '#aaa' }}>{player.name}</div>
          <div style={{ fontSize:'10px', color: '#666' }}>{player.lane}</div>
        </div>
      </div>
    );
  };

  return (
    <div style={{ height:'100%', display:'flex', flexDirection:'column', alignItems:'center', justifyContent:'center', background:'#0d1117' }}>
      <button onClick={onClose} style={{ position:'absolute', right:'20px', top:'20px', background:'none', border:'none', color:'#fff', cursor:'pointer' }}><X size={30}/></button>
      
      <div style={{ marginBottom:'40px', textAlign:'center' }}>
        <h2 style={{ color:'#fff', fontSize:'24px', margin:'0 0 10px 0' }}>DRAFT PHASE</h2>
        <div style={{ fontSize:'14px', color:'#888', marginBottom:'5px' }}>
            {isBanPhase ? 'â›” ì±”í”¼ì–¸ ê¸ˆì§€ ì§„í–‰ ì¤‘...' : 'âš”ï¸ ì±”í”¼ì–¸ ì„ íƒ ì§„í–‰ ì¤‘...'}
        </div>
        <div style={{ fontSize:'32px', fontWeight:'900', color: timer <= 5 ? '#da3633' : '#fff' }}>{timer}</div>
      </div>

      <div style={{ display:'flex', width:'90%', maxWidth:'800px', justifyContent:'space-between' }}>
        {/* BLUE TEAM */}
        <div style={{ width:'40%', color:'#58a6ff' }}>
          <h3 style={{ borderBottom:'1px solid #58a6ff44', paddingBottom:'10px', marginBottom:'15px', margin:0 }}>BLUE TEAM</h3>
          {blueTeam.map((p: any, i: number) => <DraftPlayerSlot key={i} player={p} index={i} side="BLUE" />)}
        </div>

        {/* RED TEAM */}
        <div style={{ width:'40%', color:'#e84057', textAlign:'right' }}>
          <h3 style={{ borderBottom:'1px solid #e8405744', paddingBottom:'10px', marginBottom:'15px', margin:0 }}>RED TEAM</h3>
          {redTeam.map((p: any, i: number) => <DraftPlayerSlot key={i} player={p} index={i} side="RED" />)}
        </div>
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/spectate/SpectateMap.tsx
==========================================
import React from 'react';
import { useGameStore } from '../../../store/useGameStore';

export const SpectateMap: React.FC = () => {
  const { gameState } = useGameStore();
  
  // ì—…ë¡œë“œëœ ë§µ ì´ë¯¸ì§€ê°€ ìˆëŠ”ì§€ í™•ì¸ ('map_bg' í‚¤ ì‚¬ìš©)
  const mapImage = gameState.customImages?.['map_bg'];

  return (
    <div style={{
      position: 'absolute',
      inset: 0,
      background: '#0a0f0a', // ê¸°ë³¸ ë°°ê²½ìƒ‰ (ì´ë¯¸ì§€ ì—†ì„ ë•Œ)
      overflow: 'hidden',
      zIndex: 0
    }}>
      {/* 1. ë§µ ë°°ê²½ ì´ë¯¸ì§€ ë ˆì´ì–´ */}
      {mapImage ? (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundImage: `url(${mapImage})`,
          backgroundSize: '100% 100%', // ë§µì„ ê½‰ ì±„ì›€
          backgroundPosition: 'center',
          backgroundRepeat: 'no-repeat',
          opacity: 0.8, // ìœ ë‹› ì‹œì¸ì„±ì„ ìœ„í•´ ì•½ê°„ ì–´ë‘¡ê²Œ
          filter: 'contrast(1.1) saturate(1.1)' // ê²Œì„ ëŠë‚Œ ë³´ì •
        }} />
      ) : (
        /* ì´ë¯¸ì§€ê°€ ì—†ì„ ë•Œ ë³´ì—¬ì¤„ ê¸°ë³¸ ê²©ì íŒ¨í„´ */
        <div style={{
          width: '100%', height: '100%',
          backgroundImage: 'linear-gradient(#1a1a1c 1px, transparent 1px), linear-gradient(90deg, #1a1a1c 1px, transparent 1px)',
          backgroundSize: '5% 5%',
          opacity: 0.3
        }} />
      )}

      {/* 2. ë¼ì¸ ê°€ì´ë“œ (ì´ë¯¸ì§€ê°€ ìˆì–´ë„ í¬ë¯¸í•˜ê²Œ í‘œì‹œí•˜ì—¬ ê²½ë¡œ í™•ì¸) */}
      <svg width="100%" height="100%" viewBox="0 0 100 100" style={{ position: 'absolute', top: 0, left: 0, opacity: mapImage ? 0.15 : 0.4, pointerEvents:'none' }}>
        <defs>
          <linearGradient id="riverGrad" x1="0%" y1="100%" x2="100%" y2="0%">
            <stop offset="0%" stopColor="#3498db" stopOpacity="0" />
            <stop offset="50%" stopColor="#3498db" stopOpacity="0.5" />
            <stop offset="100%" stopColor="#3498db" stopOpacity="0" />
          </linearGradient>
        </defs>
        
        {/* ê°• (River) */}
        <line x1="0" y1="100" x2="100" y2="0" stroke="url(#riverGrad)" strokeWidth="8" />

        {/* ë¼ì¸ ê²½ë¡œ */}
        <g stroke="rgba(255,255,255,0.3)" strokeWidth="0.5" fill="none" strokeDasharray="2,2">
          {/* TOP */}
          <path d="M 5 95 L 5 20 Q 5 5 20 5 L 95 5" />
          {/* MID */}
          <line x1="5" y1="95" x2="95" y2="5" /> 
          {/* BOT */}
          <path d="M 5 95 L 80 95 Q 95 95 95 80 L 95 5" />
        </g>

        {/* ë³¸ì§„ êµ¬ì—­ í‘œì‹œ */}
        <circle cx="5" cy="95" r="3" fill="#58a6ff" fillOpacity="0.2" />
        <circle cx="95" cy="5" r="3" fill="#e84057" fillOpacity="0.2" />
      </svg>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/spectate/SpectateUI.tsx
==========================================
import React from 'react';
import { GameIcon } from '../../common/GameIcon';
import { Ban, Skull, Eye, Shield, Sword, Target, Zap, Crosshair } from 'lucide-react';

export const SpeedButton = ({ label, speed, currentSpeed, setSpeed }: any) => (
  <button 
    onClick={() => setSpeed(speed)} 
    style={{ 
      flex: 1, padding: '6px 0', 
      background: currentSpeed === speed ? '#00b894' : '#2d3436', 
      border: `1px solid ${currentSpeed === speed ? '#00b894' : '#444'}`, 
      borderRadius: '4px', color: '#fff', 
      fontSize: '10px', fontWeight: 'bold', cursor: 'pointer', height: '28px'
    }}
  >
    {label}
  </button>
);

export const BanCard = ({ heroId, heroes, onClick }: any) => {
  return (
    <div 
      onClick={() => heroId && onClick && onClick(heroId)}
      style={{ 
        width: '30px', height: '30px', borderRadius: '4px', overflow: 'hidden', 
        background:'#1e1e1e', border: '1px solid #444', position:'relative',
        display:'flex', alignItems:'center', justifyContent:'center',
        flexShrink: 0
      }}
    >
      {heroId ? (
        <>
          <div style={{ filter: 'grayscale(100%) opacity(0.7)' }}><GameIcon id={heroId} size={30} shape="square" /></div>
          <div style={{ position: 'absolute', width: '140%', height: '2px', backgroundColor: '#d63031', transform: 'rotate(45deg)' }} />
        </>
      ) : <Ban size={12} color="#444"/>}
    </div>
  );
};

const RoleIcon = ({ lane }: { lane: string }) => {
  switch(lane) {
    case 'TOP': return <Shield size={9} color="#e74c3c"/>;
    case 'JUNGLE': return <Sword size={9} color="#2ecc71"/>;
    case 'MID': return <Zap size={9} color="#3498db"/>;
    case 'BOT': return <Crosshair size={9} color="#f1c40f"/>;
    default: return <Skull size={9} color="#9b59b6"/>;
  }
};

export const PlayerCard = ({ p, isSelected, onClick, heroName, teamColor }: any) => {
  if (!p) return null;

  const isDead = p.respawnTimer > 0;
  const kda = `${p.kills}/${p.deaths}/${p.assists}`;
  
  // [ìˆ˜ì •] ëˆ„ì  ê³¨ë“œ ê³„ì‚° ë¡œì§ ê°•í™”
  // totalGoldê°€ ìˆìœ¼ë©´ ì“°ê³ , ì—†ìœ¼ë©´ (í˜„ì¬ê³¨ë“œ + ì•„ì´í…œê°€ì¹˜)ë¡œ ì¶”ì •í•´ì„œ ë³´ì—¬ì¤Œ
  let totalGoldVal = p.totalGold;
  if (totalGoldVal === undefined || totalGoldVal < p.gold) {
      const itemsVal = (p.items || []).reduce((sum: number, i: any) => sum + (i.cost || 0), 0);
      totalGoldVal = Math.floor(p.gold + itemsVal);
  }
  
  const goldStr = `${(totalGoldVal / 1000).toFixed(1)}k`;
  
  const dmg = p.totalDamageDealt > 1000 
    ? `${(p.totalDamageDealt / 1000).toFixed(1)}k` 
    : p.totalDamageDealt;

  return (
    <div onClick={onClick} style={{ 
      display: 'flex', alignItems: 'center', 
      background: '#1e1e1e', 
      borderRadius: '4px', 
      border: isSelected ? `1px solid ${teamColor}` : '1px solid #333',
      borderLeft: `3px solid ${teamColor}`, 
      marginBottom: '6px', 
      padding: '4px 6px',
      cursor: 'pointer', 
      minHeight: '56px', 
      flexShrink: 0,
      opacity: isDead ? 0.5 : 1,
      position: 'relative',
      overflow: 'hidden',
      boxShadow: '0 2px 4px rgba(0,0,0,0.3)'
    }}>
      <div style={{ position:'relative', marginRight:'8px', flexShrink: 0 }}>
        <GameIcon id={p.heroId} size={42} shape="rounded" />
        <div style={{ position:'absolute', bottom:-2, right:-2, background:'#000', color:'#fff', fontSize:'10px', fontWeight:'bold', padding:'0 3px', borderRadius:'3px', border:'1px solid #555' }}>
          {p.level}
        </div>
      </div>

      <div style={{ flex: 1, display:'flex', flexDirection:'column', justifyContent:'center', minWidth: 0, gap:'1px' }}>
        <div style={{ fontSize: '12px', fontWeight: 'bold', color: '#fff', whiteSpace:'nowrap', overflow:'hidden', textOverflow:'ellipsis' }}>
          {heroName}
        </div>
        <div style={{ fontSize: '10px', color: '#ccc', whiteSpace:'nowrap', overflow:'hidden', textOverflow:'ellipsis' }}>
          {p.name}
        </div>
        <div style={{ display:'flex', alignItems:'center', gap:'2px', fontSize:'9px', color:'#888', fontWeight:'bold' }}>
          <RoleIcon lane={p.lane} /> {p.lane}
        </div>
      </div>

      <div style={{ textAlign: 'right', marginLeft:'4px', display:'flex', flexDirection:'column', justifyContent:'center', minWidth:'55px', gap:'1px' }}>
        <div style={{ fontSize: '11px', color: '#fff', fontWeight: 'bold', letterSpacing:'-0.5px' }}>
          {kda}
        </div>
        <div style={{ fontSize: '10px', color: '#e89d40', fontWeight:'bold' }}>
          {goldStr}
        </div>
        <div style={{ display:'flex', alignItems:'center', justifyContent:'flex-end', gap:'4px', fontSize:'9px', color:'#aaa', marginTop:'2px' }}>
          <div style={{ display:'flex', alignItems:'center', gap:'1px' }} title="CS">
            <Target size={8} color="#ccc"/> {p.cs}
          </div>
          <div style={{ display:'flex', alignItems:'center', gap:'1px' }} title="ë”œëŸ‰">
            <Sword size={8} color="#ff7675"/> {dmg}
          </div>
        </div>
      </div>

      {isDead && (
        <div style={{ position:'absolute', inset:0, background:'rgba(0,0,0,0.6)', display:'flex', alignItems:'center', justifyContent:'center', zIndex:10 }}>
          <span style={{ color:'#ff7675', fontWeight:'900', fontSize:'18px', textShadow:'0 0 3px #000' }}>{Math.ceil(p.respawnTimer)}</span>
        </div>
      )}
      
      <div style={{ position:'absolute', bottom:0, left:0, width:'100%', height:'2px', background:'#333' }}>
        <div style={{ width: `${(p.currentHp/p.maxHp)*100}%`, height:'100%', background: teamColor }} />
      </div>
    </div>
  );
};

export const ObjectStatBox = ({ stats, color, godName }: any) => {
  if (!stats) return null;
  const hpPercent = (stats.nexusHp / stats.maxNexusHp) * 100;
  
  const TowerLane = ({ label, brokenCount }: { label: string, brokenCount: number }) => (
    <div style={{ display:'flex', alignItems:'center', gap:'2px', fontSize:'9px', color:'#888', marginBottom:'2px' }}>
      <span style={{ width:'20px', fontWeight:'bold' }}>{label}</span>
      {[3, 2, 1].map(tier => {
        const isAlive = brokenCount < tier;
        return (
          <div key={tier} style={{
            width: '8px', height: '8px', borderRadius: '2px',
            background: isAlive ? color : '#222',
            border: isAlive ? 'none' : '1px solid #444',
            opacity: isAlive ? 1 : 0.5
          }} title={`${tier}ì°¨ íƒ€ì›Œ ${isAlive ? 'ìƒì¡´' : 'íŒŒê´´ë¨'}`} />
        );
      })}
    </div>
  );

  return (
    <div style={{ background: '#1e1e1e', border: `1px solid ${color}44`, borderRadius: '4px', padding: '8px', flex: 1 }}>
      <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:'4px' }}>
        <span style={{ color: color, fontWeight:'bold', fontSize:'11px', whiteSpace:'nowrap' }}>
          {godName}ì˜ ìˆ˜í˜¸ì
        </span>
        <span style={{ color: '#fff', fontSize:'10px', fontWeight:'bold' }}>
          {Math.ceil(stats.nexusHp).toLocaleString()}
        </span>
      </div>
      
      <div style={{ width:'100%', height:'4px', background:'#333', borderRadius:'2px', overflow:'hidden', marginBottom:'8px' }}>
         <div style={{ width:`${hpPercent}%`, height:'100%', background: color }} />
      </div>

      <div style={{ display:'flex', justifyContent:'space-between' }}>
        <div style={{ display:'flex', flexDirection:'column' }}>
          <TowerLane label="TOP" brokenCount={stats.towers?.top || 0} />
          <TowerLane label="MID" brokenCount={stats.towers?.mid || 0} />
          <TowerLane label="BOT" brokenCount={stats.towers?.bot || 0} />
        </div>

        <div style={{ display:'flex', flexDirection:'column', alignItems:'flex-end', justifyContent:'center', gap:'4px' }}>
          <div style={{ display:'flex', alignItems:'center', gap:'4px', fontSize:'10px', color:'#ccc' }} title="ì²˜ì¹˜í•œ ê±°ì‹ ë³‘">
            <Skull size={10} color="#7ee787"/> {stats.colossus}
          </div>
          <div style={{ display:'flex', alignItems:'center', gap:'4px', fontSize:'10px', color:'#ccc' }} title="ì²˜ì¹˜í•œ ì£¼ì‹œì">
            <Eye size={10} color="#a371f7"/> {stats.watcher}
          </div>
        </div>
      </div>
    </div>
  );
};

export const NeutralObjPanel = ({ colossus, watcher }: any) => {
  const ObjItem = ({ obj, name, color }: any) => {
    if(!obj) return null;
    const isAlive = obj.status === 'ALIVE';
    return (
      <div style={{ flex:1, background: isAlive ? `${color}22` : '#1e1e1e', padding:'6px', borderRadius:'4px', border: `1px solid ${isAlive ? color : '#333'}`, display:'flex', justifyContent:'space-between', alignItems:'center' }}>
        <span style={{ color: isAlive ? '#fff' : '#777', fontWeight:'bold', fontSize:'11px' }}>{name}</span>
        <span style={{ color: isAlive ? color : '#555', fontSize:'10px', fontWeight:'bold' }}>
          {isAlive ? 'ALIVE' : 'DEAD'}
        </span>
      </div>
    );
  };
  return (
    <div style={{ display:'flex', gap:'6px', padding:'8px 10px', background:'#121212', borderTop:'1px solid #222', flexShrink: 0 }}>
      <ObjItem obj={colossus} name="ê±°ì‹ ë³‘" color="#7ee787" />
      <ObjItem obj={watcher} name="ì£¼ì‹œì" color="#a371f7" />
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/spectate/UserDetailView.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/battle/spectate/UserDetailView.tsx
// ==========================================
import React from 'react';
import { X } from 'lucide-react';
import { GameIcon } from '../../common/GameIcon';

export const UserDetailView = ({ player, heroName, viewingItem, setViewingItem }: any) => {
  const hpPercent = (player.currentHp / player.maxHp) * 100;
  const mpPercent = (player.currentMp / player.maxMp) * 100 || 0;

  const items = Array.isArray(player.items) ? player.items : [];

  const StatBadge = ({ color, label, val }: any) => (
    <span style={{fontSize:'10px', color: color, background: `${color}11`, padding:'2px 4px', borderRadius:'3px', border:`1px solid ${color}33`}}>
      {label} +{val}
    </span>
  );

  return (
    <div style={{ padding:'20px', display:'flex', flexDirection:'column', alignItems:'center' }}>
      <div style={{ display:'flex', alignItems:'center', gap:'15px', width:'100%', maxWidth:'450px', marginBottom:'20px' }}>
        <GameIcon id={player.heroId} size={54} />
        <div style={{ flex:1 }}>
          <div style={{ fontWeight:'bold', fontSize:'18px', color:'#fff' }}>{heroName}</div>
          <div style={{ color:'#8b949e', fontSize:'12px' }}>{player.name} (Lv.{player.level})</div>
        </div>
        <div style={{ textAlign:'right', minWidth:'120px' }}>

          <div style={{ fontSize:'10px', color:'#2ecc71', fontWeight:'900', marginBottom:'4px' }}>
            HP {Math.ceil(player.currentHp)}/{player.maxHp}
          </div>
          <div style={{ width:'100%', height:'6px', background:'#1a1a1c', borderRadius:'3px', overflow:'hidden', border:'1px solid #333' }}>
            <div style={{ width:`${hpPercent}%`, height:'100%', background: hpPercent < 30 ? '#da3633' : '#2ecc71' }} />
          </div>

          <div style={{ fontSize:'10px', color:'#3498db', fontWeight:'900', marginBottom:'4px', marginTop:'6px' }}>
            MP {Math.ceil(player.currentMp)}/{player.maxMp}
          </div>
          <div style={{ width:'100%', height:'6px', background:'#1a1a1c', borderRadius:'3px', overflow:'hidden', border:'1px solid #333' }}>
            <div style={{ width:`${mpPercent}%`, height:'100%', background: '#3498db' }} />
          </div>

          <div style={{ color:'#f1c40f', fontWeight:'bold', fontSize:'12px', marginTop:'6px' }}>ğŸ’° {Math.floor(player.gold).toLocaleString()} G</div>
        </div>
      </div>

      {viewingItem && (
        <div style={{ width:'100%', maxWidth:'450px', background:'#161b22', border:'1px solid #30363d', borderRadius:'8px', padding:'12px', marginBottom:'15px', position:'relative' }}>
          <button onClick={() => setViewingItem(null)} style={{ position:'absolute', right:'8px', top:'8px', background:'none', border:'none', color:'#666', cursor:'pointer' }}><X size={14}/></button>
          <div style={{ display:'flex', gap:'12px', alignItems:'center', marginBottom:'10px' }}>
            <GameIcon id={viewingItem.id} size={36} shape="square" />
            <div>
              <div style={{ fontWeight:'bold', color:'#fff', fontSize:'14px' }}>{viewingItem.name}</div>
              <div style={{ color:'#f1c40f', fontSize:'11px', fontWeight:'bold' }}>{viewingItem.cost} Gold</div>
            </div>
          </div>
          <div style={{ display:'flex', flexWrap:'wrap', gap:'8px', marginBottom:'10px' }}>
             {viewingItem.ad > 0 && <StatBadge color="#ff6b6b" label="AD" val={viewingItem.ad} />}
             {viewingItem.ap > 0 && <StatBadge color="#a371f7" label="AP" val={viewingItem.ap} />}
             {viewingItem.hp > 0 && <StatBadge color="#7ee787" label="HP" val={viewingItem.hp} />}
             {viewingItem.armor > 0 && <StatBadge color="#58a6ff" label="DEF" val={viewingItem.armor} />}
             {viewingItem.crit > 0 && <StatBadge color="#e89d40" label="CRI" val={viewingItem.crit + '%'} />}
             {viewingItem.speed > 0 && <StatBadge color="#fff" label="SPD" val={viewingItem.speed} />}
          </div>
          <div style={{ fontSize:'11px', color:'#ccc' }}>{viewingItem.description || "ì„¤ëª…ì´ ì—†ìŠµë‹ˆë‹¤."}</div>
        </div>
      )}

      <div style={{ display:'flex', gap:'6px', justifyContent:'center', marginBottom:'20px' }}>
        {([0,1,2,3,4,5]).map(i => (
          <div key={i} onClick={() => items[i] && setViewingItem(items[i])} style={{ width:'42px', height:'42px', background:'#0d1117', border:'1px solid #333', borderRadius:'4px', cursor:'pointer', overflow:'hidden', display:'flex', alignItems:'center', justifyContent:'center' }}>
            {items[i] ? <GameIcon id={items[i].id} size={40} shape="square" /> : null}
          </div>
        ))}
      </div>
    </div>
  );
};


==========================================
FILE PATH: src/components/battle/spectate/views/SpectateCanvasView.tsx
==========================================
import React, { useRef, useEffect, useState } from 'react';
import { LiveMatch, Hero } from '../../../../types';
import { TOWER_COORDS } from '../../../../engine/match/constants/MapConstants';
import { useGameStore } from '../../../../store/useGameStore';

interface Props {
  match: LiveMatch;
  heroes: Hero[];
  onSelectHero: (id: string) => void;
  selectedHeroId: string | null;
}

export const SpectateCanvasView: React.FC<Props> = ({ match, heroes, onSelectHero, selectedHeroId }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const { gameState } = useGameStore();
  
  // ì´ë¯¸ì§€ ìºì‹±
  const images = useRef<Record<string, HTMLImageElement>>({});

  // í—¬í¼: ì´ë¯¸ì§€ ë¡œë“œ
  const getImage = (src: string | undefined) => {
    if (!src) return null;
    if (images.current[src]) return images.current[src];
    const img = new Image();
    img.src = src;
    images.current[src] = img;
    return img;
  };

  useEffect(() => {
    const canvas = canvasRef.current;
    const container = containerRef.current;
    if (!canvas || !container) return;

    let animationFrameId: number;

    const render = () => {
      // ìº”ë²„ìŠ¤ í¬ê¸° ë§ì¶¤
      const width = container.clientWidth;
      const height = container.clientHeight;
      
      // ê³ í•´ìƒë„ ì§€ì› (Retina ë””ìŠ¤í”Œë ˆì´ ë“±)
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      
      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      // ìŠ¤ì¼€ì¼ë§
      ctx.scale(dpr, dpr);
      // ì¢Œí‘œê³„ ì •ê·œí™” (0~100 ì¢Œí‘œë¥¼ ìº”ë²„ìŠ¤ í¬ê¸°ì— ë§ì¶¤)
      const scaleX = width / 100;
      const scaleY = height / 100;

      // 1. ë°°ê²½ ê·¸ë¦¬ê¸°
      ctx.fillStyle = '#0a0f0a';
      ctx.fillRect(0, 0, width, height);
      
      const bgSrc = gameState.customImages?.['map_bg'];
      const bgImg = getImage(bgSrc);
      if (bgImg && bgImg.complete) {
        ctx.globalAlpha = 0.6;
        ctx.drawImage(bgImg, 0, 0, width, height);
        ctx.globalAlpha = 1.0;
      } else {
        // ë°°ê²½ ì—†ì„ ë•Œ ê²©ì
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=0; i<=100; i+=10) {
            ctx.moveTo(i*scaleX, 0); ctx.lineTo(i*scaleX, height);
            ctx.moveTo(0, i*scaleY); ctx.lineTo(width, i*scaleY);
        }
        ctx.stroke();
      }

      // 2. íƒ€ì›Œ ê·¸ë¦¬ê¸°
      const drawStructure = (x: number, y: number, isDead: boolean, color: string, isNexus = false) => {
        const cx = x * scaleX;
        const cy = y * scaleY;
        const size = isNexus ? 14 : 8;
        
        ctx.fillStyle = isDead ? '#333' : color;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        ctx.arc(cx, cy, size, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // ì‚¬ê±°ë¦¬ í‘œì‹œ (ì‚´ì•„ìˆì„ ë•Œë§Œ)
        if (!isDead) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.2;
            ctx.arc(cx, cy, (isNexus ? 15 : 12) * scaleX, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }
      };

      // ë¸”ë£¨ íƒ€ì›Œ
      ['top', 'mid', 'bot'].forEach(lane => {
         const broken = (match.stats.blue.towers as any)[lane];
         const coords = (TOWER_COORDS.BLUE as any)[lane.toUpperCase()];
         coords.forEach((pos:any, i:number) => drawStructure(pos.x, pos.y, i < broken, '#58a6ff'));
      });
      drawStructure(TOWER_COORDS.BLUE.NEXUS.x, TOWER_COORDS.BLUE.NEXUS.y, match.stats.blue.nexusHp <= 0, '#58a6ff', true);

      // ë ˆë“œ íƒ€ì›Œ
      ['top', 'mid', 'bot'].forEach(lane => {
         const broken = (match.stats.red.towers as any)[lane];
         const coords = (TOWER_COORDS.RED as any)[lane.toUpperCase()];
         coords.forEach((pos:any, i:number) => drawStructure(pos.x, pos.y, i < broken, '#e84057'));
      });
      drawStructure(TOWER_COORDS.RED.NEXUS.x, TOWER_COORDS.RED.NEXUS.y, match.stats.red.nexusHp <= 0, '#e84057', true);

      // 3. ìœ ë‹› ê·¸ë¦¬ê¸° (ë¯¸ë‹ˆì–¸ & ì˜ì›…)
      
      // ë¯¸ë‹ˆì–¸
      match.minions?.forEach(m => {
        if (m.hp <= 0) return;
        const cx = m.x * scaleX;
        const cy = m.y * scaleY;
        const color = m.team === 'BLUE' ? '#58a6ff' : '#e84057';
        const size = m.type === 'SIEGE' ? 6 : 4;

        ctx.fillStyle = color;
        
        if (m.type === 'SUMMONED_COLOSSUS') {
            // ê±°ì‹ ë³‘ íŠ¹ë³„ ëŒ€ìš°
            ctx.fillStyle = '#a658ff';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#a658ff';
            ctx.beginPath();
            ctx.arc(cx, cy, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        } else {
            ctx.fillRect(cx - size/2, cy - size/2, size, size);
        }
      });

      // ì˜ì›…
      [...match.blueTeam, ...match.redTeam].forEach(p => {
        if (p.respawnTimer > 0) return; // ì£½ì€ ì˜ì›… ì•ˆ ê·¸ë¦¼

        const cx = p.x * scaleX;
        const cy = p.y * scaleY;
        const isSelected = selectedHeroId === p.heroId;
        const teamColor = match.blueTeam.includes(p) ? '#58a6ff' : '#e84057';
        
        // ì„ íƒ í•˜ì´ë¼ì´íŠ¸
        if (isSelected) {
            ctx.beginPath();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.arc(cx, cy, 18, 0, Math.PI * 2);
            ctx.stroke();
        }

        // ì˜ì›… ì´ë¯¸ì§€
        const heroImgSrc = gameState.customImages?.[p.heroId];
        const heroImg = getImage(heroImgSrc);

        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, 14, 0, Math.PI * 2);
        ctx.closePath();
        ctx.clip(); // ì›í˜• í´ë¦¬í•‘

        if (heroImg && heroImg.complete) {
            ctx.drawImage(heroImg, cx - 14, cy - 14, 28, 28);
        } else {
            ctx.fillStyle = teamColor;
            ctx.fillRect(cx - 14, cy - 14, 28, 28);
        }
        ctx.restore();

        // í…Œë‘ë¦¬
        ctx.strokeStyle = teamColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, cy, 14, 0, Math.PI * 2);
        ctx.stroke();

        // ì²´ë ¥ë°”
        const hpPct = p.currentHp / p.maxHp;
        ctx.fillStyle = '#333';
        ctx.fillRect(cx - 15, cy + 16, 30, 4);
        ctx.fillStyle = hpPct < 0.3 ? '#da3633' : teamColor;
        ctx.fillRect(cx - 15, cy + 16, 30 * hpPct, 4);

        // ìŠ¤í‚¬ ë§í’ì„ 
        if (p.activeSkill) {
            const timeDiff = match.currentDuration - p.activeSkill.timestamp;
            if (timeDiff < 1.0) { // 1ì´ˆê°„ í‘œì‹œ
                ctx.font = 'bold 12px Arial';
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                const text = `${p.activeSkill.key.toUpperCase()}!`;
                ctx.strokeText(text, cx, cy - 25);
                ctx.fillText(text, cx, cy - 25);
            }
        }
      });

      animationFrameId = requestAnimationFrame(render);
    };

    render();

    return () => cancelAnimationFrame(animationFrameId);
  }, [match, heroes, selectedHeroId, gameState.customImages]);

  // í´ë¦­ ì²˜ë¦¬ (ì¢Œí‘œ ì—­ì‚°)
  const handleClick = (e: React.MouseEvent) => {
    if (!containerRef.current) return;
    const rect = containerRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // 0~100 ì¢Œí‘œê³„ë¡œ ë³€í™˜
    const gameX = (x / rect.width) * 100;
    const gameY = (y / rect.height) * 100;

    // ê°€ì¥ ê°€ê¹Œìš´ ì˜ì›… ì°¾ê¸°
    let bestDist = 100; // ê±°ë¦¬ 5 ì´ë‚´ë§Œ í´ë¦­ ì¸ì •
    let bestId = null;

    [...match.blueTeam, ...match.redTeam].forEach(p => {
        if (p.respawnTimer > 0) return;
        const dx = p.x - gameX;
        const dy = p.y - gameY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < 5 && dist < bestDist) {
            bestDist = dist;
            bestId = p.heroId;
        }
    });

    onSelectHero(bestId || '');
  };

  return (
    <div ref={containerRef} style={{ width: '100%', height: '100%', position: 'relative' }}>
      <canvas 
        ref={canvasRef} 
        onClick={handleClick}
        style={{ width: '100%', height: '100%', display: 'block', cursor: 'pointer' }} 
      />
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/spectate/views/SpectateHeader.tsx
==========================================
import React from 'react';
import { X, Play, Pause } from 'lucide-react';
import { SpeedButton } from '../SpectateUI';

interface Props {
  score: { blue: number; red: number };
  timeStr: string;
  isGameEnded: boolean;
  isPlaying: boolean;
  gameSpeed: number;
  onTogglePlay: () => void;
  onSetSpeed: (s: number) => void;
  onClose: () => void;
  isMobile: boolean;
  mobileTab: 'LIST' | 'MAP';
  setMobileTab: (t: 'LIST' | 'MAP') => void;
}

export const SpectateHeader: React.FC<Props> = ({ 
  score, timeStr, isGameEnded, isPlaying, gameSpeed, 
  onTogglePlay, onSetSpeed, onClose, isMobile, mobileTab, setMobileTab 
}) => {
  return (
    <div style={{ flexShrink: 0, background: '#1a1a1a', borderBottom: '1px solid #333', padding: '10px' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom:'8px' }}>
        <div style={{ display:'flex', gap:'20px', alignItems:'center', flex:1, justifyContent:'center' }}>
            <span style={{ color: '#58a6ff', fontWeight: '900', fontSize:'22px', minWidth:'30px', textAlign:'right' }}>{score.blue}</span>
            <div style={{ background:'#000', padding:'4px 12px', borderRadius:'20px', border:'1px solid #444', color:'#fff', fontSize:'14px', fontFamily:'monospace', fontWeight:'bold' }}>
              {isGameEnded ? 'END' : timeStr}
            </div>
            <span style={{ color: '#e84057', fontWeight: '900', fontSize:'22px', minWidth:'30px', textAlign:'left' }}>{score.red}</span>
        </div>
        <button onClick={onClose} style={{ position:'absolute', right:'10px', top:'10px', background:'none', border:'none', color:'#888', cursor:'pointer' }}><X size={24}/></button>
      </div>
      
      <div style={{ display:'flex', justifyContent:'center', gap:'8px' }}>
          <button onClick={onTogglePlay} style={{ width:'50px', height:'30px', borderRadius:'4px', background: isPlaying ? '#ff7675' : '#55efc4', color:'#000', border:'none', cursor:'pointer', display:'flex', alignItems:'center', justifyContent:'center' }}>
            {isPlaying ? <Pause size={16}/> : <Play size={16}/>}
          </button>
          {[1, 10, 60].map(s => <SpeedButton key={s} label={`${s}ë°°`} speed={s} currentSpeed={gameSpeed} setSpeed={onSetSpeed} />)}
      </div>
      
      {isMobile && (
        <div style={{ display:'flex', marginTop:'10px', borderTop:'1px solid #333', paddingTop:'8px' }}>
          <button onClick={()=>setMobileTab('LIST')} style={{ flex:1, padding:'8px', background: mobileTab==='LIST'?'#333':'transparent', border:'none', color: mobileTab==='LIST'?'#fff':'#777', fontWeight:'bold', borderBottom: mobileTab==='LIST'?'2px solid #fff':'none' }}>ğŸ“‹ ì„ ìˆ˜ ì •ë³´</button>
          <button onClick={()=>setMobileTab('MAP')} style={{ flex:1, padding:'8px', background: mobileTab==='MAP'?'#333':'transparent', border:'none', color: mobileTab==='MAP'?'#fff':'#777', fontWeight:'bold', borderBottom: mobileTab==='MAP'?'2px solid #fff':'none' }}>ğŸ—ºï¸ ì‹¤ì‹œê°„ ë§µ</button>
        </div>
      )}
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/spectate/views/SpectateListView.tsx
==========================================
import React from 'react';
import { BanCard, PlayerCard, ObjectStatBox, NeutralObjPanel } from '../SpectateUI';
import { ChevronLeft, Terminal } from 'lucide-react';
import { GlobalLogPanel } from '../GlobalLogPanel';
import { UserDetailView } from '../UserDetailView';
import { PersonalLogView } from '../PersonalLogView';
import { LiveMatch, Hero } from '../../../../../types';

interface Props {
  match: LiveMatch;
  heroes: Hero[];
  isMobile: boolean;
  mobileTab: 'LIST' | 'MAP';
  selectedHeroId: string | null;
  onSelectHero: (id: string | null) => void;
  gameSpeed: number;
  formatTime: (s: number) => string;
  getHeroName: (id: string) => string;
}

export const SpectateListView: React.FC<Props> = ({
  match, heroes, isMobile, mobileTab, selectedHeroId, onSelectHero, gameSpeed, formatTime, getHeroName
}) => {
  const [viewingItem, setViewingItem] = React.useState<any>(null);
  const selectedPlayer = selectedHeroId ? [...match.blueTeam, ...match.redTeam].find(p => p.heroId === selectedHeroId) : null;

  return (
    <div style={{ 
      background: '#121212', 
      display: (isMobile && mobileTab !== 'LIST') ? 'none' : 'block',
      paddingBottom: '50px',
      width: '100%',
      overflowX: 'hidden'
    }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', padding: '8px 10px', borderBottom: '1px solid #222', background:'#1a1a1a' }}>
           <div style={{ display: 'flex', gap: '4px' }}>{(match.bans.blue || []).map((id:string, i:number) => <BanCard key={i} heroId={id} heroes={heroes} />)}</div>
           <div style={{ display: 'flex', gap: '4px' }}>{(match.bans.red || []).map((id:string, i:number) => <BanCard key={i} heroId={id} heroes={heroes} />)}</div>
        </div>

        <div style={{ padding: '8px', display:'flex', gap:'6px', alignItems:'flex-start' }}>
           <div style={{ flex:1, display:'flex', flexDirection:'column', gap:'4px', minWidth:0 }}>
             <div style={{ fontSize:'11px', fontWeight:'bold', color:'#58a6ff', textAlign:'center', marginBottom:'2px' }}>BLUE TEAM</div>
             {match.blueTeam.map((p:any, i:number) => <PlayerCard key={i} p={p} isSelected={selectedHeroId === p.heroId} onClick={() => onSelectHero(p.heroId)} heroName={getHeroName(p.heroId)} teamColor="#58a6ff" />)}
           </div>

           <div style={{ flex:1, display:'flex', flexDirection:'column', gap:'4px', minWidth:0 }}>
             <div style={{ fontSize:'11px', fontWeight:'bold', color:'#e84057', textAlign:'center', marginBottom:'2px' }}>RED TEAM</div>
             {match.redTeam.map((p:any, i:number) => <PlayerCard key={i} p={p} isSelected={selectedHeroId === p.heroId} onClick={() => onSelectHero(p.heroId)} heroName={getHeroName(p.heroId)} teamColor="#e84057" />)}
           </div>
        </div>

        <div style={{ padding:'0 8px 20px 8px' }}>
            <div style={{ padding:'8px 0', display:'flex', gap:'6px' }}>
               <ObjectStatBox stats={match.stats.blue} color="#58a6ff" side="BLUE" godName="ë‹¨í…Œ" />
               <ObjectStatBox stats={match.stats.red} color="#e84057" side="RED" godName="ì´ì¦ˆë§ˆí•œ" />
            </div>
            <NeutralObjPanel colossus={match.objectives?.colossus} watcher={match.objectives?.watcher} />
            
            <div style={{ height:'300px', border:'1px solid #333', marginTop:'10px', borderRadius:'8px', overflow:'hidden', display:'flex', flexDirection:'column' }}>
                {selectedPlayer ? (
                    <div style={{ height:'100%', overflowY:'auto' }}>
                        <div onClick={() => { onSelectHero(null); setViewingItem(null); }} style={{ padding:'8px', background:'#222', textAlign:'center', cursor:'pointer', fontSize:'12px', color:'#ccc', borderBottom:'1px solid #333' }}><ChevronLeft size={12}/> ëª©ë¡ìœ¼ë¡œ ëŒì•„ê°€ê¸°</div>
                        <UserDetailView player={selectedPlayer} heroName={getHeroName(selectedPlayer.heroId)} viewingItem={viewingItem} setViewingItem={setViewingItem} />
                        <PersonalLogView logs={match.logs} heroName={getHeroName(selectedPlayer.heroId)} summonerName={selectedPlayer.name} formatTime={formatTime} />
                    </div>
                ) : (
                    <>
                       <div style={{ padding:'8px', background:'#161b22', fontSize:'11px', color:'#888', display:'flex', gap:'6px', borderBottom:'1px solid #222' }}><Terminal size={12}/> ì‹¤ì‹œê°„ ë¡œê·¸</div>
                       <GlobalLogPanel logs={match.logs} gameSpeed={gameSpeed} formatTime={formatTime} />
                    </>
                )}
            </div>
        </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/spectate/views/SpectateMapView.tsx
==========================================
import React from 'react';
import { LiveMatch } from '../../../../types';
import { useGameStore } from '../../../../store/useGameStore';
import { ObjectStatBox, NeutralObjPanel } from '../SpectateUI';
import { SpectateCanvasView } from './SpectateCanvasView';

interface Props {
  match: LiveMatch;
  isMobile: boolean;
  mobileTab: 'LIST' | 'MAP';
  selectedHeroId: string | null;
  onSelectHero: (id: string) => void;
  setMobileTab: (t: 'LIST' | 'MAP') => void;
}

export const SpectateMapView: React.FC<Props> = ({ 
  match, isMobile, mobileTab, selectedHeroId, onSelectHero, setMobileTab 
}) => {
  const { heroes } = useGameStore();

  if (isMobile && mobileTab !== 'MAP') return null;

  return (
    <div style={{ 
        width: '100%', height: '100%',
        display: 'flex', flexDirection: 'column', 
        background: '#050505',
        overflowY: 'auto', overflowX: 'hidden'
    }}>
      
      {/* ë§µ ì˜ì—­ ì»¨í…Œì´ë„ˆ (ì¤‘ì•™ ì •ë ¬) */}
      <div style={{
          width: '100%', 
          display: 'flex', 
          justifyContent: 'center', 
          background: '#161b22', 
          borderBottom: '1px solid #333',
          flexShrink: 0 
      }}>
        {/* [í•µì‹¬ ìˆ˜ì •] ì •ì‚¬ê°í˜• ë¹„ìœ¨ ê°•ì œ (aspect-ratio: 1/1) */}
        <div style={{
            width: '100%', 
            maxWidth: '100vh', // ë°ìŠ¤í¬íƒ‘ì—ì„œ í™”ë©´ ë†’ì´ë³´ë‹¤ ì»¤ì§€ì§€ ì•Šê²Œ ì œí•œ
            aspectRatio: '1 / 1', // ë¬´ì¡°ê±´ ì •ì‚¬ê°í˜• ìœ ì§€
            position: 'relative',
            overflow: 'hidden' 
        }}>
            <SpectateCanvasView 
                match={match} 
                heroes={heroes} 
                onSelectHero={onSelectHero} 
                selectedHeroId={selectedHeroId} 
            />
        </div>
      </div>

      {/* í•˜ë‹¨ ì •ë³´ íŒ¨ë„ */}
      <div style={{ padding: '15px', display: 'flex', flexDirection: 'column', gap: '10px', background: '#121212' }}>
        <div style={{ display: 'flex', gap: '6px' }}>
            <ObjectStatBox stats={match.stats.blue} color="#58a6ff" side="BLUE" godName="ë‹¨í…Œ" />
            <ObjectStatBox stats={match.stats.red} color="#e84057" side="RED" godName="ì´ì¦ˆë§ˆí•œ" />
        </div>
        <NeutralObjPanel colossus={match.objectives?.colossus} watcher={match.objectives?.watcher} />
        <div style={{ textAlign:'center', color:'#555', fontSize:'11px', marginTop:'10px' }}>
            ì˜ì›…ì„ í´ë¦­í•˜ì—¬ ìƒì„¸ ì •ë³´ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        </div>
      </div>

    </div>
  );
};



==========================================
FILE PATH: src/components/battle/ui/MapObjectIcon.tsx
==========================================
import React from 'react';

interface Props {
  x: number;
  y: number;
  icon: React.ReactElement;
  color: string;
  size: number;
  label?: string;
  onClick: () => void;
}

export const MapObjectIcon: React.FC<Props> = ({ x, y, icon, color, size, label, onClick }) => {
  return (
    <div 
      onClick={onClick}
      style={{
        position: 'absolute', left: `${x}%`, top: `${y}%`,
        transform: 'translate(-50%, -50%)',
        display: 'flex', flexDirection: 'column', alignItems: 'center',
        cursor: 'pointer', zIndex: 10
      }}
      className="map-obj-hover"
    >
      <div style={{
        width: size, height: size, borderRadius: '50%',
        background: '#161b22', border: `2px solid ${color}`,
        display: 'flex', alignItems: 'center', justifyContent: 'center',
        boxShadow: `0 0 10px ${color}66`,
        transition: 'all 0.2s'
      }}>
        {React.cloneElement(icon, { size: size/1.8, color })}
      </div>
      {label && (
        <span style={{ 
          marginTop: '4px', fontSize: '10px', fontWeight: 'bold', 
          color: '#fff', background: 'rgba(0,0,0,0.6)', 
          padding: '1px 6px', borderRadius: '4px', whiteSpace: 'nowrap'
        }}>
          {label}
        </span>
      )}
      <style>{`
        .map-obj-hover:hover > div { transform: scale(1.2); background: #fff !important; }
        .map-obj-hover:hover span { background: #58a6ff !important; }
      `}</style>
    </div>
  );
};



==========================================
FILE PATH: src/components/battle/ui/PatchInputs.tsx
==========================================
import React from 'react';
import { Clock } from 'lucide-react';

interface RangeProps {
  label: string;
  icon?: React.ReactNode;
  value: number;
  onChange: (val: number) => void;
  min: number; max: number; step?: number;
  unit?: string;
  color?: string;
}

export const RangeInput: React.FC<RangeProps> = ({ label, icon, value, onChange, min, max, step = 1, unit = '', color = '#58a6ff' }) => (
  <div style={{ marginBottom: '25px' }}>
    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '12px', fontSize: '13px', color: '#ccc' }}>
      <div style={{ display:'flex', alignItems:'center', gap:'6px' }}>{icon} {label}</div>
      <span style={{ fontWeight: 'bold', color: color, fontFamily:'monospace', fontSize:'15px' }}>
        {value?.toLocaleString()}{unit}
      </span>
    </div>
    <div style={{ padding: '0 5px' }}>
      <input 
        type="range" min={min} max={max} step={step} 
        value={value || 0} 
        onChange={(e) => onChange(Number(e.target.value))} 
        style={{ width:'100%', accentColor: color, cursor:'pointer' }}
      />
    </div>
  </div>
);

export const TimeInput: React.FC<Omit<RangeProps, 'icon' | 'unit'>> = ({ label, value, onChange, min = 0, max = 3600, step = 10, color = '#ccc' }) => (
  <div style={{ marginBottom: '25px' }}>
    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '12px', fontSize: '13px', color: '#ccc' }}>
      <div style={{ display:'flex', alignItems:'center', gap:'6px' }}><Clock size={14}/> {label}</div>
      <span style={{ fontWeight: 'bold', color: color, fontFamily:'monospace', fontSize:'15px' }}>
        {Math.floor(value / 60)}ë¶„ {value % 60}ì´ˆ
      </span>
    </div>
    <input 
      type="range" min={min} max={max} step={step} 
      value={value || 0} 
      onChange={(e) => onChange(Number(e.target.value))} 
      style={{ width:'100%', accentColor: color, cursor:'pointer' }}
    />
  </div>
);



==========================================
FILE PATH: src/components/common/CrashScreen.tsx
==========================================
import React from 'react';
import { AlertTriangle, RefreshCw, Trash2, Copy, Bug } from 'lucide-react';

interface Props {
  error: Error | null;
  resetErrorBoundary: () => void;
}

export const CrashScreen: React.FC<Props> = ({ error, resetErrorBoundary }) => {
  const handleCopy = () => {
    if (error) {
      // [ìˆ˜ì •] ë¬¸ë²• ì˜¤ë¥˜ ìˆ˜ì •
      navigator.clipboard.writeText(`Message: ${error.message}\nStack: ${error.stack}`);
      alert("ì˜¤ë¥˜ ë‚´ìš©ì´ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.");
    }
  };

  const handleHardReset = () => {
    if (confirm("ì •ë§ ëª¨ë“  ë°ì´í„°ë¥¼ ì‚­ì œí•˜ê³  ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ë³µêµ¬ ë¶ˆê°€)")) {
      localStorage.clear();
      // IndexedDB ì‚­ì œ
      const req = indexedDB.deleteDatabase('GodsWar_DB_V1');
      req.onsuccess = () => window.location.reload();
      req.onerror = () => window.location.reload();
      req.onblocked = () => window.location.reload();
    }
  };

  return (
    <div style={{
      position: 'fixed', inset: 0, zIndex: 99999,
      background: '#0f1115', color: '#fff',
      display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
      padding: '20px', fontFamily: 'sans-serif'
    }}>
      <div style={{
        maxWidth: '800px', width: '100%',
        background: '#161b22', border: '1px solid #da3633', borderRadius: '12px',
        padding: '30px', boxShadow: '0 20px 50px rgba(0,0,0,0.8)'
      }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '15px', marginBottom: '20px', borderBottom: '1px solid #da3633', paddingBottom: '15px' }}>
          <div style={{ background: '#da3633', padding: '10px', borderRadius: '50%' }}>
            <Bug size={32} color="#fff" />
          </div>
          <div>
            <h2 style={{ margin: 0, fontSize: '24px', fontWeight: 'bold', color: '#da3633' }}>
              ì‹œìŠ¤í…œ ì¹˜ëª…ì  ì˜¤ë¥˜ ë°œìƒ
            </h2>
            <p style={{ margin: '5px 0 0 0', color: '#8b949e', fontSize: '14px' }}>
              ê²Œì„ ì—”ì§„ì´ ì•ˆì „ì„ ìœ„í•´ ì‹¤í–‰ì„ ì¤‘ë‹¨í–ˆìŠµë‹ˆë‹¤.
            </p>
          </div>
        </div>

        <div style={{ marginBottom: '15px' }}>
          <label style={{ fontSize: '12px', fontWeight: 'bold', color: '#da3633' }}>ERROR MESSAGE:</label>
          <div style={{ background: '#0d1117', padding: '12px', borderRadius: '6px', border: '1px solid #30363d', color: '#fff', fontWeight: 'bold', marginTop: '5px' }}>
            {error?.message || "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜"}
          </div>
        </div>

        <div style={{ marginBottom: '25px' }}>
          <label style={{ fontSize: '12px', fontWeight: 'bold', color: '#8b949e' }}>STACK TRACE:</label>
          <pre style={{ 
            background: '#0d1117', padding: '15px', borderRadius: '6px', border: '1px solid #30363d', 
            color: '#ccc', fontSize: '11px', overflow: 'auto', maxHeight: '200px', marginTop: '5px',
            fontFamily: 'Consolas, monospace', whiteSpace: 'pre-wrap' 
          }}>
            {error?.stack || "ìŠ¤íƒ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤."}
          </pre>
        </div>

        <div style={{ display: 'flex', gap: '10px', justifyContent: 'flex-end' }}>
          <button onClick={handleCopy} style={{ display:'flex', alignItems:'center', gap:'6px', padding: '10px 15px', background: '#21262d', border: '1px solid #30363d', color: '#ccc', borderRadius: '6px', cursor: 'pointer' }}>
            <Copy size={16} /> ì˜¤ë¥˜ ë³µì‚¬
          </button>
          <button onClick={() => window.location.reload()} style={{ display:'flex', alignItems:'center', gap:'6px', padding: '10px 15px', background: '#238636', border: 'none', color: '#fff', borderRadius: '6px', cursor: 'pointer', fontWeight: 'bold' }}>
            <RefreshCw size={16} /> ì¬ì‹œì‘ (ìƒˆë¡œê³ ì¹¨)
          </button>
          <button onClick={handleHardReset} style={{ display:'flex', alignItems:'center', gap:'6px', padding: '10px 15px', background: '#3f1515', border: '1px solid #da3633', color: '#da3633', borderRadius: '6px', cursor: 'pointer', fontWeight: 'bold' }}>
            <Trash2 size={16} /> ë°ì´í„° ì´ˆê¸°í™” (ë¹„ìƒìš©)
          </button>
        </div>
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/common/DevTools.tsx
==========================================
// src/components/common/DevTools.tsx
import React from 'react';
import { useGameStore } from '../../store/useGameStore';
import { Trash2 } from 'lucide-react';

export const DevTools = () => {
  const { resetHeroStats } = useGameStore();

  const handleReset = () => {
    if (window.confirm('ëª¨ë“  ì±”í”¼ì–¸ì˜ ëˆ„ì  í†µê³„(ìŠ¹ë¥ , KDA, íŒìˆ˜)ë¥¼ 0ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\n*í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ê²Œì„ì—ëŠ” ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŠµë‹ˆë‹¤.')) {
      resetHeroStats();
      alert('í†µê³„ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ì œ ìƒˆë¡œìš´ ê²Œì„ ê²°ê³¼ê°€ ì¦‰ì‹œ ìŠ¹ë¥ ì— ë°˜ì˜ë©ë‹ˆë‹¤.');
    }
  };

  return (
    <div style={{
      position: 'fixed',
      bottom: '20px',
      right: '20px',
      zIndex: 9999
    }}>
      <button 
        onClick={handleReset}
        style={{
          background: '#e74c3c',
          color: 'white',
          border: 'none',
          padding: '10px 15px',
          borderRadius: '8px',
          cursor: 'pointer',
          boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
          display: 'flex',
          alignItems: 'center',
          gap: '8px',
          fontSize: '13px',
          fontWeight: 'bold'
        }}
      >
        <Trash2 size={16} />
        í†µê³„ ì´ˆê¸°í™”
      </button>
    </div>
  );
};


==========================================
FILE PATH: src/components/common/FreezeWrapper.tsx
==========================================
import React from 'react';

interface Props {
  isHidden: boolean;
  children: React.ReactNode;
}

// React.memoë¥¼ ì‚¬ìš©í•˜ì—¬ isHiddenì´ trueì¼ ë•ŒëŠ” 
// ë‚´ë¶€ childrenì´ ë°”ë€Œì–´ë„ ë¦¬ë Œë”ë§ì„ ìˆ˜í–‰í•˜ì§€ ì•ŠìŒ (ì´ì „ ìŠ¤ëƒ…ìƒ· ìœ ì§€)
export const FreezeWrapper = React.memo(({ isHidden, children }: Props) => {
  return (
    <div style={{ flex: 1, display: isHidden ? 'none' : 'flex', flexDirection: 'column', overflow: 'hidden' }}>
      {children}
    </div>
  );
}, (prev, next) => {
  // ë§Œì•½ ë‹¤ìŒ ìƒíƒœê°€ 'ìˆ¨ê¹€(hidden)'ì´ë¼ë©´, 
  // ë‚´ë¶€ ë°ì´í„°ê°€ ì•„ë¬´ë¦¬ ë°”ë€Œì–´ë„(propsê°€ ë³€í•´ë„) ë¦¬ë Œë”ë§ í•˜ì§€ ì•ŠìŒ (true ë°˜í™˜)
  if (next.isHidden) return true;
  
  // ë³´ì—¬ì§€ëŠ” ìƒíƒœë¼ë©´ ì •ìƒì ìœ¼ë¡œ ë¹„êµí•˜ì—¬ ì—…ë°ì´íŠ¸
  return prev.isHidden === next.isHidden && prev.children === next.children;
});



==========================================
FILE PATH: src/components/common/GameIcon.tsx
==========================================
import React from 'react';
import { useGameStore } from '../../store/useGameStore';

interface Props {
  id: string; 
  size?: string | number;
  fallback?: React.ReactNode;
  shape?: 'square' | 'circle' | 'rounded';
  border?: string;
}

// React.memoë¥¼ ì¨ì„œ ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ ìì²´ë¥¼ ë§‰ìŠµë‹ˆë‹¤.
export const GameIcon = React.memo(({ id, size = 40, fallback, shape = 'rounded', border = '1px solid #333' }: Props) => {
  const customImages = useGameStore(state => state.gameState.customImages);
  const imageUrl = customImages?.[id];

  const style: React.CSSProperties = {
    width: typeof size === 'number' ? `${size}px` : size,
    height: typeof size === 'number' ? `${size}px` : size,
    borderRadius: shape === 'circle' ? '50%' : shape === 'rounded' ? '12px' : '0',
    overflow: 'hidden',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    background: '#1c1c1f', 
    border: border,
    flexShrink: 0,
    position: 'relative',
    
    // [í•µì‹¬] img íƒœê·¸ ëŒ€ì‹  background-image ì‚¬ìš©
    // ì´ëŸ¬ë©´ ì´ë¯¸ì§€ ë¡œë”© ì¤‘/ì‹¤íŒ¨/ì„±ê³µ ì—¬ë¶€ì™€ ìƒê´€ì—†ì´ íƒœê·¸ êµ¬ì¡°ê°€ <div> í•˜ë‚˜ë¡œ ì™„ë²½í•˜ê²Œ ê³ ì •ë©ë‹ˆë‹¤.
    // ë¦¬ì•¡íŠ¸ê°€ íƒœê·¸ë¥¼ ëºë‹¤ ê¼ˆë‹¤ í•  ì¼ì´ ì—†ìŠµë‹ˆë‹¤.
    backgroundImage: imageUrl ? `url(${imageUrl})` : 'none',
    backgroundSize: 'cover',
    backgroundPosition: 'center',
    backgroundRepeat: 'no-repeat'
  };

  return (
    <div style={style}>
      {/* ì´ë¯¸ì§€ê°€ ì—†ì„ ë•Œë§Œ ê¸€ì í‘œì‹œ (ë°°ê²½ ì´ë¯¸ì§€ê°€ ë®ìœ¼ë©´ ìì—°ìŠ¤ëŸ½ê²Œ ì•ˆë³´ì„) */}
      {!imageUrl && (
        <div style={{ 
          width:'100%', height:'100%', 
          display: 'flex', alignItems:'center', justifyContent:'center', 
          color: '#666', fontWeight:'bold',
          backgroundColor: 'rgba(0,0,0,0.5)' 
        }}>
           {fallback || (
             <span style={{ fontSize: '12px', textTransform:'uppercase' }}>
               {id ? id.split('_')[1]?.substring(0, 2) || '??' : '??'}
             </span>
           )}
        </div>
      )}
    </div>
  );
});



==========================================
FILE PATH: src/components/common/ModalPortal.tsx
==========================================
import React, { useEffect, useState } from 'react';
import { createPortal } from 'react-dom';

interface Props {
  children: React.ReactNode;
}

export const ModalPortal: React.FC<Props> = ({ children }) => {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
    return () => setMounted(false);
  }, []);

  if (!mounted) return null;

  // document.bodyì— ì§ì ‘ ë Œë”ë§í•˜ì—¬ ë¶€ëª¨ ì»´í¬ë„ŒíŠ¸ì˜ ìŠ¤íƒ€ì¼/ë Œë”ë§ ì˜í–¥ì—ì„œ ë²—ì–´ë‚¨
  return createPortal(children, document.body);
};



==========================================
FILE PATH: src/components/common/SaveLoadModal.tsx
==========================================
import React, { useState, useEffect } from 'react';
import { X, Save, Upload, Download } from 'lucide-react';
import { useGameStore } from '../../store/useGameStore';
import { saveToSlot, loadFromSlot, getSlotsMeta, exportSaveFile, importSaveFile, SaveMeta } from '../../engine/SaveLoadSystem';

interface Props { onClose: () => void; }

export const SaveLoadModal: React.FC<Props> = ({ onClose }) => {
  const { heroes } = useGameStore();
  const [slots, setSlots] = useState<Record<string, SaveMeta>>({});
  const [refreshKey, setRefreshKey] = useState(0); 

  useEffect(() => {
    setSlots(getSlotsMeta());
  }, [refreshKey]);

  const handleSave = (slotId: string) => {
    if (saveToSlot(slotId)) {
      alert("ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!");
      setSlots(getSlotsMeta());
    }
  };

  const handleLoad = (slotId: string) => {
    if (!slots[slotId]) return;

    if (confirm("ì •ë§ ì´ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì‹œê² ìŠµë‹ˆê¹Œ?\ní˜„ì¬ ì§„í–‰ ìƒí™©ì€ ë®ì–´ì”Œì›Œì§‘ë‹ˆë‹¤.")) {
      const success = loadFromSlot(slotId, heroes);
      if (success) {
        alert("ë¡œë“œ ì™„ë£Œ!");
        onClose();
        window.location.reload();
      } else {
        alert("ë¡œë“œ ì‹¤íŒ¨! ë°ì´í„°ê°€ ì†ìƒë˜ì—ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
      }
    }
  };

  const handleFileImport = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    if (confirm("íŒŒì¼ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì‹œê² ìŠµë‹ˆê¹Œ?")) {
      const success = await importSaveFile(file, heroes);
      if (success) {
        alert("íŒŒì¼ ë¡œë“œ ì™„ë£Œ!");
        onClose();
        window.location.reload();
      }
    }
    e.target.value = ''; 
  };

  const SlotItem = ({ id, name, color }: { id: string, name: string, color: string }) => {
    const info = slots[id];
    return (
      <div style={{ background: '#21262d', padding: '15px', borderRadius: '8px', marginBottom: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', border: `1px solid ${color}` }}>
        <div>
          <div style={{ fontWeight: 'bold', color: color, marginBottom: '4px' }}>{name}</div>
          {info ? (
            <div style={{ fontSize: '13px', color: '#ccc' }}>
              <div>Day {info.day} â€¢ ìœ ì € {info.totalUsers}ëª…</div>
              <div style={{ fontSize: '11px', color: '#777' }}>{new Date(info.timestamp).toLocaleString()}</div>
            </div>
          ) : (
            <div style={{ fontSize: '13px', color: '#555' }}>ë¹„ì–´ ìˆìŒ</div>
          )}
        </div>
        <div style={{ display: 'flex', gap: '8px' }}>
          {id !== 'auto' && (
            <button onClick={() => handleSave(id)} style={{ padding: '8px 12px', background: '#238636', border: 'none', borderRadius: '6px', color: '#fff', cursor: 'pointer', fontWeight: 'bold' }}>
              ì €ì¥
            </button>
          )}
          <button 
            onClick={() => handleLoad(id)} 
            disabled={!info}
            style={{ padding: '8px 12px', background: info ? '#1f6feb' : '#333', border: 'none', borderRadius: '6px', color: '#fff', cursor: info ? 'pointer' : 'default', fontWeight: 'bold', opacity: info ? 1 : 0.5 }}
          >
            ë¡œë“œ
          </button>
        </div>
      </div>
    );
  };

  return (
    <div style={{ position: 'fixed', top: 0, left: 0, width: '100%', height: '100%', background: 'rgba(0,0,0,0.8)', display: 'flex', justifyContent: 'center', alignItems: 'center', zIndex: 9999 }}>
      <div className="panel" style={{ width: '500px', background: '#161b22', border: '1px solid #333' }}>

        <div style={{ padding: '15px', borderBottom: '1px solid #333', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <h3 style={{ margin: 0, display:'flex', alignItems:'center', gap:'8px' }}><Save size={18}/> ì €ì¥ / ë¶ˆëŸ¬ì˜¤ê¸°</h3>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#fff', cursor: 'pointer' }}><X /></button>
        </div>

        <div style={{ padding: '20px' }}>
          <SlotItem id="auto" name="ğŸ”„ ìë™ ì €ì¥ (Auto Save)" color="#e89d40" />
          <div style={{ height: '1px', background: '#333', margin: '15px 0' }}></div>
          <SlotItem id="slot1" name="ğŸ“ ì €ì¥ ìŠ¬ë¡¯ 1" color="#58a6ff" />
          <SlotItem id="slot2" name="ğŸ“ ì €ì¥ ìŠ¬ë¡¯ 2" color="#58a6ff" />
          <SlotItem id="slot3" name="ğŸ“ ì €ì¥ ìŠ¬ë¡¯ 3" color="#58a6ff" />

          <div style={{ marginTop: '20px', paddingTop: '15px', borderTop: '1px dashed #333', display: 'flex', justifyContent: 'space-between' }}>
            <button onClick={exportSaveFile} style={{ background: 'none', border: 'none', color: '#8b949e', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '5px', fontSize: '12px' }}>
              <Download size={14}/> PC íŒŒì¼ë¡œ ë°±ì—…
            </button>
            <label style={{ cursor: 'pointer', color: '#8b949e', display: 'flex', alignItems: 'center', gap: '5px', fontSize: '12px' }}>
              <Upload size={14}/> PC íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°
              <input type="file" style={{ display: 'none' }} accept=".json" onChange={handleFileImport} />
            </label>
          </div>
        </div>

      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/common/StatCard.tsx
==========================================
import React, { useState, useEffect } from 'react';
import { LucideIcon } from 'lucide-react';

interface Props {
  title: string;
  value: string | number;
  icon: LucideIcon;
  color?: string;
}

export const StatCard: React.FC<Props> = ({ title, value, icon: Icon, color = "#58a6ff" }) => {
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return (
    <div className="stat-card-mini" style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      justifyContent: 'center',
      padding: isMobile ? '8px 4px' : '16px', 
      background: '#161b22',
      border: '1px solid #30363d',
      borderRadius: '8px',
      flex: 1,
      minWidth: 0,
    }}>
      <div style={{ 
        color: color,
        marginBottom: isMobile ? '4px' : '8px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        opacity: 0.9
      }}>
        {/* [ìˆ˜ì •] ì»´í¬ë„ŒíŠ¸ ì§ì ‘ ë Œë”ë§ ë°©ì‹ìœ¼ë¡œ ë³€ê²½ (ì•ˆì „ì„± í™•ë³´) */}
        <Icon size={isMobile ? 16 : 22} />
      </div>

      <div style={{ textAlign: 'center', width: '100%' }}>
        <div className="text-mono" style={{ 
          fontSize: isMobile ? '13px' : '18px', 
          fontWeight: '800',
          color: '#fff',
          whiteSpace: 'nowrap',
          overflow: 'hidden',
          textOverflow: 'ellipsis'
        }}>
          {value}
        </div>
        <div style={{ 
          fontSize: isMobile ? '8px' : '11px', 
          color: '#8b949e',
          marginTop: '1px',
          whiteSpace: 'nowrap'
        }}>
          {isMobile ? title.replace(' ', '') : title}
        </div>
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/common/SystemMenu.tsx
==========================================
import React, { useState } from 'react';
import { Save, Disc, AlertTriangle, X } from 'lucide-react';
import { OptionTab } from '../system/OptionTab';
import { SaveLoadTab } from '../system/SaveLoadTab';

interface Props { onClose: () => void; }

export const SystemMenu: React.FC<Props> = ({ onClose }) => {
  const [activeTab, setActiveTab] = useState<'SAVE' | 'LOAD' | 'OPTION'>('SAVE');

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };

  return (
    <div 
      onClick={handleBackdropClick} 
      style={{
        position: 'fixed', top: 0, left: 0, width: '100%', height: '100%',
        backgroundColor: 'rgba(0,0,0,0.85)', display: 'flex', justifyContent: 'center', alignItems: 'center', zIndex: 9999,
        backdropFilter: 'blur(5px)',
        padding: '10px' 
      }}
    >
      <div className="panel" style={{ 
        width: '100%', maxWidth: '450px', maxHeight: '90vh',
        background: '#1c1c1f', border: '1px solid #30363d', 
        display:'flex', flexDirection:'column', padding:0,
        overflow: 'hidden', borderRadius: '12px'
      }}>

        <div style={{ 
          padding: '15px 20px', borderBottom: '1px solid #333', 
          display: 'flex', justifyContent: 'space-between', alignItems: 'center', 
          background: '#252528', flexShrink: 0 
        }}>
          <h3 style={{ margin: 0, color: '#fff', fontSize: '16px' }}>ì‹œìŠ¤í…œ ë©”ë‰´</h3>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#fff', cursor: 'pointer', padding:'5px' }}>
            <X size={24} />
          </button>
        </div>

        <div style={{ display: 'flex', background: '#161b22', borderBottom: '1px solid #333', flexShrink: 0 }}>
          {([
            { id: 'SAVE', label: 'ì €ì¥', icon: Save },
            { id: 'LOAD', label: 'ë¶ˆëŸ¬ì˜¤ê¸°', icon: Disc },
            { id: 'OPTION', label: 'ì˜µì…˜', icon: AlertTriangle }
          ] as const).map(t => (
            <button
              key={t.id}
              onClick={() => setActiveTab(t.id)}
              style={{
                flex: 1, padding: '15px', background: 'none', border: 'none',
                borderBottom: activeTab === t.id ? '2px solid #58a6ff' : '2px solid transparent',
                color: activeTab === t.id ? '#fff' : '#777', fontWeight: 'bold', cursor: 'pointer',
                display:'flex', alignItems:'center', justifyContent:'center', gap:'8px'
              }}
            >
              <t.icon size={16} /> {t.label}
            </button>
          ))}
        </div>

        <div style={{ flex: 1, overflowY: 'auto', padding: '20px' }}>
          {activeTab === 'SAVE' && <SaveLoadTab mode="SAVE" />}
          {activeTab === 'LOAD' && <SaveLoadTab mode="LOAD" />}
          {activeTab === 'OPTION' && <OptionTab />}
        </div>

      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/community/CommunityBoard.tsx
==========================================
import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { Star, ThumbsUp } from 'lucide-react';
import { Post } from '../../types';

export const CommunityBoard: React.FC = () => {
  const { communityPosts, openPost } = useGameStore();
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  const [tab, setTab] = useState<'all' | 'best'>('all');
  const [page, setPage] = useState(1);

  const POSTS_PER_PAGE = isMobile ? 15 : 20;

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const handleTabChange = (newTab: 'all' | 'best') => {
    setTab(newTab);
    setPage(1);
  };

  const filteredPosts = tab === 'best' 
    ? communityPosts.filter(p => p.isBest || p.upvotes >= 10) 
    : communityPosts;

  const totalPages = Math.ceil(filteredPosts.length / POSTS_PER_PAGE);
  const startIndex = (page - 1) * POSTS_PER_PAGE;
  const currentPosts = filteredPosts.slice(startIndex, startIndex + POSTS_PER_PAGE);

  const getCategoryColor = (cat: string) => {
    switch (cat) {
      case 'ê³µëµ': return '#58a6ff'; 
      case 'ë¶„ì„': return '#58a6ff';
      case 'ì§•ì§•': return '#e84057'; 
      case 'ìœ ë¨¸': return '#f1c40f'; 
      case 'ìë‘': return '#2ecc71';
      default: return '#8b949e';     
    }
  };

  // [ìˆ˜ì •ë¨] post íƒ€ì… ëª…ì‹œ
  const MobilePostItem = ({ post }: { post: Post }) => (
    <div 
      onClick={() => openPost(post)}
      style={{ 
        padding: '12px 15px', 
        borderBottom: '1px solid #2c2c2f', 
        background: post.isBest ? 'rgba(232, 64, 87, 0.05)' : '#1c1c1f',
        cursor: 'pointer'
      }}
    >
      <div style={{ display: 'flex', alignItems: 'center', marginBottom: '6px', lineHeight: '1.4' }}>
        {post.isBest && (
          <span style={{ fontSize:'10px', background:'#e84057', color:'#fff', padding:'1px 4px', borderRadius:'3px', marginRight:'6px', flexShrink:0 }}>
            BEST
          </span>
        )}
        <span style={{ 
          color: '#e6edf3', 
          fontSize: '15px', 
          fontWeight: post.isBest ? 'bold' : 'normal',
          overflow: 'hidden', textOverflow: 'ellipsis', display: '-webkit-box', WebkitLineClamp: 1, WebkitBoxOrient: 'vertical'
        }}>
          {post.title}
        </span>
        {post.comments > 0 && (
          <span style={{ color:'#58a6ff', fontSize:'13px', marginLeft:'6px', fontWeight:'bold', flexShrink:0 }}>
            [{post.comments}]
          </span>
        )}
      </div>

      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', fontSize: '12px', color: '#8b949e' }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
          <span style={{ color: getCategoryColor(post.category), fontWeight:'bold' }}>{post.category}</span>
          <span style={{ width:'1px', height:'10px', background:'#444' }}></span>
          <span>{post.author}</span>
          <span style={{ width:'1px', height:'10px', background:'#444' }}></span>
          <span>{post.displayTime}</span>
        </div>

        {post.upvotes > 0 && (
          <div style={{ display: 'flex', alignItems: 'center', gap: '4px', color: post.upvotes >= 10 ? '#e84057' : '#8b949e' }}>
            <ThumbsUp size={12} />
            <span>{post.upvotes}</span>
          </div>
        )}
      </div>
    </div>
  );

  return (
    <div className="panel" style={{ 
      height: isMobile ? '80vh' : '700px', 
      position: 'relative', zIndex: 10,
      background: '#1c1c1f', border: '1px solid #30363d', 
      display:'flex', flexDirection:'column', padding: 0, overflow:'hidden'
    }}>
      <div style={{ padding: '12px 15px', borderBottom: '1px solid #333', background: '#252528', display:'flex', justifyContent:'space-between', alignItems:'center', flexShrink: 0 }}>
        <h3 style={{ margin: 0, color:'#fff', fontSize: '16px', fontWeight: '800' }}>ì˜¤ë¼í´ ììœ ê²Œì‹œíŒ</h3>
        <div style={{ display:'flex', background:'#161b22', borderRadius:'6px', padding:'3px' }}>
          <button onClick={() => handleTabChange('all')} style={{ padding: '6px 12px', border: 'none', borderRadius: '4px', cursor: 'pointer', fontWeight: 'bold', fontSize:'12px', background: tab === 'all' ? '#30363d' : 'transparent', color: tab === 'all' ? '#fff' : '#666' }}>ì „ì²´</button>
          <button onClick={() => handleTabChange('best')} style={{ padding: '6px 12px', border: 'none', borderRadius: '4px', cursor: 'pointer', fontWeight: 'bold', fontSize:'12px', background: tab === 'best' ? '#e84057' : 'transparent', color: tab === 'best' ? '#fff' : '#666', display:'flex', alignItems:'center', gap:'4px' }}><Star size={12}/> ë…ê¸€</button>
        </div>
      </div>

      <div style={{ flex: 1, overflowY: 'auto', background: '#161b22' }}>
        {isMobile ? (
          <div>{currentPosts.map((post) => <MobilePostItem key={post.id} post={post} />)}</div>
        ) : (
          <table style={{ width: '100%', borderCollapse: 'collapse', fontSize:'13px', tableLayout:'fixed' }}>
            <thead>
              <tr style={{ background:'#161b22', color:'#8b949e', height:'35px', borderBottom:'1px solid #333' }}>
                <th style={{ width:'50px', textAlign:'center' }}>ë²ˆí˜¸</th>
                <th style={{ width:'60px', textAlign:'center' }}>íƒ­</th>
                <th style={{ textAlign:'left', paddingLeft:'10px' }}>ì œëª©</th>
                <th style={{ width:'100px', textAlign:'center' }}>ê¸€ì“´ì´</th>
                <th style={{ width:'70px', textAlign:'center' }}>ì‹œê°„</th>
                <th style={{ width:'50px', textAlign:'center' }}>ì¡°íšŒ</th>
                <th style={{ width:'50px', textAlign:'center' }}>ì¶”ì²œ</th>
              </tr>
            </thead>
            <tbody>
              {currentPosts.map((post, idx) => (
                <tr key={post.id} onClick={() => openPost(post)} style={{ borderBottom:'1px solid #252528', cursor:'pointer', height:'36px', background: post.isBest ? 'rgba(232, 64, 87, 0.05)' : 'transparent' }} onMouseEnter={e => e.currentTarget.style.backgroundColor = '#222'} onMouseLeave={e => e.currentTarget.style.backgroundColor = post.isBest ? 'rgba(232, 64, 87, 0.05)' : 'transparent'}>
                  <td style={{ textAlign:'center', color:'#555' }}>{filteredPosts.length - (startIndex + idx)}</td>
                  <td style={{ textAlign:'center', color: getCategoryColor(post.category) }}>{post.category}</td>
                  <td style={{ padding:'0 10px', overflow:'hidden', whiteSpace:'nowrap', textOverflow:'ellipsis' }}>
                    <span style={{ color: post.isBest ? '#fff' : '#ddd', fontWeight: post.isBest ? 'bold' : 'normal' }}>{post.title}</span>
                    {post.comments > 0 && <span style={{ color:'#58a6ff', fontSize:'11px', marginLeft:'6px', fontWeight:'bold' }}>[{post.comments}]</span>}
                  </td>
                  <td style={{ textAlign:'center', color:'#888', overflow:'hidden', whiteSpace:'nowrap', textOverflow:'ellipsis' }}>{post.author}</td>
                  <td style={{ textAlign:'center', color:'#666' }}>{post.displayTime}</td>
                  <td style={{ textAlign:'center', color:'#666' }}>{post.views}</td>
                  <td style={{ textAlign:'center', color: post.upvotes > 0 ? '#e84057' : '#666' }}>{post.upvotes}</td>
                </tr>
              ))}
            </tbody>
          </table>
        )}
        {currentPosts.length === 0 && <div style={{ textAlign:'center', padding:'40px', color:'#555', fontSize:'13px' }}>ê²Œì‹œê¸€ì´ ì—†ìŠµë‹ˆë‹¤.</div>}
      </div>

      <div style={{ padding: '12px', borderTop: '1px solid #333', display: 'flex', justifyContent: 'center', gap: '10px', background: '#161b22', flexShrink: 0 }}>
        <button disabled={page === 1} onClick={() => setPage(p => Math.max(1, p - 1))} className="btn" style={{ background:'#333', color:'#fff', padding:'6px 12px', opacity: page===1?0.5:1, fontSize:'12px' }}>ì´ì „</button>
        <span style={{ display:'flex', alignItems:'center', color:'#fff', padding:'0 10px', fontSize:'13px', fontFamily:'monospace' }}>{page} / {totalPages || 1}</span>
        <button disabled={page >= totalPages} onClick={() => setPage(p => Math.min(totalPages, p + 1))} className="btn" style={{ background:'#333', color:'#fff', padding:'6px 12px', opacity: page>=totalPages?0.5:1, fontSize:'12px' }}>ë‹¤ìŒ</button>
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/community/PostDetailModal.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/community/PostDetailModal.tsx
// ==========================================

import React, { useState, useEffect } from 'react';
import { Post, UserProfile } from '../../types';
import { useGameStore } from '../../store/useGameStore';
// [ê²½ë¡œ ìˆ˜ì •ë¨] system í´ë” ì¶”ê°€
import { findUserProfileByName } from '../../engine/system/UserManager';
import { X, MessageSquare, ThumbsUp, ThumbsDown, User, Clock, Eye } from 'lucide-react';

interface Props {
  post: Post;
  onClose: () => void;
  onUserClick: (user: UserProfile) => void;
}

const getTierColor = (tier: string) => {
  if (tier.includes('ì²œìƒê³„') || tier.includes('ì±Œë¦°ì €')) return '#00bfff';
  if (tier.includes('ë§ˆìŠ¤í„°')) return '#9b59b6';
  if (tier.includes('ì—ì´ìŠ¤')) return '#e74c3c';
  if (tier.includes('ì¡°ì»¤')) return '#2ecc71';
  if (tier.includes('ê³¨ë“œ')) return '#f1c40f';
  if (tier.includes('ì‹¤ë²„')) return '#95a5a6';
  if (tier.includes('ë¸Œë¡ ì¦ˆ')) return '#d35400';
  return '#7f8c8d';
};

export const PostDetailModal: React.FC<Props> = ({ post, onClose, onUserClick }) => {
  const { gameState } = useGameStore();
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  useEffect(() => {
    document.body.style.overflow = 'hidden';
    return () => { document.body.style.overflow = 'unset'; };
  }, []);

  const handleAuthorClick = () => {
    const userProfile = findUserProfileByName(post.author, gameState.tierConfig);
    if (userProfile) {
      onUserClick(userProfile);
    } else {
      alert("í•´ë‹¹ ìœ ì € ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }
  };

  const overlayStyle: React.CSSProperties = isMobile ? {
    position: 'fixed', inset: 0, zIndex: 20000, 
    backgroundColor: '#0f1115',
    overflowY: 'auto', WebkitOverflowScrolling: 'touch',
    display: 'block'
  } : {
    position: 'fixed', top: 0, left: 0, width: '100%', height: '100%',
    backgroundColor: 'rgba(0,0,0,0.85)', display: 'flex', justifyContent: 'center', alignItems: 'center', 
    zIndex: 20000, backdropFilter: 'blur(3px)'
  };

  const panelStyle: React.CSSProperties = isMobile ? {
    width: '100%', minHeight: '100%', 
    background: '#1c1c1f', display: 'flex', flexDirection: 'column',
    boxSizing: 'border-box'
  } : {
    width: '100%', maxWidth: '700px', height:'85vh', 
    background: '#1c1c1f', border: '1px solid #30363d', 
    display:'flex', flexDirection:'column', borderRadius: '12px', overflow: 'hidden',
    boxShadow: '0 50px 100px -20px rgba(0,0,0,0.7)'
  };

  return (
    <div style={overlayStyle}>
      <div style={panelStyle}>
        {/* í—¤ë” */}
        <div style={{ 
          padding: '15px 20px', borderBottom: '1px solid #30363d', 
          display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start',
          background: '#252528',
          position: isMobile ? 'sticky' : 'relative', top: 0, zIndex: 50
        }}>
          <div style={{ flex: 1, paddingRight: '10px' }}>
            <div style={{ display:'flex', alignItems:'center', gap:'8px', marginBottom: '6px' }}>
              <span style={{ fontSize: '11px', color: '#58a6ff', border:'1px solid #58a6ff', padding:'1px 4px', borderRadius:'3px' }}>
                {post.category}
              </span>
              {post.isBest && <span style={{ fontSize: '11px', background: '#e84057', color: '#fff', padding:'1px 4px', borderRadius:'3px' }}>ë…ê¸€</span>}
            </div>
            <h2 style={{ margin: 0, fontSize: '18px', color: '#fff', lineHeight:'1.4', wordBreak:'keep-all' }}>{post.title}</h2>

            <div style={{ marginTop: '10px', fontSize: '12px', color: '#8b949e', display:'flex', flexWrap:'wrap', alignItems:'center', gap:'10px' }}>
              <div 
                onClick={handleAuthorClick}
                style={{ 
                  display:'flex', alignItems:'center', gap:'4px', cursor:'pointer', 
                  color: '#ccc', fontWeight:'bold', 
                  background: '#30363d', padding: '4px 8px', borderRadius: '4px',
                  border: '1px solid #444'
                }}
              >
                <User size={12} />
                {post.author} 
                <span style={{color: getTierColor(post.authorTier), fontWeight:'bold', fontSize:'11px'}}>
                  ({post.authorTier})
                </span>
              </div>
              <span style={{ display:'flex', alignItems:'center', gap:'4px' }}><Clock size={12}/> {post.displayTime}</span>
              <span style={{ display:'flex', alignItems:'center', gap:'4px' }}><Eye size={12}/> {post.views}</span>
            </div>
          </div>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#fff', cursor: 'pointer', padding:'5px' }}>
            <X size={24} />
          </button>
        </div>

        {/* ë³¸ë¬¸ */}
        <div style={{ 
          padding: '25px 20px', 
          color: '#e6edf3', fontSize: '15px', lineHeight: '1.7', 
          flex: 1, 
          overflowY: isMobile ? 'visible' : 'auto', 
          whiteSpace: 'pre-wrap',
          minHeight: '200px'
        }}>
          {post.content}
          <div style={{ marginTop:'50px', display:'flex', justifyContent:'center', gap:'15px' }}>
            <button style={{ 
              background:'#21262d', border:'1px solid #30363d', color:'#fff', 
              padding:'10px 20px', borderRadius:'30px', 
              display:'flex', alignItems:'center', gap:'8px', cursor:'pointer',
              fontSize:'14px', fontWeight:'bold'
            }}>
              <ThumbsUp size={18} color="#e89d40" /> 
              <span>{post.upvotes}</span>
            </button>
            <button style={{ 
              background:'#21262d', border:'1px solid #30363d', color:'#8b949e', 
              padding:'10px 20px', borderRadius:'30px', 
              display:'flex', alignItems:'center', gap:'8px', cursor:'pointer',
              fontSize:'14px', fontWeight:'bold'
            }}>
              <ThumbsDown size={18} /> 
              <span>{post.downvotes || 0}</span>
            </button>
          </div>
        </div>

        {/* ëŒ“ê¸€ì°½ */}
        <div style={{ background: '#161b22', borderTop: '1px solid #30363d', flexShrink: 0 }}>
          <div style={{ padding: '15px 20px', display:'flex', alignItems:'center', gap:'6px', color:'#fff', borderBottom:'1px solid #30363d', background:'#252528' }}>
            <MessageSquare size={16} /> ëŒ“ê¸€ <span style={{color:'#58a6ff', fontWeight:'bold'}}>{post.commentList?.length || 0}</span>
          </div>
          <div style={{ 
            maxHeight: isMobile ? 'none' : '300px', 
            overflowY: isMobile ? 'visible' : 'auto',
            paddingBottom: isMobile ? '50px' : '0' 
          }}>
            <div style={{ display:'flex', flexDirection:'column' }}>
              {post.commentList && post.commentList.map((comment) => (
                <div key={comment.id} style={{ padding: '15px 20px', borderBottom: '1px solid #2c2c2f' }}>
                  <div style={{ display:'flex', justifyContent:'space-between', marginBottom:'6px' }}>
                    <span style={{ fontWeight:'bold', fontSize:'13px', color:'#ccc', display:'flex', alignItems:'center', gap:'6px' }}>
                      {comment.author} 
                      <span style={{ fontSize:'10px', color: getTierColor(comment.authorTier), background:'#0d1117', padding:'1px 4px', borderRadius:'3px', border:'1px solid #333', fontWeight:'bold' }}>
                        {comment.authorTier}
                      </span>
                    </span>
                    <span style={{ fontSize:'11px', color:'#555' }}>{comment.timestamp}</span>
                  </div>
                  <div style={{ fontSize:'13px', color:'#aaa', lineHeight:'1.4' }}>{comment.content}</div>
                </div>
              ))}
              {(!post.commentList || post.commentList.length === 0) && (
                <div style={{ color:'#555', fontSize:'13px', textAlign:'center', padding:'40px 20px' }}>
                  ì•„ì§ ì‘ì„±ëœ ëŒ“ê¸€ì´ ì—†ìŠµë‹ˆë‹¤.
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};


==========================================
FILE PATH: src/components/dashboard/GameStats.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/dashboard/GameStats.tsx
// ==========================================

import React from 'react';
import { useGameStore } from '../../store/useGameStore';
import { StatCard } from '../common/StatCard';
import { Users, Activity, Smile, Frown, Meh, Monitor } from 'lucide-react';

interface Props {
  isMobile: boolean;
  onOpenGameList: () => void;
}

export const GameStats: React.FC<Props> = ({ isMobile, onOpenGameList }) => {
  const { gameState } = useGameStore();

  // ë¯¼ì‹¬ ìƒíƒœì— ë”°ë¥¸ UI ì†ì„± ë°˜í™˜
  const getSentimentInfo = (value: number) => {
    if (value >= 70) return { icon: Smile, color: '#2ecc71', label: 'ì¶•ì œ' }; // ë†’ìŒ: ì´ˆë¡
    if (value >= 40) return { icon: Meh, color: '#f1c40f', label: 'ë³´í†µ' };   // ì¤‘ê°„: ë…¸ë‘
    return { icon: Frown, color: '#e74c3c', label: 'í­ë™' };                  // ë‚®ìŒ: ë¹¨ê°•
  };

  const sentiment = gameState.userSentiment || 60;
  const sentInfo = getSentimentInfo(sentiment);

  return (
    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: isMobile ? '6px' : '15px', marginBottom: '20px' }}>

      <StatCard 
        title="ê°€ì…ì" 
        value={(gameState.totalUsers ?? 0).toLocaleString()} 
        icon={Users} 
        color="#fff" 
      />

      <StatCard 
        title="CCU" 
        value={(gameState.ccu ?? 0).toLocaleString()} 
        icon={Activity} 
        color="#58a6ff" 
      />

      {/* ë™ì  ë¯¼ì‹¬ ì¹´ë“œ */}
      <StatCard 
        title={`ë¯¼ì‹¬ (${sentInfo.label})`} 
        value={sentiment.toFixed(1)} 
        icon={sentInfo.icon} 
        color={sentInfo.color} 
      />

      <div onClick={onOpenGameList} style={{ cursor: 'pointer' }}>
        <StatCard 
          title="ì§„í–‰ì¤‘" 
          value={gameState.liveMatches?.length ?? 0} 
          icon={Monitor} 
          color="#9b59b6" 
        />
      </div>
    </div>
  );
};


==========================================
FILE PATH: src/components/hero/CustomizeHeroModal.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/hero/CustomizeHeroModal.tsx
// ==========================================

import React, { useState, useRef } from 'react';
import { Hero } from '../../types';
import { useGameStore } from '../../store/useGameStore';
import { X, Save, Camera, Image as ImageIcon, Upload, Trash2 } from 'lucide-react';
import { GameIcon } from '../common/GameIcon';

interface Props {
  hero: Hero;
  onClose: () => void;
}

export const CustomizeHeroModal: React.FC<Props> = ({ hero, onClose }) => {
  const { updateHero, setCustomImage, removeCustomImage } = useGameStore();

  // ìƒíƒœ ê´€ë¦¬: hero.conceptê°€ ìˆìœ¼ë©´ ê·¸ê±¸ ì“°ê³ , ì—†ìœ¼ë©´ ê¸°ë³¸ ë¬¸êµ¬
  const [name, setName] = useState(hero.name);
  const [concept, setConcept] = useState(hero.concept || "ìƒˆë¡œìš´ ì˜ì›…ì˜ íƒ„ìƒ");

  const profileRef = useRef<HTMLInputElement>(null);
  const bgRef = useRef<HTMLInputElement>(null);

  const handleSave = () => {
    // [í•µì‹¬ ìˆ˜ì •] concept í•„ë“œì— ì§ì ‘ ì €ì¥í•˜ì—¬ ì¦‰ì‹œ ë°˜ì˜ë˜ë„ë¡ í•¨
    updateHero(hero.id, { name, concept });
    alert('ì»¤ìŠ¤í„°ë§ˆì´ì§•ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
    onClose();
  };

  const handleUpload = (id: string, e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        if (typeof reader.result === 'string') setCustomImage(id, reader.result);
      };
      reader.readAsDataURL(file);
    }
  };

  return (
    <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.85)', zIndex: 9999, display: 'flex', justifyContent: 'center', alignItems: 'center', padding:'20px' }}>
      <div style={{ width: '100%', maxWidth: '400px', background: '#161b22', borderRadius: '16px', border: '1px solid #30363d', overflow: 'hidden' }}>

        {/* í—¤ë” */}
        <div style={{ padding: '15px 20px', borderBottom: '1px solid #333', display: 'flex', justifyContent: 'space-between', alignItems: 'center', background:'#21262d' }}>
          <h3 style={{ margin: 0, color: '#fff', fontSize:'16px' }}>ì˜ì›… ì»¤ìŠ¤í„°ë§ˆì´ì§•</h3>
          <button onClick={onClose} style={{ background:'none', border:'none', color:'#ccc', cursor:'pointer' }}><X size={20}/></button>
        </div>

        {/* ë°”ë”” */}
        <div style={{ padding: '20px', display:'flex', flexDirection:'column', gap:'20px' }}>

          {/* 1. ì‚¬ì§„ ë³€ê²½ ì˜ì—­ */}
          <div style={{ display:'flex', gap:'15px' }}>
            {/* í”„ë¡œí•„ ì‚¬ì§„ */}
            <div style={{ flex:1, display:'flex', flexDirection:'column', gap:'5px' }}>
                <div 
                onClick={() => profileRef.current?.click()}
                style={{ aspectRatio:'1/1', background:'#0d1117', border:'1px dashed #555', borderRadius:'12px', display:'flex', flexDirection:'column', alignItems:'center', justifyContent:'center', cursor:'pointer', color:'#888' }}
                >
                <GameIcon id={hero.id} size={50} shape="rounded" />
                <div style={{ fontSize:'11px', marginTop:'8px', display:'flex', alignItems:'center', gap:'4px' }}><Camera size={12}/> í”„ë¡œí•„</div>
                <input type="file" ref={profileRef} style={{ display: 'none' }} accept="image/*" onChange={(e) => handleUpload(hero.id, e)} />
                </div>
                <button onClick={() => removeCustomImage(hero.id)} style={{ fontSize:'10px', color:'#da3633', background:'none', border:'none', cursor:'pointer', display:'flex', justifyContent:'center', alignItems:'center', gap:'2px' }}>
                    <Trash2 size={10}/> ì´ˆê¸°í™”
                </button>
            </div>

            {/* ë°°ê²½ ì‚¬ì§„ */}
            <div style={{ flex:1, display:'flex', flexDirection:'column', gap:'5px' }}>
                <div 
                onClick={() => bgRef.current?.click()}
                style={{ aspectRatio:'1/1', background:'#0d1117', border:'1px dashed #555', borderRadius:'12px', display:'flex', flexDirection:'column', alignItems:'center', justifyContent:'center', cursor:'pointer', color:'#888' }}
                >
                <ImageIcon size={30} />
                <div style={{ fontSize:'11px', marginTop:'8px', display:'flex', alignItems:'center', gap:'4px' }}><Upload size={12}/> ë°°ê²½</div>
                <input type="file" ref={bgRef} style={{ display: 'none' }} accept="image/*" onChange={(e) => handleUpload(`${hero.id}_bg`, e)} />
                </div>
                <button onClick={() => removeCustomImage(`${hero.id}_bg`)} style={{ fontSize:'10px', color:'#da3633', background:'none', border:'none', cursor:'pointer', display:'flex', justifyContent:'center', alignItems:'center', gap:'2px' }}>
                    <Trash2 size={10}/> ì´ˆê¸°í™”
                </button>
            </div>
          </div>

          {/* 2. í…ìŠ¤íŠ¸ ë³€ê²½ ì˜ì—­ */}
          <div>
            <label style={{ fontSize:'12px', color:'#8b949e', marginBottom:'5px', display:'block' }}>ì˜ì›… ì´ë¦„</label>
            <input 
              type="text" value={name} onChange={(e) => setName(e.target.value)}
              style={{ width:'100%', padding:'12px', background:'#0d1117', border:'1px solid #30363d', color:'#fff', borderRadius:'8px', fontSize:'14px', fontWeight:'bold', boxSizing:'border-box' }}
            />
          </div>

          <div>
            <label style={{ fontSize:'12px', color:'#8b949e', marginBottom:'5px', display:'block' }}>ì»¨ì…‰ ë¬¸êµ¬ (ëŒ€ì‚¬)</label>
            <input 
              type="text" value={concept} onChange={(e) => setConcept(e.target.value)}
              style={{ width:'100%', padding:'12px', background:'#0d1117', border:'1px solid #30363d', color:'#fff', borderRadius:'8px', fontSize:'13px', fontStyle:'italic', boxSizing:'border-box' }}
            />
          </div>

        </div>

        {/* í‘¸í„° */}
        <div style={{ padding: '15px', borderTop: '1px solid #333', background:'#21262d' }}>
          <button onClick={handleSave} style={{ width:'100%', padding:'12px', background:'#238636', color:'#fff', border:'none', borderRadius:'8px', fontWeight:'bold', cursor:'pointer', display:'flex', justifyContent:'center', gap:'8px' }}>
            <Save size={16}/> ì €ì¥í•˜ê¸°
          </button>
        </div>

      </div>
    </div>
  );
};


==========================================
FILE PATH: src/components/hero/detail/GrowthStatsPanel.tsx
==========================================
import React from 'react';
import { Hero } from '../../../types';
import { TrendingUp, Coins, Activity, Target, Shield } from 'lucide-react';

interface Props {
  hero: Hero;
  isMobile: boolean;
}

const StatBox = ({ label, value, icon, color, subText }: any) => (
  <div style={{ 
    background: '#252528', padding: '12px', borderRadius: '8px', 
    border: '1px solid #333', display: 'flex', flexDirection: 'column', gap: '4px' 
  }}>
    <div style={{ display: 'flex', alignItems: 'center', gap: '6px', fontSize: '11px', color: '#aaa', fontWeight: 'bold' }}>
      {icon} {label}
    </div>
    <div style={{ fontSize: '16px', fontWeight: '900', color: color, fontFamily: 'monospace' }}>
      {value}
    </div>
    {subText && <div style={{ fontSize: '10px', color: '#666' }}>{subText}</div>}
  </div>
);

export const GrowthStatsPanel: React.FC<Props> = ({ hero, isMobile }) => {
  // [ì•ˆì „ì¥ì¹˜] recordê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©
  const record = hero.record || { totalMatches: 0, totalDeaths: 0 };
  
  const totalMatches = Math.max(1, record.totalMatches);
  const parseStat = (val: any) => {
    if (!val) return 0;
    const parsed = parseFloat(String(val).replace(/,/g, ''));
    return isNaN(parsed) ? 0 : parsed;
  };

  const gpm = parseStat(hero.avgGold);
  const cspm = parseStat(hero.avgCs);
  const dpm = parseStat(hero.avgDpm);
  
  const goldEfficiency = gpm > 0 ? ((dpm / gpm) * 100).toFixed(0) : '0';
  const avgDeaths = (record.totalDeaths || 0) / totalMatches;
  const survivalScore = Math.max(0, 100 - (avgDeaths * 8));

  const getScoreColor = (score: number) => {
    if (score >= 80) return '#2ecc71';
    if (score >= 50) return '#f1c40f';
    return '#da3633';
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '10px', height: '100%' }}>
      <h4 style={{ color: '#fff', margin: '0', fontSize: '14px', display: 'flex', alignItems: 'center', gap: '6px' }}>
        <TrendingUp size={14} color="#2ecc71"/> ì„±ì¥ ì§€í‘œ ë¶„ì„
      </h4>
      
      <div style={{ 
        display: 'grid', 
        gridTemplateColumns: isMobile ? '1fr 1fr' : '1fr 1fr', 
        gap: '10px' 
      }}>
        <StatBox 
          label="GPM" 
          value={Math.floor(gpm).toLocaleString()} 
          icon={<Coins size={12}/>} 
          color="#f1c40f"
          subText="ë¶„ë‹¹ ê³¨ë“œ" 
        />
        <StatBox 
          label="CSPM" 
          value={cspm.toFixed(1)} 
          icon={<Target size={12}/>} 
          color="#ccc" 
          subText="ë¶„ë‹¹ CS"
        />
        <StatBox 
          label="ìƒì¡´ ì ìˆ˜" 
          value={survivalScore.toFixed(0)} 
          icon={<Shield size={12}/>} 
          color={getScoreColor(survivalScore)} 
          subText={`í‰ê·  ${avgDeaths.toFixed(1)}ë°ìŠ¤`}
        />
        <StatBox 
          label="ê³¨ë“œ íš¨ìœ¨" 
          value={`${goldEfficiency}%`} 
          icon={<Activity size={12}/>} 
          color="#58a6ff" 
          subText="DPM/GPM"
        />
      </div>
      
      <div style={{ background: '#252528', padding: '10px', borderRadius: '8px', fontSize: '11px', color: '#888', lineHeight: '1.4', border:'1px dashed #444' }}>
        * <strong>ìƒì¡´ ì ìˆ˜</strong>ê°€ ë†’ì„ìˆ˜ë¡ ì•ˆì •ì ì¸ ì„±ì¥ì„ ì˜ë¯¸í•˜ë©°, <strong>ê³¨ë“œ íš¨ìœ¨</strong>ì´ ë†’ì„ìˆ˜ë¡ ì ì€ ëˆìœ¼ë¡œ ë†’ì€ ë”œì„ ë¿œì–´ëƒ…ë‹ˆë‹¤.
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/hero/detail/HeroPolygonChart.tsx
==========================================
import React from 'react';
import { Hero } from '../../../types';

interface Props {
  hero: Hero;
}

export const HeroPolygonChart: React.FC<Props> = ({ hero }) => {
  // [Fix] ìˆ«ìê°€ ì•„ë‹ˆë©´ ë¬´ì¡°ê±´ 0 ë°˜í™˜ (NaN ë°©ì§€)í•˜ì—¬ SVG ë Œë”ë§ ì˜¤ë¥˜ ì˜ˆë°©
  const safeParse = (val: any) => {
    if (!val) return 0;
    // ì‰¼í‘œ ì œê±° í›„ íŒŒì‹±
    const num = parseFloat(String(val).replace(/,/g, ''));
    return isNaN(num) ? 0 : num;
  };

  const MAX_DPM = 3000;
  const MAX_DPG = 4000;
  const MAX_GOLD = 15000;
  const MAX_KDA = 5.0;
  const MAX_UTIL = 15;

  // ë°ì´í„° ì•ˆì „ ì •ê·œí™”
  const stats = {
    combat: Math.min(100, (safeParse(hero.avgDpm) / MAX_DPM) * 100),
    tank: Math.min(100, (safeParse(hero.avgDpg) / MAX_DPG) * 100),
    growth: Math.min(100, (safeParse(hero.avgGold) / MAX_GOLD) * 100),
    survival: Math.min(100, (parseFloat(hero.kdaRatio || '0') / MAX_KDA) * 100),
    utility: Math.min(100, (( (hero.record?.totalAssists || 0) / Math.max(1, hero.record?.totalMatches || 1)) / MAX_UTIL) * 100)
  };

  // ëª¨ë“  ê°’ì´ ìˆ«ìì¸ì§€ ìµœì¢… í™•ì¸ (í•˜ë‚˜ë¼ë„ NaNì´ë©´ 0 ì²˜ë¦¬)
  const values = [
    isNaN(stats.combat) ? 0 : stats.combat,
    isNaN(stats.tank) ? 0 : stats.tank,
    isNaN(stats.growth) ? 0 : stats.growth,
    isNaN(stats.survival) ? 0 : stats.survival,
    isNaN(stats.utility) ? 0 : stats.utility
  ];

  const labels = ["ì „íˆ¬", "ë°©ì–´", "ì„±ì¥", "ìƒì¡´", "ìœ í‹¸"];

  // SVG ì¢Œí‘œ ê³„ì‚°
  const angle = (deg: number) => (deg - 90) * (Math.PI / 180);
  const getPoint = (value: number, idx: number, total: number) => {
    const r = (value / 100) * 40;
    const a = angle((360 / total) * idx);
    return `${50 + r * Math.cos(a)},${50 + r * Math.sin(a)}`;
  };
  
  const polyPoints = values.map((v, i) => getPoint(v, i, 5)).join(" ");
  const bgPoints = values.map((_, i) => getPoint(100, i, 5)).join(" ");

  return (
    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', height: '100%', justifyContent:'center' }}>
      <div style={{ position: 'relative', width: '160px', height: '160px' }}>
        <svg viewBox="0 0 100 100" style={{ width: '100%', height: '100%', overflow: 'visible' }}>
          {/* ë°°ê²½ ì˜¤ê°í˜• */}
          <polygon points={bgPoints} fill="#1c1c1f" stroke="#333" strokeWidth="1" />
          {[80, 60, 40, 20].map((r, i) => (
             <polygon key={i} points={values.map((_, idx) => getPoint(r, idx, 5)).join(" ")} fill="none" stroke="#333" strokeWidth="0.5" strokeDasharray="2,2" />
          ))}
          
          {/* ì‹¤ì œ ë°ì´í„° ê·¸ë˜í”„ */}
          <polygon points={polyPoints} fill="rgba(88, 166, 255, 0.4)" stroke="#58a6ff" strokeWidth="2" />
          
          {/* ë¼ë²¨ */}
          {labels.map((label, i) => {
            const pos = getPoint(125, i, 5).split(',');
            return (
              <text key={i} x={pos[0]} y={pos[1]} fontSize="8" fill="#aaa" textAnchor="middle" dominantBaseline="middle" fontWeight="bold">
                {label}
              </text>
            );
          })}
        </svg>
      </div>
      <div style={{ marginTop:'5px', fontSize:'11px', color:'#666' }}>ëŠ¥ë ¥ì¹˜ ë¶„ì„</div>
    </div>
  );
};



==========================================
FILE PATH: src/components/hero/detail/ItemBuildAnalysis.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/hero/detail/ItemBuildAnalysis.tsx
// ==========================================
import React, { useMemo } from 'react';
import { useGameStore } from '../../../store/useGameStore';
import { Hero } from '../../../types';
import { GameIcon } from '../../common/GameIcon';
import { ShoppingBag, TrendingUp, AlertCircle } from 'lucide-react';

interface Props {
  hero: Hero;
}

export const ItemBuildAnalysis: React.FC<Props> = ({ hero }) => {
  const { gameState, shopItems } = useGameStore();
  const { itemStats, godStats } = gameState;

  // ì „ì²´ ê²Œì„ ìˆ˜ (í”½ë¥  ê³„ì‚°ìš©)
  const totalGames = Math.max(1, godStats.totalMatches * 10); // 10ëª…ì´ë‹ˆê¹Œ *10

  // 1. í•´ë‹¹ ì˜ì›…ì—ê²Œ ì í•©í•œ ì•„ì´í…œ í•„í„°ë§ ë° í†µê³„ ê³„ì‚°
  const heroItems = useMemo(() => {
    // ì—­í• êµ°ë³„ ì¶”ì²œ ì•„ì´í…œ íƒ€ì… í•„í„°ë§
    const isAD = hero.stats.ad > hero.stats.ap;
    const isTank = hero.role === 'ìˆ˜í˜¸ê¸°ì‚¬';
    const isMage = hero.stats.ap > hero.stats.ad;

    return shopItems.map(item => {
      // í†µê³„ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
      const stat = itemStats[item.id] || { totalPicks: 0, totalWins: 0 };
      const pickRate = (stat.totalPicks / totalGames) * 100;
      const winRate = stat.totalPicks > 0 ? (stat.totalWins / stat.totalPicks) * 100 : 0;

      // ì¶”ì²œ ì ìˆ˜ (ë‹¨ìˆœ í•„í„°ë§ìš©)
      let relevance = 0;
      if (item.type === 'BOOTS') relevance += 50;
      if (item.type === 'POWER') relevance += 100;
      if (isAD && (item.ad > 0 || item.crit > 0)) relevance += 20;
      if (isMage && (item.ap > 0 || item.mp > 0)) relevance += 20;
      if (isTank && (item.hp > 0 || item.armor > 0)) relevance += 20;

      return { item, pickRate, winRate, relevance };
    })
    .filter(d => d.relevance > 0 && d.pickRate > 0.1) // ê´€ë ¨ì„± ìˆê³  í•œ ë²ˆì´ë¼ë„ ì“°ì¸ í…œë§Œ
    .sort((a, b) => b.pickRate - a.pickRate) // í”½ë¥  ìˆœ ì •ë ¬
    .slice(0, 8); // ìƒìœ„ 8ê°œë§Œ í‘œì‹œ
  }, [hero, shopItems, itemStats, totalGames]);

  return (
    <div style={{ height: '100%', display: 'flex', flexDirection: 'column', gap: '20px' }}>
      
      {/* ìƒë‹¨ ìš”ì•½ */}
      <div style={{ display: 'flex', gap: '15px' }}>
        <div style={{ flex: 1, background: '#1c1c1f', padding: '15px', borderRadius: '12px', border: '1px solid #333' }}>
          <h4 style={{ margin: '0 0 10px 0', fontSize: '13px', color: '#fff', display: 'flex', alignItems: 'center', gap: '6px' }}>
            <ShoppingBag size={14} color="#f1c40f"/> í•µì‹¬ ë¹Œë“œ ì¶”ì²œ
          </h4>
          <div style={{ fontSize: '11px', color: '#888', lineHeight: '1.5' }}>
            ìµœê·¼ {godStats.totalMatches.toLocaleString()}ê²½ê¸° ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë¶„ì„ëœ 
            <span style={{ color: '#f1c40f', fontWeight: 'bold' }}> {hero.name}</span>ì˜ ìŠ¹ë¥  ë†’ì€ ì•„ì´í…œì…ë‹ˆë‹¤.
          </div>
        </div>
        <div style={{ flex: 1, background: '#1c1c1f', padding: '15px', borderRadius: '12px', border: '1px solid #333' }}>
          <h4 style={{ margin: '0 0 10px 0', fontSize: '13px', color: '#fff', display: 'flex', alignItems: 'center', gap: '6px' }}>
            <AlertCircle size={14} color="#58a6ff"/> ë¹Œë“œ íŒ
          </h4>
          <div style={{ fontSize: '11px', color: '#888', lineHeight: '1.5' }}>
            ìƒëŒ€ ì¡°í•©ì— ë”°ë¼ <span style={{ color: '#58a6ff' }}>ë°©ì–´êµ¬</span>ë‚˜ <span style={{ color: '#58a6ff' }}>ê´€í†µ ì•„ì´í…œ</span>ì„ 
            ìœ ë™ì ìœ¼ë¡œ ì„ëŠ” ê²ƒì´ ìŠ¹ë¥  ìƒìŠ¹ì˜ ì§€ë¦„ê¸¸ì…ë‹ˆë‹¤.
          </div>
        </div>
      </div>

      {/* ì•„ì´í…œ ë¦¬ìŠ¤íŠ¸ í…Œì´ë¸” */}
      <div style={{ flex: 1, background: '#161b22', borderRadius: '12px', border: '1px solid #30363d', overflow: 'hidden', display: 'flex', flexDirection: 'column' }}>
        <div style={{ display: 'grid', gridTemplateColumns: '50px 1fr 100px 100px', padding: '12px 15px', background: '#21262d', borderBottom: '1px solid #30363d', fontSize: '11px', fontWeight: 'bold', color: '#8b949e' }}>
          <div style={{ textAlign: 'center' }}>ìˆœìœ„</div>
          <div>ì•„ì´í…œ ì •ë³´</div>
          <div style={{ textAlign: 'center' }}>ì±„ìš©ë¥ </div>
          <div style={{ textAlign: 'center' }}>ìŠ¹ë¥ </div>
        </div>

        <div style={{ overflowY: 'auto', flex: 1 }}>
          {heroItems.map((data, idx) => (
            <div key={data.item.id} style={{ display: 'grid', gridTemplateColumns: '50px 1fr 100px 100px', padding: '10px 15px', borderBottom: '1px solid #2c2c2f', alignItems: 'center', background: '#161b22' }}>
              <div style={{ textAlign: 'center', fontWeight: 'bold', color: idx < 3 ? '#e89d40' : '#555', fontSize: '14px' }}>
                {idx + 1}
              </div>
              <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                <GameIcon id={data.item.id} size={36} shape="rounded" border="1px solid #444" />
                <div>
                  <div style={{ color: '#fff', fontWeight: 'bold', fontSize: '13px' }}>{data.item.name}</div>
                  <div style={{ color: '#f1c40f', fontSize: '11px', fontFamily: 'monospace' }}>{data.item.cost} G</div>
                </div>
              </div>
              <div style={{ textAlign: 'center' }}>
                <div style={{ color: '#fff', fontWeight: 'bold', fontSize: '13px' }}>{data.pickRate.toFixed(1)}%</div>
                <div style={{ height: '4px', width: '60%', background: '#333', margin: '4px auto', borderRadius: '2px', overflow: 'hidden' }}>
                  <div style={{ width: `${Math.min(100, data.pickRate)}%`, height: '100%', background: '#58a6ff' }} />
                </div>
              </div>
              <div style={{ textAlign: 'center' }}>
                <div style={{ color: data.winRate >= 50 ? '#ff4d4d' : '#888', fontWeight: 'bold', fontSize: '13px' }}>{data.winRate.toFixed(1)}%</div>
                <div style={{ height: '4px', width: '60%', background: '#333', margin: '4px auto', borderRadius: '2px', overflow: 'hidden' }}>
                  <div style={{ width: `${data.winRate}%`, height: '100%', background: data.winRate >= 50 ? '#ff4d4d' : '#888' }} />
                </div>
              </div>
            </div>
          ))}
          
          {heroItems.length === 0 && (
            <div style={{ padding: '40px', textAlign: 'center', color: '#555', fontSize: '13px' }}>
              ì¶©ë¶„í•œ ë°ì´í„°ê°€ ìˆ˜ì§‘ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.
            </div>
          )}
        </div>
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/hero/detail/SkillAnalysisPanel.tsx
==========================================
import React from 'react';
import { Hero } from '../../../types';
import { ROLE_COMBOS, SkillKey } from '../../../engine/match/ai/mechanics/ComboPatterns';
import { Zap, Clock, Droplets, Swords, AlertCircle } from 'lucide-react';

const SkillCard = ({ skillKey, data, label }: { skillKey: string, data: any, label: string }) => {
  if (!data) return null;

  const color = skillKey === 'passive' ? '#f1c40f' : (skillKey === 'r' ? '#da3633' : '#58a6ff');
  
  return (
    <div style={{ background: '#252528', borderRadius: '8px', padding: '12px', borderLeft: `3px solid ${color}`, marginBottom: '8px' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '6px' }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
          <span style={{ background: color, color: '#000', fontWeight: '900', fontSize: '10px', padding: '2px 6px', borderRadius: '4px', textTransform: 'uppercase' }}>
            {label}
          </span>
          <span style={{ color: '#fff', fontWeight: 'bold', fontSize: '13px', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', maxWidth: '120px' }}>
            {data.name || 'ìŠ¤í‚¬ëª… ì—†ìŒ'}
          </span>
        </div>
        <span style={{ fontSize: '10px', color: '#888', border: '1px solid #444', padding: '1px 6px', borderRadius: '10px', whiteSpace:'nowrap' }}>
          {data.mechanic || 'NONE'}
        </span>
      </div>

      <div style={{ fontSize: '12px', color: '#ccc', lineHeight: '1.4', marginBottom: '8px' }}>
        ìˆ˜ì¹˜: <span style={{ color: '#fff', fontWeight: 'bold' }}>{data.val || 0}</span>
        {data.adRatio > 0 && <span style={{ color: '#e74c3c', marginLeft: '4px', whiteSpace:'nowrap' }}>(+{data.adRatio}AD)</span>}
        {data.apRatio > 0 && <span style={{ color: '#9b59b6', marginLeft: '4px', whiteSpace:'nowrap' }}>(+{data.apRatio}AP)</span>}
      </div>

      {!data.isPassive && (
        <div style={{ display: 'flex', gap: '12px', fontSize: '11px', color: '#888', borderTop: '1px dashed #444', paddingTop: '6px' }}>
          <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}><Clock size={10}/> {data.cd || 0}s</div>
          <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}><Droplets size={10} color="#3498db"/> {data.cost || 0}</div>
        </div>
      )}
    </div>
  );
};

const ComboStat = ({ combo, index, heroWinRate, totalMatches }: { combo: SkillKey[], index: number, heroWinRate: number, totalMatches: number }) => {
  // [ìˆ˜ì •] ë°ì´í„°ê°€ ì—†ìœ¼ë©´(0íŒ) í†µê³„ ëŒ€ì‹  'ìˆ˜ì§‘ì¤‘' í‘œì‹œ
  const hasData = totalMatches > 0;
  
  // ë°ì´í„°ê°€ ìˆì„ ë•Œë§Œ ê³„ì‚°, ì—†ìœ¼ë©´ 0
  const comboWinRate = hasData ? (heroWinRate + (2 - index)) : 0; 
  const pickRate = hasData ? (40 - (index * 10)) : 0; 

  return (
    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', background: '#1c1c1f', padding: '10px', borderRadius: '6px', marginBottom: '6px', border: '1px solid #333' }}>
      <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
        <span style={{ fontSize: '14px', fontWeight: 'bold', color: '#888', width: '15px' }}>{index + 1}</span>
        <div style={{ display: 'flex', gap: '4px', flexWrap:'wrap' }}>
          {combo.map((key, i) => (
            <React.Fragment key={i}>
              <div style={{ 
                width: '24px', height: '24px', background: '#333', borderRadius: '4px', 
                display: 'flex', alignItems: 'center', justifyContent: 'center',
                fontWeight: 'bold', fontSize: '12px', color: key === 'r' ? '#da3633' : '#fff',
                border: key === 'r' ? '1px solid #da3633' : '1px solid #555'
              }}>
                {key.toUpperCase()}
              </div>
              {i < combo.length - 1 && <span style={{ color: '#555', fontSize: '10px', display: 'flex', alignItems: 'center' }}>â–¶</span>}
            </React.Fragment>
          ))}
        </div>
      </div>
      
      {/* í†µê³„ í‘œì‹œ ì˜ì—­ */}
      <div style={{ textAlign: 'right', minWidth:'80px' }}>
        {hasData ? (
          <>
            <div style={{ fontSize: '12px', fontWeight: 'bold', color: comboWinRate >= 50 ? '#ff4d4d' : '#888' }}>
              {comboWinRate.toFixed(1)}%
            </div>
            <div style={{ fontSize: '10px', color: '#666' }}>
              í”½ {pickRate}%
            </div>
          </>
        ) : (
          <div style={{ fontSize: '10px', color: '#555', display:'flex', alignItems:'center', gap:'4px' }}>
            <AlertCircle size={10}/> ìˆ˜ì§‘ ì¤‘
          </div>
        )}
      </div>
    </div>
  );
};

interface Props {
  hero: Hero;
  isMobile: boolean;
}

export const SkillAnalysisPanel: React.FC<Props> = ({ hero, isMobile }) => {
  if (!hero || !hero.skills) {
    return <div style={{ padding:'20px', color:'#666' }}>ìŠ¤í‚¬ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>;
  }

  const skills = hero.skills;
  const roleCombos = ROLE_COMBOS[hero.role] || [];
  const totalMatches = hero.record?.totalMatches || 0;

  return (
    <div style={{ display: 'flex', flexDirection: isMobile ? 'column' : 'row', gap: '20px', height: '100%' }}>
      <div style={{ flex: 1.2 }}>
        <h4 style={{ color: '#fff', margin: '0 0 10px 0', fontSize: '14px', display: 'flex', alignItems: 'center', gap: '6px' }}>
          <Zap size={14} color="#f1c40f"/> ìŠ¤í‚¬ ìƒì„¸ ì •ë³´
        </h4>
        <div style={{ maxHeight: isMobile ? 'none' : '400px', overflowY: isMobile ? 'visible' : 'auto' }}>
            <SkillCard skillKey="passive" data={skills.passive} label="P" />
            <SkillCard skillKey="q" data={skills.q} label="Q" />
            <SkillCard skillKey="w" data={skills.w} label="W" />
            <SkillCard skillKey="e" data={skills.e} label="E" />
            <SkillCard skillKey="r" data={skills.r} label="R" />
        </div>
      </div>

      <div style={{ flex: 1 }}>
        <h4 style={{ color: '#fff', margin: '0 0 10px 0', fontSize: '14px', display: 'flex', alignItems: 'center', gap: '6px' }}>
          <Swords size={14} color="#da3633"/> ì¶”ì²œ ìŠ¤í‚¬ ì½¤ë³´
        </h4>
        <div style={{ background: '#21262d', padding: '15px', borderRadius: '8px' }}>
          {roleCombos.length > 0 ? (
            roleCombos.map((combo, idx) => (
                <ComboStat 
                  key={idx} 
                  combo={combo} 
                  index={idx} 
                  heroWinRate={hero.recentWinRate} 
                  totalMatches={totalMatches} // [ìˆ˜ì •] íŒìˆ˜ ì •ë³´ ì „ë‹¬
                />
            ))
          ) : (
            <div style={{ color: '#666', fontSize: '12px', textAlign: 'center', padding: '20px' }}>
              ë“±ë¡ëœ ì½¤ë³´ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.
            </div>
          )}
        </div>
        <div style={{ marginTop: '15px', padding: '10px', background: '#252528', borderRadius: '8px', fontSize: '11px', color: '#aaa', lineHeight: '1.5' }}>
          * ì½¤ë³´ ìˆœì„œëŠ” <strong>ì—­í• êµ°ë³„ ì •ì„ ë¹Œë“œ</strong>ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.
          <br/>
          * ìŠ¹ë¥  ë°ì´í„°ëŠ” <strong>ì‹¤ì œ ë§¤ì¹˜ ê¸°ë¡</strong>ì´ ìŒ“ì´ë©´ í™œì„±í™”ë©ë‹ˆë‹¤.
        </div>
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/hero/detail/SummaryOverview.tsx
==========================================
import React from 'react';
import { Hero } from '../../../types';
import { Trophy } from 'lucide-react';
import { HeroPolygonChart } from './HeroPolygonChart';
import { TimeWinRatePanel } from './TimeWinRatePanel';

interface Props {
  hero: Hero;
  isMobile: boolean;
}

const getScoreColor = (score: number) => {
  if (score >= 52) return '#ff4d4d'; 
  if (score >= 48) return '#2ecc71'; 
  return '#8b949e'; 
};

const PerformanceCard = ({ winRate, kdaRatio, pickRate, banRate }: any) => (
  <div style={{ background: '#1c1c1f', padding: '15px', borderRadius: '12px', border: '1px solid #333' }}>
    <h3 style={{ margin:'0 0 15px 0', fontSize:'14px', color:'#f1c40f', display:'flex', gap:'6px', alignItems:'center' }}>
      <Trophy size={14}/> ì‹œì¦Œ í¼í¬ë¨¼ìŠ¤ ìš”ì•½
    </h3>
    <div style={{ display:'grid', gridTemplateColumns:'1fr 1fr 1fr 1fr', gap:'8px', textAlign:'center' }}>
      <div style={{ display:'flex', flexDirection:'column', gap:'4px' }}>
        <div style={{ fontSize:'11px', color:'#888' }}>ìŠ¹ë¥ </div>
        <div style={{ fontSize:'18px', fontWeight:'900', color: getScoreColor(winRate) }}>{(winRate || 0).toFixed(1)}%</div>
      </div>
      <div style={{ display:'flex', flexDirection:'column', gap:'4px', borderLeft:'1px solid #333' }}>
        <div style={{ fontSize:'11px', color:'#888' }}>KDA</div>
        <div style={{ fontSize:'18px', fontWeight:'900', color: parseFloat(kdaRatio || '0') >= 3 ? '#2ecc71' : '#fff' }}>{kdaRatio || '0.00'}</div>
      </div>
      <div style={{ display:'flex', flexDirection:'column', gap:'4px', borderLeft:'1px solid #333' }}>
        <div style={{ fontSize:'11px', color:'#888' }}>í”½ë¥ </div>
        <div style={{ fontSize:'18px', fontWeight:'900', color:'#fff' }}>{(pickRate || 0).toFixed(1)}%</div>
      </div>
      <div style={{ display:'flex', flexDirection:'column', gap:'4px', borderLeft:'1px solid #333' }}>
        <div style={{ fontSize:'11px', color:'#da3633' }}>ë°´ë¥ </div>
        <div style={{ fontSize:'18px', fontWeight:'900', color:'#da3633' }}>{(banRate || 0).toFixed(1)}%</div>
      </div>
    </div>
  </div>
);

export const SummaryOverview: React.FC<Props> = ({ hero, isMobile }) => {
  // [ì•ˆì „ì¥ì¹˜] recordê°€ ì—†ëŠ” ê²½ìš°ë¥¼ ëŒ€ë¹„
  const record = hero.record || { totalMatches: 0, totalWins: 0 };
  const totalMatches = Math.max(1, record.totalMatches);
  const winRate = (record.totalWins / totalMatches) * 100;

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '15px', height:'100%' }}>
      
      <PerformanceCard 
        winRate={winRate} 
        kdaRatio={hero.kdaRatio} 
        pickRate={hero.pickRate} 
        banRate={hero.banRate} 
      />

      <div style={{ 
        display: 'grid', 
        gridTemplateColumns: isMobile ? '1fr' : '1fr 1fr', 
        gap: '15px', 
        flex: 1 
      }}>
        <div style={{ background: '#1c1c1f', padding: '20px', borderRadius: '12px', border: '1px solid #333', minHeight: '200px' }}>
          <HeroPolygonChart hero={hero} />
        </div>

        <div style={{ background: '#1c1c1f', padding: '20px', borderRadius: '12px', border: '1px solid #333', minHeight: '200px' }}>
          <TimeWinRatePanel hero={hero} />
        </div>
      </div>

    </div>
  );
};



==========================================
FILE PATH: src/components/hero/detail/TimeWinRatePanel.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/hero/detail/TimeWinRatePanel.tsx
// ==========================================
import React from 'react';
import { Hero } from '../../../types';
import { Clock } from 'lucide-react';

interface Props { hero: Hero; }

export const TimeWinRatePanel: React.FC<Props> = ({ hero }) => {
  
  const getPowerCurve = (role: string) => {
    switch(role) {
      case 'ì¶”ì ì': return { early: 65, mid: 50, late: 35 };
      case 'ì‹ ì‚´ì': return { early: 30, mid: 50, late: 70 };
      case 'ì„ ì§€ì': return { early: 40, mid: 60, late: 50 };
      case 'ìˆ˜í˜¸ê¸°ì‚¬': return { early: 45, mid: 55, late: 60 };
      default: return { early: 50, mid: 50, late: 50 };
    }
  };

  const curve = getPowerCurve(hero.role);
  // [Fix] ìŠ¹ë¥ ì´ 0ì´ê±°ë‚˜ NaNì´ë©´ 50ìœ¼ë¡œ ê°„ì£¼
  const baseWinRate = (hero.recentWinRate && !isNaN(hero.recentWinRate)) ? hero.recentWinRate : 50;
  const factor = baseWinRate / 50; 
  
  const stats = [
    { label: '0~15ë¶„', value: curve.early * factor, color: '#2ecc71' },
    { label: '15~30ë¶„', value: curve.mid * factor, color: '#f1c40f' },
    { label: '30ë¶„+', value: curve.late * factor, color: '#e74c3c' }
  ];

  // [Fix] ì•ˆì „í•œ í‚¤ì›Œë“œ ìƒì„±
  const getKeywords = () => {
    const tags = [];
    if (baseWinRate >= 52) tags.push({ text: 'OP ì±”í”¼ì–¸', color: '#ff4d4d' });
    
    const kda = parseFloat(hero.kdaRatio || '0');
    if (!isNaN(kda) && kda >= 4.0) tags.push({ text: 'ìƒì¡´ì™•', color: '#58a6ff' });
    
    const dpm = parseFloat((hero.avgDpm || '0').replace(/,/g,''));
    if (!isNaN(dpm) && dpm > 2000) tags.push({ text: 'í­ë”œëŸ¬', color: '#da3633' });
    
    if (tags.length === 0) tags.push({ text: 'ë°¸ëŸ°ìŠ¤í˜•', color: '#ccc' });
    return tags;
  };

  return (
    <div style={{ display:'flex', flexDirection:'column', height:'100%', gap:'15px' }}>
      
      <div style={{ display:'flex', gap:'6px', flexWrap:'wrap' }}>
        {getKeywords().map((tag, i) => (
          <span key={i} style={{ 
            fontSize:'11px', fontWeight:'bold', color: tag.color, 
            background: `${tag.color}15`, border: `1px solid ${tag.color}44`,
            padding:'2px 8px', borderRadius:'12px'
          }}>
            #{tag.text}
          </span>
        ))}
      </div>

      <div style={{ flex:1, display:'flex', flexDirection:'column', justifyContent:'center' }}>
        <div style={{ fontSize:'12px', color:'#ccc', marginBottom:'10px', display:'flex', alignItems:'center', gap:'6px' }}>
          <Clock size={12}/> ì‹œê°„ëŒ€ë³„ ìŠ¹ë¥  ì¶”ì´
        </div>
        <div style={{ display:'flex', alignItems:'flex-end', height:'80px', gap:'15px', borderBottom:'1px solid #333', paddingBottom:'5px' }}>
          {stats.map((s, i) => {
            // [Fix] ë†’ì´ ê°’ ì•ˆì „ ë³´ì • (NaN ë°©ì§€)
            const safeValue = isNaN(s.value) ? 50 : s.value;
            const displayHeight = Math.max(10, Math.min(100, safeValue));

            return (
              <div key={i} style={{ flex:1, display:'flex', flexDirection:'column', alignItems:'center', gap:'4px' }}>
                <div style={{ fontSize:'11px', fontWeight:'bold', color: safeValue >= 50 ? s.color : '#666' }}>
                  {safeValue.toFixed(1)}%
                </div>
                <div style={{ width:'100%', background:'#333', borderRadius:'4px 4px 0 0', height:'100%', position:'relative', overflow:'hidden' }}>
                  <div style={{ 
                    position:'absolute', bottom:0, width:'100%', 
                    height: `${displayHeight}%`, 
                    background: safeValue >= 50 ? s.color : '#555',
                    transition: 'height 0.5s'
                  }} />
                </div>
                <div style={{ fontSize:'10px', color:'#888' }}>{s.label}</div>
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/hero/GrowthSettingModal.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/hero/GrowthSettingModal.tsx
// ==========================================
import React, { useState, useEffect, useRef } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { X, Save, TrendingUp, Heart, Sword, Shield, Zap, Activity, Clock, RotateCcw } from 'lucide-react';
import { GrowthIntervals } from '../../types';

const PerfectSlider = ({ value, min, max, onChange, color }: { value: number, min: number, max: number, onChange: (val: number) => void, color: string }) => {
  const trackRef = useRef<HTMLDivElement>(null);
  const [active, setActive] = useState(false);
  const percent = Math.min(100, Math.max(0, ((value - min) / (max - min)) * 100));

  const handlePointerDown = (e: React.PointerEvent<HTMLDivElement>) => {
    e.preventDefault(); e.stopPropagation();
    (e.target as Element).setPointerCapture(e.pointerId);
    setActive(true);
  };
  const handlePointerMove = (e: React.PointerEvent<HTMLDivElement>) => {
    if (!active || !trackRef.current) return;
    e.preventDefault();
    const rect = trackRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    let ratio = x / rect.width;
    ratio = Math.max(0, Math.min(1, ratio));
    const newValue = Math.round(min + ratio * (max - min));
    if (newValue !== value) onChange(newValue);
  };
  const handlePointerUp = (e: React.PointerEvent<HTMLDivElement>) => {
    setActive(false);
    (e.target as Element).releasePointerCapture(e.pointerId);
  };

  return (
    <div style={{ position: 'relative', width: '100%', height: '36px', display: 'flex', alignItems: 'center', justifyContent: 'center', touchAction: 'none' }}>
      <div ref={trackRef} style={{ width: '100%', height: '6px', background: '#30363d', borderRadius: '3px', position: 'relative' }}>
        <div style={{ width: `${percent}%`, height: '100%', background: color, borderRadius: '3px' }} />
      </div>
      <div onPointerDown={handlePointerDown} onPointerMove={handlePointerMove} onPointerUp={handlePointerUp} onPointerCancel={handlePointerUp}
        style={{ position: 'absolute', left: `${percent}%`, width: '28px', height: '28px', borderRadius: '50%', background: '#fff', border: `2px solid ${color}`, boxShadow: '0 2px 5px rgba(0,0,0,0.5)', transform: 'translate(-50%, 0)', cursor: 'grab', zIndex: 10, touchAction: 'none' }}
      >
        {active && <div style={{ position:'absolute', inset: -6, borderRadius:'50%', border: `2px solid ${color}`, opacity: 0.5 }}/>}
      </div>
    </div>
  );
};

interface Props { onClose: () => void; }

export const GrowthSettingModal: React.FC<Props> = ({ onClose }) => {
  const { gameState, updateGrowthSettings } = useGameStore();
  const [localSettings, setLocalSettings] = useState({ ...gameState.growthSettings });
  
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const handleChange = (stat: keyof typeof localSettings, period: keyof GrowthIntervals, val: number) => {
    setLocalSettings(prev => ({ ...prev, [stat]: { ...prev[stat as any], [period]: val } }));
  };

  const handleSimpleChange = (field: string, val: number) => {
    setLocalSettings(prev => ({ ...prev, [field]: val }));
  };

  const handleSave = () => {
    updateGrowthSettings(localSettings);
    alert('âœ… ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.\në‹¤ìŒ ì‹œë®¬ë ˆì´ì…˜ë¶€í„° ì ìš©ë©ë‹ˆë‹¤.');
    onClose();
  };

  const StatRow = ({ label, icon, statKey, color }: { label: string, icon: any, statKey: string, color: string }) => {
    const data = (localSettings as any)[statKey] as GrowthIntervals;
    const renderSlider = (title: string, period: keyof GrowthIntervals) => (
      <div style={{ flex: 1 }}>
        <div style={{ fontSize:'11px', color:'#aaa', marginBottom:'0px', display:'flex', justifyContent:'space-between', alignItems:'center' }}>
            <span>{title}</span>
            <span style={{ color: color, fontWeight:'bold', fontFamily:'monospace', fontSize:'14px' }}>{data[period]}%</span>
        </div>
        <PerfectSlider min={0} max={30} value={data[period]} onChange={(val) => handleChange(statKey as any, period, val)} color={color} />
      </div>
    );
    return (
      <div style={{ marginBottom: '15px', background:'#1f242e', padding:'15px', borderRadius:'8px', border:'1px solid #30363d' }}>
        <div style={{ display:'flex', alignItems:'center', gap:'6px', color: color, fontWeight:'bold', fontSize:'13px', marginBottom:'12px' }}>{icon} {label}</div>
        <div style={{ display: 'flex', flexDirection: isMobile ? 'column' : 'row', gap: isMobile ? '12px' : '20px' }}>
          {renderSlider("ì´ˆë°˜ (Lv.1~6)", "early")}
          {renderSlider("ì¤‘ë°˜ (Lv.7~12)", "mid")}
          {renderSlider("í›„ë°˜ (Lv.13~)", "late")}
        </div>
      </div>
    );
  };

  return (
    <div style={{ position:'fixed', inset:0, background:'rgba(0,0,0,0.85)', zIndex:9999, display:'flex', justifyContent:'center', alignItems:'center', padding: isMobile ? '0' : '10px' }}>
      <div style={{ width:'100%', maxWidth:'600px', height: isMobile ? '100%' : 'auto', background:'#161b22', border: isMobile ? 'none' : '1px solid #30363d', borderRadius: isMobile ? '0' : '12px', overflow:'hidden', display:'flex', flexDirection:'column', maxHeight:'95vh' }}>
        
        <div style={{ padding:'15px', background:'#21262d', borderBottom:'1px solid #30363d', display:'flex', justifyContent:'space-between', alignItems:'center' }}>
          <h3 style={{ margin:0, color:'#fff', fontSize:'16px', display:'flex', alignItems:'center', gap:'8px' }}><TrendingUp size={18} color="#2ecc71"/> ê²Œì„ ë°¸ëŸ°ìŠ¤ ì„¤ì •</h3>
          <button onClick={onClose} style={{ background:'none', border:'none', color:'#888', cursor:'pointer', padding:'5px' }}><X size={24}/></button>
        </div>

        <div style={{ padding:'15px', overflowY:'auto', flex:1, WebkitOverflowScrolling: 'touch' }}>
          
          {/* 1. ê²Œì„ ê·œì¹™ ì„¤ì • */}
          <div style={{ marginBottom:'25px' }}>
            <h4 style={{ margin:'0 0 10px 0', fontSize:'13px', color:'#ccc', borderBottom:'1px solid #333', paddingBottom:'5px' }}>ê²Œì„ ê·œì¹™ (Game Rules)</h4>
            <div style={{ display:'grid', gridTemplateColumns: isMobile ? '1fr' : '1fr 1fr', gap:'15px' }}>
                <div style={{ background:'#0d1117', padding:'12px', borderRadius:'8px', border:'1px solid #30363d' }}>
                    <div style={{ display:'flex', justifyContent:'space-between', marginBottom:'8px' }}>
                        <span style={{ fontSize:'12px', color:'#ccc', display:'flex', gap:'4px', alignItems:'center' }}><Clock size={12}/> ë ˆë²¨ë‹¹ ë¶€í™œì‹œê°„ ê³„ìˆ˜</span>
                        <span style={{ fontSize:'13px', fontWeight:'bold', color:'#f1c40f' }}>x{localSettings.respawnPerLevel}</span>
                    </div>
                    {/* ê³„ìˆ˜ëŠ” 1~10ê¹Œì§€ */}
                    <PerfectSlider min={1} max={10} value={localSettings.respawnPerLevel} onChange={(v)=>handleSimpleChange('respawnPerLevel', v)} color="#f1c40f" />
                    <div style={{ fontSize:'10px', color:'#666', marginTop:'4px' }}>
                      (ê¸°ë³¸: 3.0, í›„ë°˜ í˜ë„í‹° ë³„ë„ ì ìš©)
                    </div>
                </div>
                <div style={{ background:'#0d1117', padding:'12px', borderRadius:'8px', border:'1px solid #30363d' }}>
                    <div style={{ display:'flex', justifyContent:'space-between', marginBottom:'8px' }}>
                        <span style={{ fontSize:'12px', color:'#ccc', display:'flex', gap:'4px', alignItems:'center' }}><RotateCcw size={12}/> ê·€í™˜ ì†Œìš”ì‹œê°„</span>
                        <span style={{ fontSize:'13px', fontWeight:'bold', color:'#3498db' }}>{localSettings.recallTime}ì´ˆ</span>
                    </div>
                    {/* ê·€í™˜ì‹œê°„ì€ 1~20ì´ˆê¹Œì§€ */}
                    <PerfectSlider min={1} max={20} value={localSettings.recallTime} onChange={(v)=>handleSimpleChange('recallTime', v)} color="#3498db" />
                </div>
            </div>
          </div>

          {/* 2. ì„±ì¥ ë°¸ëŸ°ìŠ¤ */}
          <h4 style={{ margin:'0 0 10px 0', fontSize:'13px', color:'#ccc', borderBottom:'1px solid #333', paddingBottom:'5px' }}>êµ¬ê°„ë³„ ì„±ì¥ (Growth Curve)</h4>
          <StatRow label="ê³µê²©ë ¥ (AD)" icon={<Sword size={14}/>} statKey="ad" color="#e74c3c" />
          <StatRow label="ì£¼ë¬¸ë ¥ (AP)" icon={<Zap size={14}/>} statKey="ap" color="#9b59b6" />
          <StatRow label="ìµœëŒ€ ì²´ë ¥ (HP)" icon={<Heart size={14}/>} statKey="hp" color="#2ecc71" />
          <StatRow label="ë°©ì–´ë ¥ (Armor)" icon={<Shield size={14}/>} statKey="armor" color="#3498db" />
          <StatRow label="ê¸°ë³¸ ê³µê²© (Base)" icon={<Sword size={14}/>} statKey="baseAtk" color="#777" />
          <StatRow label="ì²´ë ¥ ì¬ìƒ (Regen)" icon={<Activity size={14}/>} statKey="regen" color="#2ecc71" />
        </div>

        <div style={{ padding:'15px', borderTop:'1px solid #30363d', display:'flex', gap:'10px', background:'#161b22', paddingBottom: isMobile ? '30px' : '15px' }}>
          <button onClick={onClose} style={{ flex:1, background:'transparent', border:'1px solid #444', color:'#ccc', padding:'12px', borderRadius:'8px', fontWeight:'bold', cursor:'pointer' }}>ë‹«ê¸°</button>
          <button onClick={handleSave} style={{ flex:2, background:'#238636', border:'none', color:'#fff', padding:'12px', borderRadius:'8px', fontWeight:'bold', cursor:'pointer', display:'flex', justifyContent:'center', alignItems:'center', gap:'6px' }}>
            <Save size={18}/> ì„¤ì • ì €ì¥
          </button>
        </div>
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/hero/HeroDetailView.tsx
==========================================
import React, { useState, useEffect, useMemo } from 'react';
import { Hero } from '../../types';
import { useGameStore } from '../../store/useGameStore';
import { ROLE_DATA } from '../../data/roles';
import { 
  X, Wrench, Edit, Swords, Shield, Zap, Target, Heart, Footprints, Crosshair, Droplets, Flame, Trash, BarChart2, Search, Activity
} from 'lucide-react';
import { GameIcon } from '../common/GameIcon';
import { CustomizeHeroModal } from './CustomizeHeroModal';
import { HeroVsModal } from './HeroVsModal';

import { SkillAnalysisPanel } from './detail/SkillAnalysisPanel';
import { ItemBuildAnalysis } from './detail/ItemBuildAnalysis';
import { GrowthStatsPanel } from './detail/GrowthStatsPanel';
import { SummaryOverview } from './detail/SummaryOverview';

interface Props {
  hero: Hero;
  onBack: () => void;
  onPatch: () => void;
}

const HeroSpecItem = ({ icon, label, value, color }: any) => (
  <div style={{ display:'flex', alignItems:'center', justifyContent:'space-between', background:'#161b22', padding:'6px 10px', borderRadius:'6px', border:'1px solid #30363d', minWidth:'80px' }}>
    <div style={{ display:'flex', alignItems:'center', gap:'6px' }}>
      {React.cloneElement(icon, { size: 12, color: color })}
      <span style={{ fontSize:'10px', color:'#aaa', fontWeight:'bold' }}>{label}</span>
    </div>
    <span style={{ fontSize:'12px', fontWeight:'900', color:'#fff', fontFamily:'monospace' }}>{value}</span>
  </div>
);

const TabButton = ({ id, label, icon, activeTab, onClick }: any) => (
  <button 
    onClick={() => onClick(id)}
    style={{ 
      flex: 1, display:'flex', alignItems:'center', justifyContent:'center', gap:'4px',
      padding: '12px 0',
      background: activeTab === id ? 'rgba(88, 166, 255, 0.2)' : 'rgba(0,0,0,0.6)',
      border: 'none', borderBottom: activeTab === id ? '3px solid #58a6ff' : '3px solid transparent',
      color: activeTab === id ? '#58a6ff' : '#aaa', fontWeight:'bold', cursor:'pointer', transition:'0.2s',
      fontSize: '11px', whiteSpace: 'nowrap'
    }}
  >
    {React.cloneElement(icon, { size: 14 })} {label}
  </button>
);

export const HeroDetailView: React.FC<Props> = ({ hero, onBack, onPatch }) => {
  const { heroes, gameState, deleteHero } = useGameStore();
  const [activeTab, setActiveTab] = useState<'SUMMARY' | 'COUNTER' | 'COMBAT' | 'BUILD'>('SUMMARY');
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
  const [showCustomize, setShowCustomize] = useState(false);

  const [selectedEnemy, setSelectedEnemy] = useState<Hero | null>(null);
  const [enemySearch, setEnemySearch] = useState('');

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const roleInfo = ROLE_DATA[hero.role];
  const bgId = `${hero.id}_bg`;
  const customBg = gameState.customImages?.[bgId];
  const displayConcept = hero.concept || roleInfo.concept;

  const handleDelete = () => {
    if (confirm(`ì •ë§ '${hero.name}' ì˜ì›…ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
      deleteHero(hero.id);
      onBack();
    }
  };
  
  const enemyList = useMemo(() => {
    return heroes
      .filter(h => h.id !== hero.id && h.name.includes(enemySearch))
      .sort((a, b) => b.recentWinRate - a.recentWinRate);
  }, [heroes, hero.id, enemySearch]);

  const renderContent = () => {
    switch(activeTab) {
        case 'SUMMARY':
            return <SummaryOverview hero={hero} isMobile={isMobile} />;
        case 'COUNTER':
            return (
              <div style={{ background: '#1c1c1f', padding: '15px', borderRadius: '12px', border: '1px solid #333', minHeight:'400px' }}>
                <div style={{ display:'flex', gap:'10px', marginBottom:'15px', background:'#252528', padding:'10px', borderRadius:'8px' }}>
                  <Search size={16} color="#888"/>
                  <input type="text" placeholder="ë¹„êµí•  ì˜ì›… ì´ë¦„ ê²€ìƒ‰..." value={enemySearch} onChange={(e) => setEnemySearch(e.target.value)} style={{ background:'none', border:'none', color:'#fff', outline:'none', width:'100%', fontWeight:'bold', fontSize:'13px' }} />
                </div>
                <div style={{ display:'flex', flexDirection:'column', gap:'8px' }}>
                  {enemyList.map(enemy => (
                    <div key={enemy.id} onClick={() => setSelectedEnemy(enemy)} style={{ display:'flex', alignItems:'center', gap:'12px', padding:'10px', background:'#252528', borderRadius:'8px', cursor:'pointer' }}>
                      <GameIcon id={enemy.id} size={36} shape="rounded" />
                      <div style={{ flex:1 }}>
                        <div style={{ fontWeight:'bold', color:'#fff', fontSize:'13px' }}>{enemy.name}</div>
                        <div style={{ fontSize:'11px', color:'#888' }}>{enemy.role}</div>
                      </div>
                      <div style={{ fontSize:'12px', fontWeight:'bold', color: enemy.recentWinRate >= 50 ? '#ff4d4d' : '#888' }}>{enemy.recentWinRate.toFixed(1)}%</div>
                    </div>
                  ))}
                </div>
              </div>
            );
        case 'COMBAT':
            return (
              <div style={{ display:'flex', flexDirection:'column', gap:'20px' }}>
                <SkillAnalysisPanel hero={hero} isMobile={isMobile} />
                <div style={{ height:'1px', background:'#333', margin:'5px 0' }} />
                <GrowthStatsPanel hero={hero} isMobile={isMobile} />
              </div>
            );
        case 'BUILD':
            return <ItemBuildAnalysis hero={hero} />;
        default:
            return null;
    }
  };

  return (
    <div style={{ position: 'fixed', inset: 0, zIndex: 9999, display: 'flex', justifyContent: 'center', alignItems: 'center', backgroundColor: 'rgba(0,0,0,0.85)', backdropFilter: 'blur(5px)' }}>
      <div style={{ width: isMobile ? '100%' : '650px', height: isMobile ? '100%' : '90vh', backgroundColor: '#0d1117', display: 'flex', flexDirection: 'column', overflow: 'hidden', position: 'relative', borderRadius: isMobile ? '0' : '16px', border: isMobile ? 'none' : '1px solid #30363d', boxShadow: '0 20px 60px rgba(0,0,0,0.8)' }}>

        {/* ë°°ê²½ (í¬ì¸í„° ì´ë²¤íŠ¸ ì œê±°) */}
        <div style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', backgroundImage: customBg ? `url(${customBg})` : 'none', backgroundSize: 'cover', backgroundPosition: 'center top', zIndex: 0, opacity: 0.6, pointerEvents: 'none' }} />
        <div style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', background: 'linear-gradient(to bottom, rgba(13,17,23,0.2) 0%, rgba(13,17,23,0.9) 50%, #0d1117 100%)', zIndex: 1, pointerEvents: 'none' }} />

        {/* ë‹«ê¸° ë²„íŠ¼ */}
        <div style={{ padding: '15px 20px', position: 'relative', zIndex: 10, display: 'flex', justifyContent: 'flex-end' }}>
          <button onClick={onBack} style={{ background:'rgba(0,0,0,0.5)', border:'1px solid rgba(255,255,255,0.2)', color:'#fff', padding:'8px', borderRadius:'50%', cursor:'pointer', display:'flex', alignItems:'center', justifyContent:'center' }}><X size={20}/></button>
        </div>

        {/* ë©”ì¸ ìŠ¤í¬ë¡¤ ì˜ì—­ */}
        <div style={{ flex: 1, overflowY: 'auto', position: 'relative', zIndex: 10, scrollbarWidth:'none', paddingBottom:'50px' }}>

          {/* 1. í—¤ë” */}
          <div style={{ padding: '0 20px 20px 20px', display: 'flex', flexDirection: 'row', gap: '20px', alignItems: 'center' }}>
            <div style={{ flexShrink: 0 }}>
              <GameIcon id={hero.id} size={isMobile ? 100 : 120} shape="rounded" border={`3px solid ${roleInfo.color}`} />
            </div>
            <div style={{ display:'flex', flexDirection:'column', gap:'4px', flex: 1 }}>
              <h1 style={{ margin: 0, fontSize: isMobile ? '24px' : '32px', fontWeight: '900', color: '#fff', textShadow: '0 2px 10px rgba(0,0,0,0.8)' }}>{hero.name}</h1>
              <div style={{ display:'flex', gap:'6px', alignItems:'center', marginTop:'4px' }}>
                <span style={{ fontSize: '11px', fontWeight: '800', color: '#000', background: roleInfo.color, padding:'2px 8px', borderRadius:'4px' }}>{hero.role}</span>
                <span style={{ fontSize: '11px', fontWeight: '800', color: roleInfo.color, border:`1px solid ${roleInfo.color}`, padding:'2px 8px', borderRadius:'4px' }}>{hero.tier}í‹°ì–´</span>
              </div>
              
              <div style={{ margin: '8px 0 10px 0', fontSize: '13px', color: '#e0e0e0', fontStyle: 'italic', opacity: 0.9, borderLeft:`3px solid ${roleInfo.color}`, paddingLeft:'10px', lineHeight:'1.4', background:'rgba(0,0,0,0.3)', padding:'8px 10px', borderRadius:'0 6px 6px 0' }}>
                "{displayConcept}"
              </div>
              
              <div style={{ display: 'flex', gap: '8px' }}>
                <button onClick={onPatch} style={{ flex:1, background:'#238636', border:'none', color:'#fff', padding:'6px', borderRadius:'4px', fontWeight:'bold', fontSize:'12px', cursor:'pointer', display:'flex', alignItems:'center', justifyContent:'center', gap:'4px' }}><Wrench size={12}/> íŒ¨ì¹˜</button>
                <button onClick={() => setShowCustomize(true)} style={{ flex:1, background:'#1f6feb', border:'none', color:'#fff', padding:'6px', borderRadius:'4px', fontWeight:'bold', fontSize:'12px', cursor:'pointer', display:'flex', alignItems:'center', justifyContent:'center', gap:'4px' }}><Edit size={12}/> ì»¤ìŠ¤í…€</button>
                <button onClick={handleDelete} style={{ flex:1, background:'#3f1515', border:'1px solid #5a1e1e', color:'#ff6b6b', padding:'6px', borderRadius:'4px', fontWeight:'bold', fontSize:'12px', cursor:'pointer', display:'flex', alignItems:'center', justifyContent:'center', gap:'4px' }}><Trash size={12}/> ì‚­ì œ</button>
              </div>
            </div>
          </div>

          {/* 2. ìŠ¤íƒ¯ ê·¸ë¦¬ë“œ */}
          <div style={{ padding: '0 20px 20px 20px' }}>
            <div style={{ display: 'grid', gridTemplateColumns: isMobile ? '1fr 1fr' : 'repeat(4, 1fr)', gap: '6px' }}>
              <HeroSpecItem label="HP" value={hero.stats.hp} icon={<Heart/>} color="#2ecc71" />
              <HeroSpecItem label="MP" value={hero.stats.mp || 300} icon={<Droplets/>} color="#3498db" />
              <HeroSpecItem label="AD" value={hero.stats.ad} icon={<Swords/>} color="#da3633" />
              <HeroSpecItem label="AP" value={hero.stats.ap} icon={<Zap/>} color="#9b59b6" />
              <HeroSpecItem label="DEF" value={hero.stats.armor} icon={<Shield/>} color="#58a6ff" />
              <HeroSpecItem label="SPD" value={hero.stats.speed} icon={<Footprints/>} color="#f1c40f" />
              <HeroSpecItem label="RNG" value={hero.stats.range} icon={<Crosshair/>} color="#ccc" />
              <HeroSpecItem label="CRI" value={`${hero.stats.crit}%`} icon={<Target/>} color="#e67e22" />
              {/* [ìˆ˜ì • ì™„ë£Œ] Activity ì•„ì´ì½˜ import ì¶”ê°€ë¨ */}
              <HeroSpecItem label="H.Reg" value={hero.stats.regen} icon={<Activity/>} color="#2ecc71" />
              <HeroSpecItem label="M.Reg" value={hero.stats.mpRegen || 5} icon={<Activity/>} color="#3498db" />
              <HeroSpecItem label="PEN" value={hero.stats.pen} icon={<Flame/>} color="#da3633" />
              <HeroSpecItem label="BASE" value={hero.stats.baseAtk} icon={<Swords/>} color="#777" />
            </div>
          </div>

          <div style={{ display: 'flex', background: '#161b22', borderBottom: '1px solid #30363d', borderTop: '1px solid rgba(255,255,255,0.1)', position: 'sticky', top: 0, zIndex: 20 }}>
            <TabButton id="SUMMARY" label="ì¢…í•©ë¶„ì„" icon={<BarChart2/>} activeTab={activeTab} onClick={setActiveTab} />
            <TabButton id="COUNTER" label="ìƒëŒ€ë¶„ì„" icon={<Swords/>} activeTab={activeTab} onClick={setActiveTab} />
            <TabButton id="COMBAT" label="ìŠ¤í‚¬/ì„±ì¥" icon={<Zap/>} activeTab={activeTab} onClick={setActiveTab} />
            <TabButton id="BUILD" label="ì•„ì´í…œ" icon={<Target/>} activeTab={activeTab} onClick={setActiveTab} />
          </div>

          {/* íƒ­ ì»¨í…ì¸  */}
          <div key={activeTab} style={{ padding: '20px', minHeight: '400px', background: 'rgba(13, 17, 23, 0.95)' }}>
            {renderContent()}
          </div>
        </div>

        {showCustomize && <CustomizeHeroModal hero={hero} onClose={() => setShowCustomize(false)} />}
        {selectedEnemy && <HeroVsModal myHero={hero} enemyHero={selectedEnemy} onClose={() => setSelectedEnemy(null)} />}

      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/hero/HeroListTable.tsx
==========================================
import React from 'react';
import { Hero, Tier } from '../../types';
import { Target, Swords, Coins, Skull, Shield } from 'lucide-react'; 
import { GameIcon } from '../common/GameIcon';

interface Props {
  heroes: Hero[];
  isMobile?: boolean;
  onHeroClick?: (hero: Hero) => void;
}

const getWinRateColor = (rate: number) => {
  if (rate >= 52) return '#ff4d4d'; 
  if (rate >= 50) return '#3fb950'; 
  return '#8b949e'; 
};

const getTierStyle = (tier: Tier) => {
  switch (tier) {
    case 'OP': return { color: '#ff4d4d', border: '#ff4d4d', bg: 'rgba(255, 77, 77, 0.15)' };
    case '1': return { color: '#e89d40', border: '#e89d40', bg: 'rgba(232, 157, 64, 0.15)' };
    case '2': return { color: '#58a6ff', border: '#58a6ff', bg: 'rgba(88, 166, 255, 0.15)' };
    case '3': return { color: '#2ecc71', border: '#2ecc71', bg: 'rgba(46, 204, 113, 0.15)' };
    case '4': return { color: '#95a5a6', border: '#95a5a6', bg: 'rgba(149, 165, 166, 0.15)' };
    case '5': return { color: '#7f8c8d', border: '#7f8c8d', bg: 'rgba(127, 140, 141, 0.15)' };
    default: return { color: '#8b949e', border: '#30363d', bg: '#21262d' };
  }
};

// [í•µì‹¬] í–‰(Row)ì„ ë³„ë„ ì»´í¬ë„ŒíŠ¸ë¡œ ë¶„ë¦¬í•˜ê³  ë©”ëª¨ì´ì œì´ì…˜(React.memo) ì²˜ë¦¬
// ë¦¬ìŠ¤íŠ¸ ì „ì²´ê°€ ë‹¤ì‹œ ê·¸ë ¤ì§ˆ ë•Œ ê°œë³„ í–‰ë“¤ì€ ê±´ë“œë¦¬ì§€ ì•Šê²Œ í•˜ì—¬ ì‚­ì œ ì˜¤ë¥˜ ë°©ì§€
const HeroRow = React.memo(({ hero, isMobile, onClick }: { hero: Hero, isMobile: boolean, onClick: (h: Hero) => void }) => {
  const tierStyle = getTierStyle(hero.tier);

  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    // [í•µì‹¬] í´ë¦­ ì´ë²¤íŠ¸ì™€ ë Œë”ë§ ì‚¬ì´í´ ë¶„ë¦¬
    requestAnimationFrame(() => onClick(hero));
  };

  if (isMobile) {
    return (
      <div 
        onClick={handleClick}
        style={{ background: '#161b22', border: '1px solid #30363d', borderRadius: '10px', padding: '12px', display: 'flex', flexDirection: 'column', gap: '10px', cursor: 'pointer' }}
      >
        <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
          <div style={{ fontSize: '14px', fontWeight: '900', fontStyle: 'italic', color: hero.rank <= 3 ? '#e89d40' : '#555', width: '24px', textAlign: 'center' }}>
            <span>{hero.rank}</span>
          </div>
          <GameIcon id={hero.id} size={48} shape="rounded" border="1px solid #444" />
          <div style={{ flex: 1, minWidth: 0 }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
              <span style={{ fontWeight: 'bold', fontSize: '15px', color: '#fff' }}>{hero.name}</span>
              <span style={{ fontSize: '10px', fontWeight: '800', color: tierStyle.color, border: `1px solid ${tierStyle.border}`, background: tierStyle.bg, padding: '1px 5px', borderRadius: '4px' }}>
                {hero.tier}<span>í‹°ì–´</span>
              </span>
            </div>
            <div style={{ fontSize: '11px', color: '#888', marginTop: '4px', display:'flex', alignItems:'center', gap:'6px' }}>
              <span style={{ fontWeight:'bold', color:'#ccc' }}>{hero.role}</span>
              <span style={{ width:'1px', height:'10px', background:'#444' }}></span>
              <span style={{ fontFamily:'monospace', color:'#aaa' }}>{hero.avgKda}</span>
            </div>
          </div>
          <div style={{ textAlign: 'right' }}>
            <div style={{ fontSize: '16px', fontWeight: 'bold', color: getWinRateColor(hero.recentWinRate) }}>
              {hero.recentWinRate.toFixed(1)}<span>%</span>
            </div>
            <div style={{ fontSize: '10px', color: '#666', marginTop:'2px' }}>
              <span>í”½</span> {hero.pickRate.toFixed(0)}<span>%</span>
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div 
      onClick={handleClick} 
      style={{ 
        display: 'grid', gridTemplateColumns: '50px 200px 100px 140px 120px 100px 100px 1fr', 
        padding: '10px', borderBottom: '1px solid #2c2c2f', alignItems: 'center', 
        fontSize: '13px', color: '#ccc', textAlign: 'center', background: '#161b22', cursor: 'pointer'
      }}
    >
      <div style={{ fontWeight: '900', color: '#555', fontStyle: 'italic' }}>
        <span>{hero.rank}</span>
      </div>
      
      <div style={{ textAlign: 'left', paddingLeft: '10px', display: 'flex', alignItems: 'center', gap: '12px' }}>
        <GameIcon id={hero.id} size={32} />
        <div style={{ display: 'flex', flexDirection: 'column' }}>
          <span style={{ fontWeight: 'bold', color: '#fff' }}>{hero.name}</span>
          <div style={{ display:'flex', gap:'4px', alignItems:'center', marginTop:'2px' }}>
            <span style={{ fontSize: '10px', color: '#888' }}>{hero.role}</span>
            <span style={{ fontSize: '9px', fontWeight: '800', color: tierStyle.color, border: `1px solid ${tierStyle.border}`, background: tierStyle.bg, padding: '0 4px', borderRadius: '3px' }}>
              {hero.tier}
            </span>
          </div>
        </div>
      </div>

      <div style={{ fontWeight: 'bold', color: getWinRateColor(hero.recentWinRate) }}>
        {hero.recentWinRate.toFixed(1)}<span>%</span>
      </div>
      
      <div style={{ fontSize: '12px', color: '#888' }}>
        <span style={{ color: '#fff' }}>{hero.pickRate.toFixed(1)}%</span>
        <span style={{ color: '#444', margin: '0 4px' }}>/</span>
        <span style={{ color: '#da3633' }}>{hero.banRate.toFixed(1)}%</span>
      </div>

      <div>
        <span style={{ color: '#fff', fontWeight: 'bold' }}>{hero.avgKda}</span>
        <span style={{ display:'block', fontSize:'10px', color:'#666' }}>({hero.kdaRatio}:1)</span>
      </div>

      <div style={{ fontFamily: 'monospace', color: '#aaa' }}><span>{hero.avgCs}</span></div>
      <div style={{ fontFamily: 'monospace', color: '#da3633' }}><span>{hero.avgDpm}</span></div>
      <div style={{ fontFamily: 'monospace', color: '#f1c40f' }}><span>{hero.avgGold}</span></div>
    </div>
  );
});

export const HeroListTable: React.FC<Props> = ({ heroes, isMobile = false, onHeroClick }) => {
  const sortedHeroes = [...heroes].sort((a, b) => (a.rank || 999) - (b.rank || 999));

  return (
    <div style={{ overflowX: 'auto', flex: 1, overflowY: 'auto', display: 'flex', flexDirection: 'column' }}>
      {!isMobile && (
        <div style={{ display: 'grid', gridTemplateColumns: '50px 200px 100px 140px 120px 100px 100px 1fr', padding: '12px 10px', background: '#0d1117', borderBottom: '1px solid #30363d', fontSize: '12px', color: '#8b949e', fontWeight: 'bold', textAlign: 'center', position: 'sticky', top: 0, zIndex: 10 }}>
          <span>ìˆœìœ„</span>
          <div style={{ textAlign: 'left', paddingLeft: '10px' }}><span>ì±”í”¼ì–¸</span></div>
          <span>ìŠ¹ë¥ </span>
          <span>í”½ë¥  / ë°´ë¥ </span>
          <span>KDA</span>
          <span>CS</span>
          <span>DPM</span>
          <span>GOLD</span>
        </div>
      )}

      <div style={isMobile ? { padding: '10px', display: 'flex', flexDirection: 'column', gap: '8px', paddingBottom: '80px' } : {}}>
        {sortedHeroes.map((hero) => (
          <HeroRow 
            key={hero.id} 
            hero={hero} 
            isMobile={!!isMobile} 
            onClick={onHeroClick || (() => {})} 
          />
        ))}
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/hero/HeroManagement.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/hero/HeroManagement.tsx
// ==========================================
import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { Edit3, Search, Plus, Trash2, Shield, Swords, Zap, Crosshair, Skull, Layers, Target } from 'lucide-react';
import { Hero, Role } from '../../types';
import { GameIcon } from '../common/GameIcon';

interface Props { onEditHero: (hero: Hero) => void; }

// ì—­í• êµ° ë°ì´í„° ë° ì•„ì´ì½˜ ë§¤í•‘ (ì›ë³¸ ìœ ì§€)
const ROLES: (Role | 'ALL')[] = ['ALL', 'ì§‘í–‰ê´€', 'ì¶”ì ì', 'ì„ ì§€ì', 'ì‹ ì‚´ì', 'ìˆ˜í˜¸ê¸°ì‚¬'];

const getRoleIcon = (role: string) => {
  switch(role) {
    case 'ALL': return <Layers size={14}/>;
    case 'ì§‘í–‰ê´€': return <Shield size={14}/>;
    case 'ì¶”ì ì': return <Swords size={14}/>;
    case 'ì„ ì§€ì': return <Zap size={14}/>;
    case 'ì‹ ì‚´ì': return <Crosshair size={14}/>;
    case 'ìˆ˜í˜¸ê¸°ì‚¬': return <Skull size={14}/>;
    default: return <Layers size={14}/>;
  }
};

const getRoleColor = (role: string) => {
  switch(role) {
    case 'ì§‘í–‰ê´€': return '#e74c3c';
    case 'ì¶”ì ì': return '#2ecc71';
    case 'ì„ ì§€ì': return '#3498db';
    case 'ì‹ ì‚´ì': return '#f1c40f';
    case 'ìˆ˜í˜¸ê¸°ì‚¬': return '#9b59b6';
    default: return '#8b949e';
  }
};

export const HeroManagement: React.FC<Props> = ({ onEditHero }) => {
  const { heroes, addHero, deleteHero } = useGameStore();
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedRole, setSelectedRole] = useState<Role | 'ALL'>('ALL');

  // ëª¨ë°”ì¼ ê°ì§€ ë¡œì§ (ì›ë³¸ ìœ ì§€)
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // í•„í„°ë§ ë¡œì§ (ì›ë³¸ ìœ ì§€)
  const filteredHeroes = heroes.filter(h => {
    const matchRole = selectedRole === 'ALL' || h.role === selectedRole;
    const matchSearch = h.name.includes(searchTerm) || h.role.includes(searchTerm);
    return matchRole && matchSearch;
  });

  // ì˜ì›… ìƒì„± ë¡œì§ (statsì— range ê¸°ë³¸ê°’ í¬í•¨í•˜ì—¬ ë¬´ê²°ì„± ìœ ì§€)
  const handleCreateHero = () => {
    const id = `h_custom_${Date.now()}`;
    const newHero: Hero = {
      id,
      name: "ì´ë¦„ ì—†ëŠ” ì˜ì›…",
      role: selectedRole === 'ALL' ? "ì§‘í–‰ê´€" : selectedRole,
      tier: "3",
      stats: { hp: 2000, ad: 60, ap: 0, armor: 30, crit: 0, range: 150, speed: 340, regen: 10, pen: 0, baseAtk: 60 },
      skills: {
        passive: { name: "ê¸°ë³¸ íŒ¨ì‹œë¸Œ", mechanic: "NONE", val: 0, adRatio: 0, apRatio: 0, cd: 0, isPassive: true },
        q: { name: "Q ìŠ¤í‚¬", mechanic: "DAMAGE", val: 100, adRatio: 1.0, apRatio: 0, cd: 8 },
        w: { name: "W ìŠ¤í‚¬", mechanic: "NONE", val: 0, adRatio: 0, apRatio: 0, cd: 12 },
        e: { name: "E ìŠ¤í‚¬", mechanic: "DASH", val: 50, adRatio: 0, apRatio: 0, cd: 15 },
        r: { name: "R ê¶ê·¹ê¸°", mechanic: "DAMAGE", val: 300, adRatio: 1.5, apRatio: 0, cd: 100 }
      },
      record: {
        totalMatches: 0, totalWins: 0, totalPicks: 0, totalBans: 0,
        totalKills: 0, totalDeaths: 0, totalAssists: 0,
        totalDamage: 0, totalDamageTaken: 0, totalCs: 0, totalGold: 0,
        recentResults: []
      },
      rank: 999, rankChange: 0, recentWinRate: 0, pickRate: 0, banRate: 0,
      avgKda: "0.0/0.0/0.0", kdaRatio: "0.00", avgDpm: "0", avgDpg: "0", avgCs: "0", avgGold: "0"
    };
    addHero(newHero);
    onEditHero(newHero);
  };

  const handleDelete = (e: React.MouseEvent, id: string, name: string) => {
    e.stopPropagation();
    if (confirm(`ì •ë§ '${name}' ì˜ì›…ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nì‚­ì œ í›„ ë˜ëŒë¦´ ìˆ˜ ì—†ìœ¼ë©°, í†µê³„ ë°ì´í„°ë„ ì‚¬ë¼ì§‘ë‹ˆë‹¤.`)) {
      deleteHero(id);
    }
  };

  return (
    <div style={{ background: '#161b22', padding: isMobile ? '15px' : '20px', borderRadius: '12px', border: '1px solid #30363d', minHeight:'80vh', display:'flex', flexDirection:'column' }}>

      {/* 1. í—¤ë” & ê²€ìƒ‰ì°½ (ì›ë³¸ ë””ìì¸ ìœ ì§€) */}
      <div style={{ display: 'flex', flexDirection: isMobile ? 'column' : 'row', justifyContent: 'space-between', alignItems: isMobile ? 'stretch' : 'center', marginBottom: '15px', gap: '10px' }}>
        <h3 style={{ margin:0, color:'#fff', display:'flex', alignItems:'center', gap:'8px' }}>
          ğŸ›¡ï¸ ì˜ì›… ë°ì´í„° ê´€ë¦¬
        </h3>

        <div style={{ display:'flex', gap:'10px' }}>
          <div style={{ flex:1, display: 'flex', alignItems: 'center', gap: '10px', background: '#0d1117', padding: '8px 15px', borderRadius: '8px', border: '1px solid #30363d' }}>
            <Search size={16} color="#888" />
            <input 
              type="text" 
              placeholder="ì˜ì›… ê²€ìƒ‰..." 
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              style={{ background: 'none', border: 'none', color: '#fff', outline: 'none', width: '100%', fontSize:'13px' }}
            />
          </div>
          <button 
            onClick={handleCreateHero}
            style={{ 
              background:'#238636', color:'#fff', display:'flex', alignItems:'center', gap:'6px', 
              fontSize:'13px', whiteSpace:'nowrap', padding:'8px 16px', border:'none', borderRadius:'8px', cursor:'pointer', fontWeight:'bold'
            }}
          >
            <Plus size={16}/> {isMobile ? '' : 'ìƒˆ ì˜ì›…'}
          </button>
        </div>
      </div>

      {/* 2. í¬ì§€ì…˜ í•„í„° (ì›ë³¸ ê°€ë¡œ ìŠ¤í¬ë¡¤ ë””ìì¸ ìœ ì§€) */}
      <div style={{ 
        display: 'flex', gap: '8px', overflowX: 'auto', paddingBottom: '10px', marginBottom: '10px',
        scrollbarWidth: 'none', msOverflowStyle: 'none' 
      }}>
        {ROLES.map(role => (
          <button
            key={role}
            onClick={() => setSelectedRole(role)}
            style={{
              padding: '8px 12px', borderRadius: '20px', border: selectedRole === role ? `1px solid ${getRoleColor(role)}` : '1px solid #30363d',
              background: selectedRole === role ? `${getRoleColor(role)}22` : '#0d1117',
              color: selectedRole === role ? getRoleColor(role) : '#8b949e',
              fontSize: '12px', fontWeight: 'bold', cursor: 'pointer', whiteSpace: 'nowrap',
              display: 'flex', alignItems: 'center', gap: '6px', flexShrink: 0
            }}
          >
            {getRoleIcon(role)} {role === 'ALL' ? 'ì „ì²´' : role}
          </button>
        ))}
      </div>

      {/* 3. ì˜ì›… ë¦¬ìŠ¤íŠ¸ (ì›ë³¸ ë””ìì¸ ìœ ì§€ + ì‚¬ê±°ë¦¬ ì •ë³´ë§Œ ì¶”ê°€) */}
      <div style={{ 
        display: 'grid', 
        gridTemplateColumns: isMobile ? '1fr' : 'repeat(auto-fill, minmax(240px, 1fr))', 
        gap: '10px', flex: 1, overflowY: 'auto', alignContent: 'start'
      }}>
        {filteredHeroes.map(hero => (
          <div key={hero.id} style={{ 
            background: '#0d1117', padding: '12px', borderRadius: '10px', border: '1px solid #30363d', 
            display: 'flex', alignItems: 'center', gap: '15px', position: 'relative'
          }}>

            <div onClick={() => onEditHero(hero)} style={{ cursor:'pointer' }}>
                <GameIcon id={hero.id} size={50} fallback={<span style={{fontSize:'24px'}}>ğŸ§™â€â™‚ï¸</span>} shape="rounded" border={`2px solid ${getRoleColor(hero.role)}44`}/>
            </div>

            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '2px' }} onClick={() => onEditHero(hero)}>
              <div style={{ display:'flex', alignItems:'center', gap:'6px' }}>
                <span style={{ fontSize: '10px', color: getRoleColor(hero.role), border: `1px solid ${getRoleColor(hero.role)}44`, padding:'1px 4px', borderRadius:'3px', fontWeight:'bold' }}>
                  {hero.role}
                </span>
                {hero.id.startsWith('h_custom') && (
                  <span style={{ fontSize:'9px', background:'#1f6feb', color:'#fff', padding:'1px 4px', borderRadius:'3px' }}>NEW</span>
                )}
              </div>
              <strong style={{ fontSize: '15px', color: '#fff', cursor:'pointer' }}>{hero.name}</strong>

              {/* [ì¶”ê°€] ì‚¬ê±°ë¦¬ ì •ë³´ ë° ê¸°ì¡´ ìŠ¹ë¥  ì •ë³´ ë¬´ê²°í•˜ê²Œ í‘œì‹œ */}
              <div style={{ fontSize: '11px', color: '#666', display:'flex', gap:'8px', marginTop:'2px' }}>
                <span style={{ display:'flex', alignItems:'center', gap:'3px' }}>
                    <Target size={10} color="#58a6ff"/> {hero.stats.range}
                </span>
                <span style={{ color:'#444' }}>|</span>
                <span>ìŠ¹ë¥  {hero.recentWinRate.toFixed(1)}%</span>
              </div>
            </div>

            <div style={{ display:'flex', flexDirection: isMobile ? 'row' : 'column', gap:'6px' }}>
              <button onClick={() => onEditHero(hero)} style={{ background: '#21262d', border: '1px solid #30363d', color: '#fff', padding: '8px', borderRadius: '6px', cursor: 'pointer' }}>
                <Edit3 size={16} />
              </button>

              <button onClick={(e) => handleDelete(e, hero.id, hero.name)} style={{ background: '#3f1515', border: '1px solid #5a1e1e', color: '#ff6b6b', padding: '8px', borderRadius: '6px', cursor: 'pointer' }}>
                <Trash2 size={16} />
              </button>
            </div>

          </div>
        ))}

        {filteredHeroes.length === 0 && (
          <div style={{ gridColumn: '1/-1', textAlign: 'center', padding: '40px', color: '#555' }}>
            í•´ë‹¹í•˜ëŠ” ì˜ì›…ì´ ì—†ìŠµë‹ˆë‹¤.
          </div>
        )}
      </div>

    </div>
  );
};


==========================================
FILE PATH: src/components/hero/HeroStatsView.tsx
==========================================
import React, { useState, useEffect, useMemo } from 'react'; 
import { useGameStore } from '../../store/useGameStore';
import { Award, LayoutGrid, List, TrendingUp, Coins } from 'lucide-react';
import { Role, Hero } from '../../types';
import { HeroListTable } from './HeroListTable';
import { LaneStatsView } from './LaneStatsView';
import { HeroDetailView } from './HeroDetailView';
import { PatchModal } from './PatchModal';
import { GrowthSettingModal } from './GrowthSettingModal';
import { RewardSettingModal } from './RewardSettingModal';
import { ModalPortal } from '../common/ModalPortal';

export const HeroStatsView = () => {
  const { heroes } = useGameStore();
  const [mode, setMode] = useState<'HERO' | 'LANE'>('HERO');
  const [selectedRole, setSelectedRole] = useState<Role>('ì§‘í–‰ê´€');

  const [viewingHeroId, setViewingHeroId] = useState<string | null>(null);
  const [showPatchModal, setShowPatchModal] = useState(false);
  const [showGrowthModal, setShowGrowthModal] = useState(false);
  const [showRewardModal, setShowRewardModal] = useState(false);

  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  const viewingHero = useMemo(() => 
    heroes.find(h => h.id === viewingHeroId) || null, 
  [heroes, viewingHeroId]);

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const handleHeroClick = (hero: Hero) => {
    // ë Œë”ë§ ì‚¬ì´í´ì„ ë¶„ë¦¬í•˜ê¸° ìœ„í•´ ë¹„ë™ê¸° ì²˜ë¦¬
    requestAnimationFrame(() => {
        setViewingHeroId(hero.id);
    });
  };

  // ëª¨ë‹¬ì´ ì—´ë ¤ìˆìœ¼ë©´ ë¦¬ìŠ¤íŠ¸ëŠ” ë³´ì´ì§€ ì•Šì•„ì•¼ í•¨
  const isModalOpen = !!viewingHeroId;

  return (
    <div className="stats-container" style={{ 
      background: '#161b22', borderRadius: '12px', border: '1px solid #30363d', 
      minHeight: '600px', display: 'flex', flexDirection: 'column', overflow: 'hidden',
      position: 'relative'
    }}>

      <div style={{ 
        padding: '12px 15px', borderBottom: '1px solid #30363d', 
        display: 'flex', alignItems: 'center', justifyContent: 'space-between',
        background:'#21262d', gap: '10px'
      }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '6px', fontWeight: 'bold', fontSize: isMobile ? '14px' : '16px', color: '#fff', whiteSpace:'nowrap' }}>
          <Award size={isMobile ? 16 : 18} color="#58a6ff" />
          <span>{isMobile ? 'ì‹œì¦Œ1' : 'ì‹œì¦Œ 1 ë°ì´í„°'}</span>
        </div>

        <div style={{ display:'flex', gap:'8px', alignItems:'center' }}>
          <button onClick={() => setShowRewardModal(true)} style={{ background: '#e67e22', border: '1px solid rgba(255,255,255,0.2)', color: '#fff', padding: isMobile ? '6px 8px' : '6px 10px', borderRadius: '4px', cursor: 'pointer', fontSize: '11px', fontWeight: 'bold', display: 'flex', alignItems: 'center', gap: '4px' }}>
              <Coins size={12}/> {isMobile ? 'ë³´ìƒ' : 'ë³´ìƒ'}
          </button>
          <button onClick={() => setShowGrowthModal(true)} style={{ background: '#238636', border: '1px solid rgba(255,255,255,0.2)', color: '#fff', padding: isMobile ? '6px 8px' : '6px 10px', borderRadius: '4px', cursor: 'pointer', fontSize: '11px', fontWeight: 'bold', display: 'flex', alignItems: 'center', gap: '4px' }}>
              <TrendingUp size={12}/> {isMobile ? 'ì„±ì¥' : 'ì„±ì¥'}
          </button>
          <div style={{ display:'flex', background:'#0d1117', padding:'3px', borderRadius:'6px', border:'1px solid #30363d' }}>
            <button onClick={() => setMode('HERO')} style={{ display:'flex', alignItems:'center', justifyContent:'center', gap:'4px', padding: isMobile ? '6px 10px' : '6px 14px', borderRadius:'4px', border:'none', cursor:'pointer', fontWeight:'bold', fontSize: isMobile ? '11px' : '12px', background: mode === 'HERO' ? '#58a6ff' : 'transparent', color: mode === 'HERO' ? '#000' : '#8b949e', transition: '0.2s', whiteSpace:'nowrap' }}>
              <List size={12}/> {isMobile ? 'ì˜ì›…' : 'ì˜ì›…'}
            </button>
            <button onClick={() => setMode('LANE')} style={{ display:'flex', alignItems:'center', justifyContent:'center', gap:'4px', padding: isMobile ? '6px 10px' : '6px 14px', borderRadius:'4px', border:'none', cursor:'pointer', fontWeight:'bold', fontSize: isMobile ? '11px' : '12px', background: mode === 'LANE' ? '#58a6ff' : 'transparent', color: mode === 'LANE' ? '#000' : '#8b949e', transition: '0.2s', whiteSpace:'nowrap' }}>
              <LayoutGrid size={12}/> {isMobile ? 'ë¼ì¸' : 'ë¼ì¸'}
            </button>
          </div>
        </div>
      </div>

      {/* 
          [ìˆ˜ì •] FreezeWrapper ì œê±°
          ë‹¨ìˆœí•œ CSS display í† ê¸€ë¡œ ë³€ê²½í•˜ì—¬ DOM ì •í•©ì„± ìœ ì§€
          ëª¨ë‹¬ì´ ì—´ë¦¬ë©´(isModalOpen) ë¦¬ìŠ¤íŠ¸ë¥¼ ìˆ¨ê¹€
      */}
      <div style={{ flex: 1, display: (mode === 'HERO' && !isModalOpen) ? 'flex' : 'none', flexDirection: 'column', overflow: 'hidden' }}>
        <HeroListTable heroes={heroes} isMobile={isMobile} onHeroClick={handleHeroClick} />
      </div>

      <div style={{ flex: 1, display: (mode === 'LANE' && !isModalOpen) ? 'flex' : 'none', flexDirection: 'column', overflow: 'hidden' }}>
        <LaneStatsView heroes={heroes} selectedRole={selectedRole} onSelectRole={setSelectedRole} isMobile={isMobile} onHeroClick={handleHeroClick} />
      </div>

      {viewingHero && (
        <ModalPortal>
          <HeroDetailView 
            hero={viewingHero} 
            onBack={() => setViewingHeroId(null)} 
            onPatch={() => setShowPatchModal(true)} 
          />
        </ModalPortal>
      )}
      
      {showPatchModal && viewingHero && (
        <ModalPortal>
          <PatchModal hero={viewingHero} onClose={() => setShowPatchModal(false)} />
        </ModalPortal>
      )}
      
      {showGrowthModal && (
        <ModalPortal>
          <GrowthSettingModal onClose={() => setShowGrowthModal(false)} />
        </ModalPortal>
      )}
      
      {showRewardModal && (
        <ModalPortal>
          <RewardSettingModal onClose={() => setShowRewardModal(false)} />
        </ModalPortal>
      )}
    </div>
  );
};



==========================================
FILE PATH: src/components/hero/HeroTable.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/hero/HeroTable.tsx
// ==========================================

import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { Hero } from '../../types';
import { 
  Swords, Shield, Zap, Crosshair, Skull, 
  Target, Coins, Trophy, Activity, AlertCircle 
} from 'lucide-react';

interface Props { onHeroClick: (hero: Hero) => void; }

// --- Helper Functions & Components ---

const RoleIcon = ({ role, size = 14, color = "#ccc" }: { role: string, size?: number, color?: string }) => {
  switch(role) {
    case 'ì§‘í–‰ê´€': return <Swords size={size} color={color} />;
    case 'ìˆ˜í˜¸ê¸°ì‚¬': return <Shield size={size} color={color} />;
    case 'ì„ ì§€ì': return <Zap size={size} color={color} />;
    case 'ì‹ ì‚´ì': return <Crosshair size={size} color={color} />;
    case 'ì¶”ì ì': return <Skull size={size} color={color} />;
    default: return <span>?</span>;
  }
};

const formatNumber = (numStr: string | number) => {
  if (!numStr) return '0';
  const num = typeof numStr === 'string' ? parseInt(numStr.replace(/,/g, '')) : numStr;
  if (isNaN(num)) return '0';
  return num.toLocaleString();
};

const getTierBg = (tier: string) => tier === 'OP' ? '#5383e8' : 'transparent';
const getTierBorder = (tier: string) => {
  if (tier === 'OP') return '#5383e8';
  if (tier === '1') return '#e84057';
  if (tier === '2') return '#e89d40';
  if (tier === '3') return '#59c7ba';
  return '#555';
};
const getTierColor = (tier: string) => {
  if (tier === 'OP') return '#5383e8';
  if (tier === '1') return '#e84057';
  if (tier === '2') return '#e89d40';
  if (tier === '3') return '#59c7ba';
  return '#888';
};
const getWinRateColor = (rate: number) => rate >= 52 ? '#5383e8' : rate <= 48 ? '#e84057' : '#fff';


// --- Main Component ---

export const HeroTable: React.FC<Props> = ({ onHeroClick }) => {
  const { heroes } = useGameStore();
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  if (!heroes || heroes.length === 0) {
    return (
      <div style={{ padding:'40px', textAlign:'center', color:'#666', background:'#1c1c1f', borderRadius:'8px' }}>
        <Activity size={32} style={{ marginBottom:'10px', opacity:0.5 }}/>
        <br/>ë°ì´í„°ë¥¼ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤...
      </div>
    );
  }

  // =========================================================
  // [Mobile View] ì¹´ë“œ ë¦¬ìŠ¤íŠ¸ í˜•íƒœ
  // =========================================================
  if (isMobile) {
    return (
      <div style={{ paddingBottom: '20px' }}>
        {heroes.map((hero) => (
          <div 
            key={hero.id}
            onClick={() => onHeroClick(hero)}
            style={{
              background: '#1c1c1f',
              border: '1px solid #333',
              borderRadius: '12px',
              padding: '15px',
              marginBottom: '12px',
              display: 'flex',
              flexDirection: 'column',
              gap: '12px',
              boxShadow: '0 4px 10px rgba(0,0,0,0.2)'
            }}
          >
            {/* ìƒë‹¨: ë­í¬ + ê¸°ë³¸ì •ë³´ + í‹°ì–´ */}
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                <div style={{ 
                  width: '36px', height: '36px', background: '#252528', borderRadius: '8px', 
                  display: 'flex', alignItems: 'center', justifyContent: 'center',
                  border: '1px solid #444', fontWeight: 'bold', color: '#fff'
                }}>
                  {hero.rank}
                </div>
                <div>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                    <span style={{ fontWeight: 'bold', fontSize: '16px', color: '#fff' }}>{hero.name}</span>
                    <span style={{ fontSize: '12px', color: '#888' }}>{hero.role}</span>
                  </div>
                  <div style={{ display:'flex', gap:'5px', fontSize:'11px', color:'#666', marginTop:'2px' }}>
                    <RoleIcon role={hero.role} size={12} color="#666" />
                    <span>{hero.skills?.passive?.name || 'ê¸°ë³¸ ê³µê²©'}</span>
                  </div>
                </div>
              </div>

              <div style={{ 
                padding: '4px 10px', borderRadius: '6px', fontSize: '12px', fontWeight: '800',
                background: getTierBg(hero.tier), 
                color: hero.tier === 'OP' ? '#fff' : getTierColor(hero.tier),
                border: `1px solid ${getTierBorder(hero.tier)}`
              }}>
                {hero.tier} í‹°ì–´
              </div>
            </div>

            {/* í•˜ë‹¨: ì£¼ìš” ìŠ¤íƒ¯ Grid */}
            <div style={{ 
              display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', 
              background: '#121212', borderRadius: '8px', padding: '10px', gap: '5px'
            }}>
              <div style={{ textAlign: 'center' }}>
                <div style={{ fontSize: '11px', color: '#666' }}>ìŠ¹ë¥ </div>
                <div style={{ fontWeight: 'bold', color: getWinRateColor(hero.recentWinRate || 0) }}>
                  {(hero.recentWinRate || 0).toFixed(1)}%
                </div>
              </div>
              <div style={{ textAlign: 'center', borderLeft: '1px solid #333', borderRight: '1px solid #333' }}>
                <div style={{ fontSize: '11px', color: '#666' }}>í”½ë¥ </div>
                <div style={{ fontWeight: 'bold', color: '#fff' }}>
                  {(hero.pickRate || 0).toFixed(1)}%
                </div>
              </div>
              <div style={{ textAlign: 'center' }}>
                <div style={{ fontSize: '11px', color: '#666' }}>KDA</div>
                <div style={{ fontWeight: 'bold', color: parseFloat(hero.kdaRatio) >= 4 ? '#5383e8' : '#ccc' }}>
                  {hero.kdaRatio}
                </div>
              </div>
            </div>

          </div>
        ))}
      </div>
    );
  }

  // =========================================================
  // [Desktop View] ê¸°ì¡´ í…Œì´ë¸” í˜•íƒœ
  // =========================================================
  return (
    <div className="panel" style={{ overflowX: 'auto', background: '#1c1c1f', border: '1px solid #2c2c2f', boxShadow: '0 4px 20px rgba(0,0,0,0.3)' }}>
      <h3 style={{ margin: '0', padding: '15px 20px', fontSize: '15px', color: '#fff', borderLeft: '4px solid #5383e8', background: '#252528', borderBottom: '1px solid #2c2c2f' }}>
        ğŸ“Š ì±”í”¼ì–¸ ë¶„ì„ (Ranked Statistics)
      </h3>
      <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '13px', whiteSpace: 'nowrap' }}>
        <thead>
          <tr style={{ color: '#9aa4af', borderBottom: '1px solid #2c2c2f', textAlign: 'right', height: '45px', background: '#1c1c1f' }}>
            <th style={{ width: '60px', textAlign: 'center' }}>ìˆœìœ„</th>
            <th style={{ textAlign: 'left', paddingLeft: '20px' }}>ì±”í”¼ì–¸</th>
            <th style={{ width: '100px' }}>ìŠ¹ë¥ </th>
            <th style={{ width: '140px' }}>í”½ë¥  / ë°´ë¥ </th>
            <th style={{ width: '200px' }}>KDA (í‰ì )</th>
            <th style={{ width: '160px' }}>CS / ê³¨ë“œ</th>
            <th style={{ width: '180px', paddingRight: '20px' }}>ê°€í•œ í”¼í•´ / ë°›ì€ í”¼í•´</th>
          </tr>
        </thead>
        <tbody>
          {heroes.map((hero) => (
            <tr 
              key={hero.id} 
              onClick={() => onHeroClick(hero)}
              style={{ borderBottom: '1px solid #2c2c2f', cursor: 'pointer', height: '50px', transition: 'background 0.1s' }}
              onMouseEnter={(e) => e.currentTarget.style.background = '#2a2a2e'}
              onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
            >
              <td style={{ textAlign: 'center', color: '#777' }}>
                <span style={{ fontSize: '14px', color: '#fff', fontWeight: 'bold', marginRight: '4px' }}>{hero.rank || '-'}</span>
              </td>

              <td style={{ textAlign: 'left', paddingLeft: '20px' }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                  <div style={{ width: '32px', height: '32px', background: '#333', borderRadius: '6px', display:'flex', alignItems:'center', justifyContent:'center', border: '1px solid #444' }}>
                     <RoleIcon role={hero.role} />
                  </div>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                    <span style={{ fontWeight: 'bold', fontSize: '14px', color: '#eee' }}>{hero.name}</span>
                    <span style={{ fontSize: '12px', color: '#666' }}>{hero.role}</span>
                    <span style={{ 
                      marginLeft: '6px', padding: '1px 6px', borderRadius: '3px', fontWeight: '800', fontSize: '10px',
                      background: getTierBg(hero.tier), color: '#fff', border: `1px solid ${getTierBorder(hero.tier)}`
                    }}>
                      {hero.tier || 'unranked'}
                    </span>
                  </div>
                </div>
              </td>

              <td style={{ textAlign: 'right', fontWeight: 'bold' }}>
                <span style={{ color: getWinRateColor(hero.recentWinRate || 0) }}>
                  {(hero.recentWinRate || 0).toFixed(2)}%
                </span>
              </td>

              <td style={{ textAlign: 'right' }}>
                <span style={{ color: '#ccc' }}>{(hero.pickRate || 0).toFixed(1)}%</span>
                <span style={{ color: '#555', margin: '0 6px' }}>/</span>
                <span style={{ color: '#e84057', fontSize: '12px' }}>{(hero.banRate || 0).toFixed(1)}%</span>
              </td>

              <td style={{ textAlign: 'right' }}>
                <span style={{ color: '#8b949e', fontSize: '12px', marginRight: '8px' }}>({hero.avgKda || '0/0/0'})</span>
                <span style={{ fontWeight: 'bold', color: parseFloat(hero.kdaRatio || '0') >= 4 ? '#5383e8' : '#fff' }}>
                  {hero.kdaRatio || '0.00'}:1
                </span>
              </td>

              <td style={{ textAlign: 'right' }}>
                <div style={{ display: 'inline-flex', alignItems: 'center', gap: '15px' }}>
                  <span style={{ color: '#aaa', fontSize: '12px', display: 'flex', alignItems: 'center', gap: '4px' }}>
                    <Target size={12}/> {hero.avgCs || 0}
                  </span>
                  <span style={{ color: '#e89d40', fontSize: '12px', display: 'flex', alignItems: 'center', gap: '4px' }}>
                    <Coins size={12}/> {formatNumber(hero.avgGold || '0')}
                  </span>
                </div>
              </td>

              <td style={{ textAlign: 'right', paddingRight: '20px' }}>
                <span style={{ color: '#e84057' }}>{formatNumber(hero.avgDpm || '0')}</span>
                <span style={{ color: '#555', margin: '0 6px' }}>/</span>
                <span style={{ color: '#8b949e' }}>{formatNumber(hero.avgDpg || '0')}</span>
              </td>

            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};


==========================================
FILE PATH: src/components/hero/HeroVsModal.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/hero/HeroVsModal.tsx
// ==========================================

import React, { useMemo } from 'react';
import { Hero } from '../../types';
// â–¼ [ìˆ˜ì •] 'Trophy'ë¥¼ import ëª©ë¡ì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.
import { X, Swords, Skull, Target, Zap, Shield, TrendingUp, AlertTriangle, Trophy } from 'lucide-react';
import { GameIcon } from '../common/GameIcon';

interface Props {
  myHero: Hero;
  enemyHero: Hero;
  onClose: () => void;
}

export const HeroVsModal: React.FC<Props> = ({ myHero, enemyHero, onClose }) => {

  // --- [1. ì •ë°€ ìƒì„± ì‹œë®¬ë ˆì´ì…˜ ì—”ì§„] ---
  const analysis = useMemo(() => {
    let score = 0; // 0 ê¸°ì¤€, ì–‘ìˆ˜ë©´ myHero ìœ ë¦¬, ìŒìˆ˜ë©´ enemyHero ìœ ë¦¬

    // 1. ê¸°ë³¸ ì²´ê¸‰ ì°¨ì´ (ìŠ¹ë¥  ê¸°ë°˜)
    const myWin = myHero.recentWinRate;
    const enWin = enemyHero.recentWinRate;
    score += (myWin - enWin) * 1.5;

    // 2. ì—­í• êµ° ìƒì„± (ê°€ìœ„ë°”ìœ„ë³´ ë¡œì§)
    // ì¶”ì ì(ì•”ì‚´) > ì‹ ì‚´ì(ì›ë”œ) > ìˆ˜í˜¸ê¸°ì‚¬(íƒ±ì»¤) > ì¶”ì ì
    // ì„ ì§€ì(ë©”ì´ì§€) vs ì§‘í–‰ê´€(ë¸Œë£¨ì €) : ì†ì‹¸ì›€
    const roles = { my: myHero.role, en: enemyHero.role };

    if (roles.my === 'ì¶”ì ì' && (roles.en === 'ì‹ ì‚´ì' || roles.en === 'ì„ ì§€ì')) score += 10; // ì•”ì‚´ ì„±ê³µ
    if (roles.my === 'ì‹ ì‚´ì' && roles.en === 'ìˆ˜í˜¸ê¸°ì‚¬') score += 8; // ì¹´ì´íŒ… ìš°ìœ„
    if (roles.my === 'ìˆ˜í˜¸ê¸°ì‚¬' && roles.en === 'ì¶”ì ì') score += 10; // ë”œ ì•ˆë°•í˜
    if (roles.my === 'ì§‘í–‰ê´€' && roles.en === 'ì¶”ì ì') score += 5; // ì²´ê¸‰ ì°¨ì´

    // ë°˜ëŒ€ ê²½ìš° (íŒ¨ë„í‹°)
    if (roles.en === 'ì¶”ì ì' && (roles.my === 'ì‹ ì‚´ì' || roles.my === 'ì„ ì§€ì')) score -= 10;
    if (roles.en === 'ì‹ ì‚´ì' && roles.my === 'ìˆ˜í˜¸ê¸°ì‚¬') score -= 8;
    if (roles.en === 'ìˆ˜í˜¸ê¸°ì‚¬' && roles.my === 'ì¶”ì ì') score -= 10;

    // 3. ìŠ¤í‚¬ ë©”ì»¤ë‹ˆì¦˜ ìƒì„±
    const mySkills = Object.values(myHero.skills);
    const enSkills = Object.values(enemyHero.skills);

    const myCC = mySkills.filter(s => s.mechanic === 'STUN' || s.mechanic === 'HOOK').length;
    const enCC = enSkills.filter(s => s.mechanic === 'STUN' || s.mechanic === 'HOOK').length;
    const myDash = mySkills.filter(s => s.mechanic === 'DASH').length;
    const enDash = enSkills.filter(s => s.mechanic === 'DASH').length;

    // CCê¸°ê°€ ë§ìœ¼ë©´ ì´ë™ê¸° ì—†ëŠ” ì ì—ê²Œ ìœ ë¦¬
    if (myCC > 0 && enDash === 0) score += 5;
    if (enCC > 0 && myDash === 0) score -= 5;

    // 4. ìµœì¢… ìŠ¹ë¥  ë° ì§€í‘œ ì‚°ì¶œ
    // ìµœì†Œ 35%, ìµœëŒ€ 65%ë¡œ ë³´ì •
    const matchupWinRate = Math.min(65, Math.max(35, 50 + score));

    // ë¼ì¸ì „ í‚¬ í™•ë¥  (ìƒì„±ì´ ê·¹ë‹¨ì ì¼ìˆ˜ë¡ í‚¬ í™•ë¥  ë†’ìŒ)
    const laneKillRate = 50 + (score * 1.2);

    // 15ë¶„ ê³¨ë“œ ê²©ì°¨ ì˜ˆìƒ
    const goldDiff = Math.floor(score * 35);

    return { score, matchupWinRate, laneKillRate, goldDiff };
  }, [myHero, enemyHero]);


  // --- [2. ë‹¤ì±„ë¡œìš´ ë¶„ì„ ì½”ë©˜íŠ¸ ìƒì„±ê¸°] ---
  const getAnalystComment = () => {
    const { score, matchupWinRate } = analysis;
    const myName = myHero.name;
    const enName = enemyHero.name;

    // ìƒí™©ë³„ ë©˜íŠ¸ í’€ (Pool)
    const comments = {
      // ì••ë„ì  ìš°ìœ„ (ìŠ¹ë¥  60% ì´ìƒ)
      dominate: [
        `"${enName}" ì…ì¥ì—ì„œ ì¬ì•™ê³¼ë„ ê°™ì€ ë§¤ì¹˜ì—…ì…ë‹ˆë‹¤. ${myName}ì˜ ìŠ¤í‚¬ ì…‹ì´ ìƒëŒ€ë¥¼ ì™„ë²½í•˜ê²Œ ì¹´ìš´í„°ì¹©ë‹ˆë‹¤.`,
        `ë¼ì¸ì „ë¶€í„° í•œíƒ€ê¹Œì§€ ${myName}ê°€ ì£¼ë„ê¶Œì„ ì¥˜ ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•„ìŠ¹ ì¹´ë“œì…ë‹ˆë‹¤.`,
        `ë°ì´í„°ìƒ 7:3 ì •ë„ë¡œ ìœ ë¦¬í•©ë‹ˆë‹¤. ${enName}ì˜ ì§„ì…ì„ ${myName}ê°€ ì†ì‰½ê²Œ ë°›ì•„ì¹  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`,
        `ìƒëŒ€ëŠ” ë°´í”½ ë‹¨ê³„ì—ì„œ ì´ë¯¸ ì¡ŒìŠµë‹ˆë‹¤. ${myName}ì˜ ë”œì„ ë²„í‹¸ ìˆ˜ ì—†ëŠ” êµ¬ì¡°ì…ë‹ˆë‹¤.`
      ],
      // ì†Œí­ ìš°ìœ„ (52~59%)
      advantage: [
        `ê¸°ë¶„ ì¢‹ì€ ìƒì„±ì…ë‹ˆë‹¤. ì´ˆë°˜ êµì „ë§Œ ì¡°ì‹¬í•˜ë©´ ${myName}ì˜ ì„±ì¥ ê¸°ëŒ€ì¹˜ê°€ ë” ë†’ìŠµë‹ˆë‹¤.`,
        `${enName}ì˜ ì£¼ìš” ìŠ¤í‚¬ì´ ë¹ ì§€ëŠ” íƒ€ì´ë°ì„ ë…¸ë¦¬ë©´ í‚¬ê°ì„ ì‰½ê²Œ ì¡ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`,
        `í†µê³„ì ìœ¼ë¡œ ìœ ë¦¬í•˜ì§€ë§Œ ë°©ì‹¬ì€ ê¸ˆë¬¼ì…ë‹ˆë‹¤. ${myName}ì˜ ìœ ì§€ë ¥ì´ ìŠ¹íŒ¨ë¥¼ ê°€ë¥¼ ê²ƒì…ë‹ˆë‹¤.`,
        `ì¤‘ë°˜ íƒ€ì´ë°ë¶€í„° ${myName}ê°€ ì‚¬ì´ë“œ ì£¼ë„ê¶Œì„ ê°€ì ¸ì˜¤ê¸° í¸í•œ êµ¬ë„ì…ë‹ˆë‹¤.`
      ],
      // ì—„ëŒ€ì—„ (48~51%)
      even: [
        `ìˆœìˆ˜ í”¼ì§€ì»¬ ì‹¸ì›€ì…ë‹ˆë‹¤. ìŠ¤í‚¬ í•˜ë‚˜ ì°¨ì´ë¡œ ìŠ¹íŒ¨ê°€ ê°ˆë¦´ 'ì†ì‹¸ì›€' êµ¬ë„ì…ë‹ˆë‹¤.`,
        `ì •ê¸€ëŸ¬ì˜ ê°œì…ì´ ìŠ¹íŒ¨ë¥¼ ê°€ë¥¼ ê²ƒì…ë‹ˆë‹¤. ë¼ì¸ì „ë³´ë‹¤ëŠ” í•©ë¥˜ ì‹¸ì›€ì´ ì¤‘ìš”í•©ë‹ˆë‹¤.`,
        `ì„œë¡œ í‚¬ì„ ë‚´ê¸° í˜ë“  êµ¬ì¡°ì…ë‹ˆë‹¤. íŒŒë° ìœ„ì£¼ì˜ ì§€ë£¨í•œ ë¼ì¸ì „ì´ ì˜ˆìƒë©ë‹ˆë‹¤.`,
        `ëˆ„ê°€ ë” ì‹¤ìˆ˜ë¥¼ ëœ í•˜ëŠëƒì˜ ì‹¸ì›€ì…ë‹ˆë‹¤. ë°ì´í„°ìƒ ìŠ¹ë¥ ì€ ì •í™•íˆ ë°˜ë°˜ì…ë‹ˆë‹¤.`
      ],
      // ì†Œí­ ì—´ì„¸ (41~47%)
      disadvantage: [
        `ë‹¤ì†Œ ê»„ë„ëŸ¬ìš´ ìƒëŒ€ì…ë‹ˆë‹¤. ${enName}ì˜ ê²¬ì œë¥¼ ë²„í‹°ë©° í›„ë°˜ì„ ë„ëª¨í•´ì•¼ í•©ë‹ˆë‹¤.`,
        `ë§ë”œì€ í”¼í•˜ëŠ” ê²Œ ì¢‹ìŠµë‹ˆë‹¤. ì•„êµ°ì˜ ì§€ì› ì—†ì´ëŠ” ë¼ì¸ì „ ì£¼ë„ê¶Œì„ ì¡ê¸° í˜ë“­ë‹ˆë‹¤.`,
        `${enName}ì˜ ì„±ì¥ ì†ë„ê°€ ë” ë¹ ë¦…ë‹ˆë‹¤. ì´ˆë°˜ì— ë³€ìˆ˜ë¥¼ ë§Œë“¤ì§€ ì•Šìœ¼ë©´ ê²Œì„ì´ í˜ë“¤ì–´ì§‘ë‹ˆë‹¤.`,
        `ìƒì„±ìƒ ë¶ˆë¦¬í•˜ì§€ë§Œ ê·¹ë³µ ë¶ˆê°€ëŠ¥í•˜ì§„ ì•ŠìŠµë‹ˆë‹¤. ì•„ì´í…œìœ¼ë¡œ ì¹´ìš´í„° ì¹˜ëŠ” ê²ƒì„ ì¶”ì²œí•©ë‹ˆë‹¤.`
      ],
      // ì••ë„ì  ì—´ì„¸ (40% ì´í•˜)
      hardCounter: [
        `ë‹·ì§€ë¥¼ ì¶”ì²œí•©ë‹ˆë‹¤. ${myName}ë¡œëŠ” ${enName}ë¥¼ ì´ê¸°ê¸° ì •ë§ í˜ë“­ë‹ˆë‹¤.`,
        `"ì§€ì˜¥ì˜ ì¹´ìš´í„°" ë§¤ì¹˜ì—…ì…ë‹ˆë‹¤. ìˆ¨ë§Œ ì‰¬ì–´ë„ ë¼ì¸ì „ì´ í„°ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`,
        `${enName}ë¥¼ ë°´í•˜ì§€ ì•Šì€ ëŒ€ê°€ë¥¼ ì¹˜ë¥¼ ê²ƒì…ë‹ˆë‹¤. íƒ€ì›Œ í—ˆê¹…ì´ ìœ ì¼í•œ ì‚´ê¸¸ì…ë‹ˆë‹¤.`,
        `ì ˆëŒ€ 1:1ì„ ê±¸ì§€ ë§ˆì‹­ì‹œì˜¤. ëª¨ë“  ì§€í‘œê°€ ${enName}ì˜ ìŠ¹ë¦¬ë¥¼ ê°€ë¦¬í‚¤ê³  ìˆìŠµë‹ˆë‹¤.`
      ]
    };

    // ëœë¤ ì„ íƒ ë¡œì§
    const pick = (arr: string[]) => arr[Math.floor(Math.random() * arr.length)];

    if (matchupWinRate >= 60) return pick(comments.dominate);
    if (matchupWinRate >= 52) return pick(comments.advantage);
    if (matchupWinRate >= 48) return pick(comments.even);
    if (matchupWinRate >= 40) return pick(comments.disadvantage);
    return pick(comments.hardCounter);
  };

  const comment = useMemo(() => getAnalystComment(), [analysis]);


  // --- [3. UI ì»´í¬ë„ŒíŠ¸] ---
  const ComparisonRow = ({ label, icon, leftVal, rightVal, unit = '', inverse = false }: any) => {
    // ê°’ì´ ë” í° ìª½ì´ ì´ê¸°ëŠ”ì§€(true), ì‘ì€ ìª½ì´ ì´ê¸°ëŠ”ì§€(false)
    const isLeftWin = inverse ? leftVal <= rightVal : leftVal >= rightVal;
    const total = leftVal + rightVal;
    const leftP = total > 0 ? (leftVal / total) * 100 : 50;

    const winColor = '#58a6ff'; // Blue
    const loseColor = '#da3633'; // Red (ì )

    return (
      <div style={{ marginBottom: '15px' }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '12px', color: '#ccc', marginBottom: '6px', padding: '0 5px' }}>
          <span style={{ fontWeight: 'bold', color: isLeftWin ? winColor : '#888' }}>
            {leftVal.toLocaleString()}{unit}
          </span>
          <div style={{ display:'flex', alignItems:'center', gap:'4px', color:'#aaa', fontSize:'11px' }}>{icon} {label}</div>
          <span style={{ fontWeight: 'bold', color: !isLeftWin ? loseColor : '#888' }}>
            {rightVal.toLocaleString()}{unit}
          </span>
        </div>

        {/* ê·¸ë˜í”„ ë°” */}
        <div style={{ display: 'flex', height: '6px', background: '#222', borderRadius: '3px', overflow: 'hidden' }}>
          <div style={{ width: `${leftP}%`, background: isLeftWin ? winColor : '#444', transition:'1s' }} />
          <div style={{ width: '2px', background: '#000' }} />
          <div style={{ flex: 1, background: !isLeftWin ? loseColor : '#444', transition:'1s' }} />
        </div>
      </div>
    );
  };

  return (
    <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.85)', zIndex: 9999, display: 'flex', justifyContent: 'center', alignItems: 'center', padding: '15px', backdropFilter: 'blur(5px)' }}>
      <div style={{ width: '100%', maxWidth: '500px', background: '#161b22', borderRadius: '16px', border: '1px solid #30363d', overflow: 'hidden', display:'flex', flexDirection:'column', maxHeight:'85vh' }}>

        {/* í—¤ë” */}
        <div style={{ padding: '15px 20px', background: '#21262d', borderBottom: '1px solid #30363d', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <h3 style={{ margin: 0, color: '#fff', fontSize: '15px', display:'flex', alignItems:'center', gap:'8px', fontWeight:'bold' }}>
            <Swords size={16} color="#da3633"/> ìƒëŒ€ ì „ì  ì‹œë®¬ë ˆì´ì…˜
          </h3>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#ccc', cursor: 'pointer' }}><X size={20}/></button>
        </div>

        {/* VS ë°°ë„ˆ */}
        <div style={{ padding: '25px 20px', background: 'linear-gradient(135deg, rgba(88, 166, 255, 0.15) 0%, rgba(218, 54, 51, 0.15) 100%)', display: 'flex', justifyContent: 'space-between', alignItems: 'center', borderBottom:'1px solid #30363d' }}>
          {/* ë‚˜ (ì™¼ìª½) */}
          <div style={{ textAlign: 'center', width:'30%' }}>
            <div style={{ position:'relative', display:'inline-block' }}>
              <GameIcon id={myHero.id} size={60} shape="circle" border="3px solid #58a6ff" />
              <div style={{ position:'absolute', bottom:-5, left:'50%', transform:'translateX(-50%)', background:'#58a6ff', color:'#000', fontSize:'9px', fontWeight:'bold', padding:'1px 6px', borderRadius:'10px', whiteSpace:'nowrap' }}>ME</div>
            </div>
            <div style={{ marginTop: '8px', fontWeight: 'bold', color: '#fff', fontSize:'13px' }}>{myHero.name}</div>
          </div>

          <div style={{ textAlign: 'center', flex:1 }}>
            <div style={{ fontSize: '11px', color: '#aaa', marginBottom: '2px' }}>ìƒëŒ€ ìŠ¹ë¥  ì˜ˆì¸¡</div>
            <div style={{ fontSize: '28px', fontWeight: '900', color: analysis.matchupWinRate >= 50 ? '#58a6ff' : '#da3633', textShadow:'0 0 10px rgba(0,0,0,0.5)' }}>
              {analysis.matchupWinRate.toFixed(1)}%
            </div>
            <div style={{ fontSize:'10px', color: analysis.matchupWinRate >= 50 ? '#58a6ff' : '#da3633', fontWeight:'bold' }}>
              {analysis.matchupWinRate >= 50 ? 'ìœ ë¦¬í•¨' : 'ë¶ˆë¦¬í•¨'}
            </div>
          </div>

          {/* ì  (ì˜¤ë¥¸ìª½) */}
          <div style={{ textAlign: 'center', width:'30%' }}>
            <div style={{ position:'relative', display:'inline-block' }}>
              <GameIcon id={enemyHero.id} size={60} shape="circle" border="3px solid #da3633" />
              <div style={{ position:'absolute', bottom:-5, left:'50%', transform:'translateX(-50%)', background:'#da3633', color:'#fff', fontSize:'9px', fontWeight:'bold', padding:'1px 6px', borderRadius:'10px', whiteSpace:'nowrap' }}>ENEMY</div>
            </div>
            <div style={{ marginTop: '8px', fontWeight: 'bold', color: '#fff', fontSize:'13px' }}>{enemyHero.name}</div>
          </div>
        </div>

        {/* ë¶„ì„ ì»¨í…ì¸  (ìŠ¤í¬ë¡¤) */}
        <div style={{ padding: '20px', flex: 1, overflowY: 'auto', background:'#0d1117' }}>

          {/* ë¶„ì„ ì½”ë©˜íŠ¸ ë°•ìŠ¤ */}
          <div style={{ marginBottom:'25px', padding:'15px', background:'#1c1c1f', borderRadius:'8px', border:'1px solid #333', borderLeft:'4px solid #58a6ff' }}>
            <div style={{ fontSize:'12px', color:'#58a6ff', fontWeight:'bold', marginBottom:'6px', display:'flex', alignItems:'center', gap:'5px' }}>
              <TrendingUp size={14}/> ë¶„ì„ ì½”ë©˜íŠ¸
            </div>
            <div style={{ fontSize:'13px', color:'#eee', lineHeight:'1.5' }}>
              "{comment}"
            </div>
          </div>

          <h4 style={{ fontSize:'12px', color:'#888', margin:'0 0 15px 0' }}>ìƒì„¸ ì§€í‘œ ë¹„êµ</h4>

          <ComparisonRow 
            label="ë¼ì¸ì „ í‚¬ í™•ë¥ " icon={<Skull size={12}/>} 
            leftVal={analysis.laneKillRate} rightVal={100 - analysis.laneKillRate} unit="%"
          />
          <ComparisonRow 
            label="15ë¶„ ê³¨ë“œ ê²©ì°¨" icon={<Zap size={12}/>} 
            leftVal={analysis.goldDiff > 0 ? `+${analysis.goldDiff}` : 0} 
            rightVal={analysis.goldDiff < 0 ? `+${Math.abs(analysis.goldDiff)}` : 0} 
          />
          <ComparisonRow 
            label="ë¶„ë‹¹ ë°ë¯¸ì§€ (DPM)" icon={<Target size={12}/>} 
            leftVal={parseInt(myHero.avgDpm.replace(/,/g, ''))} 
            rightVal={parseInt(enemyHero.avgDpm.replace(/,/g, ''))} 
          />
          <ComparisonRow 
            label="KDA ë¹„ìœ¨" icon={<Trophy size={12}/>} 
            leftVal={parseFloat(myHero.kdaRatio)} 
            rightVal={parseFloat(enemyHero.kdaRatio)} 
          />

          <div style={{ marginTop:'20px', fontSize:'11px', color:'#555', textAlign:'center' }}>
            * ìœ„ ë°ì´í„°ëŠ” ìµœê·¼ {Math.max(myHero.record.totalMatches, 100)}ê²½ê¸° ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‹œë®¬ë ˆì´ì…˜ ë˜ì—ˆìŠµë‹ˆë‹¤.
          </div>
        </div>

      </div>
    </div>
  );
};


==========================================
FILE PATH: src/components/hero/LaneStatsView.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/hero/LaneStatsView.tsx
// ==========================================

import React, { useRef, useState, useMemo } from 'react';
import { Hero, Role } from '../../types';
import { ROLE_DATA } from '../../data/roles';
import { useGameStore } from '../../store/useGameStore';
import { Wrench, Camera, Image as ImageIcon, Target, Swords, Coins, Activity, TrendingUp, Skull } from 'lucide-react';
import { RolePatchModal } from './RolePatchModal'; 
import { GameIcon } from '../common/GameIcon';

interface Props {
  heroes: Hero[];
  selectedRole: Role;
  onSelectRole: (role: Role) => void;
  isMobile?: boolean;
  onHeroClick?: (hero: Hero) => void; // í´ë¦­ í•¸ë“¤ëŸ¬ ì¶”ê°€
}

const getRoleId = (role: Role) => {
  switch(role) {
    case 'ì§‘í–‰ê´€': return 'role_executor';
    case 'ì¶”ì ì': return 'role_tracker';
    case 'ì„ ì§€ì': return 'role_prophet';
    case 'ì‹ ì‚´ì': return 'role_slayer';
    case 'ìˆ˜í˜¸ê¸°ì‚¬': return 'role_guardian';
    default: return 'role_unknown';
  }
};

export const LaneStatsView: React.FC<Props> = ({ heroes, selectedRole, onSelectRole, isMobile = false, onHeroClick }) => {
  const { gameState, setCustomImage } = useGameStore();
  const [showPatchModal, setShowPatchModal] = useState(false);
  const [isHovered, setIsHovered] = useState(false);

  const roleInfo = ROLE_DATA[selectedRole];
  const roleId = getRoleId(selectedRole);
  const roleBgId = `${roleId}_bg`; 

  // [ìˆ˜ì •] ë°°ê²½ ì´ë¯¸ì§€ ë¡œë”© ë¡œì§ ê°•í™” (ë°°ê²½í‚¤ -> ì•„ì´ì½˜í‚¤ ìˆœì„œë¡œ í™•ì¸)
  const displayBg = gameState.customImages?.[roleBgId] || gameState.customImages?.[roleId];

  const iconInputRef = useRef<HTMLInputElement>(null);
  const bgInputRef = useRef<HTMLInputElement>(null);

  const s = gameState.roleSettings || {
    executor: { damage: 10, defense: 10 },
    tracker: { gold: 20, smiteChance: 1.5 },
    prophet: { cdrPerLevel: 2 },
    slayer: { structureDamage: 30 },
    guardian: { survivalRate: 20 }
  };

  const getDynamicTraitText = (role: Role) => {
    switch (role) {
      case 'ì§‘í–‰ê´€': return `ì£¼ë³€ì— ì•„êµ°ì´ ì—†ì„ ë•Œ(ì†”ë¡œ ë¼ì¸ì „ ì‹œ) í”¼í•´ëŸ‰ +${s.executor.damage}%, ë°©ì–´ë ¥ +${s.executor.defense}%.`;
      case 'ì¶”ì ì': return `ëª¬ìŠ¤í„°/ì˜¤ë¸Œì íŠ¸ ì²˜ì¹˜ ì‹œ ê³¨ë“œ íšë“ëŸ‰ +${s.tracker.gold}%. ë‹¤ë¥¸ ë¼ì¸ ê°œì…(ê°±í‚¹) ì‹œ ì„±ê³µë¥  ì¦ê°€. (ê°•íƒ€ í™•ë¥  ${s.tracker.smiteChance}ë°°)`;
      case 'ì„ ì§€ì': return `ë ˆë²¨ì´ ì˜¤ë¥¼ìˆ˜ë¡ ìŠ¤í‚¬ ê°€ì†(ì¿¨íƒ€ì„ ê°ì†Œ) íš¨ê³¼ê°€ ì¶”ê°€ë¡œ ë¶™ìŒ. (ë ˆë²¨ë‹¹ ìœ„ë ¥ +${s.prophet.cdrPerLevel}%)`;
      case 'ì‹ ì‚´ì': return `êµ¬ì¡°ë¬¼(íƒ€ì›Œ, ì–µì œê¸°, ìˆ˜í˜¸ì) ë° ê±°ì‹ ë³‘ì—ê²Œ ì…íˆëŠ” í”¼í•´ëŸ‰ +${s.slayer.structureDamage}%.`;
      case 'ìˆ˜í˜¸ê¸°ì‚¬': return `ê°™ì€ ë¼ì¸ì— ìˆëŠ” ì•„êµ°ì˜ ìƒì¡´ìœ¨ì„ ${s.guardian.survivalRate}% ì˜¬ë ¤ì¤Œ. (ìì‹ ì´ ëŒ€ì‹  ì£½ì„ í™•ë¥  ì¦ê°€)`;
      default: return '';
    }
  };

  const laneHeroes = heroes
    .filter(h => h.role === selectedRole)
    .sort((a, b) => b.recentWinRate - a.recentWinRate);

  const roleStats = useMemo(() => {
    if (laneHeroes.length === 0) return null;

    let totalWins = 0, totalMatches = 0;
    let totalK = 0, totalD = 0, totalA = 0;
    let totalGold = 0, totalCs = 0, totalDpm = 0;

    laneHeroes.forEach(h => {
        totalWins += h.record.totalWins;
        totalMatches += h.record.totalMatches;
        totalK += h.record.totalKills;
        totalD += h.record.totalDeaths;
        totalA += h.record.totalAssists;

        totalGold += parseInt(h.avgGold.replace(/,/g, '')) || 0;
        totalCs += parseFloat(h.avgCs) || 0;
        totalDpm += parseInt(h.avgDpm.replace(/,/g, '')) || 0;
    });

    const count = laneHeroes.length;
    const safeDiv = (a: number, b: number) => b === 0 ? 0 : a / b;

    return {
        avgWinRate: totalMatches > 0 ? (totalWins / totalMatches) * 100 : 0,
        avgKda: safeDiv(totalK + totalA, totalD).toFixed(2),
        avgGold: Math.round(totalGold / count).toLocaleString(),
        avgCs: (totalCs / count).toFixed(1),
        avgDpm: Math.round(totalDpm / count).toLocaleString(),
    };
  }, [laneHeroes]);

  const handleIconUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if(file) {
        const reader = new FileReader();
        reader.onloadend = () => { if(typeof reader.result === 'string') setCustomImage(roleId, reader.result); };
        reader.readAsDataURL(file);
    }
  };

  const handleBgUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if(file) {
        const reader = new FileReader();
        reader.onloadend = () => { if(typeof reader.result === 'string') setCustomImage(roleBgId, reader.result); };
        reader.readAsDataURL(file);
    }
  };

  const actionButtonStyle = {
    background: 'rgba(33, 38, 45, 0.8)', 
    border: '1px solid rgba(255,255,255,0.2)', 
    color: '#fff', 
    padding: '8px 12px', 
    borderRadius: '6px', 
    cursor: 'pointer', 
    fontWeight: 'bold' as const, 
    display: 'flex', alignItems: 'center', gap: '8px', 
    fontSize: '12px', whiteSpace: 'nowrap' as const, 
    backdropFilter: 'blur(4px)', width: '100%', justifyContent: 'center'
  };

  return (
    <div 
      key={selectedRole}
      style={{ 
        display: 'flex', flexDirection: 'column', height: '100%', 
        backgroundColor: '#0d1117',
        // [ìˆ˜ì •] ë°°ê²½ ì´ë¯¸ì§€ ì ìš© ë¶€ë¶„
        backgroundImage: displayBg ? `linear-gradient(to bottom, rgba(13,17,23,0.5), rgba(13,17,23,0.95)), url(${displayBg})` : 'none',
        backgroundSize: 'cover', backgroundPosition: 'center top', position: 'relative'
      }}
    >

      {/* 0. ìƒë‹¨ íƒ­ ë„¤ë¹„ê²Œì´ì…˜ */}
      <div style={{ 
        padding: '10px 15px', borderBottom: '1px solid rgba(255,255,255,0.1)', 
        background: 'rgba(22, 27, 34, 0.8)', backdropFilter: 'blur(10px)',
        display: 'flex', gap: '10px', overflowX: 'auto', whiteSpace: 'nowrap',
        flexShrink: 0, zIndex: 10
      }}>
        {Object.entries(ROLE_DATA).map(([key, info]) => {
          const role = key as Role;
          const isSelected = selectedRole === role;
          return (
            <button key={role} onClick={() => onSelectRole(role)}
              style={{ 
                flex: 1, minWidth: isMobile ? '70px' : '100px',
                background: isSelected ? info.color : 'rgba(255,255,255,0.05)', 
                color: isSelected ? '#000' : '#ccc',
                border: '1px solid', borderColor: isSelected ? info.color : 'transparent',
                borderRadius: '6px', padding: '10px 0', cursor: 'pointer',
                display: 'flex', alignItems: 'center', justifyContent:'center', gap: '6px',
                transition: '0.2s', fontWeight: '800', fontSize:'12px'
              }}
            >
              {React.createElement(info.icon, { size: 14 })} {role}
            </button>
          );
        })}
      </div>

      {/* 1. ì—­í• êµ° ì„¤ëª… í—¤ë” */}
      <div style={{ 
        padding: isMobile ? '15px' : '30px', 
        display: 'flex', flexDirection: isMobile ? 'column' : 'row', 
        gap: isMobile ? '15px' : '30px', alignItems: 'flex-start', 
        background: `linear-gradient(180deg, ${roleInfo.color}11 0%, transparent 100%)`,
        flexShrink: 0, position: 'relative'
      }}>

        <div style={{ display:'flex', gap:'20px', width: isMobile ? '100%' : 'auto', alignItems:'center' }}>
          <div style={{ position: 'relative' }} onMouseEnter={() => setIsHovered(true)} onMouseLeave={() => setIsHovered(false)}>
            <div onClick={() => iconInputRef.current?.click()} style={{ cursor: 'pointer', display: 'block' }}>
              <GameIcon id={roleId} size={isMobile ? 60 : 100} fallback={React.createElement(roleInfo.icon, { size: isMobile ? 30 : 50, color: roleInfo.color })} border={`2px solid ${roleInfo.color}`} shape="rounded" />
              <div style={{ position: 'absolute', inset: 0, borderRadius: '12px', background: 'rgba(0,0,0,0.5)', display: isHovered ? 'flex' : 'none', alignItems: 'center', justifyContent: 'center', transition: '0.2s' }}>
                <Camera size={24} color="#fff" />
              </div>
            </div>
          </div>
          {isMobile && (
             <div style={{ flex: 1 }}>
                <h2 style={{ margin: 0, color: '#fff', fontSize: '24px', fontWeight: '900', textShadow: '0 2px 10px rgba(0,0,0,0.8)' }}>{selectedRole}</h2>
                <span style={{ fontSize: '12px', color: roleInfo.color, fontWeight: 'bold', background: 'rgba(0,0,0,0.6)', padding: '2px 8px', borderRadius: '4px', border: `1px solid ${roleInfo.color}44` }}>{roleInfo.name}</span>
             </div>
          )}
        </div>

        <div style={{ flex: 1, width: '100%' }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
            <div style={{ flex: 1, marginRight: '20px' }}>
              {!isMobile && (
                <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '10px' }}>
                  <h2 style={{ margin: 0, color: '#fff', fontSize: '32px', fontWeight: '900', textShadow: '0 2px 10px rgba(0,0,0,0.8)' }}>{selectedRole}</h2>
                  <span style={{ fontSize: '16px', color: roleInfo.color, fontWeight: 'bold', background: 'rgba(0,0,0,0.6)', padding: '2px 8px', borderRadius: '4px', border: `1px solid ${roleInfo.color}44` }}>{roleInfo.name}</span>
                </div>
              )}
              <div style={{ fontSize: isMobile ? '13px' : '16px', color: '#fff', fontWeight: 'bold', marginBottom: '8px', fontStyle: 'italic', textShadow: '0 1px 3px rgba(0,0,0,0.8)' }}>"{roleInfo.concept}"</div>
              <div style={{ fontSize: '13px', color: '#eee', marginBottom: '15px', lineHeight: '1.5', textShadow: '0 1px 2px rgba(0,0,0,0.8)' }}>{roleInfo.desc}</div>
            </div>
            {!isMobile && (
              <div style={{ display: 'flex', flexDirection: 'column', gap: '8px', minWidth: '140px' }}>
                <button onClick={() => setShowPatchModal(true)} style={actionButtonStyle}><Wrench size={14}/> ë°¸ëŸ°ìŠ¤ íŒ¨ì¹˜</button>
                <button onClick={() => iconInputRef.current?.click()} style={actionButtonStyle}><Camera size={14}/> í”„ë¡œí•„ ë³€ê²½</button>
                <button onClick={() => bgInputRef.current?.click()} style={actionButtonStyle}><ImageIcon size={14}/> ë°°ê²½ ë³€ê²½</button>
              </div>
            )}
          </div>

          <div style={{ display: 'grid', gridTemplateColumns: isMobile ? '1fr' : '1fr 1fr', gap: '10px' }}>
            <div style={{ background: 'rgba(28, 28, 31, 0.7)', padding: '12px', borderRadius: '8px', border: '1px solid rgba(255,255,255,0.1)', backdropFilter:'blur(4px)' }}>
              <div style={{ fontSize: '11px', color: '#58a6ff', fontWeight: 'bold', marginBottom: '4px' }}>ê³ ìœ  íŠ¹ì„± : {roleInfo.traitName}</div>
              <div style={{ fontSize: '12px', color: '#fff', lineHeight: '1.4' }}>{getDynamicTraitText(selectedRole)}</div>
            </div>
            <div style={{ background: 'rgba(28, 28, 31, 0.7)', padding: '12px', borderRadius: '8px', border: '1px solid rgba(255,255,255,0.1)', backdropFilter:'blur(4px)' }}>
              <div style={{ fontSize: '11px', color: '#da3633', fontWeight: 'bold', marginBottom: '4px' }}>ì‹œë®¬ë ˆì´ì…˜ ë°˜ì˜</div>
              <div style={{ fontSize: '12px', color: '#ccc', lineHeight: '1.4' }}>{roleInfo.simEffect}</div>
            </div>
          </div>

          {isMobile && (
            <div style={{ marginTop: '15px', display: 'flex', gap: '8px' }}>
              <button onClick={() => setShowPatchModal(true)} style={{...actionButtonStyle, flex:1 }}><Wrench size={14}/> íŒ¨ì¹˜</button>
              <button onClick={() => iconInputRef.current?.click()} style={{...actionButtonStyle, flex:1 }}><Camera size={14}/> í”„ë¡œí•„</button>
              <button onClick={() => bgInputRef.current?.click()} style={{...actionButtonStyle, flex:1 }}><ImageIcon size={14}/> ë°°ê²½</button>
            </div>
          )}
        </div>
      </div>

      <input type="file" ref={iconInputRef} style={{ display: 'none' }} accept="image/*" onChange={handleIconUpload} />
      <input type="file" ref={bgInputRef} style={{ display: 'none' }} accept="image/*" onChange={handleBgUpload} />

      {roleStats && (
        <div style={{ background: 'rgba(18, 20, 24, 0.85)', borderBottom: '1px solid #30363d', borderTop: '1px solid rgba(255,255,255,0.1)', padding: '15px 20px', backdropFilter: 'blur(5px)', display: 'flex', flexDirection: isMobile ? 'column' : 'row', alignItems: 'center', justifyContent:'space-between', gap:'15px' }}>
          <div style={{ display:'flex', alignItems:'center', gap:'8px', color:'#fff', fontWeight:'bold', fontSize:'14px' }}>
            <Activity size={16} color={roleInfo.color}/> <span style={{ color: roleInfo.color }}>{selectedRole}</span> í†µê³„
          </div>
          <div style={{ display:'flex', gap: isMobile ? '10px' : '25px', flexWrap:'wrap', justifyContent: isMobile ? 'space-between' : 'flex-end', width:'100%' }}>
            <RoleStatItem label="í‰ê·  ìŠ¹ë¥ " value={`${roleStats.avgWinRate.toFixed(1)}%`} color={roleStats.avgWinRate >= 50 ? '#ff4d4d' : '#8b949e'} icon={<TrendingUp size={12}/>} />
            <RoleStatItem label="í‰ê·  KDA" value={`${roleStats.avgKda}:1`} color="#fff" icon={<Skull size={12}/>} />
            <RoleStatItem label="ë¶„ë‹¹ ê³¨ë“œ" value={roleStats.avgGold} color="#e89d40" icon={<Coins size={12}/>} />
            <RoleStatItem label="ë¶„ë‹¹ ë°ë¯¸ì§€" value={roleStats.avgDpm} color="#da3633" icon={<Swords size={12}/>} />
            <RoleStatItem label="í‰ê·  CS" value={roleStats.avgCs} color="#ccc" icon={<Target size={12}/>} />
          </div>
        </div>
      )}

      <div style={{ flex: 1, overflowY: 'auto', paddingBottom: '80px', background: 'rgba(13, 17, 23, 0.6)', backdropFilter: 'blur(3px)' }}>
        {isMobile ? (
          <div style={{ padding: '10px', display: 'flex', flexDirection: 'column', gap: '8px' }}>
            {laneHeroes.map((hero, idx) => (
              <div 
                key={hero.id} 
                onClick={() => onHeroClick && onHeroClick(hero)} // [ì¶”ê°€] í´ë¦­ ì—°ê²°
                style={{ background: 'rgba(22, 27, 34, 0.85)', border: '1px solid rgba(48, 54, 61, 0.8)', borderRadius: '12px', padding: '12px 15px', display: 'flex', alignItems: 'center', justifyContent: 'space-between', cursor: 'pointer' }}
              >
                <div style={{ display: 'flex', alignItems: 'center', gap: '15px', flex: 1 }}>
                  <div style={{ fontSize: '16px', fontWeight: '900', fontStyle: 'italic', color: idx < 3 ? '#e74c3c' : '#666', width: '20px', textAlign: 'center' }}>{idx + 1}</div>
                  <GameIcon id={hero.id} size={42} fallback={<span style={{fontSize:'22px'}}>ğŸ§™â€â™‚ï¸</span>} />
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '3px' }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                      <span style={{ fontWeight: 'bold', fontSize: '14px', color: '#fff' }}>{hero.name}</span>
                      <span className={`tier-badge tier-${hero.tier}`} style={{ fontSize: '9px', padding: '2px 5px', height: 'fit-content' }}>{hero.tier}í‹°ì–´</span>
                    </div>
                    <div style={{ fontSize: '11px', color: '#8b949e' }}>
                      <span style={{ color: hero.recentWinRate >= 50 ? '#ff4d4d' : '#8b949e', fontWeight: 'bold' }}>ìŠ¹ë¥  {hero.recentWinRate.toFixed(1)}%</span>
                      <span style={{ margin: '0 4px', opacity: 0.3 }}>â€¢</span>
                      <span>í”½ë¥  {hero.pickRate.toFixed(1)}%</span>
                    </div>
                  </div>
                </div>
                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-end', gap: '2px', minWidth: '80px' }}>
                  <div style={{ fontWeight: 'bold', fontSize: '12px', color: '#fff' }}>{hero.avgKda}</div>
                  <div style={{ fontSize: '10px', color: '#e89d40', fontWeight:'bold' }}>{hero.avgGold} G</div>
                  <div style={{ fontSize: '9px', color: '#888', display:'flex', gap:'6px', marginTop:'2px' }}>
                    <span>CS {hero.avgCs}</span>
                    <span style={{ color: '#da3633' }}>{hero.avgDpm}</span>
                  </div>
                </div>
              </div>
            ))}
            {laneHeroes.length === 0 && <div style={{ padding: '40px', textAlign: 'center', color: '#ccc' }}>ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>}
          </div>
        ) : (
          <>
            <div style={{ display: 'grid', gridTemplateColumns: '40px 140px 100px 120px 140px 100px 80px 1fr', padding: '10px 20px', background: 'rgba(28, 28, 31, 0.95)', fontSize: '11px', color: '#8b949e', fontWeight: 'bold', textAlign: 'center', borderBottom: '1px solid #30363d', position:'sticky', top:0 }}>
              <div>#</div>
              <div style={{ textAlign: 'left', paddingLeft: '10px' }}>ì±”í”¼ì–¸</div>
              <div>ìŠ¹ë¥ </div>
              <div>í”½ë¥  / ë°´ë¥ </div>
              <div>KDA (í‚¬/ëƒ/ì–´)</div>
              <div><Target size={10} style={{ display: 'inline' }} /> CS</div>
              <div><Swords size={10} style={{ display: 'inline' }} /> DPM</div>
              <div><Coins size={10} style={{ display: 'inline' }} /> GOLD</div>
            </div>
            <div>
              {laneHeroes.map((hero, idx) => (
                <div key={hero.id} onClick={() => onHeroClick && onHeroClick(hero)} style={{ display: 'grid', gridTemplateColumns: '40px 140px 100px 120px 140px 100px 80px 1fr', padding: '10px 20px', borderBottom: '1px solid rgba(255,255,255,0.05)', alignItems: 'center', fontSize: '12px', color: '#ccc', textAlign: 'center', background: 'rgba(22, 27, 34, 0.6)', cursor: 'pointer' }}>
                  <div style={{ fontWeight: 'bold', color: '#aaa' }}>{idx + 1}</div>
                  <div style={{ textAlign: 'left', paddingLeft: '10px', display: 'flex', alignItems: 'center', gap: '8px' }}>
                    <GameIcon id={hero.id} size={32} fallback={<span style={{fontSize:'16px'}}>ğŸ§™â€â™‚ï¸</span>} />
                    <div style={{ display: 'flex', flexDirection: 'column' }}>
                      <span style={{ fontWeight: 'bold', color: '#fff' }}>{hero.name}</span>
                      <span className={`tier-badge tier-${hero.tier}`} style={{ marginLeft: 0, width: 'fit-content' }}>{hero.tier}í‹°ì–´</span>
                    </div>
                  </div>
                  <div style={{ fontWeight: 'bold', color: hero.recentWinRate >= 50 ? '#ff4d4d' : '#4d94ff' }}>{hero.recentWinRate.toFixed(1)}%</div>
                  <div style={{ fontSize: '11px', color: '#ccc' }}>
                    <span style={{ color: '#fff' }}>{hero.pickRate.toFixed(1)}%</span> <span style={{ color: '#888' }}>|</span> <span style={{ color: '#da3633' }}>{hero.banRate.toFixed(1)}%</span>
                  </div>
                  <div>
                    <span style={{ color: '#fff', fontWeight: 'bold', fontSize: '11px' }}>{hero.avgKda}</span>
                    <span style={{ display:'block', fontSize:'10px', color:'#888' }}>({hero.kdaRatio}:1)</span>
                  </div>
                  <div style={{ fontFamily: 'monospace', color: '#ccc' }}>{hero.avgCs}</div>
                  <div style={{ fontFamily: 'monospace', color: '#da3633' }}>{hero.avgDpm}</div>
                  <div style={{ fontFamily: 'monospace', color: '#f1c40f' }}>{hero.avgGold}</div>
                </div>
              ))}
            </div>
          </>
        )}
      </div>

      {showPatchModal && <RolePatchModal role={selectedRole} onClose={() => setShowPatchModal(false)} />}
    </div>
  );
};

const RoleStatItem = ({ label, value, color, icon }: any) => (
  <div style={{ display:'flex', flexDirection:'column', alignItems:'flex-end' }}>
    <span style={{ fontSize:'10px', color:'#ccc', marginBottom:'2px', display:'flex', alignItems:'center', gap:'4px' }}>
      {icon} {label}
    </span>
    <span style={{ fontSize:'14px', fontWeight:'bold', color: color, fontFamily:'monospace' }}>
      {value}
    </span>
  </div>
);


==========================================
FILE PATH: src/components/hero/PatchModal.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/hero/PatchModal.tsx
// ==========================================

import React, { useState, useEffect } from 'react';
import { Hero, HeroStats, HeroSkillSet } from '../../types';
import { useGameStore } from '../../store/useGameStore';
import { X, Save, Sliders, Zap, Swords, Shield } from 'lucide-react';
import { GameIcon } from '../common/GameIcon';

import { SkillEditor } from './patch/SkillEditor';
import { StatEditor } from './patch/StatEditor';

interface Props { hero: Hero | null; onClose: () => void; }

export const PatchModal: React.FC<Props> = ({ hero, onClose }) => {
  const { updateHero } = useGameStore();
  const [activeTab, setActiveTab] = useState<'skill' | 'combat' | 'basic'>('skill');

  const [stats, setStats] = useState<HeroStats | null>(null);
  const [skills, setSkills] = useState<HeroSkillSet | null>(null);

  useEffect(() => {
    if (hero) {
      setStats(JSON.parse(JSON.stringify(hero.stats)));
      setSkills(JSON.parse(JSON.stringify(hero.skills)));
    }
  }, [hero]);

  if (!hero || !stats || !skills) return null;

  const handleSave = () => {
    const r = hero.record;
    
    // 1. ê³¼ê±° ê¸°ë¡ ì••ì¶• (Soft Reset) - ê¸°ì¡´ ë°ì´í„°ì˜ 20% ë¹„ì¤‘ë§Œ ë‚¨ê¹€
    const COMPRESSION_RATIO = 0.2; 
    const newTotalMatches = Math.max(100, Math.floor(r.totalMatches * COMPRESSION_RATIO));
    
    // ê¸°ì¡´ ìŠ¹ë¥  ìœ ì§€
    const winRate = r.totalMatches > 0 ? r.totalWins / r.totalMatches : 0.5;
    const newTotalWins = Math.floor(newTotalMatches * winRate);

    // 2. [í•µì‹¬ ìˆ˜ì •] ìµœê·¼ ì „ì (Trend)ì— ê°€ìƒ ë°ì´í„° ì£¼ì…
    // ë¹ˆ ë°°ì—´([])ë¡œ ë‘ë©´ ìŠ¹ë¥ ì´ 50%ë¡œ íŠ€ì–´ë²„ë¦¬ë¯€ë¡œ, ê¸°ì¡´ ìŠ¹ë¥  íŒ¨í„´ì„ ë°˜ì˜í•œ ë”ë¯¸ ë°ì´í„° 20ê°œë¥¼ ë„£ìŒ
    const newRecentResults: boolean[] = [];
    for (let i = 0; i < 20; i++) {
        // winRate í™•ë¥ ë¡œ ìŠ¹ë¦¬(true) ì£¼ì…
        newRecentResults.push(Math.random() < winRate);
    }

    const updatedRecord = {
        ...r,
        totalMatches: newTotalMatches,
        totalWins: newTotalWins,
        // í”½/ë°´ ë“± ê¸°íƒ€ í†µê³„ë„ ì••ì¶•
        totalPicks: Math.floor(r.totalPicks * COMPRESSION_RATIO),
        totalBans: Math.floor(r.totalBans * COMPRESSION_RATIO),
        totalDamage: r.totalDamage * COMPRESSION_RATIO,
        totalDamageTaken: r.totalDamageTaken * COMPRESSION_RATIO,
        totalCs: r.totalCs * COMPRESSION_RATIO,
        totalGold: r.totalGold * COMPRESSION_RATIO,
        totalKills: r.totalKills * COMPRESSION_RATIO,
        totalDeaths: r.totalDeaths * COMPRESSION_RATIO,
        totalAssists: r.totalAssists * COMPRESSION_RATIO,
        
        recentResults: newRecentResults
    };

    updateHero(hero.id, { stats, skills, record: updatedRecord });
    
    alert(`[${hero.name}] íŒ¨ì¹˜ ì™„ë£Œ!\ní†µê³„ê°€ ì†Œí”„íŠ¸ ë¦¬ì…‹ë˜ì–´ ìŠ¹ë¥  ë³€í™”ê°€ ì¦‰ê° ë°˜ì˜ë©ë‹ˆë‹¤.`);
    onClose();
  };

  const handleStatChange = (field: string, value: number) => {
    setStats(prev => prev ? ({ ...prev, [field]: value }) : null);
  };

  const handleSkillChange = (key: string, field: string, value: any) => {
    setSkills(prev => {
      if (!prev) return null;
      return {
        ...prev,
        [key]: { ...prev[key as keyof HeroSkillSet], [field]: value }
      };
    });
  };

  const TabButton = ({ id, label, icon }: any) => (
    <button 
      onClick={() => setActiveTab(id)} 
      style={{ 
        flex: 1, padding: '12px', background: activeTab === id ? '#1f242e' : 'transparent', 
        border: 'none', borderBottom: activeTab === id ? '2px solid #58a6ff' : '1px solid #30363d', 
        color: activeTab === id ? '#58a6ff' : '#8b949e', fontWeight: 'bold', cursor: 'pointer',
        display:'flex', alignItems:'center', justifyContent:'center', gap:'6px', fontSize:'13px',
        transition: '0.2s'
      }}
    >
      {icon} {label}
    </button>
  );

  return (
    <div className="modal-overlay" onClick={onClose} style={{ 
      position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.85)', 
      display: 'flex', justifyContent: 'center', alignItems: 'center', 
      zIndex: 9999, backdropFilter: 'blur(5px)', padding:'20px'
    }}>
      <div onClick={e => e.stopPropagation()} style={{ 
        width: '100%', maxWidth: '500px', maxHeight: '90vh', display: 'flex', flexDirection: 'column',
        background: '#161b22', borderRadius: '16px', border: '1px solid #30363d', 
        overflow: 'hidden', boxShadow: '0 20px 60px rgba(0,0,0,0.6)'
      }}>
        <div style={{ padding: '15px 20px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', background: '#21262d', borderBottom: '1px solid #30363d' }}>
          <div style={{ display: 'flex', alignItems: 'center', gap: '15px' }}>
            <GameIcon id={hero.id} size={44} shape="rounded" />
            <div>
              <div style={{ display:'flex', alignItems:'center', gap:'6px' }}>
                <h3 style={{ margin: 0, fontSize: '16px', color: '#fff' }}>{hero.name}</h3>
                <span style={{ fontSize:'10px', background:'#30363d', padding:'2px 6px', borderRadius:'4px', color:'#ccc' }}>{hero.role}</span>
              </div>
              <div style={{ fontSize: '12px', color: '#58a6ff', marginTop:'2px', display:'flex', alignItems:'center', gap:'4px' }}>
                <Sliders size={12}/> ë°¸ëŸ°ìŠ¤ ì¡°ì • ì¤‘...
              </div>
            </div>
          </div>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#888', cursor: 'pointer', padding:'5px' }}><X size={24}/></button>
        </div>
        <div style={{ display: 'flex', background: '#0d1117' }}>
          <TabButton id="skill" label="ìŠ¤í‚¬" icon={<Zap size={14}/>} />
          <TabButton id="combat" label="ì „íˆ¬" icon={<Swords size={14}/>} />
          <TabButton id="basic" label="ê¸°ë³¸" icon={<Shield size={14}/>} />
        </div>
        <div style={{ flex: 1, overflowY: 'auto', padding: '20px' }}>
          {activeTab === 'skill' && <SkillEditor skills={skills} onChange={handleSkillChange} />}
          {activeTab === 'combat' && <StatEditor fields={['baseAtk', 'ad', 'ap', 'crit', 'pen', 'range']} stats={stats} onChange={handleStatChange} />}
          {activeTab === 'basic' && <StatEditor fields={['hp', 'mp', 'armor', 'regen', 'mpRegen', 'speed']} stats={stats} onChange={handleStatChange} />}
        </div>
        <div style={{ padding: '15px 20px', background: '#21262d', borderTop: '1px solid #30363d' }}>
          <button onClick={handleSave} style={{ 
            width: '100%', padding: '12px', background: '#238636', border: 'none', 
            borderRadius: '8px', color: '#fff', fontWeight: 'bold', fontSize:'14px',
            cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px',
            boxShadow: '0 4px 12px rgba(35, 134, 54, 0.2)'
          }}>
            <Save size={18}/> íŒ¨ì¹˜ ì ìš© (í†µê³„ ë³´ì •ë¨)
          </button>
        </div>
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/hero/patch/SkillEditor.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/hero/patch/SkillEditor.tsx
// ==========================================
import React, { useState } from 'react';
import { HeroSkillSet } from '../../../types';
import { Edit2, Check } from 'lucide-react';

const MECHANIC_UI_CONFIG: any = {
  DAMAGE: [
    { key: 'val', label: 'í”¼í•´ëŸ‰', max: 1000, step: 10 }, 
    { key: 'adRatio', label: 'ADê³„ìˆ˜', max: 2.5, step: 0.05, color: '#e67e22' }, 
    { key: 'apRatio', label: 'APê³„ìˆ˜', max: 3.0, step: 0.05, color: '#9b59b6' },
    { key: 'cost', label: 'ë§ˆë‚˜ ì†Œëª¨', max: 300, step: 5, color: '#3498db' },
    { key: 'cd', label: 'ì¿¨íƒ€ì„', max: 180, step: 1, color: '#bdc3c7' }
  ],
  HEAL: [
    { key: 'val', label: 'íšŒë³µëŸ‰', max: 800, step: 10, color: '#2ecc71' }, 
    { key: 'apRatio', label: 'APê³„ìˆ˜', max: 2.0, step: 0.05, color: '#9b59b6' },
    { key: 'cost', label: 'ë§ˆë‚˜ ì†Œëª¨', max: 300, step: 5, color: '#3498db' },
    { key: 'cd', label: 'ì¿¨íƒ€ì„', max: 180, step: 1, color: '#bdc3c7' }
  ],
  SHIELD: [
    { key: 'val', label: 'ë³´í˜¸ë§‰', max: 1000, step: 10, color: '#3498db' }, 
    { key: 'adRatio', label: 'ADê³„ìˆ˜', max: 1.5, step: 0.05, color: '#e67e22' }, 
    { key: 'duration', label: 'ì§€ì†ì‹œê°„', max: 8, step: 0.5 },
    { key: 'cost', label: 'ë§ˆë‚˜ ì†Œëª¨', max: 300, step: 5, color: '#3498db' },
    { key: 'cd', label: 'ì¿¨íƒ€ì„', max: 180, step: 1, color: '#bdc3c7' }
  ],
  HOOK: [
    { key: 'val', label: 'ê·¸ë©ê±°ë¦¬', max: 1200, step: 25, color: '#f1c40f' }, 
    { key: 'duration', label: 'ê¸°ì ˆì‹œê°„', max: 3, step: 0.1 },
    { key: 'cost', label: 'ë§ˆë‚˜ ì†Œëª¨', max: 300, step: 5, color: '#3498db' },
    { key: 'cd', label: 'ì¿¨íƒ€ì„', max: 180, step: 1, color: '#bdc3c7' }
  ],
  DASH: [
    { key: 'val', label: 'ì´ë™ê±°ë¦¬', max: 800, step: 10, color: '#9b59b6' }, 
    { key: 'duration', label: 'ì¤€ë¹„ì‹œê°„', max: 1.5, step: 0.05 },
    { key: 'cost', label: 'ë§ˆë‚˜ ì†Œëª¨', max: 300, step: 5, color: '#3498db' },
    { key: 'cd', label: 'ì¿¨íƒ€ì„', max: 180, step: 1, color: '#bdc3c7' }
  ],
  STUN: [
    { key: 'duration', label: 'ê¸°ì ˆì‹œê°„', max: 4, step: 0.1, color: '#e74c3c' }, 
    { key: 'val', label: 'ë²”ìœ„', max: 600, step: 10 },
    { key: 'cost', label: 'ë§ˆë‚˜ ì†Œëª¨', max: 300, step: 5, color: '#3498db' },
    { key: 'cd', label: 'ì¿¨íƒ€ì„', max: 180, step: 1, color: '#bdc3c7' }
  ],
  STEALTH: [
    { key: 'duration', label: 'ì§€ì†ì‹œê°„', max: 15, step: 0.5, color: '#95a5a6' }, 
    { key: 'val', label: 'ì´ì†ì¦ê°€', max: 80, step: 1 },
    { key: 'cost', label: 'ë§ˆë‚˜ ì†Œëª¨', max: 300, step: 5, color: '#3498db' },
    { key: 'cd', label: 'ì¿¨íƒ€ì„', max: 180, step: 1, color: '#bdc3c7' }
  ],
  EXECUTE: [
    { key: 'val', label: 'ê¸°ë³¸í”¼í•´', max: 1000, step: 10, color: '#da3633' },
    { key: 'adRatio', label: 'ADê³„ìˆ˜', max: 3.0, step: 0.1, color: '#e67e22' },
    { key: 'cost', label: 'ë§ˆë‚˜ ì†Œëª¨', max: 300, step: 5, color: '#3498db' },
    { key: 'cd', label: 'ì¿¨íƒ€ì„', max: 200, step: 1, color: '#bdc3c7' }
  ],
  GLOBAL: [
    { key: 'val', label: 'í”¼í•´/í', max: 1000, step: 10, color: '#f1c40f' },
    { key: 'apRatio', label: 'APê³„ìˆ˜', max: 3.0, step: 0.1, color: '#9b59b6' },
    { key: 'duration', label: 'ì§€ì†ì‹œê°„', max: 10, step: 0.5 },
    { key: 'cost', label: 'ë§ˆë‚˜ ì†Œëª¨', max: 300, step: 5, color: '#3498db' },
    { key: 'cd', label: 'ì¿¨íƒ€ì„', max: 300, step: 5, color: '#bdc3c7' }
  ]
};

interface Props {
  skills: HeroSkillSet;
  onChange: (key: string, field: string, value: any) => void;
}

export const SkillEditor: React.FC<Props> = ({ skills, onChange }) => {
  const [selectedKey, setSelectedKey] = useState<keyof HeroSkillSet>('passive');
  const [activeField, setActiveField] = useState<string | null>(null);
  const [isEditingName, setIsEditingName] = useState(false);

  if (!skills) {
    return <div style={{ color: '#fff', padding: '20px' }}>{"ìŠ¤í‚¬ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."}</div>;
  }

  const currentSkill = skills[selectedKey];
  const uiConfig = MECHANIC_UI_CONFIG[currentSkill.mechanic] || MECHANIC_UI_CONFIG.DAMAGE;

  const currentStatValue = activeField ? (currentSkill as any)[activeField] : 0;
  const currentConfig = activeField ? uiConfig.find((c: any) => c.key === activeField) : null;
  const currentMax = currentConfig?.max || 1000;
  const currentStep = currentConfig?.step || 1;
  const currentLabel = currentConfig?.label || '';

  return (
    <div className="skill-editor">
      <div style={{ display: 'flex', gap: '6px', marginBottom: '20px' }}>
        {(['passive', 'q', 'w', 'e', 'r'] as const).map(k => (
          <button 
            key={k} 
            onClick={() => {setSelectedKey(k); setActiveField(null);}} 
            style={{ 
              flex: 1, padding: '10px', 
              background: selectedKey === k ? '#30363d' : '#161b22', 
              border: '1px solid #30363d', borderRadius: '10px', 
              color: selectedKey === k ? '#fff' : '#8b949e', fontWeight: 'bold', cursor: 'pointer',
              transition: 'all 0.2s'
            }}
          >
            {k === 'passive' ? 'P' : k.toUpperCase()}
          </button>
        ))}
      </div>

      <div style={{ marginBottom: '15px', padding: '12px', background: '#161b22', borderRadius: '12px', border: '1px solid #30363d' }}>
        {isEditingName ? (
          <div style={{ display: 'flex', gap: '8px' }}>
            <input 
              value={currentSkill.name} 
              onChange={e => onChange(selectedKey, 'name', e.target.value)} 
              onBlur={() => setIsEditingName(false)} 
              autoFocus 
              style={{ background: '#000', border: '1px solid #58a6ff', color: '#fff', padding: '5px', flex: 1, outline: 'none', borderRadius:'4px' }} 
            />
            <Check size={16} color="#2ecc71" onClick={() => setIsEditingName(false)} style={{ cursor: 'pointer' }} />
          </div>
        ) : (
          <div onClick={() => setIsEditingName(true)} style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer' }}>
            <span style={{ fontSize: '10px', color: '#8b949e', fontWeight: 'bold' }}>{selectedKey.toUpperCase()}</span>
            <span style={{ fontWeight: 'bold', flex: 1, color: '#fff' }}>{currentSkill.name}</span>
            <Edit2 size={12} color="#58a6ff" />
          </div>
        )}
      </div>

      <select 
        value={currentSkill.mechanic} 
        onChange={e => onChange(selectedKey, 'mechanic', e.target.value)} 
        style={{ width: '100%', padding: '10px', background: '#161b22', border: '1px solid #30363d', color: '#fff', borderRadius: '10px', marginBottom: '15px', outline:'none', cursor:'pointer' }}
      >
        <option value="DAMAGE">âš”ï¸ í”¼í•´ (DAMAGE)</option>
        <option value="HEAL">ğŸ’š íšŒë³µ (HEAL)</option>
        <option value="SHIELD">ğŸ›¡ï¸ ë³´í˜¸ë§‰ (SHIELD)</option>
        <option value="HOOK">ğŸª ê·¸ë© (HOOK)</option>
        <option value="DASH">ğŸ’¨ ì´ë™ (DASH)</option>
        <option value="STUN">ğŸ’« ê¸°ì ˆ (STUN)</option>
        <option value="STEALTH">ğŸ‘» ì€ì‹  (STEALTH)</option>
        <option value="EXECUTE">ğŸ©¸ ì²˜í˜• (EXECUTE)</option>
        <option value="GLOBAL">ğŸŒ ê¸€ë¡œë²Œ (GLOBAL)</option>
      </select>

      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px', marginBottom: '15px' }}>
        {uiConfig.map((item: any) => (
          <div 
            key={item.key} 
            onClick={() => setActiveField(item.key)} 
            style={{ 
              background: '#161b22', 
              border: activeField === item.key ? '1px solid #58a6ff' : '1px solid #30363d', 
              borderRadius: '10px', padding: '10px', 
              textAlign: 'center', cursor: 'pointer',
              transition: 'all 0.2s'
            }}
          >
            <label style={{ display: 'block', fontSize: '10px', color: '#8b949e', marginBottom: '4px' }}>{item.label}</label>
            <div style={{ fontSize: '15px', fontWeight: 'bold', color: item.color || '#fff' }}>
              {(currentSkill as any)[item.key] ?? 0}
              {item.key === 'cd' ? 'ì´ˆ' : ''}
            </div>
          </div>
        ))}
      </div>

      {activeField && (
        <div style={{ background: '#161b22', padding: '15px', borderRadius: '12px', border: '1px solid #58a6ff44', animation: 'fadeIn 0.2s' }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '10px' }}>
            <span style={{ color: '#aaa', fontSize: '12px', fontWeight:'bold' }}>
              {currentLabel} ì¡°ì ˆ
            </span>
            <strong style={{ color: '#58a6ff', fontSize:'14px' }}>
              {currentStatValue}
            </strong>
          </div>
          <input 
            type="range" 
            min={0} 
            max={currentMax}
            step={currentStep}
            value={currentStatValue || 0} 
            onChange={e => onChange(selectedKey, activeField!, Number(e.target.value))}
            style={{ width: '100%', accentColor: '#58a6ff', height:'6px', cursor:'pointer' }}
          />
          <div style={{ display:'flex', justifyContent:'flex-end', gap:'10px', marginTop:'10px' }}>
             <button 
               onClick={() => onChange(selectedKey, activeField!, Math.max(0, Number(currentStatValue || 0) - currentStep))} 
               style={{background:'#30363d', border:'none', color:'#fff', padding:'5px 10px', borderRadius:'4px', cursor:'pointer'}}
             >
               -
             </button>
             <button 
               onClick={() => onChange(selectedKey, activeField!, Number(currentStatValue || 0) + currentStep)} 
               style={{background:'#30363d', border:'none', color:'#fff', padding:'5px 10px', borderRadius:'4px', cursor:'pointer'}}
             >
               +
             </button>
          </div>
        </div>
      )}
      <style>{`
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
      `}</style>
    </div>
  );
};


==========================================
FILE PATH: src/components/hero/patch/StatEditor.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/hero/patch/StatEditor.tsx
// ==========================================
import React, { useState } from 'react';
import { Sliders } from 'lucide-react';

// [ìˆ˜ì •] ìŠ¤íƒ¯ ì„¤ì • í™•ì¥ (ë§ˆë‚˜, ì¬ìƒ, ê´€í†µë ¥ ì¶”ê°€)
const STAT_CONFIG: any = {
  baseAtk: { min: 0, max: 200, step: 1, color: '#777', label: 'ê¸°ë³¸ ê³µê²©ë ¥', unit: '' },
  ad: { min: 0, max: 1000, step: 1, color: '#e67e22', label: 'ì¶”ê°€ AD (ê³„ìˆ˜ìš©)', unit: '' },
  ap: { min: 0, max: 1000, step: 1, color: '#9b59b6', label: 'ì£¼ë¬¸ë ¥(AP)', unit: '' },
  crit: { min: 0, max: 100, step: 1, color: '#e74c3c', label: 'ì¹˜ëª…íƒ€ìœ¨', unit: '%' },
  range: { min: 1, max: 1000, step: 5, color: '#ccc', label: 'ê³µê²© ì‚¬ê±°ë¦¬', unit: '' },
  pen: { min: 0, max: 100, step: 1, color: '#da3633', label: 'ë°©ì–´ ê´€í†µë ¥', unit: '' },

  hp: { min: 1, max: 5000, step: 10, color: '#2ecc71', label: 'ì²´ë ¥(HP)', unit: '' },
  mp: { min: 0, max: 2000, step: 10, color: '#3498db', label: 'ë§ˆë‚˜(MP)', unit: '' },
  regen: { min: 0, max: 100, step: 1, color: '#27ae60', label: 'ì²´ë ¥ ì¬ìƒ', unit: '/s' },
  mpRegen: { min: 0, max: 50, step: 1, color: '#2980b9', label: 'ë§ˆë‚˜ ì¬ìƒ', unit: '/s' },
  armor: { min: 0, max: 300, step: 1, color: '#3498db', label: 'ë°©ì–´ë ¥', unit: '' },
  speed: { min: 100, max: 600, step: 5, color: '#f1c40f', label: 'ì´ë™ ì†ë„', unit: '' }
};

interface Props {
  fields: string[];
  stats: any;
  onChange: (field: string, value: number) => void;
}

export const StatEditor: React.FC<Props> = ({ fields, stats, onChange }) => {
  const [activeField, setActiveField] = useState<string | null>(null);

  const currentStatValue = activeField ? stats[activeField] : 0;
  const currentConfig = activeField ? STAT_CONFIG[activeField] : null;

  const currentMax = currentConfig?.max || 1000;
  const currentStep = currentConfig?.step || 1;
  const currentLabel = currentConfig?.label || '';
  const currentUnit = currentConfig?.unit || '';
  const currentColor = currentConfig?.color || '#fff';

  return (
    <div className="stat-editor">

      {/* 1. ìŠ¤íƒ¯ ì¹´ë“œ ê·¸ë¦¬ë“œ */}
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '8px', marginBottom: '20px' }}>
        {fields.map(f => {
          const conf = STAT_CONFIG[f];
          if (!conf) return null;

          const isActive = activeField === f;
          const val = stats[f] !== undefined ? stats[f] : 0;

          return (
            <div 
              key={f} 
              onClick={() => setActiveField(f)}
              style={{ 
                background: isActive ? '#1f242e' : '#161b22', 
                border: isActive ? `2px solid ${conf.color}` : '1px solid #30363d', 
                borderRadius: '8px', padding: '10px 5px', 
                textAlign: 'center', cursor: 'pointer',
                transition: 'all 0.2s',
              }}
            >
              <div style={{ fontSize: '10px', color: isActive ? conf.color : '#8b949e', marginBottom: '2px', fontWeight:'bold', whiteSpace:'nowrap' }}>
                {conf.label}
              </div>
              <div style={{ fontSize: '14px', fontWeight: '800', color: conf.color }}>
                {val}<span style={{fontSize:'10px', marginLeft:'1px', color:'#666'}}>{conf.unit}</span>
              </div>
            </div>
          );
        })}
      </div>

      {/* 2. ìŠ¬ë¼ì´ë” íŒ¨ë„ */}
      {activeField && currentConfig && (
        <div style={{ 
          background: '#1c1c1f', padding: '20px', borderRadius: '16px', 
          border: `1px solid ${currentColor}`, boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
          animation: 'slideUp 0.2s ease-out'
        }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>
            <div style={{ display:'flex', alignItems:'center', gap:'8px' }}>
              <Sliders size={18} color={currentColor}/>
              <span style={{ color: '#fff', fontSize: '14px', fontWeight:'bold' }}>{currentLabel} ì¡°ì ˆ</span>
            </div>
            <div style={{ fontSize: '24px', fontWeight: '900', color: currentColor }}>
              {currentStatValue}<span style={{fontSize:'14px', color:'#555'}}>{currentUnit}</span>
            </div>
          </div>

          <input 
            type="range" 
            min={currentConfig.min} 
            max={currentMax} 
            step={currentStep}
            value={currentStatValue || 0} 
            onChange={e => onChange(activeField, Number(e.target.value))}
            style={{ width: '100%', accentColor: currentColor, height:'8px', cursor:'pointer', marginBottom:'15px' }}
          />

          <div style={{ display:'grid', gridTemplateColumns:'1fr 1fr 1fr 1fr', gap:'8px' }}>
             <AdjustBtn onClick={() => onChange(activeField, Math.max(currentConfig.min, (currentStatValue||0) - (currentStep*10)))} label={`-${currentStep*10}`} />
             <AdjustBtn onClick={() => onChange(activeField, Math.max(currentConfig.min, (currentStatValue||0) - currentStep))} label={`-${currentStep}`} />
             <AdjustBtn onClick={() => onChange(activeField, Math.min(currentMax, (currentStatValue||0) + currentStep))} label={`+${currentStep}`} />
             <AdjustBtn onClick={() => onChange(activeField, Math.min(currentMax, (currentStatValue||0) + (currentStep*10)))} label={`+${currentStep*10}`} />
          </div>
        </div>
      )}

      <style>{`
        @keyframes slideUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
      `}</style>
    </div>
  );
};

const AdjustBtn = ({ onClick, label }: any) => (
  <button 
    onClick={onClick} 
    style={{
      background:'#21262d', border:'1px solid #30363d', color:'#fff', 
      padding:'12px 0', borderRadius:'8px', cursor:'pointer', fontWeight:'bold',
      fontSize:'14px', transition:'0.1s'
    }}
  >
    {label}
  </button>
);


==========================================
FILE PATH: src/components/hero/RewardSettingModal.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/hero/RewardSettingModal.tsx
// ==========================================
import React, { useState } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { X, Save, Coins, Star, Users, Zap, Skull } from 'lucide-react';
import { RangeInput } from '../battle/ui/PatchInputs';

interface Props { onClose: () => void; }

export const RewardSettingModal: React.FC<Props> = ({ onClose }) => {
  const { gameState, updateBattleSettings } = useGameStore();
  const economy = gameState.battleSettings.economy;
  const [localSettings, setLocalSettings] = useState({ ...economy });

  const handleChange = (field: string, val: number) => {
    setLocalSettings(prev => ({ ...prev, [field]: val }));
  };

  const handleSave = () => {
    updateBattleSettings({ economy: localSettings });
    alert('âœ… ë³´ìƒ ë°¸ëŸ°ìŠ¤ê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.\në‹¤ìŒ í‚¬ë¶€í„° ì¦‰ì‹œ ì ìš©ë©ë‹ˆë‹¤.');
    onClose();
  };

  return (
    <div style={{ position:'fixed', inset:0, background:'rgba(0,0,0,0.85)', zIndex:9999, display:'flex', justifyContent:'center', alignItems:'center', padding:'20px' }}>
      <div style={{ width:'100%', maxWidth:'450px', background:'#161b22', border:'1px solid #30363d', borderRadius:'12px', overflow:'hidden', display:'flex', flexDirection:'column', maxHeight:'90vh' }}>
        
        <div style={{ padding:'15px', background:'#21262d', borderBottom:'1px solid #30363d', display:'flex', justifyContent:'space-between', alignItems:'center' }}>
          <h3 style={{ margin:0, color:'#fff', fontSize:'16px', display:'flex', alignItems:'center', gap:'8px' }}>
            <Coins size={18} color="#f1c40f"/> ë³´ìƒ ë°¸ëŸ°ìŠ¤ ì„¤ì •
          </h3>
          <button onClick={onClose} style={{ background:'none', border:'none', color:'#888', cursor:'pointer', padding:'5px' }}><X size={24}/></button>
        </div>

        <div style={{ padding:'20px', overflowY:'auto', flex:1 }}>
          <div style={{ fontSize:'12px', color:'#888', marginBottom:'20px', background:'#0d1117', padding:'10px', borderRadius:'6px' }}>
            * í‚¬ì„ í•  ë•Œë§ˆë‹¤ ê³¨ë“œì™€ ê²½í—˜ì¹˜ë¥¼ íšë“í•©ë‹ˆë‹¤.<br/>
            * í˜„ìƒê¸ˆì€ ì—°ì† í‚¬ì„ ê¸°ë¡ ì¤‘ì¸ ì ì„ ì²˜ì¹˜í•  ë•Œ ì¶”ê°€ë©ë‹ˆë‹¤.
          </div>

          <div style={{ marginBottom:'10px', fontWeight:'bold', color:'#f1c40f', fontSize:'13px' }}>[ê³¨ë“œ ë³´ìƒ]</div>
          <RangeInput label="ê¸°ë³¸ í‚¬ ê³¨ë“œ" icon={<Coins size={14}/>} value={localSettings.killGold} onChange={(v) => handleChange('killGold', v)} min={100} max={1000} step={10} unit=" G" color="#f1c40f" />
          
          <RangeInput label="ì  ë ˆë²¨ë‹¹ ì¶”ê°€ ê³¨ë“œ" icon={<TrendingUp size={14} />} value={localSettings.goldPerLevel} onChange={(v) => handleChange('goldPerLevel', v)} min={0} max={100} step={5} unit=" G" color="#e67e22" />
          
          <RangeInput label="ì—°ì† í‚¬ë‹¹ í˜„ìƒê¸ˆ ì¦ê°€" icon={<Skull size={14}/>} value={localSettings.bountyIncrement} onChange={(v) => handleChange('bountyIncrement', v)} min={0} max={500} step={50} unit=" G" color="#da3633" />

          <div style={{borderTop:'1px dashed #333', margin:'20px 0'}}></div>

          <div style={{ marginBottom:'10px', fontWeight:'bold', color:'#2ecc71', fontSize:'13px' }}>[ê²½í—˜ì¹˜ & ì–´ì‹œìŠ¤íŠ¸]</div>
          <RangeInput label="ê¸°ë³¸ í‚¬ ê²½í—˜ì¹˜" icon={<Star size={14}/>} value={localSettings.killXpBase} onChange={(v) => handleChange('killXpBase', v)} min={0} max={500} step={10} unit=" XP" color="#2ecc71" />
          
          <RangeInput label="ë ˆë²¨ë‹¹ ì¶”ê°€ ê²½í—˜ì¹˜" icon={<Zap size={14}/>} value={localSettings.killXpPerLevel} onChange={(v) => handleChange('killXpPerLevel', v)} min={0} max={100} step={5} unit=" XP" color="#2ecc71" />
          
          <div style={{borderTop:'1px dashed #333', margin:'20px 0'}}></div>

          <RangeInput label="ì–´ì‹œìŠ¤íŠ¸ ë¶„ë°°ìœ¨" icon={<Users size={14}/>} value={localSettings.assistPool} onChange={(v) => handleChange('assistPool', v)} min={0} max={100} step={5} unit="%" color="#3498db" />
          <div style={{fontSize:'11px', color:'#666', marginTop:'-15px', textAlign:'right'}}>
             * í‚¬ ê³¨ë“œì˜ {localSettings.assistPool}%ë¥¼ ì–´ì‹œìŠ¤íŠ¸ ì¸ì›ë¼ë¦¬ ë‚˜ëˆ”
          </div>

        </div>

        <div style={{ padding:'15px', borderTop:'1px solid #30363d', display:'flex', gap:'10px', background:'#161b22' }}>
          <button onClick={onClose} style={{ flex:1, background:'transparent', border:'1px solid #444', color:'#ccc', padding:'12px', borderRadius:'8px', fontWeight:'bold', cursor:'pointer' }}>ë‹«ê¸°</button>
          <button onClick={handleSave} style={{ flex:2, background:'#238636', border:'none', color:'#fff', padding:'12px', borderRadius:'8px', fontWeight:'bold', cursor:'pointer', display:'flex', justifyContent:'center', alignItems:'center', gap:'6px' }}>
            <Save size={18}/> ì„¤ì • ì €ì¥
          </button>
        </div>

      </div>
    </div>
  );
};
import { TrendingUp } from 'lucide-react';



==========================================
FILE PATH: src/components/hero/RolePatchModal.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/hero/RolePatchModal.tsx
// ==========================================

import React, { useState } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { Role, RoleSettings } from '../../types';
import { X, Save, Sliders } from 'lucide-react';

interface Props {
  role: Role;
  onClose: () => void;
}

export const RolePatchModal: React.FC<Props> = ({ role, onClose }) => {
  const { gameState, updateRoleSettings } = useGameStore();

  // ìŠ¤í† ì–´ì—ì„œ í˜„ì¬ ì„¤ì •ê°’ ê°€ì ¸ì˜¤ê¸° (ì—†ìœ¼ë©´ ê¸°ë³¸ê°’)
  // [ìˆ˜ì •] ì´ê³³ì—ì„œ ë¬¸ë²• ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì—ˆìŠµë‹ˆë‹¤. ê´„í˜¸ì™€ ì½¤ë§ˆë¥¼ ì •í™•íˆ í™•ì¸í•˜ì„¸ìš”.
  const initialSettings = gameState.roleSettings || {
    executor: { damage: 15, defense: 15 },
    tracker: { gold: 20, smiteChance: 1.5 },
    prophet: { cdrPerLevel: 2 },
    slayer: { structureDamage: 30 },
    guardian: { survivalRate: 20 }
  };

  const [settings, setSettings] = useState<RoleSettings>(initialSettings);

  // ê°’ ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleChange = (group: keyof RoleSettings, field: string, value: number) => {
    setSettings(prev => ({
      ...prev,
      [group]: { ...prev[group], [field]: value }
    }));
  };

  // ì €ì¥ í•¸ë“¤ëŸ¬
  const handleSave = () => {
    updateRoleSettings(settings);
    alert(`[${role}] ë°¸ëŸ°ìŠ¤ íŒ¨ì¹˜ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.\në‹¤ìŒ ì‹œë®¬ë ˆì´ì…˜ í‹±ë¶€í„° ì¦‰ì‹œ ì ìš©ë©ë‹ˆë‹¤.`);
    onClose();
  };

  // ìŠ¬ë¼ì´ë” ì»´í¬ë„ŒíŠ¸ (ë‚´ë¶€ ì •ì˜)
  const RangeInput = ({ label, value, onChange, unit, max, step = 1 }: any) => (
    <div style={{ marginBottom: '15px' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px', fontSize: '12px', color: '#ccc' }}>
        <span>{label}</span>
        <span style={{ fontWeight: 'bold', color: '#58a6ff', fontFamily:'monospace' }}>{value}{unit}</span>
      </div>
      <input 
        type="range" min={0} max={max} step={step} value={value} 
        onChange={(e) => onChange(Number(e.target.value))} 
        style={{ width: '100%', accentColor: '#58a6ff', height: '4px', cursor: 'pointer' }} 
      />
    </div>
  );

  // ì—­í• êµ°ë³„ë¡œ ë‹¤ë¥¸ ì…ë ¥ì°½ ë Œë”ë§
  const renderInputs = () => {
    switch(role) {
      case 'ì§‘í–‰ê´€':
        return (
          <>
            <div style={{fontSize:'12px', color:'#888', marginBottom:'15px'}}>
              * ê³ ë¦½(ì£¼ë³€ì— ì•„êµ° ì—†ìŒ) ìƒíƒœì¼ ë•Œ ì ìš©ë˜ëŠ” ë³´ë„ˆìŠ¤ì…ë‹ˆë‹¤.
            </div>
            <RangeInput 
              label="ì¶”ê°€ í”¼í•´ëŸ‰" 
              value={settings.executor.damage} 
              onChange={(v: number) => handleChange('executor', 'damage', v)} 
              unit="%" max={100} 
            />
            <RangeInput 
              label="ì¶”ê°€ ë°©ì–´ë ¥" 
              value={settings.executor.defense} 
              onChange={(v: number) => handleChange('executor', 'defense', v)} 
              unit="%" max={100} 
            />
          </>
        );
      case 'ì¶”ì ì':
        return (
          <>
            <div style={{fontSize:'12px', color:'#888', marginBottom:'15px'}}>
              * ì •ê¸€ëŸ¬ì˜ ì„±ì¥ ì†ë„ì™€ ì˜¤ë¸Œì íŠ¸ ì‹¸ì›€ ëŠ¥ë ¥ì„ ì¡°ì ˆí•©ë‹ˆë‹¤.
            </div>
            <RangeInput 
              label="ê³¨ë“œ íšë“ëŸ‰ ë³´ë„ˆìŠ¤" 
              value={settings.tracker.gold} 
              onChange={(v: number) => handleChange('tracker', 'gold', v)} 
              unit="%" max={200} 
            />
            <RangeInput 
              label="ê°•íƒ€ í™•ë¥  ë°°ìœ¨ (ê¸°ë³¸ 1.0)" 
              value={settings.tracker.smiteChance} 
              onChange={(v: number) => handleChange('tracker', 'smiteChance', v)} 
              unit="ë°°" max={5} step={0.1} 
            />
          </>
        );
      case 'ì„ ì§€ì':
        return (
          <>
            <div style={{fontSize:'12px', color:'#888', marginBottom:'15px'}}>
              * ë ˆë²¨ì´ ì˜¤ë¥¼ìˆ˜ë¡ ìŠ¤í‚¬ ì¿¨íƒ€ì„ì´ ì¤„ì–´ë“œëŠ” íš¨ê³¼ë¥¼ ë°ë¯¸ì§€ë¡œ í™˜ì‚°í•©ë‹ˆë‹¤.
            </div>
            <RangeInput 
              label="ë ˆë²¨ë‹¹ ìŠ¤í‚¬ ìœ„ë ¥ ì¦ê°€" 
              value={settings.prophet.cdrPerLevel} 
              onChange={(v: number) => handleChange('prophet', 'cdrPerLevel', v)} 
              unit="%" max={10} step={0.5} 
            />
            <div style={{fontSize:'11px', color:'#58a6ff', marginTop:'5px'}}>
              (ì˜ˆ: 3% ì„¤ì • ì‹œ, 16ë ˆë²¨ ë„ë‹¬í•˜ë©´ ë°ë¯¸ì§€ 48% ì¦ê°€)
            </div>
          </>
        );
      case 'ì‹ ì‚´ì':
        return (
          <>
             <div style={{fontSize:'12px', color:'#888', marginBottom:'15px'}}>
              * íƒ€ì›Œ ì² ê±° ë° ë„¥ì„œìŠ¤ íŒŒê´´ ëŠ¥ë ¥ì„ ì¡°ì ˆí•©ë‹ˆë‹¤.
            </div>
            <RangeInput 
              label="êµ¬ì¡°ë¬¼ ëŒ€ìƒ ì¶”ê°€ í”¼í•´" 
              value={settings.slayer.structureDamage} 
              onChange={(v: number) => handleChange('slayer', 'structureDamage', v)} 
              unit="%" max={300} 
            />
          </>
        );
      case 'ìˆ˜í˜¸ê¸°ì‚¬':
        return (
          <>
            <div style={{fontSize:'12px', color:'#888', marginBottom:'15px'}}>
              * ê°™ì€ ë¼ì¸ ì•„êµ°ì˜ ìƒì¡´ë ¥ì„ ë†’ì—¬ì¤ë‹ˆë‹¤.
            </div>
            <RangeInput 
              label="ì•„êµ° ìƒì¡´ìœ¨ ì¦ê°€ ë³´ì •" 
              value={settings.guardian.survivalRate} 
              onChange={(v: number) => handleChange('guardian', 'survivalRate', v)} 
              unit="%" max={80} 
            />
          </>
        );
      default: return null;
    }
  };

  return (
    <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.85)', zIndex: 9999, display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
      <div style={{ width: '90%', maxWidth: '400px', background: '#161b22', border: '1px solid #30363d', borderRadius: '12px', overflow: 'hidden', boxShadow: '0 20px 50px rgba(0,0,0,0.8)' }}>

        {/* í—¤ë” */}
        <div style={{ padding: '15px', background: '#21262d', borderBottom: '1px solid #30363d', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <h3 style={{ margin: 0, color: '#fff', display: 'flex', alignItems: 'center', gap: '8px', fontSize: '16px' }}>
            <Sliders size={18} color="#58a6ff"/> {role} ë°¸ëŸ°ìŠ¤ íŒ¨ì¹˜
          </h3>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#888', cursor: 'pointer' }}><X size={20}/></button>
        </div>

        {/* ë°”ë”” */}
        <div style={{ padding: '20px', display: 'flex', flexDirection: 'column', gap: '10px' }}>
          {renderInputs()}
        </div>

        {/* í‘¸í„° */}
        <div style={{ padding: '15px', borderTop: '1px solid #30363d', display: 'flex', justifyContent: 'flex-end', background:'#0d1117' }}>
          <button onClick={handleSave} style={{ background: '#238636', color: '#fff', border: 'none', padding: '10px 20px', borderRadius: '6px', fontWeight: 'bold', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '6px' }}>
            <Save size={16}/> íŒ¨ì¹˜ ì ìš©
          </button>
        </div>
      </div>
    </div>
  );
};


==========================================
FILE PATH: src/components/layout/Header.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/layout/Header.tsx
// ==========================================

import React from 'react';
import { useGameStore } from '../../store/useGameStore';
import { Settings, Save, Play, Pause } from 'lucide-react';

interface Props {
  isMobile: boolean;
  onOpenSystemMenu: () => void;
}

export const Header: React.FC<Props> = ({ isMobile, onOpenSystemMenu }) => {
  const { gameState, togglePlay, setSpeed } = useGameStore();

  // ì‹œê°„ í¬ë§·íŒ… (00:00:00)
  const formatTime = (h: number, m: number, s: number) => 
    `${String(h || 0).padStart(2, '0')}:${String(m || 0).padStart(2, '0')}:${String(Math.floor(s || 0)).padStart(2, '0')}`;

  // ë²„íŠ¼ ìŠ¤íƒ€ì¼ í—¬í¼
  const getBtnStyle = (speed: number) => ({
    padding: '6px 10px', 
    background: gameState.gameSpeed === speed ? '#58a6ff' : '#30363d',
    border: '1px solid #444', 
    borderRadius: '6px', 
    color: '#fff', 
    fontSize: '11px', 
    fontWeight: 'bold',
    cursor: 'pointer',
    minWidth: '40px'
  });

  return (
    <header style={{ 
      display: 'flex', flexDirection: isMobile ? 'column' : 'row', 
      justifyContent: 'space-between', alignItems: isMobile ? 'stretch' : 'center', 
      marginBottom: '20px', background: '#161b22', padding: '15px', 
      borderRadius: '12px', border: '1px solid #30363d', gap: isMobile ? '15px' : '0' 
    }}>
      {/* 1. ì™¼ìª½ ì„¹ì…˜: ì œëª© ë° ì‹œê°„ */}
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
        <div>
          <h1 style={{ margin: 0, fontSize: '20px', color: '#fff' }}>
            ORACLE <span style={{ fontSize:'12px', background:'#58a6ff', color:'#000', padding:'2px 6px', borderRadius:'4px', fontWeight:'bold'}}>PRO</span>
          </h1>
          <div style={{ display: 'flex', gap: '15px', marginTop: '5px', fontSize: '14px', color: '#8b949e' }}>
            <span>ğŸ“… S{gameState.season || 1}</span>
            <span>D{gameState.day || 1}</span>
            <span style={{ color: '#fff', fontWeight: 'bold', fontFamily: 'monospace' }}>
              â° {formatTime(gameState.hour, gameState.minute, gameState.second)}
            </span>
          </div>
        </div>
        {isMobile && (
          <button onClick={onOpenSystemMenu} style={{ background:'none', border:'none', color:'#8b949e' }}>
            <Settings size={24} />
          </button>
        )}
      </div>

      {/* 2. ì˜¤ë¥¸ìª½ ì„¹ì…˜: ë°°ì† ë° ì €ì¥ ì»¨íŠ¸ë¡¤ */}
      <div style={{ display: 'flex', gap: '10px', alignItems: 'center', justifyContent: isMobile ? 'space-between' : 'flex-end' }}>
        <div style={{ display:'flex', alignItems:'center', gap:'6px' }}>
          {!isMobile && (
            <button className="btn" onClick={onOpenSystemMenu} style={{ background: '#21262d', color: '#ccc', border:'1px solid #30363d', display:'flex', alignItems:'center', gap:'6px', padding: '8px 12px', marginRight:'10px' }}>
              <Save size={16}/> ì €ì¥/ë¡œë“œ
            </button>
          )}

          {/* ë°°ì† ë²„íŠ¼ë“¤ */}
          <button style={getBtnStyle(1)} onClick={() => setSpeed(1)}>1ë°°</button>
          <button style={getBtnStyle(3)} onClick={() => setSpeed(3)}>3ë°°</button>
          <button style={getBtnStyle(60)} onClick={() => setSpeed(60)}>1ë¶„</button>
          <button style={getBtnStyle(600)} onClick={() => setSpeed(600)}>10ë¶„</button>
          <button style={getBtnStyle(3600)} onClick={() => setSpeed(3600)}>1ì‹œê°„</button>
        </div>

        {/* ì¬ìƒ/ì •ì§€ ë²„íŠ¼ */}
        <button className="btn" onClick={togglePlay} style={{ background: gameState.isPlaying ? '#da3633' : '#238636', width: '80px', color:'white', fontWeight:'bold', display:'flex', alignItems:'center', justifyContent:'center', gap:'6px' }}>
          {gameState.isPlaying ? <><Pause size={16}/> ì •ì§€</> : <><Play size={16}/> ì¬ìƒ</>}
        </button>
      </div>
    </header>
  );
};


==========================================
FILE PATH: src/components/shop/ItemPatchModal.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/shop/ItemPatchModal.tsx
// ==========================================

import React, { useState, useEffect, useRef } from 'react';
import { Item } from '../../types';
import { useGameStore } from '../../store/useGameStore';
// [ìˆ˜ì •] Trash2 -> Trash ë¡œ ë³€ê²½ (í° í™”ë©´ í•´ê²°ì˜ í•µì‹¬)
import { X, Save, Trash, Sliders } from 'lucide-react';
import { GameIcon } from '../common/GameIcon';

interface Props {
  item?: Item | null;
  onClose: () => void;
}

// ì „ì²´ ìŠ¤íƒ¯ ì„¤ì • ì •ì˜
const ALL_STATS: Record<string, { label: string, color: string, max: number, step: number, unit: string }> = {
  ad: { label: 'ê³µê²©ë ¥ (AD)', color: '#e74c3c', max: 300, step: 1, unit: '' },
  ap: { label: 'ì£¼ë¬¸ë ¥ (AP)', color: '#9b59b6', max: 500, step: 1, unit: '' },
  crit: { label: 'ì¹˜ëª…íƒ€ (CRI)', color: '#e67e22', max: 100, step: 1, unit: '%' },
  pen: { label: 'ê´€í†µë ¥ (PEN)', color: '#da3633', max: 100, step: 1, unit: '' },

  hp: { label: 'ì²´ë ¥ (HP)', color: '#2ecc71', max: 2000, step: 10, unit: '' },
  armor: { label: 'ë°©ì–´ë ¥ (DEF)', color: '#3498db', max: 200, step: 1, unit: '' },
  regen: { label: 'ì²´ë ¥ ì¬ìƒ', color: '#27ae60', max: 100, step: 1, unit: '/s' },

  mp: { label: 'ë§ˆë‚˜ (MP)', color: '#3498db', max: 2000, step: 10, unit: '' },
  mpRegen: { label: 'ë§ˆë‚˜ ì¬ìƒ', color: '#2980b9', max: 50, step: 1, unit: '/s' },
  speed: { label: 'ì´ë™ì†ë„', color: '#f1c40f', max: 150, step: 1, unit: '' },
};

// ë¶„ë¥˜ë³„ í—ˆìš© ìŠ¤íƒ¯ ì •ì˜
const TYPE_ALLOWED_STATS: Record<string, string[]> = {
  WEAPON: ['ad', 'crit', 'pen', 'speed', 'hp'], 
  ARMOR: ['hp', 'armor', 'regen', 'mp'],        
  ARTIFACT: ['ap', 'mp', 'mpRegen', 'pen', 'hp'], 
  BOOTS: ['speed', 'armor', 'pen'],             
  ACCESSORY: Object.keys(ALL_STATS),            
  POWER: Object.keys(ALL_STATS),                
};

const DEFAULT_ITEM: Item = {
  id: '', name: '', cost: 1000,
  ad: 0, ap: 0, hp: 0, armor: 0, crit: 0, speed: 0,
  mp: 0, regen: 0, mpRegen: 0, pen: 0,
  type: 'WEAPON', description: ''
};

// ìŠ¤íƒ¯ ì—ë””í„° ì»´í¬ë„ŒíŠ¸
const StatEditor = ({ 
  statKey, data, activeStat, setActiveStat, handleChange 
}: { 
  statKey: string, 
  data: Item, 
  activeStat: string | null, 
  setActiveStat: (key: string | null) => void, 
  handleChange: (field: keyof Item, value: number) => void 
}) => {
  const config = ALL_STATS[statKey];
  const value = (data as any)[statKey] || 0;
  const isActive = activeStat === statKey;

  return (
    <div 
      onClick={() => setActiveStat(isActive ? null : statKey)}
      style={{
        background: isActive ? '#1f242e' : '#161b22',
        border: isActive ? `1px solid ${config.color}` : '1px solid #30363d',
        borderRadius: '10px', padding: '12px',
        cursor: 'pointer', transition: 'all 0.2s',
        display: 'flex', flexDirection: 'column', gap: '8px'
      }}
    >
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <span style={{ fontSize: '11px', color: isActive ? config.color : '#888', fontWeight: 'bold' }}>
          {config.label}
        </span>
        <span style={{ fontSize: '16px', fontWeight: '900', color: value > 0 ? config.color : '#555', fontFamily: 'monospace' }}>
          {value > 0 ? '+' : ''}{value}{config.unit}
        </span>
      </div>

      {isActive && (
        <div onClick={(e) => e.stopPropagation()} style={{ marginTop: '10px', animation: 'fadeIn 0.2s' }}>
          <input 
            type="range" min={0} max={config.max} step={config.step} value={value}
            onChange={(e) => handleChange(statKey as keyof Item, Number(e.target.value))}
            style={{ width: '100%', accentColor: config.color, height: '20px', cursor: 'pointer', marginBottom: '10px', touchAction: 'none' }}
          />
          <div style={{ display: 'flex', gap: '5px', justifyContent: 'flex-end' }}>
            <button onClick={() => handleChange(statKey as keyof Item, Math.max(0, value - (config.step*10)))} className="mini-btn">--</button>
            <button onClick={() => handleChange(statKey as keyof Item, Math.max(0, value - config.step))} className="mini-btn">-</button>
            <button onClick={() => handleChange(statKey as keyof Item, Math.min(config.max, value + config.step))} className="mini-btn">+</button>
            <button onClick={() => handleChange(statKey as keyof Item, Math.min(config.max, value + (config.step*10)))} className="mini-btn">++</button>
          </div>
        </div>
      )}
    </div>
  );
};

export const ItemPatchModal: React.FC<Props> = ({ item, onClose }) => {
  // deleteItemì„ ì•ˆì „í•˜ê²Œ ê°€ì ¸ì˜µë‹ˆë‹¤. (ì—†ìœ¼ë©´ undefined)
  const store = useGameStore();
  const { addItem, updateItem, setCustomImage, removeCustomImage } = store;
  // deleteItemì´ ì—†ì„ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ anyë¡œ ì²˜ë¦¬í•˜ê±°ë‚˜ ë°©ì–´ ì½”ë“œ ì‘ì„±
  const deleteItem = (store as any).deleteItem;

  const [data, setData] = useState<Item>(DEFAULT_ITEM);
  const [activeStat, setActiveStat] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    if (item) setData({ ...DEFAULT_ITEM, ...item });
    else setData({ ...DEFAULT_ITEM, id: `i_custom_${Date.now()}` });
  }, [item]);

  const handleSave = () => {
    if (!data.name) return alert('ì•„ì´í…œ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
    item ? updateItem(item.id, data) : addItem(data);
    onClose();
  };

  const handleDelete = () => {
    if (!item) return;
    if (!deleteItem) {
      alert("ì‚­ì œ ê¸°ëŠ¥ì´ ìŠ¤í† ì–´ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. (store/itemSlice.ts í™•ì¸)");
      return;
    }
    if (confirm(`ì •ë§ '${item.name}' ì•„ì´í…œì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
      deleteItem(item.id);
      onClose();
    }
  };

  const handleChange = (field: keyof Item, value: any) => {
    setData(prev => ({ ...prev, [field]: value }));
  };

  const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        if (typeof reader.result === 'string') setCustomImage(data.id, reader.result);
      };
      reader.readAsDataURL(file);
    }
  };

  const visibleStats = TYPE_ALLOWED_STATS[data.type] || Object.keys(ALL_STATS);

  return (
    <div style={{
      position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.85)', zIndex: 9999,
      display: 'flex', justifyContent: 'center', alignItems: 'center', backdropFilter: 'blur(5px)', padding: '15px'
    }}>
      <div style={{ 
        width: '100%', maxWidth: '500px', background: '#0d1117', border: '1px solid #30363d', 
        borderRadius: '16px', overflow: 'hidden', display: 'flex', flexDirection: 'column', maxHeight: '90vh',
        boxShadow: '0 20px 60px rgba(0,0,0,0.8)'
      }}>

        {/* 1. ìƒë‹¨ ì •ë³´ */}
        <div style={{ padding: '20px', borderBottom: '1px solid #30363d', background: '#161b22', display: 'flex', gap: '15px' }}>
          <div onClick={() => fileInputRef.current?.click()} className="group" style={{ position: 'relative', cursor: 'pointer', flexShrink: 0 }}>
            <GameIcon id={data.id} size={72} shape="rounded" border="2px solid #30363d" />
            <div style={{ position: 'absolute', inset: 0, background: 'rgba(0,0,0,0.6)', display: 'flex', alignItems: 'center', justifyContent: 'center', borderRadius: '12px', opacity: 0, transition: '0.2s', color: '#fff', fontSize: '10px', fontWeight: 'bold' }} className="hover-show">ë³€ê²½</div>
            <input type="file" ref={fileInputRef} style={{ display: 'none' }} accept="image/*" onChange={handleImageUpload} />
          </div>

          <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '8px' }}>
            <input 
              type="text" value={data.name} onChange={(e) => handleChange('name', e.target.value)}
              placeholder="ì•„ì´í…œ ì´ë¦„"
              style={{ background: 'transparent', border: 'none', borderBottom: '1px solid #30363d', color: '#fff', fontSize: '16px', fontWeight: 'bold', padding: '5px 0', width: '100%', outline: 'none' }}
            />
            <div style={{ display: 'flex', gap: '10px' }}>
              <div style={{ flex: 1 }}>
                <label style={{ fontSize: '10px', color: '#888' }}>ê°€ê²©</label>
                <input 
                  type="number" value={data.cost} onChange={(e) => handleChange('cost', Number(e.target.value))}
                  style={{ background: '#0d1117', border: '1px solid #30363d', color: '#f1c40f', borderRadius: '4px', width: '100%', padding: '6px', fontWeight: 'bold', fontSize: '13px' }}
                />
              </div>
              <div style={{ flex: 1 }}>
                <label style={{ fontSize: '10px', color: '#888' }}>ë¶„ë¥˜</label>
                <select 
                  value={data.type} onChange={(e) => handleChange('type', e.target.value)}
                  style={{ background: '#0d1117', border: '1px solid #30363d', color: '#ccc', borderRadius: '4px', width: '100%', padding: '6px', fontSize: '12px' }}
                >
                  <option value="WEAPON">âš”ï¸ ë¬´ê¸°</option>
                  <option value="ARMOR">ğŸ›¡ï¸ ë°©ì–´êµ¬</option>
                  <option value="ARTIFACT">ğŸ”® ë§ˆë„êµ¬</option>
                  <option value="BOOTS">ğŸ‘ ì‹ ë°œ</option>
                  <option value="ACCESSORY">ğŸ’ ì¥ì‹ êµ¬</option>
                  <option value="POWER">âš¡ ê¶ŒëŠ¥</option>
                </select>
              </div>
            </div>
          </div>
        </div>

        {/* 2. ìŠ¤íƒ¯ ì—ë””í„° */}
        <div style={{ flex: 1, overflowY: 'auto', padding: '20px' }}>
          <div style={{ marginBottom: '20px' }}>
            <textarea 
              value={data.description || ''} onChange={(e) => handleChange('description', e.target.value)}
              placeholder="ì„¤ëª…..." rows={2}
              style={{ width: '100%', background: '#161b22', border: '1px solid #30363d', borderRadius: '8px', padding: '10px', color: '#ccc', fontSize: '12px', resize: 'none', boxSizing: 'border-box' }}
            />
          </div>

          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px' }}>
            {visibleStats.map(key => (
              <StatEditor key={key} statKey={key} data={data} activeStat={activeStat} setActiveStat={setActiveStat} handleChange={handleChange} />
            ))}
          </div>

          <div style={{ marginTop: '20px', display: 'flex', justifyContent: 'center' }}>
            <button onClick={() => removeCustomImage(data.id)} style={{ background: 'none', border: 'none', color: '#666', fontSize: '11px', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '4px' }}>
                <Trash size={12}/> ì‚¬ì§„ ì´ˆê¸°í™”
            </button>
          </div>
        </div>

        {/* 3. í‘¸í„° (ì‚­ì œ ë²„íŠ¼ í¬í•¨) */}
        <div style={{ padding: '15px 20px', borderTop: '1px solid #30363d', background: '#161b22', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <div>
            {item && (
              <button 
                onClick={handleDelete}
                style={{ 
                  padding: '10px 16px', background: '#3f1515', border: '1px solid #5a1e1e', 
                  color: '#ff6b6b', borderRadius: '8px', cursor: 'pointer', 
                  fontWeight: 'bold', fontSize: '13px', display: 'flex', alignItems: 'center', gap: '6px' 
                }}
              >
                <Trash size={16}/> ì‚­ì œ
              </button>
            )}
          </div>

          <div style={{ display:'flex', gap:'10px' }}>
            <button onClick={onClose} style={{ padding: '10px 20px', background: 'transparent', border: '1px solid #30363d', color: '#ccc', borderRadius: '8px', cursor: 'pointer', fontWeight: 'bold', fontSize: '13px' }}>ì·¨ì†Œ</button>
            <button onClick={handleSave} style={{ padding: '10px 24px', background: '#238636', border: 'none', color: '#fff', borderRadius: '8px', cursor: 'pointer', fontWeight: 'bold', fontSize: '13px', display: 'flex', alignItems: 'center', gap: '6px' }}>
              <Save size={16}/> {item ? 'ìˆ˜ì •' : 'ìƒì„±'}
            </button>
          </div>
        </div>

      </div>
      <style>{`
        .hover-show:hover { opacity: 1 !important; }
        .mini-btn {
          background: #30363d; border: none; color: #fff; 
          padding: 4px 8px; border-radius: 4px; 
          cursor: pointer; display: flex; alignItems: center; justifyContent: center;
          font-size: 11px; font-weight: bold;
        }
        .mini-btn:hover { background: #444; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }
      `}</style>
    </div>
  );
};



==========================================
FILE PATH: src/components/shop/ItemStatsView.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/shop/ItemStatsView.tsx
// ==========================================

import React, { useState } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { Item } from '../../types';
import { Trophy, Target, Activity, ArrowUp, ArrowDown } from 'lucide-react';

export const ItemStatsView: React.FC = () => {
  const { shopItems, gameState } = useGameStore();

  // [ìˆ˜ì •] ê¸°ì¡´ ì„¸ì´ë¸Œ íŒŒì¼ì— itemStatsê°€ ì—†ì„ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ë¹ˆ ê°ì²´({}) í• ë‹¹
  const itemStats = gameState.itemStats || {};
  const godStats = gameState.godStats || { totalMatches: 0 };

  const [sortKey, setSortKey] = useState<'winRate' | 'pickRate' | 'kda'>('pickRate');

  // ì „ì²´ ê²Œì„ ìˆ˜ (í”½ë¥  ê³„ì‚°ìš©)
  const totalPlayerGames = Math.max(1, godStats.totalMatches * 10);

  // ë°ì´í„° ê°€ê³µ
  const statsList = shopItems.map(item => {
    // itemStatsê°€ ë¹„ì–´ìˆì–´ë„ ì•ˆì „í•˜ê²Œ ê¸°ë³¸ê°’ ì‚¬ìš©
    const stat = itemStats[item.id] || { totalPicks: 0, totalWins: 0, totalKills: 0, totalDeaths: 0, totalAssists: 0 };

    const pickRate = (stat.totalPicks / totalPlayerGames) * 100;
    const winRate = stat.totalPicks > 0 ? (stat.totalWins / stat.totalPicks) * 100 : 0;
    const kills = stat.totalPicks > 0 ? stat.totalKills / stat.totalPicks : 0;
    const deaths = stat.totalPicks > 0 ? stat.totalDeaths / stat.totalPicks : 0;
    const assists = stat.totalPicks > 0 ? stat.totalAssists / stat.totalPicks : 0;
    const kda = deaths === 0 ? (kills + assists) : (kills + assists) / deaths;

    return {
      ...item,
      stat,
      displayPickRate: pickRate,
      displayWinRate: winRate,
      displayKda: kda,
      avgKdaStr: `${kills.toFixed(1)} / ${deaths.toFixed(1)} / ${assists.toFixed(1)}`
    };
  });

  // ì •ë ¬
  const sortedList = [...statsList].sort((a, b) => {
    if (sortKey === 'winRate') return b.displayWinRate - a.displayWinRate;
    if (sortKey === 'kda') return b.displayKda - a.displayKda;
    return b.displayPickRate - a.displayPickRate; // default: pickRate
  });

  const getWinRateColor = (rate: number) => {
    if (rate >= 55) return '#ff4d4d'; // OP
    if (rate >= 50) return '#3fb950'; // Good
    return '#8b949e'; // Bad
  };

  return (
    <div style={{ padding: '0 5px' }}>
      {/* ì •ë ¬ ë²„íŠ¼ */}
      <div style={{ display: 'flex', gap: '10px', marginBottom: '15px', justifyContent: 'flex-end' }}>
        {[
          { key: 'pickRate', label: 'ì±„íƒë¥  ìˆœ' },
          { key: 'winRate', label: 'ìŠ¹ë¥  ìˆœ' },
          { key: 'kda', label: 'í‰ì (KDA) ìˆœ' }
        ].map((btn) => (
          <button
            key={btn.key}
            onClick={() => setSortKey(btn.key as any)}
            style={{
              background: sortKey === btn.key ? '#30363d' : 'transparent',
              color: sortKey === btn.key ? '#fff' : '#888',
              border: '1px solid #30363d', padding: '6px 12px', borderRadius: '6px', cursor: 'pointer', fontSize: '11px', fontWeight: 'bold',
              display:'flex', alignItems:'center', gap:'4px'
            }}
          >
            {btn.label} {sortKey === btn.key && <ArrowDown size={12}/>}
          </button>
        ))}
      </div>

      {/* í…Œì´ë¸” í—¤ë” */}
      <div style={{ display: 'grid', gridTemplateColumns: '2fr 1fr 1fr 1.5fr', padding: '10px', background: '#21262d', borderRadius: '8px 8px 0 0', fontSize: '11px', color: '#8b949e', fontWeight: 'bold' }}>
        <div>ì•„ì´í…œ ëª…</div>
        <div style={{ textAlign: 'center' }}>ì±„íƒë¥ </div>
        <div style={{ textAlign: 'center' }}>ìŠ¹ë¥ </div>
        <div style={{ textAlign: 'right', paddingRight:'10px' }}>í‰ê·  KDA</div>
      </div>

      {/* ë¦¬ìŠ¤íŠ¸ */}
      <div style={{ border: '1px solid #30363d', borderTop: 'none', borderRadius: '0 0 8px 8px', background: '#161b22' }}>
        {sortedList.map((item, idx) => (
          <div key={item.id} style={{ 
            display: 'grid', gridTemplateColumns: '2fr 1fr 1fr 1.5fr', 
            padding: '12px 10px', borderBottom: '1px solid #2c2c2f', alignItems: 'center' 
          }}>
            {/* 1. ì•„ì´í…œ ì •ë³´ */}
            <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
              <div style={{ fontSize: '12px', color: '#555', width: '20px', textAlign: 'center' }}>{idx + 1}</div>
              <div>
                <div style={{ color: item.type === 'POWER' ? '#9b59b6' : '#fff', fontWeight: 'bold', fontSize: '13px' }}>
                  {item.name}
                </div>
                <div style={{ fontSize: '10px', color: '#666' }}>{item.cost} G</div>
              </div>
            </div>

            {/* 2. ì±„íƒë¥  */}
            <div style={{ textAlign: 'center' }}>
              <div style={{ color: '#fff', fontSize: '13px', fontWeight: 'bold' }}>{item.displayPickRate.toFixed(1)}%</div>
              <div style={{ fontSize: '10px', color: '#555' }}>{item.stat.totalPicks.toLocaleString()}íšŒ</div>
            </div>

            {/* 3. ìŠ¹ë¥  */}
            <div style={{ textAlign: 'center' }}>
              <div style={{ color: getWinRateColor(item.displayWinRate), fontSize: '13px', fontWeight: 'bold' }}>
                {item.displayWinRate.toFixed(1)}%
              </div>
            </div>

            {/* 4. KDA */}
            <div style={{ textAlign: 'right', paddingRight:'10px' }}>
              <div style={{ color: item.displayKda >= 3 ? '#e89d40' : '#ccc', fontWeight: 'bold', fontSize: '13px' }}>
                {item.displayKda.toFixed(2)}:1
              </div>
              <div style={{ fontSize: '10px', color: '#666' }}>{item.avgKdaStr}</div>
            </div>
          </div>
        ))}

        {sortedList.length === 0 && (
          <div style={{ padding: '40px', textAlign: 'center', color: '#555' }}>ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>
        )}
      </div>
    </div>
  );
};


==========================================
FILE PATH: src/components/shop/ShopTab.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/shop/ShopTab.tsx
// ==========================================

import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { 
  Coins, Plus, Shield, Sword, Zap, Briefcase, 
  BarChart2, ShoppingCart, Search, ChevronRight, Footprints, Gem 
} from 'lucide-react'; // Trash ì œê±°ë¨
import { ItemStatsView } from './ItemStatsView'; 
import { ItemPatchModal } from './ItemPatchModal';
import { Item } from '../../types';
import { GameIcon } from '../common/GameIcon';

export const ShopTab: React.FC = () => {
  const { shopItems } = useGameStore();
  const [mode, setMode] = useState<'MANAGE' | 'STATS'>('MANAGE');
  const [filter, setFilter] = useState<string>('ALL');
  const [searchQuery, setSearchQuery] = useState('');
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingItem, setEditingItem] = useState<Item | null>(null);

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const filteredItems = shopItems.filter(i => {
    const matchFilter = filter === 'ALL' || i.type === filter;
    const matchSearch = i.name.toLowerCase().includes(searchQuery.toLowerCase());
    return matchFilter && matchSearch;
  });

  // ê°€ê²©ìˆœ ì •ë ¬
  filteredItems.sort((a, b) => a.cost - b.cost);

  const handleCreate = () => { setEditingItem(null); setIsModalOpen(true); };
  const handleEdit = (item: Item) => { setEditingItem(item); setIsModalOpen(true); };

  const getTypeIcon = (type: string) => {
    switch(type) {
      case 'WEAPON': return <Sword size={14} color="#e74c3c"/>;
      case 'ARMOR': return <Shield size={14} color="#2ecc71"/>;
      case 'ACCESSORY': return <Briefcase size={14} color="#f1c40f"/>;
      case 'POWER': return <Zap size={14} color="#9b59b6"/>;
      case 'BOOTS': return <Footprints size={14} color="#00b894"/>;
      case 'ARTIFACT': return <Gem size={14} color="#a29bfe"/>;
      default: return <Coins size={14} color="#888"/>;
    }
  };

  const StatBadge = ({ label, val, color }: { label: string, val?: number, color: string }) => {
    if (!val || val === 0) return null;
    return (
      <span style={{ 
        fontSize: '10px', fontWeight: 'bold', color: color, 
        background: `${color}11`, border: `1px solid ${color}44`, 
        padding: '1px 5px', borderRadius: '4px', whiteSpace: 'nowrap',
        display: 'inline-flex', alignItems: 'center', fontFamily: 'monospace'
      }}>
        {label} +{val}
      </span>
    );
  };

  const ItemStatsRenderer = ({ item }: { item: Item }) => (
    <div style={{ display: 'flex', gap: '4px', flexWrap: 'wrap' }}>
      <StatBadge label="AD" val={item.ad} color="#e74c3c" />
      <StatBadge label="AP" val={item.ap} color="#9b59b6" />
      <StatBadge label="HP" val={item.hp} color="#2ecc71" />
      <StatBadge label="DEF" val={item.armor} color="#3498db" />
      <StatBadge label="CRI" val={item.crit} color="#e67e22" />
      <StatBadge label="SPD" val={item.speed} color="#f1c40f" />
      <StatBadge label="MP" val={item.mp} color="#3498db" />
      <StatBadge label="PEN" val={item.pen} color="#da3633" />
      <StatBadge label="REG" val={item.regen} color="#27ae60" />
      <StatBadge label="M.REG" val={item.mpRegen} color="#2980b9" />
    </div>
  );

  const DesktopRow = ({ item, index }: { item: Item, index: number }) => (
    <div 
      onClick={() => handleEdit(item)}
      style={{ 
        // [ìˆ˜ì •] ê·¸ë¦¬ë“œ ì»¬ëŸ¼ì—ì„œ ì‚­ì œ ë²„íŠ¼ ê³µê°„ ì œê±° (80px -> ì œê±°)
        display: 'grid', gridTemplateColumns: '50px 250px 100px 1fr', 
        padding: '10px 15px', borderBottom: '1px solid #2c2c2f', 
        alignItems: 'center', background: '#161b22', cursor: 'pointer',
        transition: 'background 0.1s'
      }}
      onMouseEnter={e => e.currentTarget.style.background = '#21262d'}
      onMouseLeave={e => e.currentTarget.style.background = '#161b22'}
    >
      <div style={{ color: '#555', fontStyle: 'italic', fontWeight: 'bold', textAlign:'center' }}>{index + 1}</div>
      <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
        <GameIcon id={item.id} size={36} shape="rounded" border="1px solid #444" />
        <div>
          <div style={{ fontWeight: 'bold', color: item.type === 'POWER' ? '#9b59b6' : '#fff', fontSize: '13px' }}>{item.name}</div>
          <div style={{ fontSize: '11px', color: '#666', display:'flex', alignItems:'center', gap:'4px' }}>
            {getTypeIcon(item.type)} {item.type}
          </div>
        </div>
      </div>
      <div style={{ color: '#f1c40f', fontWeight: 'bold', fontSize: '13px', fontFamily: 'monospace' }}>
        {item.cost.toLocaleString()} G
      </div>
      <div><ItemStatsRenderer item={item} /></div>
      
      {/* [ìˆ˜ì •] ì‚­ì œ ë²„íŠ¼ ì œê±°ë¨ */}
    </div>
  );

  const MobileRow = ({ item, index }: { item: Item, index: number }) => (
    <div onClick={() => handleEdit(item)} style={{ display: 'flex', alignItems: 'center', gap: '12px', padding: '12px', borderBottom: '1px solid #2c2c2f', background: '#161b22', cursor: 'pointer' }}>
      <div style={{ fontSize: '12px', color: '#555', fontStyle: 'italic', width: '20px', textAlign:'center' }}>{index + 1}</div>
      <GameIcon id={item.id} size={42} shape="rounded" border="1px solid #444" />
      <div style={{ flex: 1, minWidth: 0 }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '4px' }}>
          <span style={{ fontWeight: 'bold', color: '#fff', fontSize: '14px' }}>{item.name}</span>
          <span style={{ color: '#f1c40f', fontWeight: 'bold', fontSize: '12px' }}>{item.cost.toLocaleString()}</span>
        </div>
        <ItemStatsRenderer item={item} />
      </div>
      <ChevronRight size={16} color="#444" />
      {/* [ìˆ˜ì •] ì‚­ì œ ë²„íŠ¼ ì œê±°ë¨ */}
    </div>
  );

  return (
    <div style={{ paddingBottom: '80px', display: 'flex', flexDirection: 'column', height: '100%' }}>
      <div style={{ background:'#161b22', borderRadius:'12px', border:'1px solid #30363d', padding: '12px 15px', marginBottom: '10px', display:'flex', flexDirection: isMobile ? 'column' : 'row', gap: isMobile ? '10px' : '15px', justifyContent:'space-between', alignItems: isMobile ? 'stretch' : 'center' }}>
        <div style={{ display:'flex', alignItems:'center', gap:'10px' }}>
            <Coins color="#f1c40f" size={20}/>
            <h2 style={{ margin:0, color:'#fff', fontSize: '16px', fontWeight:'800' }}>ì•„ì´í…œ ìƒì </h2>
        </div>
        <div style={{ display:'flex', background:'#0d1117', padding:'3px', borderRadius:'6px', border:'1px solid #30363d' }}>
            <button onClick={() => setMode('MANAGE')} style={{ flex:1, padding:'6px 12px', borderRadius:'4px', border:'none', background: mode === 'MANAGE' ? '#58a6ff' : 'transparent', color: mode === 'MANAGE' ? '#000' : '#8b949e', fontWeight:'bold', fontSize:'12px', cursor:'pointer', display:'flex', alignItems:'center', justifyContent:'center', gap:'6px' }}><ShoppingCart size={14}/> ê´€ë¦¬</button>
            <button onClick={() => setMode('STATS')} style={{ flex:1, padding:'6px 12px', borderRadius:'4px', border:'none', background: mode === 'STATS' ? '#58a6ff' : 'transparent', color: mode === 'STATS' ? '#000' : '#8b949e', fontWeight:'bold', fontSize:'12px', cursor:'pointer', display:'flex', alignItems:'center', justifyContent:'center', gap:'6px' }}><BarChart2 size={14}/> í†µê³„</button>
        </div>
      </div>

      {mode === 'STATS' && <ItemStatsView />}

      {mode === 'MANAGE' && (
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', background: '#1c1c1f', border: '1px solid #30363d', borderRadius: '12px', overflow: 'hidden' }}>
          <div style={{ padding: '10px 15px', borderBottom: '1px solid #30363d', display: 'flex', flexDirection: isMobile ? 'column' : 'row', gap: '10px', background: '#252528' }}>
            <div style={{ display: 'flex', gap: '5px', overflowX: 'auto', scrollbarWidth: 'none' }}>
              {['ALL', 'WEAPON', 'ARMOR', 'ARTIFACT', 'BOOTS', 'ACCESSORY', 'POWER'].map(f => (
                <button key={f} onClick={() => setFilter(f)} style={{ background: filter === f ? '#30363d' : 'transparent', color: filter === f ? '#fff' : '#888', border: '1px solid', borderColor: filter === f ? '#555' : 'transparent', padding: '4px 10px', borderRadius: '4px', cursor: 'pointer', fontWeight: 'bold', fontSize: '11px', whiteSpace: 'nowrap' }}>
                  {f === 'ALL' ? 'ì „ì²´' : f}
                </button>
              ))}
            </div>
            <div style={{ position: 'relative', flex: 1 }}>
              <Search size={14} color="#666" style={{ position: 'absolute', left: '10px', top: '50%', transform: 'translateY(-50%)' }} />
              <input type="text" placeholder="ì•„ì´í…œ ê²€ìƒ‰..." value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} style={{ width: '100%', background: '#161b22', border: '1px solid #444', borderRadius: '4px', padding: '6px 10px 6px 30px', color: '#fff', fontSize: '12px', outline: 'none', boxSizing: 'border-box' }} />
            </div>
            <button onClick={handleCreate} style={{ background: '#238636', border: '1px solid #2ea043', borderRadius: '4px', color: '#fff', fontSize: '12px', fontWeight: 'bold', padding: '6px 12px', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '4px', whiteSpace: 'nowrap', justifyContent:'center' }}><Plus size={14}/> ì‹ ê·œ ë“±ë¡</button>
          </div>

          <div style={{ flex: 1, overflowY: 'auto' }}>
            {!isMobile && (
              // [ìˆ˜ì •] í—¤ë” ê·¸ë¦¬ë“œ ì¡°ì • (80px ì‚­ì œ)
              <div style={{ display: 'grid', gridTemplateColumns: '50px 250px 100px 1fr', padding: '10px 15px', borderBottom: '1px solid #30363d', background: '#161b22', fontSize: '11px', fontWeight: 'bold', color: '#8b949e', position: 'sticky', top: 0 }}>
                <div style={{ textAlign:'center' }}>No.</div>
                <div>ì•„ì´í…œ ì •ë³´</div>
                <div>ê°€ê²©</div>
                <div>ëŠ¥ë ¥ì¹˜ (Stats)</div>
                {/* ê´€ë¦¬(ì‚­ì œ) íƒ­ í—¤ë” ì œê±°ë¨ */}
              </div>
            )}
            {filteredItems.length > 0 ? (
              filteredItems.map((item, idx) => (
                isMobile ? <MobileRow key={item.id} item={item} index={idx} /> : <DesktopRow key={item.id} item={item} index={idx} />
              ))
            ) : <div style={{ padding: '40px', textAlign: 'center', color: '#555', fontSize: '13px' }}>ê²€ìƒ‰ëœ ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤.</div>}
          </div>
        </div>
      )}

      {isModalOpen && <ItemPatchModal item={editingItem} onClose={() => setIsModalOpen(false)} />}
    </div>
  );
};



==========================================
FILE PATH: src/components/shop/ui/ShopItemRow.tsx
==========================================
import React from 'react';
import { Item } from '../../../types';
import { GameIcon } from '../../common/GameIcon';
import { Sword, Shield, Coins, Zap, Briefcase, ChevronRight, Footprints, Gem } from 'lucide-react';

interface Props {
  item: Item;
  index: number;
  isMobile: boolean;
  onEdit: (item: Item) => void;
}

const getTypeIcon = (type: string) => {
  switch(type) {
    case 'WEAPON': return <Sword size={14} color="#e74c3c"/>;
    case 'ARMOR': return <Shield size={14} color="#2ecc71"/>;
    case 'ACCESSORY': return <Briefcase size={14} color="#f1c40f"/>;
    case 'POWER': return <Zap size={14} color="#9b59b6"/>;
    case 'BOOTS': return <Footprints size={14} color="#00b894"/>;
    case 'ARTIFACT': return <Gem size={14} color="#a29bfe"/>;
    default: return <Coins size={14} color="#888"/>;
  }
};

const StatBadge = ({ label, val, color }: { label: string, val?: number, color: string }) => {
  if (!val || val === 0) return null;
  return (
    <span style={{ fontSize: '10px', fontWeight: 'bold', color: color, background: \`\${color}11\`, border: \`1px solid \${color}44\`, padding: '1px 5px', borderRadius: '4px', whiteSpace: 'nowrap', display: 'inline-flex', alignItems: 'center', fontFamily: 'monospace' }}>
      {label} +{val}
    </span>
  );
};

const ItemStatsRenderer = ({ item }: { item: Item }) => (
  <div style={{ display: 'flex', gap: '4px', flexWrap: 'wrap' }}>
    <StatBadge label="AD" val={item.ad} color="#e74c3c" />
    <StatBadge label="AP" val={item.ap} color="#9b59b6" />
    <StatBadge label="HP" val={item.hp} color="#2ecc71" />
    <StatBadge label="DEF" val={item.armor} color="#3498db" />
    <StatBadge label="CRI" val={item.crit} color="#e67e22" />
    <StatBadge label="SPD" val={item.speed} color="#f1c40f" />
    <StatBadge label="MP" val={item.mp} color="#3498db" />
    <StatBadge label="PEN" val={item.pen} color="#da3633" />
    <StatBadge label="REG" val={item.regen} color="#27ae60" />
    <StatBadge label="M.REG" val={item.mpRegen} color="#2980b9" />
  </div>
);

export const ShopItemRow: React.FC<Props> = ({ item, index, isMobile, onEdit }) => {
  if (isMobile) {
    return (
      <div onClick={() => onEdit(item)} style={{ display: 'flex', alignItems: 'center', gap: '12px', padding: '12px', borderBottom: '1px solid #2c2c2f', background: '#161b22', cursor: 'pointer' }}>
        <div style={{ fontSize: '12px', color: '#555', fontStyle: 'italic', width: '20px', textAlign:'center' }}>{index + 1}</div>
        <GameIcon id={item.id} size={42} shape="rounded" border="1px solid #444" />
        <div style={{ flex: 1, minWidth: 0 }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '4px' }}>
            <span style={{ fontWeight: 'bold', color: '#fff', fontSize: '14px' }}>{item.name}</span>
            <span style={{ color: '#f1c40f', fontWeight: 'bold', fontSize: '12px' }}>{item.cost.toLocaleString()}</span>
          </div>
          <ItemStatsRenderer item={item} />
        </div>
        <ChevronRight size={16} color="#444" />
      </div>
    );
  }

  return (
    <div onClick={() => onEdit(item)} style={{ display: 'grid', gridTemplateColumns: '50px 250px 100px 1fr', padding: '10px 15px', borderBottom: '1px solid #2c2c2f', alignItems: 'center', background: '#161b22', cursor: 'pointer', transition: 'background 0.1s' }} onMouseEnter={e => e.currentTarget.style.background = '#21262d'} onMouseLeave={e => e.currentTarget.style.background = '#161b22'}>
      <div style={{ color: '#555', fontStyle: 'italic', fontWeight: 'bold', textAlign:'center' }}>{index + 1}</div>
      <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
        <GameIcon id={item.id} size={36} shape="rounded" border="1px solid #444" />
        <div>
          <div style={{ fontWeight: 'bold', color: item.type === 'POWER' ? '#9b59b6' : '#fff', fontSize: '13px' }}>{item.name}</div>
          <div style={{ fontSize: '11px', color: '#666', display:'flex', alignItems:'center', gap:'4px' }}>{getTypeIcon(item.type)} {item.type}</div>
        </div>
      </div>
      <div style={{ color: '#f1c40f', fontWeight: 'bold', fontSize: '13px', fontFamily: 'monospace' }}>{item.cost.toLocaleString()} G</div>
      <div><ItemStatsRenderer item={item} /></div>
    </div>
  );
};



==========================================
FILE PATH: src/components/system/OptionTab.tsx
==========================================
import React, { useState, useRef, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { exportSaveFile, importSaveFile } from '../../engine/SaveLoadSystem';
// [ì‹ ê·œ] ë‹¤ìš´ë¡œë” ì„í¬íŠ¸
import { downloadAllResources, checkCachedStatus } from '../../utils/ResourceDownloader';
import { 
  Bot, Key, CheckCircle, Download, Upload, Trash2, RefreshCw, 
  Map as MapIcon, Image as ImageIcon, Database, CloudLightning, Loader2 
} from 'lucide-react';

export const OptionTab: React.FC = () => {
  const { gameState, heroes, shopItems, updateAIConfig, resetHeroStats, hardReset, loadModData, setCustomImage, removeCustomImage } = useGameStore();
  const [aiSettings, setAiSettings] = useState(gameState.aiConfig);
  
  // [ì‹ ê·œ] ë‹¤ìš´ë¡œë“œ ìƒíƒœ ê´€ë¦¬
  const [isDownloading, setIsDownloading] = useState(false);
  const [progress, setProgress] = useState(0);
  const [cachedCount, setCachedCount] = useState(0);
  
  const fileInputRef = useRef<HTMLInputElement>(null);
  const modInputRef = useRef<HTMLInputElement>(null);
  const mapInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    checkCachedStatus().then(setCachedCount);
  }, []);

  const handleDownloadResources = async () => {
    if (isDownloading) return;
    if (!confirm("ê²Œì„ì— í•„ìš”í•œ ëª¨ë“  ì´ë¯¸ì§€ë¥¼ ë‹¤ìš´ë¡œë“œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(ì•½ 5~10MB ì†Œìš”)")) return;

    setIsDownloading(true);
    setProgress(0);

    const success = await downloadAllResources((current, total) => {
      setProgress((current / total) * 100);
    });

    if (success) {
      alert("âœ… ëª¨ë“  ë¦¬ì†ŒìŠ¤ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ!\nì´ì œ ë¡œë”© ì—†ì´ ì¾Œì í•˜ê²Œ í”Œë ˆì´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
      checkCachedStatus().then(setCachedCount);
    }
    setIsDownloading(false);
  };

  const saveAISettings = () => {
    updateAIConfig(aiSettings);
    alert("âœ… AI ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!");
  };

  const handleStatReset = () => {
    if (confirm('ëª¨ë“  ì±”í”¼ì–¸ì˜ ëˆ„ì  í†µê³„(ìŠ¹ë¥ , KDA, íŒìˆ˜)ë¥¼ 0ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
      resetHeroStats();
      alert('í†µê³„ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
    }
  };

  const handleSafeReset = () => {
    if(confirm('í˜„ì¬ ê²Œì„ì„ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(ì €ì¥ëœ ìŠ¬ë¡¯ê³¼ ì„¤ì •ì€ ìœ ì§€ë©ë‹ˆë‹¤.)')) {
      hardReset(); 
      window.location.reload();
    }
  };

  // ê¸°ì¡´ í•¨ìˆ˜ë“¤ ìœ ì§€
  const handleExportMod = () => {
    const cleanHeroes = heroes.map(h => ({
      id: h.id, name: h.name, role: h.role, concept: h.concept, stats: h.stats, skills: h.skills
    }));
    const modData = {
      version: 2,
      heroes: cleanHeroes, items: shopItems,
      settings: { battle: gameState.battleSettings, field: gameState.fieldSettings, role: gameState.roleSettings, tier: gameState.tierConfig },
      images: gameState.customImages
    };
    const json = JSON.stringify(modData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = `GodsWar_Mod_${new Date().toISOString().slice(0,10)}.json`;
    a.click(); URL.revokeObjectURL(url);
  };

  const handleImportMod = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    if (!confirm('ì´ íŒŒì¼ì„ ì ìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) { e.target.value = ''; return; }
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const json = JSON.parse(ev.target?.result as string);
        if (json.heroes && json.settings) {
          loadModData(json);
          alert('âœ… MOD ë°ì´í„° ì ìš© ì™„ë£Œ!');
        } else alert('âŒ ì˜¬ë°”ë¥´ì§€ ì•Šì€ MOD íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤.');
      } catch (err) { console.error(err); alert('âŒ íŒŒì¼ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'); }
    };
    reader.readAsText(file); e.target.value = '';
  };

  const handleMapUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if(file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        if(typeof reader.result === 'string') {
          setCustomImage('map_bg', reader.result); 
          alert("âœ… ì „ì¥ ë§µ ìŠ¤í‚¨ì´ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤!");
        }
      };
      reader.readAsDataURL(file);
    }
    e.target.value = '';
  };

  const handleMapReset = () => {
    if(confirm("ë§µ ìŠ¤í‚¨ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë˜ëŒë¦¬ì‹œê² ìŠµë‹ˆê¹Œ?")) {
      removeCustomImage('map_bg');
    }
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '15px' }}>

      {/* 1. [ì‹ ê·œ] ë¦¬ì†ŒìŠ¤ ë‹¤ìš´ë¡œë“œ ì„¹ì…˜ */}
      <div style={{ background: '#161b22', padding: '15px', borderRadius: '8px', border: '1px solid #30363d' }}>
        <h4 style={{ margin:'0 0 10px 0', color:'#f1c40f', display:'flex', alignItems:'center', gap:'6px', fontSize:'14px' }}>
          <CloudLightning size={16}/> ê²Œì„ ë¦¬ì†ŒìŠ¤ ìµœì í™”
        </h4>
        <div style={{ fontSize: '11px', color: '#8b949e', marginBottom: '10px' }}>
          ì´ë¯¸ì§€ê°€ ëŠë¦¬ê²Œ ëœ¬ë‹¤ë©´ ë¦¬ì†ŒìŠ¤ë¥¼ ë¯¸ë¦¬ ë‹¤ìš´ë¡œë“œí•˜ì„¸ìš”.<br/>
          í˜„ì¬ ì €ì¥ëœ ë¦¬ì†ŒìŠ¤: <span style={{color:'#fff', fontWeight:'bold'}}>{cachedCount}ê°œ</span>
        </div>
        
        {isDownloading ? (
          <div style={{ background:'#0d1117', borderRadius:'6px', padding:'10px', border:'1px solid #30363d' }}>
            <div style={{ display:'flex', justifyContent:'space-between', marginBottom:'6px', fontSize:'12px', color:'#fff' }}>
              <span>Downloading...</span>
              <span>{progress.toFixed(0)}%</span>
            </div>
            <div style={{ width:'100%', height:'6px', background:'#333', borderRadius:'3px', overflow:'hidden' }}>
              <div style={{ width:`${progress}%`, height:'100%', background:'#f1c40f', transition:'width 0.1s' }}></div>
            </div>
          </div>
        ) : (
          <button 
            onClick={handleDownloadResources} 
            className="btn" 
            style={{ width:'100%', background: '#d29922', color: '#000', border:'none', fontSize:'13px', display:'flex', alignItems:'center', justifyContent:'center', gap:'6px', padding:'10px' }}
          >
            <Database size={16}/> ë¦¬ì†ŒìŠ¤ ì „ì²´ ë‹¤ìš´ë¡œë“œ (Fast Load)
          </button>
        )}
      </div>

      <div style={{ borderTop: '1px solid #333', margin: '5px 0' }}></div>

      {/* 2. ë§µ ìŠ¤í‚¨ ì„¤ì • */}
      <div style={{ background: '#161b22', padding: '15px', borderRadius: '8px', border: '1px solid #30363d' }}>
        <h4 style={{ margin:'0 0 10px 0', color:'#2ecc71', display:'flex', alignItems:'center', gap:'6px', fontSize:'14px' }}>
          <MapIcon size={16}/> ì „ì¥(Map) ìŠ¤í‚¨ ì„¤ì •
        </h4>
        <div style={{ fontSize: '11px', color: '#8b949e', marginBottom: '10px' }}>
          AIë¡œ ìƒì„±í•œ ë§µ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ë©´ ê´€ì „ ë°°ê²½ì— ì ìš©ë©ë‹ˆë‹¤.
        </div>
        <div style={{ display: 'flex', gap: '10px' }}>
          <button onClick={() => mapInputRef.current?.click()} className="btn" style={{ flex: 2, background: '#238636', color: '#fff', border:'none', fontSize:'12px', display:'flex', alignItems:'center', justifyContent:'center', gap:'6px' }}>
            <ImageIcon size={14}/> ë§µ ì´ë¯¸ì§€ ì—…ë¡œë“œ
          </button>
          <button onClick={handleMapReset} className="btn" style={{ flex: 1, background: '#3f1515', color: '#ff6b6b', border:'1px solid #5a1e1e', fontSize:'12px', display:'flex', alignItems:'center', justifyContent:'center', gap:'6px' }}>
            <Trash2 size={14}/> ì´ˆê¸°í™”
          </button>
          <input type="file" ref={mapInputRef} onChange={handleMapUpload} style={{ display: 'none' }} accept="image/*" />
        </div>
      </div>

      <div style={{ borderTop: '1px solid #333', margin: '5px 0' }}></div>

      {/* 3. AI ì„¤ì • */}
      <div style={{ background: '#161b22', padding: '15px', borderRadius: '8px', border: '1px solid #30363d' }}>
        <h4 style={{ margin:'0 0 15px 0', color:'#58a6ff', display:'flex', alignItems:'center', gap:'6px', fontSize:'14px' }}>
          <Bot size={16}/> ì»¤ë®¤ë‹ˆí‹° AI ì„¤ì •
        </h4>
        <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:'12px' }}>
          <span style={{ fontSize:'13px', color:'#fff' }}>AI ê¸€ì‘ì„± í™œì„±í™”</span>
          <input type="checkbox" checked={aiSettings.enabled} onChange={e => setAiSettings({...aiSettings, enabled: e.target.checked})} style={{ transform:'scale(1.2)', cursor:'pointer' }}/>
        </div>
        <div style={{ marginBottom:'12px' }}>
          <div style={{ fontSize:'11px', color:'#8b949e', marginBottom:'4px' }}>API Key</div>
          <input type="password" value={aiSettings.apiKey} onChange={e => setAiSettings({...aiSettings, apiKey: e.target.value})} placeholder="API í‚¤ ì…ë ¥..." style={{ width:'100%', padding:'8px', background:'#0d1117', border:'1px solid #30363d', color:'#fff', borderRadius:'4px', boxSizing:'border-box' }}/>
        </div>
        <button onClick={saveAISettings} className="btn" style={{ width:'100%', background:'#1f6feb', color:'#fff', display:'flex', justifyContent:'center', alignItems:'center', gap:'6px', padding:'10px' }}>
          <CheckCircle size={16}/> ì„¤ì • ì €ì¥
        </button>
      </div>

      <div style={{ borderTop: '1px solid #333', margin: '5px 0' }}></div>

      {/* 4. íŒŒì¼ ê´€ë¦¬ */}
      <h4 style={{ margin:'0 0 10px 0', color:'#ccc' }}>íŒŒì¼ ê´€ë¦¬</h4>
      <div style={{ display: 'flex', gap: '10px', marginBottom:'10px' }}>
        <button onClick={handleExportMod} className="btn" style={{ flex: 1, background: '#30363d', color: '#ccc', border:'1px solid #444', fontSize:'12px', display:'flex', alignItems:'center', justifyContent:'center', gap:'6px' }}>
          <Download size={14}/> MOD ë‚´ë³´ë‚´ê¸°
        </button>
        <button onClick={() => modInputRef.current?.click()} className="btn" style={{ flex: 1, background: '#30363d', color: '#ccc', border:'1px solid #444', fontSize:'12px', display:'flex', alignItems:'center', justifyContent:'center', gap:'6px' }}>
          <Upload size={14}/> MOD ì ìš©
        </button>
        <input type="file" ref={modInputRef} onChange={handleImportMod} style={{ display: 'none' }} accept=".json" />
      </div>
      <div style={{ display: 'flex', gap: '10px' }}>
        <button onClick={exportSaveFile} className="btn" style={{ flex:1, background: '#30363d', border:'1px solid #444', color: '#ccc', padding: '10px', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px', fontSize:'12px' }}>
          <Download size={14} /> ì„¸ì´ë¸Œ ë°±ì—…
        </button>
        <button onClick={() => fileInputRef.current?.click()} className="btn" style={{ flex:1, background: '#30363d', border:'1px solid #444', color: '#ccc', padding: '10px', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px', fontSize:'12px' }}>
          <Upload size={14} /> ì„¸ì´ë¸Œ ë³µêµ¬
        </button>
        <input type="file" ref={fileInputRef} onChange={async (e) => {
          const file = e.target.files?.[0];
          if(file && await importSaveFile(file, heroes)) { alert('ë¡œë“œ ì„±ê³µ!'); window.location.reload(); }
        }} style={{ display: 'none' }} accept=".json" />
      </div>

      <div style={{ borderTop: '1px solid #333', margin: '10px 0' }}></div>

      {/* 5. ì´ˆê¸°í™” */}
      <h4 style={{ margin:'0 0 10px 0', color:'#da3633' }}>ìœ„í—˜ êµ¬ì—­</h4>
      <div style={{ display:'flex', gap:'10px' }}>
        <button onClick={handleSafeReset} className="btn" style={{ flex:1, background: '#da3633', color: '#fff', display:'flex', alignItems:'center', justifyContent:'center', gap:'8px' }}>
          <Trash2 size={16} /> ê²Œì„ ì¬ì‹œì‘
        </button>
        <button onClick={handleStatReset} className="btn" style={{ flex:1, background: '#d29922', color: '#000', display:'flex', alignItems:'center', justifyContent:'center', gap:'8px', fontWeight:'bold' }}>
          <RefreshCw size={16} /> í†µê³„ ì´ˆê¸°í™”
        </button>
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/system/SaveLoadTab.tsx
==========================================
import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { saveToSlot, loadFromSlot, getSlotsMeta, deleteSlot, SaveMeta } from '../../engine/SaveLoadSystem';
import { Trash2, Clock, Calendar, Loader2 } from 'lucide-react';

interface Props {
  mode: 'SAVE' | 'LOAD'; 
}

export const SaveLoadTab: React.FC<Props> = ({ mode }) => {
  const { heroes } = useGameStore();
  const [slots, setSlots] = useState<Record<string, SaveMeta>>({});
  const [isProcessing, setIsProcessing] = useState(false);

  useEffect(() => {
    setSlots(getSlotsMeta());
  }, []);

  const refreshSlots = () => {
    setSlots(getSlotsMeta());
  };

  const handleSave = async (slotId: string) => {
    if (isProcessing) return;
    setIsProcessing(true);
    
    const success = await saveToSlot(slotId);
    if (success) {
      // [ìˆ˜ì •] ë°±í‹±ê³¼ ë³€ìˆ˜ ì•ì˜ ì—­ìŠ¬ë˜ì‹œ ì œê±° (ì˜¬ë°”ë¥¸ JS ë¬¸ë²•)
      alert(`${slotId === 'auto' ? 'ìë™ ì €ì¥' : `ìŠ¬ë¡¯ ${slotId}`}ì— ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);
      refreshSlots();
    }
    setIsProcessing(false);
  };

  const handleLoad = async (slotId: string) => {
    if (isProcessing) return;
    if (!slots[slotId]) return;

    // [ìˆ˜ì •] ë°±í‹±ê³¼ ë³€ìˆ˜ ì•ì˜ ì—­ìŠ¬ë˜ì‹œ ì œê±°
    if (confirm(`[Slot ${slotId}] ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
      setIsProcessing(true);
      
      const success = await loadFromSlot(slotId, heroes);
      
      // ë¡œë“œ ì„±ê³µ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ í”„ë¡œì„¸ì‹± ìƒíƒœ í•´ì œ (í™”ë©´ì€ ì—”ì§„ì´ ì´ë¯¸ ê°±ì‹ í•¨)
      setIsProcessing(false);
    }
  };

  const handleDelete = async (e: React.MouseEvent, slotId: string) => {
    e.stopPropagation();
    if (confirm('ì´ ìŠ¬ë¡¯ì˜ ë°ì´í„°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
      await deleteSlot(slotId);
      refreshSlots();
    }
  };

  const SlotItem = ({ id, label, isAuto = false }: { id: string, label: string, isAuto?: boolean }) => {
    const meta = slots[id];
    const isEmpty = !meta;

    return (
      <div 
        onClick={() => mode === 'SAVE' ? handleSave(id) : handleLoad(id)}
        style={{ 
          background: isEmpty ? '#222' : '#2a2a2e', 
          border: '1px solid #444', 
          borderRadius: '8px', 
          padding: '15px', 
          marginBottom: '10px',
          cursor: isProcessing ? 'wait' : 'pointer',
          display: 'flex', justifyContent: 'space-between', alignItems: 'center',
          transition: '0.2s',
          opacity: (mode === 'LOAD' && isEmpty) || isProcessing ? 0.5 : 1,
          pointerEvents: (mode === 'LOAD' && isEmpty) || isProcessing ? 'none' : 'auto'
        }}
        onMouseEnter={e => e.currentTarget.style.borderColor = '#58a6ff'}
        onMouseLeave={e => e.currentTarget.style.borderColor = '#444'}
      >
        <div style={{ display: 'flex', alignItems: 'center', gap: '15px' }}>
          <div style={{ 
            width: '40px', height: '40px', borderRadius: '50%', 
            background: isAuto ? '#e89d40' : '#58a6ff', color: '#000',
            display: 'flex', alignItems: 'center', justifyContent: 'center', fontWeight: 'bold' 
          }}>
            {isAuto ? 'A' : id}
          </div>
          <div>
            <div style={{ fontWeight: 'bold', color: isEmpty ? '#777' : '#fff', fontSize: '14px', marginBottom:'4px' }}>
              {label}
            </div>
            {isEmpty ? (
              <div style={{ fontSize: '12px', color: '#555' }}>ë¹„ì–´ ìˆìŒ</div>
            ) : (
              <div style={{ display:'flex', flexDirection:'column', gap:'2px' }}>
                <div style={{ fontSize: '12px', color: '#e89d40', fontWeight:'bold', display:'flex', alignItems:'center', gap:'4px' }}>
                   {/* [ìˆ˜ì •] ì—¬ê¸°ë„ ì—­ìŠ¬ë˜ì‹œ ì œê±° */}
                   <Clock size={12}/> {meta.gameTimeDisplay || `S${meta.season} Day${meta.day}`}
                </div>
                <div style={{ fontSize: '11px', color: '#888', display:'flex', alignItems:'center', gap:'4px' }}>
                   <Calendar size={11}/> {meta.realDateStr || new Date(meta.timestamp).toLocaleString()}
                </div>
                <div style={{ fontSize:'11px', color:'#666' }}>ìœ ì € {meta.totalUsers.toLocaleString()}ëª…</div>
              </div>
            )}
          </div>
        </div>

        <div style={{ display:'flex', gap:'10px', alignItems:'center' }}>
            {isProcessing ? <Loader2 size={16} className="animate-spin text-white"/> : (
              <>
                {mode === 'SAVE' && (
                    <div style={{ fontSize:'12px', color:'#58a6ff', fontWeight:'bold' }}>
                        {isEmpty ? 'ì €ì¥í•˜ê¸°' : 'ë®ì–´ì“°ê¸°'}
                    </div>
                )}
                {!isEmpty && mode === 'SAVE' && (
                    <button onClick={(e) => handleDelete(e, id)} style={{ background:'none', border:'none', color:'#da3633', cursor:'pointer' }}>
                        <Trash2 size={16} />
                    </button>
                )}
              </>
            )}
        </div>
      </div>
    );
  };

  return (
    <>
      <div style={{ fontSize:'12px', color:'#888', marginBottom:'15px', textAlign:'center' }}>
        {mode === 'SAVE' ? 'ìŠ¬ë¡¯ì„ ì„ íƒí•˜ì—¬ ì €ì¥í•˜ì„¸ìš”.' : 'ë¶ˆëŸ¬ì˜¬ ìŠ¬ë¡¯ì„ ì„ íƒí•˜ì„¸ìš”.'}
      </div>

      <SlotItem id="auto" label="ìë™ ì €ì¥ ìŠ¬ë¡¯ (Auto)" isAuto />
      <div style={{ height:'10px' }}></div>
      <SlotItem id="1" label="ì €ì¥ ìŠ¬ë¡¯ 1" />
      <SlotItem id="2" label="ì €ì¥ ìŠ¬ë¡¯ 2" />
      <SlotItem id="3" label="ì €ì¥ ìŠ¬ë¡¯ 3" />
      
      <style>{`
        .animate-spin { animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
      `}</style>
    </>
  );
};



==========================================
FILE PATH: src/components/system/SystemMenu.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/common/SystemMenu.tsx
// ==========================================

import React, { useState } from 'react';
import { Save, Disc, AlertTriangle, X } from 'lucide-react';

// ë¶„ë¦¬í•œ ì»´í¬ë„ŒíŠ¸ import
import { OptionTab } from '../system/OptionTab';
import { SaveLoadTab } from '../system/SaveLoadTab';

interface Props { onClose: () => void; }

export const SystemMenu: React.FC<Props> = ({ onClose }) => {
  const [activeTab, setActiveTab] = useState<'SAVE' | 'LOAD' | 'OPTION'>('SAVE');

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };

  return (
    <div 
      onClick={handleBackdropClick} 
      style={{
        position: 'fixed', top: 0, left: 0, width: '100%', height: '100%',
        backgroundColor: 'rgba(0,0,0,0.85)', display: 'flex', justifyContent: 'center', alignItems: 'center', zIndex: 9999,
        backdropFilter: 'blur(5px)',
        padding: '10px' 
      }}
    >
      <div className="panel" style={{ 
        width: '100%', maxWidth: '450px', maxHeight: '90vh',
        background: '#1c1c1f', border: '1px solid #30363d', 
        display:'flex', flexDirection:'column', padding:0,
        overflow: 'hidden', borderRadius: '12px'
      }}>

        {/* í—¤ë” */}
        <div style={{ 
          padding: '15px 20px', borderBottom: '1px solid #333', 
          display: 'flex', justifyContent: 'space-between', alignItems: 'center', 
          background: '#252528', flexShrink: 0 
        }}>
          <h3 style={{ margin: 0, color: '#fff', fontSize: '16px' }}>ì‹œìŠ¤í…œ ë©”ë‰´</h3>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#fff', cursor: 'pointer', padding:'5px' }}>
            <X size={24} />
          </button>
        </div>

        {/* íƒ­ ë²„íŠ¼ */}
        <div style={{ display: 'flex', background: '#161b22', borderBottom: '1px solid #333', flexShrink: 0 }}>
          {([
            { id: 'SAVE', label: 'ì €ì¥', icon: Save },
            { id: 'LOAD', label: 'ë¶ˆëŸ¬ì˜¤ê¸°', icon: Disc },
            { id: 'OPTION', label: 'ì˜µì…˜', icon: AlertTriangle }
          ] as const).map(t => (
            <button
              key={t.id}
              onClick={() => setActiveTab(t.id)}
              style={{
                flex: 1, padding: '15px', background: 'none', border: 'none',
                borderBottom: activeTab === t.id ? '2px solid #58a6ff' : '2px solid transparent',
                color: activeTab === t.id ? '#fff' : '#777', fontWeight: 'bold', cursor: 'pointer',
                display:'flex', alignItems:'center', justifyContent:'center', gap:'8px'
              }}
            >
              <t.icon size={16} /> {t.label}
            </button>
          ))}
        </div>

        {/* ë©”ì¸ ì»¨í…ì¸  ì˜ì—­ (ë¶„ë¦¬ëœ ì»´í¬ë„ŒíŠ¸ ë Œë”ë§) */}
        <div style={{ flex: 1, overflowY: 'auto', padding: '20px' }}>
          {activeTab === 'SAVE' && <SaveLoadTab mode="SAVE" />}
          {activeTab === 'LOAD' && <SaveLoadTab mode="LOAD" />}
          {activeTab === 'OPTION' && <OptionTab />}
        </div>

      </div>
    </div>
  );
};


==========================================
FILE PATH: src/components/user/detail/MatchHistoryList.tsx
==========================================
import React from 'react';
import { UserProfile } from '../../../types';
import { GameIcon } from '../../common/GameIcon';
import { Trophy, Skull, Crosshair } from 'lucide-react';

interface Props { user: UserProfile; heroes: any[]; }

export const MatchHistoryList: React.FC<Props> = ({ user, heroes }) => {
  const champStats = Object.entries(user.heroStats || {})
    .map(([id, stat]) => ({ id, hero: heroes.find(h => h.id === id), stat }))
    .sort((a, b) => b.stat.matches - a.stat.matches)
    .slice(0, 3);

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '20px' }}>
      
      {/* ëª¨ìŠ¤íŠ¸ ì±”í”¼ì–¸ ì¹´ë“œ */}
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '10px' }}>
        {champStats.map((item, idx) => {
          const wr = item.stat.matches > 0 ? (item.stat.wins / item.stat.matches) * 100 : 0;
          return (
            <div key={idx} style={{ background: '#1c1c1f', borderRadius: '12px', padding: '12px', border: '1px solid #30363d', display:'flex', flexDirection:'column', alignItems:'center', gap:'8px' }}>
              <div style={{ position:'relative' }}>
                <GameIcon id={item.id} size={48} shape="rounded" />
                <div style={{ position:'absolute', bottom:-5, right:-5, background:'#0d1117', border:'1px solid #333', borderRadius:'50%', width:'20px', height:'20px', display:'flex', alignItems:'center', justifyContent:'center', fontSize:'10px', fontWeight:'bold', color: idx===0?'#f1c40f':'#ccc' }}>
                  {idx+1}
                </div>
              </div>
              <div style={{ textAlign:'center' }}>
                <div style={{ fontSize:'12px', fontWeight:'bold', color:'#fff' }}>{item.hero?.name}</div>
                <div style={{ fontSize:'10px', color:'#888' }}>{item.stat.matches}ì „</div>
                <div style={{ fontSize:'12px', fontWeight:'900', color: wr >= 60 ? '#da3633' : wr >= 50 ? '#fff' : '#888' }}>{wr.toFixed(0)}%</div>
              </div>
            </div>
          );
        })}
        {champStats.length === 0 && <div style={{ gridColumn: '1/-1', textAlign:'center', padding:'20px', color:'#555', fontSize:'13px' }}>í”Œë ˆì´ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>}
      </div>

      {/* ìµœê·¼ ì „ì  ë¦¬ìŠ¤íŠ¸ */}
      <div>
        <h4 style={{ margin: '0 0 10px 0', fontSize: '13px', color: '#ccc' }}>ìµœê·¼ ì „ì  (Recent Matches)</h4>
        <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
          {user.history.map((match, idx) => {
            const isWin = match.result === 'WIN' || match.result === 'PROMO WIN';
            const bgColor = isWin ? 'rgba(46, 204, 113, 0.1)' : 'rgba(231, 76, 60, 0.1)';
            const barColor = isWin ? '#2ecc71' : '#e74c3c';
            
            return (
              <div key={idx} style={{ display: 'flex', background: bgColor, borderRadius: '6px', overflow: 'hidden', height: '56px' }}>
                <div style={{ width: '6px', background: barColor }} />
                <div style={{ flex: 1, padding: '0 12px', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                  
                  {/* ì™¼ìª½: ê²°ê³¼ & ì˜ì›… */}
                  <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                    <div style={{ display:'flex', flexDirection:'column' }}>
                      <span style={{ fontSize: '13px', fontWeight: '900', color: barColor }}>{isWin ? 'ìŠ¹ë¦¬' : 'íŒ¨ë°°'}</span>
                      <span style={{ fontSize: '10px', color: '#aaa' }}>{match.date.split(' ')[1]}</span>
                    </div>
                    {/* ì˜ì›… ì´ë¦„ (ì¶”í›„ ì•„ì´ì½˜ìœ¼ë¡œ ëŒ€ì²´ ê°€ëŠ¥) */}
                    <div style={{ fontSize: '13px', fontWeight: 'bold', color: '#fff' }}>{match.heroName}</div>
                  </div>

                  {/* ì˜¤ë¥¸ìª½: KDA & LP */}
                  <div style={{ textAlign: 'right' }}>
                    <div style={{ fontSize: '14px', fontWeight: 'bold', color: '#fff', fontFamily:'monospace' }}>{match.kda}</div>
                    <div style={{ fontSize: '11px', fontWeight: 'bold', color: match.lpChange > 0 ? '#f1c40f' : '#888' }}>
                      {match.lpChange > 0 ? `+${match.lpChange}` : match.lpChange} LP
                    </div>
                  </div>

                </div>
              </div>
            );
          })}
          {user.history.length === 0 && <div style={{ textAlign:'center', padding:'30px', color:'#555', fontSize:'12px' }}>ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>}
        </div>
      </div>

    </div>
  );
};



==========================================
FILE PATH: src/components/user/detail/ProfileHeader.tsx
==========================================
import React from 'react';
import { UserProfile } from '../../../types';
import { X, Award, Hash } from 'lucide-react';
import { GameIcon } from '../../common/GameIcon';

interface Props {
  user: UserProfile;
  onClose: () => void;
  heroImage?: string; // ë°°ê²½ìš© ì´ë¯¸ì§€ URL
}

const getTierColor = (tier: string) => {
  if (tier.includes('ì±Œë¦°ì €') || tier.includes('ì²œìƒê³„')) return '#00bfff';
  if (tier.includes('ë§ˆìŠ¤í„°')) return '#9b59b6';
  if (tier.includes('ì—ì´ìŠ¤')) return '#e74c3c';
  if (tier.includes('ì¡°ì»¤')) return '#2ecc71';
  if (tier.includes('ê³¨ë“œ')) return '#f1c40f';
  if (tier.includes('ì‹¤ë²„')) return '#95a5a6';
  return '#cd7f32'; // ë¸Œë¡ ì¦ˆ
};

export const ProfileHeader: React.FC<Props> = ({ user, onClose, heroImage }) => {
  const tierColor = getTierColor(user.tier);
  const level = Math.floor(user.totalGames / 10) + 1;

  return (
    <div style={{ 
      position: 'relative', 
      padding: '30px 25px', 
      overflow: 'hidden', 
      borderBottom: '1px solid #333',
      background: '#161b22'
    }}>
      {/* ë°°ê²½ ì´ë¯¸ì§€ (ì–´ë‘¡ê²Œ ì²˜ë¦¬) */}
      <div style={{
        position: 'absolute', inset: 0,
        backgroundImage: heroImage ? `url(${heroImage})` : 'none',
        backgroundSize: 'cover', backgroundPosition: 'center 20%',
        opacity: 0.25, filter: 'blur(2px)', zIndex: 0
      }} />
      
      {/* ê·¸ë¼ë°ì´ì…˜ ì˜¤ë²„ë ˆì´ */}
      <div style={{ position: 'absolute', inset: 0, background: 'linear-gradient(to right, #0d1117 10%, rgba(13,17,23,0.6) 100%)', zIndex: 1 }} />

      <div style={{ position: 'relative', zIndex: 10, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '20px' }}>
          
          {/* í”„ë¡œí•„ ì•„ì´ì½˜ */}
          <div style={{ position: 'relative' }}>
            <div style={{ 
              width: '80px', height: '80px', borderRadius: '24px', 
              background: '#0d1117', border: `3px solid ${tierColor}`, 
              overflow: 'hidden', boxShadow: `0 0 20px ${tierColor}44`
            }}>
              <GameIcon id={user.mainHeroId} size="100%" />
            </div>
            <div style={{ 
              position: 'absolute', bottom: -10, left: '50%', transform: 'translateX(-50%)',
              background: '#21262d', color: '#fff', fontSize: '11px', fontWeight: 'bold',
              padding: '2px 8px', borderRadius: '10px', border: '1px solid #444', whiteSpace: 'nowrap'
            }}>
              Lv.{level}
            </div>
          </div>

          {/* ìœ ì € ì •ë³´ í…ìŠ¤íŠ¸ */}
          <div>
            <h1 style={{ margin: 0, fontSize: '28px', color: '#fff', fontWeight: '900', letterSpacing: '-0.5px', textShadow: '0 2px 4px rgba(0,0,0,0.5)' }}>
              {user.name}
            </h1>
            <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginTop: '6px' }}>
              <span style={{ 
                color: tierColor, fontWeight: '800', fontSize: '14px', 
                display: 'flex', alignItems: 'center', gap: '4px',
                background: `${tierColor}11`, padding: '2px 8px', borderRadius: '4px', border: `1px solid ${tierColor}44`
              }}>
                <Award size={14}/> {user.tier}
              </span>
              <span style={{ color: '#8b949e', fontSize: '13px', fontWeight: 'bold' }}>
                {user.score.toLocaleString()} LP
              </span>
              <span style={{ color: '#444' }}>|</span>
              <span style={{ color: '#8b949e', fontSize: '13px' }}>
                ë­í‚¹ {user.rank > 0 ? `${user.rank}ìœ„` : 'Unranked'}
              </span>
            </div>
          </div>
        </div>

        <button onClick={onClose} style={{ 
          background: 'rgba(255,255,255,0.1)', border: 'none', color: '#fff', 
          width: '36px', height: '36px', borderRadius: '50%', 
          cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center',
          backdropFilter: 'blur(4px)'
        }}>
          <X size={20} />
        </button>
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/user/detail/StatsOverview.tsx
==========================================
import React from 'react';
import { UserProfile } from '../../../types';
import { TrendingUp, Target, Brain, Zap, Activity } from 'lucide-react';

interface Props { user: UserProfile; }

export const StatsOverview: React.FC<Props> = ({ user }) => {
  // ìŠ¤íƒ¯ ê³„ì‚° (0~100)
  const combat = Math.min(100, user.winRate + 40);
  const brain = user.brain || 50;
  const mechanics = user.mechanics || 50;
  const activity = Math.min(100, 50 + (user.activityBias * 100));
  const potential = Math.min(100, (user.hiddenMmr / 3000) * 100);

  const getBarColor = (val: number) => {
    if (val >= 80) return '#e74c3c'; // ìµœìƒìœ„ (ë¹¨ê°•)
    if (val >= 60) return '#f1c40f'; // ìƒìœ„ (ë…¸ë‘)
    if (val >= 40) return '#2ecc71'; // ì¤‘ìœ„ (ì´ˆë¡)
    return '#8b949e'; // í•˜ìœ„ (íšŒìƒ‰)
  };

  const StatBar = ({ label, value, icon }: any) => (
    <div style={{ marginBottom: '8px' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '11px', color: '#ccc', marginBottom: '2px' }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>{icon} {label}</div>
        <span style={{ fontWeight: 'bold', color: getBarColor(value) }}>{value.toFixed(0)}</span>
      </div>
      <div style={{ width: '100%', height: '6px', background: '#30363d', borderRadius: '3px', overflow: 'hidden' }}>
        <div style={{ width: `${value}%`, height: '100%', background: getBarColor(value), borderRadius: '3px' }} />
      </div>
    </div>
  );

  // ì„±í–¥ íƒœê·¸ ìƒì„±
  const tags = [];
  if (user.playStyle === 'HARDCORE') tags.push({ label: 'ğŸ”¥ íì¸', color: '#da3633' });
  if (user.playStyle === 'WORKER') tags.push({ label: 'ğŸ’¼ ì§ì¥ì¸', color: '#3498db' });
  if (user.playStyle === 'STUDENT') tags.push({ label: 'ğŸ“ ê¸‰ì‹', color: '#f1c40f' });
  if (user.playStyle === 'NIGHT_OWL') tags.push({ label: 'ğŸŒ™ ì˜¬ë¹¼ë¯¸', color: '#9b59b6' });
  
  if (user.winRate >= 55) tags.push({ label: 'ğŸ† ìŠ¹ë¦¬ì™•', color: '#e74c3c' });
  else if (user.winRate <= 45) tags.push({ label: 'ğŸ“‰ ì—°íŒ¨ì¤‘', color: '#7f8c8d' });

  if (brain > 70) tags.push({ label: 'ğŸ§  ë‡Œì§€ì»¬', color: '#2ecc71' });
  if (mechanics > 70) tags.push({ label: 'âš¡ í”¼ì§€ì»¬', color: '#e67e22' });

  return (
    <div style={{ background: '#1c1c1f', borderRadius: '12px', padding: '20px', border: '1px solid #30363d' }}>
      <h3 style={{ margin: '0 0 15px 0', fontSize: '14px', color: '#fff', display: 'flex', alignItems: 'center', gap: '6px' }}>
        <Activity size={16} color="#58a6ff"/> í”Œë ˆì´ì–´ ë¶„ì„
      </h3>

      <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px', marginBottom: '20px' }}>
        {tags.map((t, i) => (
          <span key={i} style={{ fontSize: '11px', color: t.color, border: `1px solid ${t.color}44`, background: `${t.color}11`, padding: '2px 8px', borderRadius: '10px', fontWeight: 'bold' }}>
            {t.label}
          </span>
        ))}
      </div>

      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '15px' }}>
        <StatBar label="ì „íˆ¬ë ¥" value={combat} icon={<TrendingUp size={10}/>} />
        <StatBar label="ìš´ì˜ëŠ¥ë ¥" value={brain} icon={<Brain size={10}/>} />
        <StatBar label="ì»¨íŠ¸ë¡¤" value={mechanics} icon={<Zap size={10}/>} />
        <StatBar label="ì„±ì¥ë ¥" value={potential} icon={<Target size={10}/>} />
      </div>
      
      <div style={{ marginTop: '15px', paddingTop: '15px', borderTop: '1px dashed #30363d', fontSize: '11px', color: '#888', textAlign: 'center' }}>
        * ìµœê·¼ 50ê²½ê¸° ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ AIê°€ ë¶„ì„í•œ ì§€í‘œì…ë‹ˆë‹¤.
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/user/TierSettingsModal.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/user/TierSettingsModal.tsx
// ==========================================

import React, { useState } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { X, Save, Settings, Trophy, Swords } from 'lucide-react';
import { TierConfig } from '../../types';

export const TierSettingsModal = ({ onClose }: { onClose: () => void }) => {
  const { gameState, updateTierConfig } = useGameStore();

  // [ìˆ˜ì •] ê¸°ì¡´ ì„¸ì´ë¸Œ íŒŒì¼ í˜¸í™˜ì„± ì²˜ë¦¬ (promosê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì£¼ì…)
  const [config, setConfig] = useState<TierConfig>(() => {
    const current = gameState.tierConfig;
    // ë§Œì•½ promos ê°ì²´ê°€ ì—†ë‹¤ë©´(êµ¬ë²„ì „ ë°ì´í„°ë¼ë©´) ê¸°ë³¸ê°’ìœ¼ë¡œ ì´ˆê¸°í™”
    if (!current.promos) {
      return {
        ...current,
        promos: {
          master: 5,
          ace: 5,
          joker: 5,
          gold: 3,
          silver: 3,
          bronze: 3
        }
      };
    }
    return current;
  });

  const handleSave = () => {
    updateTierConfig(config);
    alert('í‹°ì–´ ì‹œìŠ¤í…œ ì„¤ì •ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.\në‹¤ìŒ ìŠ¹ê¸‰ì „ë¶€í„° ì ìš©ë©ë‹ˆë‹¤.');
    onClose();
  };

  const handlePromoChange = (tier: keyof TierConfig['promos'], value: number) => {
    setConfig(prev => ({
      ...prev,
      promos: { ...prev.promos, [tier]: value }
    }));
  };

  // í‹°ì–´ë³„ ì„¤ì • í–‰ ì»´í¬ë„ŒíŠ¸
  const TierRow = ({ label, keyName, color, promoKey }: { label: string, keyName: keyof TierConfig, color: string, promoKey: keyof TierConfig['promos'] }) => (
    <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:'12px', background:'#252528', padding:'10px', borderRadius:'8px', border:'1px solid #333' }}>

      {/* ì™¼ìª½: í‹°ì–´ ì´ë¦„ ë° ì»¤íŠ¸ë¼ì¸ */}
      <div style={{ display:'flex', alignItems:'center', gap:'15px' }}>
        <div style={{ display:'flex', alignItems:'center', gap:'10px', width:'100px' }}>
          <div style={{ width:'12px', height:'12px', borderRadius:'50%', background:color }}></div>
          <span style={{ color: color, fontWeight:'bold', fontSize:'14px' }}>{label}</span>
        </div>
        <div style={{ display:'flex', alignItems:'center', gap:'6px' }}>
          <input 
            type="number" 
            value={config[keyName] as number} 
            onChange={(e) => setConfig({ ...config, [keyName]: parseInt(e.target.value) })}
            style={{ background:'#0d1117', border:'1px solid #444', color:'#fff', padding:'6px', borderRadius:'4px', width:'70px', textAlign:'right', fontWeight:'bold' }}
          />
          <span style={{ fontSize:'12px', color:'#888' }}>LP</span>
        </div>
      </div>

      {/* ì˜¤ë¥¸ìª½: ìŠ¹ê¸‰ì „ íŒìˆ˜ ì„ íƒ */}
      <div style={{ display:'flex', alignItems:'center', gap:'8px' }}>
        <Swords size={14} color="#666" />
        <select 
          value={config.promos ? config.promos[promoKey] : 3} // ì•ˆì „í•˜ê²Œ ì ‘ê·¼
          onChange={(e) => handlePromoChange(promoKey, parseInt(e.target.value))}
          style={{ background:'#0d1117', border:'1px solid #444', color:'#ccc', padding:'4px 8px', borderRadius:'4px', fontSize:'12px', cursor:'pointer' }}
        >
          <option value={3}>3ì „ 2ì„ ìŠ¹</option>
          <option value={5}>5ì „ 3ì„ ìŠ¹</option>
          <option value={7}>7ì „ 4ì„ ìŠ¹</option>
          <option value={9}>9ì „ 5ì„ ìŠ¹</option>
        </select>
      </div>
    </div>
  );

  return (
    <div style={{ position:'fixed', top:0, left:0, width:'100%', height:'100%', background:'rgba(0,0,0,0.85)', display:'flex', justifyContent:'center', alignItems:'center', zIndex:2000, backdropFilter:'blur(5px)' }}>
      <div className="panel" style={{ width:'500px', background:'#161b22', border:'1px solid #30363d', borderRadius:'12px', padding:0, overflow:'hidden', boxShadow:'0 20px 50px rgba(0,0,0,0.5)' }}>

        {/* í—¤ë” */}
        <div style={{ padding:'20px', background:'#21262d', borderBottom:'1px solid #333', display:'flex', justifyContent:'space-between', alignItems:'center' }}>
          <h3 style={{ margin:0, display:'flex', alignItems:'center', gap:'10px', color:'#fff', fontSize:'16px' }}>
            <Settings size={18} /> ë­í¬ ì‹œìŠ¤í…œ ì„¤ì •
          </h3>
          <button onClick={onClose} style={{ background:'none', border:'none', color:'#888', cursor:'pointer' }}><X size={20}/></button>
        </div>

        <div style={{ padding:'20px' }}>

          {/* 1. ì±Œë¦°ì € ì„¤ì • */}
          <div style={{ marginBottom:'20px', paddingBottom:'15px', borderBottom:'1px dashed #333' }}>
            <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center' }}>
              <div style={{ display:'flex', alignItems:'center', gap:'10px' }}>
                <Trophy size={16} color="#00bfff" />
                <span style={{ color:'#00bfff', fontWeight:'bold' }}>ì±Œë¦°ì € ì •ì› (Ranking)</span>
              </div>
              <div style={{ display:'flex', alignItems:'center', gap:'6px' }}>
                <span style={{ fontSize:'12px', color:'#888' }}>ìƒìœ„</span>
                <input 
                  type="number" 
                  value={config.challengerRank} 
                  onChange={(e) => setConfig({ ...config, challengerRank: parseInt(e.target.value) })}
                  style={{ background:'#00bfff22', border:'1px solid #00bfff', color:'#fff', padding:'6px', borderRadius:'4px', width:'60px', textAlign:'center', fontWeight:'bold' }}
                />
                <span style={{ fontSize:'12px', color:'#888' }}>ìœ„</span>
              </div>
            </div>
            <div style={{ fontSize:'11px', color:'#666', marginTop:'8px', marginLeft:'26px' }}>
              * ë§ˆìŠ¤í„° í‹°ì–´ ì ìˆ˜ë¥¼ ë„˜ê¸´ ìœ ì € ì¤‘, ì„¤ì •ëœ ë“±ìˆ˜ ì•ˆì— ë“¤ì–´ì•¼ ì±Œë¦°ì €ê°€ ë©ë‹ˆë‹¤.
            </div>
          </div>

          {/* 2. í‹°ì–´ë³„ ì»¤íŠ¸ë¼ì¸ ë° ìŠ¹ê¸‰ì „ ì„¤ì • */}
          <div style={{ display:'flex', flexDirection:'column', gap:'5px', maxHeight:'400px', overflowY:'auto' }}>
            {config.promos && (
              <>
                <TierRow label="ë§ˆìŠ¤í„°" keyName="master" color="#9b59b6" promoKey="master" />
                <TierRow label="ì—ì´ìŠ¤" keyName="ace" color="#e74c3c" promoKey="ace" />
                <TierRow label="ì¡°ì»¤" keyName="joker" color="#2ecc71" promoKey="joker" />
                <TierRow label="ê³¨ë“œ" keyName="gold" color="#f1c40f" promoKey="gold" />
                <TierRow label="ì‹¤ë²„" keyName="silver" color="#95a5a6" promoKey="silver" />
                <TierRow label="ë¸Œë¡ ì¦ˆ" keyName="bronze" color="#d35400" promoKey="bronze" />
              </>
            )}
          </div>

        </div>

        <div style={{ padding:'20px', borderTop:'1px solid #333', background:'#21262d' }}>
          <button className="btn" style={{ width:'100%', background:'#238636', color:'#fff', display:'flex', justifyContent:'center', gap:'8px', padding:'12px', fontSize:'14px', borderRadius:'8px', border:'none', cursor:'pointer', fontWeight:'bold' }} onClick={handleSave}>
            <Save size={18} /> ì„¤ì • ì €ì¥í•˜ê¸°
          </button>
        </div>
      </div>
    </div>
  );
};


==========================================
FILE PATH: src/components/user/TierUserListModal.tsx
==========================================
import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { getUsersInTier } from '../../engine/system/UserManager';
import { UserProfile } from '../../types';
import { X, Trophy } from 'lucide-react';

interface Props {
  tierName: string;
  onClose: () => void;
  onUserClick: (u: UserProfile) => void;
}

export const TierUserListModal: React.FC<Props> = ({ tierName, onClose, onUserClick }) => {
  const { gameState } = useGameStore();
  const [users, setUsers] = useState<UserProfile[]>([]);

  useEffect(() => {
    const fetchUsers = () => {
      // getUsersInTierëŠ” ì´ì œ ë‚´ë¶€ì ìœ¼ë¡œ í—¬í¼ë¥¼ ì“°ë¯€ë¡œ ì•ˆì „
      const list = getUsersInTier(tierName, gameState.tierConfig);
      setUsers(list);
    };
    fetchUsers();
    const interval = setInterval(fetchUsers, 1000); 
    return () => clearInterval(interval);
  }, [tierName, gameState.tierConfig]);

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) onClose();
  };

  const getRankStyle = (index: number) => {
    if (index === 0) return { color: '#FFD700' }; 
    if (index === 1) return { color: '#C0C0C0' }; 
    if (index === 2) return { color: '#CD7F32' };
    return { color: '#666' };
  };

  return (
    <div onClick={handleBackdropClick} style={{ position: 'fixed', top: 0, left: 0, width: '100%', height: '100%', background: 'rgba(0,0,0,0.85)', display: 'flex', justifyContent: 'center', alignItems: 'center', zIndex: 1500, backdropFilter: 'blur(5px)', padding: '15px' }}>
      <div className="panel" style={{ width: '100%', maxWidth: '450px', maxHeight: '80vh', background: '#161b22', border: '1px solid #30363d', display: 'flex', flexDirection: 'column', borderRadius: '16px', overflow: 'hidden', boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.5)' }}>
        <div style={{ padding: '16px 20px', background: '#0d1117', borderBottom: '1px solid #30363d', display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexShrink: 0 }}>
          <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
            <Trophy size={18} color="#e89d40" />
            <h3 style={{ margin: 0, fontSize: '16px', color: '#fff', fontWeight: 'bold' }}>{tierName} <span style={{ color:'#8b949e', fontSize:'13px', fontWeight:'normal' }}>TOP {users.length}</span></h3>
          </div>
          <button onClick={onClose} style={{ background: 'none', border: 'none', color: '#8b949e', cursor: 'pointer', padding:'4px' }}><X size={24} /></button>
        </div>
        <div style={{ flex: 1, overflowY: 'auto', background: '#161b22' }}>
          {users.map((u, i) => {
            const rankStyle = getRankStyle(i);
            const isTop3 = i < 3;
            const bgStyle = isTop3 ? `rgba(255, 215, 0, ${0.05 - (i * 0.015)})` : 'transparent';
            return (
              <div key={u.id} onClick={() => onUserClick(u)} style={{ display: 'flex', alignItems: 'center', padding: '12px 16px', borderBottom: '1px solid #21262d', cursor: 'pointer', background: bgStyle }}>
                <div style={{ width: '40px', textAlign: 'center', fontSize: isTop3 ? '18px' : '14px', fontWeight: '900', fontStyle: 'italic', color: rankStyle.color, marginRight: '12px' }}>{i + 1}</div>
                <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '2px' }}>
                  <div style={{ color: '#fff', fontWeight: 'bold', fontSize: '14px' }}>{u.name}</div>
                  <div style={{ fontSize: '12px', color: '#8b949e', display: 'flex', alignItems: 'center', gap: '4px' }}>
                    <span style={{ color: '#e89d40', fontWeight:'bold' }}>{u.score} LP</span>
                    <span style={{ width: '3px', height: '3px', background: '#444', borderRadius: '50%' }}></span>
                    <span>Lv.{Math.floor(u.totalGames / 10) + 1}</span>
                  </div>
                </div>
                <div style={{ textAlign: 'right' }}>
                  <div style={{ fontSize: '14px', fontWeight: 'bold', color: u.winRate >= 60 ? '#ff4d4d' : u.winRate >= 50 ? '#3fb950' : '#8b949e' }}>{u.winRate.toFixed(1)}%</div>
                  <div style={{ fontSize: '11px', color: '#666' }}>{u.totalGames}ì „</div>
                </div>
              </div>
            );
          })}
          {users.length === 0 && <div style={{ padding: '40px 20px', textAlign: 'center', color: '#555', fontSize: '14px' }}>ì´ í‹°ì–´ì— ë°°ì¹˜ëœ ìœ ì €ê°€ ì—†ìŠµë‹ˆë‹¤.</div>}
        </div>
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/components/user/UserDashboard.tsx
==========================================
import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../store/useGameStore';
import { UserProfile } from '../../types';
import { Clock, Settings, ChevronRight } from 'lucide-react';
import { TierSettingsModal } from './TierSettingsModal';
import { TierUserListModal } from './TierUserListModal';

interface Props { onUserClick: (u: UserProfile) => void; }

export const UserDashboard: React.FC<Props> = ({ onUserClick }) => {
  const { gameState, heroes } = useGameStore();
  const { userStatus, topRankers } = gameState;
  const [showSettings, setShowSettings] = useState(false);
  const [selectedTier, setSelectedTier] = useState<string | null>(null);

  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const getHeroName = (id: string) => {
    const hero = heroes.find(h => h.id === id);
    return hero ? hero.name : id;
  };

  if (!userStatus) return <div>ë°ì´í„° ë¡œë”© ì¤‘...</div>;

  return (
    <div style={{ display: 'grid', gridTemplateColumns: isMobile ? '1fr' : '1fr 1fr', gap: '20px' }}>
      <div style={{ display: 'flex', flexDirection: 'column', gap: '20px' }}>
        <div className="panel">
          <h3 style={{ margin: '0 0 15px 0', borderBottom: '1px solid #333', paddingBottom: '10px', fontSize:'16px' }}>ğŸ“¡ ì‹¤ì‹œê°„ ë§¤ì¹­ í˜„í™©</h3>
          <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '20px' }}>
            <div style={{ textAlign: 'center', flex: 1, borderRight: '1px solid #333' }}>
              <div style={{ fontSize: '12px', color: '#8b949e' }}>ê²Œì„ ì¤‘ (Ingame)</div>
              <div style={{ fontSize: '24px', fontWeight: 'bold', color: '#3fb950' }}>{userStatus.playingUsers.toLocaleString()}</div>
            </div>
            <div style={{ textAlign: 'center', flex: 1 }}>
              <div style={{ fontSize: '12px', color: '#8b949e' }}>ë§¤ì¹­ ëŒ€ê¸° (Queue)</div>
              <div style={{ fontSize: '24px', fontWeight: 'bold', color: '#d29922' }}>{userStatus.queuingUsers.toLocaleString()}</div>
            </div>
          </div>
          <div style={{ background: '#0d1117', padding: '15px', borderRadius: '8px', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '10px' }}>
            <Clock size={16} color="#58a6ff" />
            <span style={{ color: '#8b949e', fontSize: '13px' }}>í‰ê·  ë§¤ì¹­ ì‹œê°„:</span>
            <span style={{ fontWeight: 'bold', color: '#fff' }}>{userStatus.avgWaitTime}ì´ˆ</span>
          </div>
        </div>

        <div className="panel">
          <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', borderBottom: '1px solid #333', paddingBottom: '10px', marginBottom: '15px' }}>
            <h3 style={{ margin: 0, fontSize:'16px' }}>ğŸ† í‹°ì–´ë³„ ì¸êµ¬ ë¶„í¬</h3>
            <button onClick={() => setShowSettings(true)} style={{ background:'none', border:'none', color:'#8b949e', cursor:'pointer', display:'flex', alignItems:'center', gap:'5px', fontSize:'12px' }}>
              <Settings size={14}/> ì„¤ì •
            </button>
          </div>

          <div style={{ display:'flex', flexDirection:'column', gap:'8px' }}>
            {userStatus.tierDistribution.map((tier) => (
              <div key={tier.name} onClick={() => setSelectedTier(tier.name)} style={{ cursor:'pointer', padding:'8px', borderRadius:'6px', background:'#0d1117', transition:'0.2s', display:'flex', alignItems:'center', justifyContent:'space-between' }}>
                <div style={{ display:'flex', alignItems:'center', gap:'10px', width: isMobile ? '80px' : '120px' }}>
                  <div style={{ width:'8px', height:'8px', borderRadius:'50%', background:tier.color }}></div>
                  <span style={{ fontWeight:'bold', color:tier.color, fontSize:'13px' }}>{tier.name}</span>
                </div>
                <div style={{ flex:1, height:'6px', background:'#333', borderRadius:'3px', margin:'0 15px' }}>
                  <div style={{ width:`${tier.percent}%`, height:'100%', background:tier.color, borderRadius:'3px', minWidth:'2px' }}></div>
                </div>
                <div style={{ textAlign:'right', width: isMobile ? '80px' : '100px' }}>
                  <span style={{ fontWeight:'bold', display:'block', fontSize:'13px' }}>{tier.count.toLocaleString()}</span>
                  <span style={{ fontSize:'10px', color:'#666' }}>{tier.percent.toFixed(1)}%</span>
                </div>
                {!isMobile && <ChevronRight size={14} color="#555" />}
              </div>
            ))}
          </div>
        </div>
      </div>

      <div className="panel">
        <h3 style={{ margin: '0 0 15px 0', borderBottom: '1px solid #333', paddingBottom: '10px', display: 'flex', justifyContent: 'space-between', fontSize:'16px' }}>
          <span>ğŸ¥‡ ìƒìœ„ ë­ì»¤ (Top 50)</span>
          <span style={{ fontSize: '12px', color: '#8b949e' }}>ì‹¤ì‹œê°„</span>
        </h3>

        <div style={{ height: '600px', overflowY: 'auto' }}>
          {isMobile ? (
            <div style={{ display:'flex', flexDirection:'column', gap:'10px' }}>
              {topRankers.map((user, idx) => (
                <div key={user.id} onClick={() => onUserClick(user)} style={{ background:'#0d1117', padding:'10px', borderRadius:'6px', border:'1px solid #333', display:'flex', alignItems:'center', gap:'10px' }}>
                  <div style={{ fontSize:'16px', fontWeight:'bold', color: idx < 3 ? '#e74c3c' : '#777', width:'24px', textAlign:'center' }}>{idx + 1}</div>
                  <div style={{ flex:1 }}>
                    <div style={{ fontWeight:'bold', color:'#fff', fontSize:'14px' }}>{user.name}</div>
                    <div style={{ fontSize:'12px', color:'#888' }}>
                      <span style={{ color: user.tier === 'ì²œìƒê³„' ? '#00bfff' : '#fff' }}>{user.tier}</span> ({user.score}LP)
                    </div>
                  </div>
                  <div style={{ textAlign:'right' }}>
                    <div style={{ fontSize:'12px', color:'#ddd', fontWeight:'bold' }}>{getHeroName(user.mainHeroId)}</div>
                    <div style={{ fontSize:'12px', color: user.winRate > 55 ? '#3fb950' : '#8b949e' }}>{user.winRate.toFixed(1)}%</div>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '13px' }}>
              <thead style={{ position: 'sticky', top: 0, background: '#161b22' }}>
                <tr style={{ color: '#8b949e', borderBottom: '1px solid #333', textAlign: 'left' }}>
                  <th style={{ padding: '8px', textAlign: 'center' }}>#</th>
                  <th>ì†Œí™˜ì‚¬ëª…</th>
                  <th>í‹°ì–´ (LP)</th>
                  <th>ëª¨ìŠ¤íŠ¸</th>
                  <th>ìŠ¹ë¥ </th>
                  <th>ìµœê·¼ 5ì „</th>
                </tr>
              </thead>
              <tbody>
                {topRankers.map((user, idx) => (
                  <tr key={user.id} style={{ borderBottom: '1px solid #222', height: '40px', cursor:'pointer' }} onClick={() => onUserClick(user)}>
                    <td style={{ textAlign: 'center', fontWeight: 'bold', color: idx < 3 ? '#e74c3c' : '#fff' }}>{idx + 1}</td>
                    <td style={{ fontWeight: 'bold', color: '#fff' }}>{user.name}</td>
                    <td>
                      <span style={{ color: user.tier === 'ì²œìƒê³„' ? '#00bfff' : user.tier === 'ë§ˆìŠ¤í„°' ? '#9b59b6' : '#fff' }}>{user.tier}</span>
                      <span style={{ fontSize: '11px', color: '#777', marginLeft: '4px' }}>({user.score}LP)</span>
                    </td>
                    <td style={{ color: '#ddd', fontWeight:'bold' }}>{getHeroName(user.mainHeroId)}</td>
                    <td style={{ color: user.winRate > 55 ? '#3fb950' : '#8b949e' }}>{user.winRate.toFixed(1)}%</td>
                    <td>
                      <div style={{ display: 'flex', gap: '2px' }}>
                        {user.history.slice(0, 5).map((h, i) => (
                          <div key={i} style={{ width: '16px', height: '16px', borderRadius: '2px', background: h.result === 'WIN' ? '#3fb950' : '#da3633', fontSize: '10px', color: 'white', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                            {h.result === 'WIN' ? 'W' : 'L'}
                          </div>
                        ))}
                      </div>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          )}
        </div>
      </div>
      {showSettings && <TierSettingsModal onClose={() => setShowSettings(false)} />}
      {selectedTier && <TierUserListModal tierName={selectedTier} onClose={() => setSelectedTier(null)} onUserClick={(u) => { onUserClick(u); setSelectedTier(null); }} />}
    </div>
  );
};



==========================================
FILE PATH: src/components/user/UserDetailModal.tsx
==========================================
// ==========================================
// FILE PATH: /src/components/user/UserDetailModal.tsx
// ==========================================

import React, { useState, useEffect } from 'react';
import { UserProfile } from '../../types';
import { useGameStore } from '../../store/useGameStore';

// ë¶„ë¦¬ëœ ëª¨ë“ˆ ì„í¬íŠ¸
import { ProfileHeader } from './detail/ProfileHeader';
import { StatsOverview } from './detail/StatsOverview';
import { MatchHistoryList } from './detail/MatchHistoryList';

interface Props { user: UserProfile; onClose: () => void; }

export const UserDetailModal: React.FC<Props> = ({ user, onClose }) => {
  const { heroes, gameState } = useGameStore();
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // ë°°ê²½ ì´ë¯¸ì§€ìš© (ì˜ì›… ID ê¸°ë°˜)
  const heroImage = gameState.customImages?.[`${user.mainHeroId}_bg`] || gameState.customImages?.[user.mainHeroId];

  return (
    <div style={{ 
      position: 'fixed', inset: 0, zIndex: 9999, 
      backgroundColor: 'rgba(0,0,0,0.85)', backdropFilter: 'blur(5px)',
      display: 'flex', justifyContent: 'center', alignItems: isMobile ? 'flex-end' : 'center',
      padding: isMobile ? 0 : '20px'
    }}>
      <div className="panel-content" style={{ 
        width: '100%', maxWidth: '900px', 
        height: isMobile ? '90vh' : '85vh',
        background: '#0d1117', border: '1px solid #30363d', borderRadius: isMobile ? '16px 16px 0 0' : '16px',
        display: 'flex', flexDirection: 'column', overflow: 'hidden',
        boxShadow: '0 50px 100px -20px rgba(0,0,0,0.8)'
      }}>
        
        {/* 1. ìƒë‹¨ í—¤ë” ëª¨ë“ˆ */}
        <ProfileHeader user={user} onClose={onClose} heroImage={heroImage} />

        {/* 2. ë©”ì¸ ì»¨í…ì¸  (ìŠ¤í¬ë¡¤ ì˜ì—­) */}
        <div style={{ flex: 1, overflowY: 'auto', padding: isMobile ? '15px' : '25px', display: 'flex', flexDirection: isMobile ? 'column' : 'row', gap: '25px' }}>
          
          {/* ì¢Œì¸¡: ë¶„ì„ ë° ìŠ¤íƒ¯ */}
          <div style={{ flex: 1, minWidth: isMobile ? '100%' : '300px', display:'flex', flexDirection:'column', gap:'20px' }}>
            <StatsOverview user={user} />
            
            {/* ì„ í˜¸ í¬ì§€ì…˜ (ê°„ë‹¨ í‘œì‹œ) */}
            <div style={{ background: '#161b22', padding: '15px', borderRadius: '12px', border: '1px solid #30363d', display:'flex', alignItems:'center', justifyContent:'space-between' }}>
              <span style={{ fontSize:'12px', color:'#888', fontWeight:'bold' }}>ì„ í˜¸ í¬ì§€ì…˜</span>
              <span style={{ fontSize:'14px', color:'#fff', fontWeight:'900' }}>{user.preferredLane}</span>
            </div>
          </div>

          {/* ìš°ì¸¡: ì±”í”¼ì–¸ ë° ì „ì  */}
          <div style={{ flex: 1.5, minWidth: isMobile ? '100%' : '400px' }}>
            <MatchHistoryList user={user} heroes={heroes} />
          </div>

        </div>
      </div>
    </div>
  );
};



==========================================
FILE PATH: src/data/heroes/helpers.ts
==========================================
// src/data/heroes/helpers.ts
import { HeroSkillSet } from '../../types';

export const getEmptyRecord = () => ({ 
  totalMatches: 0, totalWins: 0, totalPicks: 0, totalBans: 0,
  totalKills: 0, totalDeaths: 0, totalAssists: 0, 
  totalDamage: 0, totalDamageTaken: 0, totalCs: 0, totalGold: 0,
  recentResults: [] 
});

export const getEmptyUI = () => ({
  tier: '3' as const, rank: 0, rankChange: 0,
  recentWinRate: 0, pickRate: 0, banRate: 0,
  avgKda: '0.0/0.0/0.0', kdaRatio: '0.00', 
  avgDpm: '0', avgDpg: '0', avgCs: '0', avgGold: '0'
});

export const fallbackSkills: HeroSkillSet = {
  passive: { name: "ê¸°ë³¸ ëŠ¥ë ¥", mechanic: "NONE", val: 0, adRatio: 0, apRatio: 0, cd: 0, isPassive: true },
  q: { name: "Q ìŠ¤í‚¬", mechanic: "NONE", val: 100, adRatio: 0.7, apRatio: 0, cd: 8 },
  w: { name: "W ìŠ¤í‚¬", mechanic: "NONE", val: 80, adRatio: 0.5, apRatio: 0, cd: 12 },
  e: { name: "E ìŠ¤í‚¬", mechanic: "NONE", val: 60, adRatio: 0.3, apRatio: 0, cd: 15 },
  r: { name: "R ìŠ¤í‚¬", mechanic: "STUN", val: 400, adRatio: 1.2, apRatio: 0, cd: 100 }
};


==========================================
FILE PATH: src/data/heroes/heroList.ts
==========================================
// ==========================================
// FILE PATH: /src/data/heroes/heroList.ts
// ==========================================
import { Role } from '../../types';

/**
 * [ë°¸ëŸ°ìŠ¤ íŒ¨ì¹˜ v1.1]
 * - ëª©í‘œ: ìƒì¡´ë ¥ ê°•í™” (TTK ì¦ê°€)
 * - ë³€ê²½: ëª¨ë“  ì˜ì›… ê¸°ë³¸ HP +250, ë°©ì–´ë ¥ +8, ì¬ìƒ +3 ìƒí–¥ í‰ì¤€í™”
 */

export const RAW_HERO_LIST = [
  // =================================================================
  // 1. ì§‘í–‰ê´€ (EXECUTOR) - ë”œíƒ±í˜• ë¸Œë£¨ì €
  // (ê¸°ì¡´ HP 2000ëŒ€ -> 2300~2500ëŒ€ë¡œ ìƒí–¥, ë°©ì–´ë ¥ 40~50 -> 50~60ëŒ€ë¡œ ìƒí–¥)
  // =================================================================
  { id: 'h_ragna', name: "ë¼ê·¸ë‚˜", role: "ì§‘í–‰ê´€" as Role, concept: "ë¶ˆê½ƒì´ì—¬, ë‚˜ì˜ ë¶„ë…¸ê°€ ë˜ì–´ë¼!", stats: { ad: 75, hp: 2450, mp: 300, mpRegen: 5, armor: 53, crit: 20, range: 175, speed: 345, regen: 18, pen: 10 } },
  { id: 'h_kensei', name: "ì¼„ì„¸ì´", role: "ì§‘í–‰ê´€" as Role, concept: "ê²€ì€ ì£¼ì €í•˜ì§€ ì•ŠëŠ”ë‹¤. ì˜¤ì§ ë²¨ ë¿.", stats: { ad: 80, hp: 2200, mp: 250, mpRegen: 6, armor: 45, crit: 25, range: 175, speed: 350, regen: 15, pen: 15 } },
  { id: 'h_baldur', name: "ë°œë‘ë¥´", role: "ì§‘í–‰ê´€" as Role, concept: "ë¹›ì´ ìˆëŠ” í•œ, ë‚˜ëŠ” ì“°ëŸ¬ì§€ì§€ ì•ŠëŠ”ë‹¤.", stats: { ad: 70, hp: 2650, mp: 350, mpRegen: 5, armor: 65, crit: 10, range: 150, speed: 335, regen: 25, pen: 5 } },
  { id: 'h_freya', name: "í”„ë ˆì´ì•¼", role: "ì§‘í–‰ê´€" as Role, concept: "ë°œí‚¤ë¦¬ì˜ ë‚ ê°œê°€ ì „ì¥ì„ ë®ìœ¼ë¦¬ë¼.", stats: { ad: 72, hp: 2350, mp: 320, mpRegen: 7, armor: 48, crit: 15, range: 175, speed: 340, regen: 16, pen: 12 } },
  { id: 'h_gorgon', name: "ê³ ë¥´ê³¤", role: "ì§‘í–‰ê´€" as Role, concept: "ë‚´ ëˆˆì„ ë°”ë¼ë´... ì˜ì›íˆ.", stats: { ad: 85, hp: 2250, mp: 300, mpRegen: 5, armor: 48, crit: 15, range: 150, speed: 330, regen: 20, pen: 20 } },
  { id: 'h_arthur', name: "ì•„ì„œ", role: "ì§‘í–‰ê´€" as Role, concept: "ì™•ì˜ ì´ë¦„ìœ¼ë¡œ, ìŠ¹ë¦¬ë¥¼ ìŸì·¨í•˜ê² ë‹¤.", stats: { ad: 68, hp: 2550, mp: 340, mpRegen: 6, armor: 58, crit: 10, range: 150, speed: 340, regen: 18, pen: 8 } },
  { id: 'h_leonidas', name: "ë ˆì˜¤ë‹ˆë‹¤ìŠ¤", role: "ì§‘í–‰ê´€" as Role, concept: "ìš°ë¦¬ëŠ” ë¬¼ëŸ¬ì„œì§€ ì•ŠëŠ”ë‹¤! ì´ê²ƒì´ ìŠ¤íŒŒë¥´íƒ€ë‹¤!", stats: { ad: 78, hp: 2600, mp: 280, mpRegen: 5, armor: 60, crit: 15, range: 175, speed: 340, regen: 20, pen: 10 } },
  { id: 'h_musashi', name: "ë¬´ì‚¬ì‹œ", role: "ì§‘í–‰ê´€" as Role, concept: "ì´ë„ë¥˜ì˜ ëì„ ë³´ì—¬ì£¼ì§€.", stats: { ad: 82, hp: 2300, mp: 200, mpRegen: 8, armor: 46, crit: 30, range: 150, speed: 355, regen: 16, pen: 20 } },
  { id: 'h_lancelot', name: "ë€ìŠ¬ë¡¯", role: "ì§‘í–‰ê´€" as Role, concept: "ë‚˜ì˜ ê²€ì€ ëª…ì˜ˆë¥¼ ìœ„í•´ ì¡´ì¬í•œë‹¤.", stats: { ad: 74, hp: 2500, mp: 310, mpRegen: 6, armor: 56, crit: 20, range: 175, speed: 345, regen: 18, pen: 15 } },
  { id: 'h_siegfried', name: "ì§€í¬í”„ë¦¬íŠ¸", role: "ì§‘í–‰ê´€" as Role, concept: "ìš©ì˜ í”¼ê°€ ë‚˜ë¥¼ ë¶ˆì‚¬ë¡œ ë§Œë“ ë‹¤.", stats: { ad: 88, hp: 2750, mp: 300, mpRegen: 5, armor: 68, crit: 10, range: 150, speed: 330, regen: 30, pen: 5 } },

  // =================================================================
  // 2. ì„ ì§€ì (PROPHET) - ë§ˆë²•ì‚¬
  // (ê¸°ì¡´ HP 1500ëŒ€ -> 1750~1900ëŒ€ë¡œ ìƒí–¥, ë°©ì–´ë ¥ 20ëŒ€ -> 30ëŒ€ë¡œ ìƒí–¥)
  // =================================================================
  { id: 'h_merlin', name: "ë©€ë¦°", role: "ì„ ì§€ì" as Role, concept: "ë§ˆë²•ì˜ ê·¼ì›ì€ ì§€í˜œ, ê·¸ë¦¬ê³  ì•½ê°„ì˜ ê´‘ê¸°ì§€.", stats: { ad: 40, ap: 85, hp: 1850, mp: 600, mpRegen: 12, armor: 35, crit: 0, range: 550, speed: 330, regen: 10, pen: 30 } },
  { id: 'h_crowley', name: "í¬ë¡œìš¸ë¦¬", role: "ì„ ì§€ì" as Role, concept: "ê¸ˆì§€ëœ ì§€ì‹ì—ëŠ” ëŒ€ê°€ê°€ ë”°ë¥´ëŠ” ë²•.", stats: { ad: 45, ap: 90, hp: 1800, mp: 550, mpRegen: 10, armor: 32, crit: 0, range: 525, speed: 335, regen: 9, pen: 35 } },
  { id: 'h_elara', name: "ì—˜ë¼ë¼", role: "ì„ ì§€ì" as Role, concept: "ë³„ë“¤ì´ ë‹¹ì‹ ì˜ ìš´ëª…ì„ ì†ì‚­ì´ë„¤ìš”.", stats: { ad: 38, ap: 80, hp: 1900, mp: 650, mpRegen: 15, armor: 38, crit: 0, range: 575, speed: 325, regen: 11, pen: 25 } },
  { id: 'h_nix', name: "ë‹‰ìŠ¤", role: "ì„ ì§€ì" as Role, concept: "ì–´ë‘ ì´ ë‚´ë¦¬ë©´, ì•„ë¬´ë„ ìˆ¨ì„ ìˆ˜ ì—†ì–´.", stats: { ad: 42, ap: 95, hp: 1750, mp: 580, mpRegen: 11, armor: 30, crit: 0, range: 600, speed: 340, regen: 8, pen: 40 } },
  { id: 'h_sol', name: "ì†”", role: "ì„ ì§€ì" as Role, concept: "íƒœì–‘ ë§Œì„¸! ëª¨ë“  ê²ƒì„ íƒœì›Œ ì •í™”í•˜ë¦¬ë¼!", stats: { ad: 35, ap: 88, hp: 1950, mp: 620, mpRegen: 13, armor: 36, crit: 0, range: 550, speed: 330, regen: 12, pen: 28 } },
  { id: 'h_gaia', name: "ê°€ì´ì•„", role: "ì„ ì§€ì" as Role, concept: "ëŒ€ì§€ëŠ” ê¸°ì–µí•œë‹¤. ë„ˆì˜ ì£„ë¥¼.", stats: { ad: 40, ap: 82, hp: 2050, mp: 700, mpRegen: 14, armor: 45, crit: 0, range: 500, speed: 320, regen: 13, pen: 20 } },
  { id: 'h_nostra', name: "ë…¸ìŠ¤íŠ¸ë¼", role: "ì„ ì§€ì" as Role, concept: "ì´ë¯¸ ë„ˆì˜ íŒ¨ë°°ëŠ” ì˜ˆê²¬ë˜ì–´ ìˆë‹¤.", stats: { ad: 35, ap: 92, hp: 1800, mp: 500, mpRegen: 10, armor: 30, crit: 0, range: 580, speed: 325, regen: 9, pen: 35 } },
  { id: 'h_rasputin', name: "ë¼ìŠ¤í‘¸í‹´", role: "ì„ ì§€ì" as Role, concept: "ì£½ìŒ? ë‚˜ëŠ” ìˆ˜ì—†ì´ ê²ªì–´ë³´ì•˜ë‹¤.", stats: { ad: 45, ap: 88, hp: 2000, mp: 560, mpRegen: 12, armor: 40, crit: 0, range: 525, speed: 330, regen: 18, pen: 25 } },
  { id: 'h_circe', name: "í‚¤ë¥´ì¼€", role: "ì„ ì§€ì" as Role, concept: "ê·€ì—¬ìš´ ë¼ì§€ë¡œ ë§Œë“¤ì–´ì¤„ê¹Œ?", stats: { ad: 40, ap: 96, hp: 1720, mp: 540, mpRegen: 11, armor: 28, crit: 0, range: 600, speed: 335, regen: 8, pen: 40 } },
  { id: 'h_morgana', name: "ëª¨ë¥´ê°€ë‚˜", role: "ì„ ì§€ì" as Role, concept: "ê³ í†µì„ ì¦ê²¨ë¼, í”¼í•  ìˆ˜ ì—†ë‹¤ë©´.", stats: { ad: 42, ap: 85, hp: 1880, mp: 600, mpRegen: 12, armor: 35, crit: 0, range: 550, speed: 340, regen: 11, pen: 30 } },

  // =================================================================
  // 3. ì¶”ì ì (TRACKER) - ì•”ì‚´ì
  // (ê¸°ì¡´ HP 1600ëŒ€ -> 1850~1950ëŒ€ë¡œ ìƒí–¥, ë°©ì–´ë ¥ 30ëŒ€ -> 40ëŒ€ë¡œ ìƒí–¥)
  // =================================================================
  { id: 'h_kage', name: "ì¹´ê²Œ", role: "ì¶”ì ì" as Role, concept: "ê·¸ë¦¼ìê°€ ì§™ì–´ì§€ë©´, ë‚´ê°€ ê±°ê¸° ìˆë‹¤.", stats: { ad: 88, hp: 1880, mp: 200, mpRegen: 10, armor: 38, crit: 35, range: 125, speed: 360, regen: 11, pen: 40 } },
  { id: 'h_fenrir', name: "íœë¦¬ë¥´", role: "ì¶”ì ì" as Role, concept: "ì‚¬ëƒ¥ê°ì´... ê²ì— ì§ˆë ¸êµ°.", stats: { ad: 82, hp: 2050, mp: 250, mpRegen: 8, armor: 43, crit: 25, range: 125, speed: 355, regen: 15, pen: 30 } },
  { id: 'h_viper', name: "ë°”ì´í¼", role: "ì¶”ì ì" as Role, concept: "ë…ì´ í¼ì§€ëŠ” ê±´ ìˆœì‹ê°„ì´ì§€.", stats: { ad: 78, hp: 1950, mp: 280, mpRegen: 7, armor: 36, crit: 20, range: 150, speed: 350, regen: 12, pen: 35 } },
  { id: 'h_specter', name: "ìŠ¤í™í„°", role: "ì¶”ì ì" as Role, concept: "ë²½ì„ ë„˜ëŠ” ì, ëª©ìˆ¨ì„ ê±·ëŠ” ì.", stats: { ad: 90, hp: 1800, mp: 220, mpRegen: 9, armor: 33, crit: 40, range: 125, speed: 355, regen: 10, pen: 45 } },
  { id: 'h_locust', name: "ë¡œì»¤ìŠ¤íŠ¸", role: "ì¶”ì ì" as Role, concept: "ìš°ë¦¬ëŠ” êµ°ë‹¨ì´ë‹¤. ë‚¨ê¹€ì—†ì´ ë¨¹ì–´ì¹˜ì›Œë¼.", stats: { ad: 75, hp: 2000, mp: 300, mpRegen: 6, armor: 40, crit: 30, range: 150, speed: 365, regen: 14, pen: 25 } },
  { id: 'h_scarlet', name: "ìŠ¤ì¹¼ë ›", role: "ì¶”ì ì" as Role, concept: "í”¼ ëƒ„ìƒˆê°€... í–¥ê¸‹í•´.", stats: { ad: 85, hp: 1850, mp: 0, mpRegen: 0, armor: 28, crit: 45, range: 125, speed: 350, regen: 9, pen: 50 } },
  { id: 'h_hattori', name: "í•«í† ë¦¬", role: "ì¶”ì ì" as Role, concept: "ì„ë¬´ ì™„ë£Œ. í”ì ì€ ë‚¨ê¸°ì§€ ì•ŠëŠ”ë‹¤.", stats: { ad: 86, hp: 1850, mp: 240, mpRegen: 10, armor: 36, crit: 40, range: 125, speed: 365, regen: 10, pen: 45 } },
  { id: 'h_jack', name: "ì­", role: "ì¶”ì ì" as Role, concept: "ì•ˆê°œ ì†ì˜ ì‚´ì¸ê·€ê°€ ë‹¹ì‹ ì„ ì°¾ì•„ê°‘ë‹ˆë‹¤.", stats: { ad: 92, hp: 1830, mp: 260, mpRegen: 8, armor: 33, crit: 50, range: 125, speed: 360, regen: 9, pen: 55 } },
  { id: 'h_arachne', name: "ì•„ë¼í¬ë„¤", role: "ì¶”ì ì" as Role, concept: "ë‚´ ê±°ë¯¸ì¤„ì— ê±¸ë¦° ì´ìƒ, ë„ë§ì¹  ê³³ì€ ì—†ì–´.", stats: { ad: 76, hp: 1980, mp: 350, mpRegen: 6, armor: 43, crit: 25, range: 150, speed: 355, regen: 14, pen: 30 } },
  { id: 'h_goemon', name: "ê³ ì—ëª¬", role: "ì¶”ì ì" as Role, concept: "ë„¤ ëª©ìˆ¨ê³¼ ì§€ê°‘, ë‘˜ ë‹¤ ê°€ì ¸ê°€ë§ˆ!", stats: { ad: 84, hp: 1920, mp: 300, mpRegen: 8, armor: 40, crit: 30, range: 150, speed: 350, regen: 12, pen: 35 } },

  // =================================================================
  // 4. ìˆ˜í˜¸ê¸°ì‚¬ (GUARDIAN) - íƒ±ì»¤
  // (ê¸°ì¡´ HP 3000ëŒ€ -> 3300~3800ëŒ€ë¡œ ìƒí–¥, ë°©ì–´ë ¥ 90ëŒ€ -> 100ëŒ€ë¡œ ìƒí–¥)
  // =================================================================
  { id: 'h_aigis', name: "ì•„ì´ê¸°ìŠ¤", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "ë‚˜ëŠ” ëš«ë¦¬ì§€ ì•ŠëŠ” ë°©íŒ¨ë‹¤.", stats: { ad: 50, hp: 3800, mp: 400, mpRegen: 5, armor: 105, crit: 0, range: 150, speed: 315, regen: 35, pen: 0 } },
  { id: 'h_golem', name: "ê³¨ë ˜", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "ë°”ìœ„... ë‹¨ë‹¨í•˜ë‹¤... ë¶€ìˆœë‹¤...", stats: { ad: 60, hp: 3600, mp: 200, mpRegen: 4, armor: 100, crit: 5, range: 150, speed: 310, regen: 30, pen: 5 } },
  { id: 'h_paladin', name: "íŒ”ë¼ë”˜", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "ì‹ ì„±í•œ ë¹›ì´ ìš°ë¦¬ë¥¼ ë³´í˜¸í•˜ë¦¬ë¼.", stats: { ad: 55, hp: 3300, mp: 500, mpRegen: 7, armor: 95, crit: 0, range: 150, speed: 325, regen: 25, pen: 0 } },
  { id: 'h_treant', name: "íŠ¸ë¦¬ì–¸íŠ¸", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "ìˆ²ì„ í•´ì¹˜ëŠ” ì, ìš©ì„œí•˜ì§€ ì•Šê² ë‹¤.", stats: { ad: 65, hp: 3500, mp: 450, mpRegen: 6, armor: 90, crit: 5, range: 175, speed: 320, regen: 45, pen: 5 } },
  { id: 'h_magnus', name: "ë§¤ê·¸ë„ˆìŠ¤", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "ì§„ì •í•œ í˜ì´ ë¬´ì—‡ì¸ì§€ ë³´ì—¬ì£¼ë§ˆ!", stats: { ad: 58, hp: 3200, mp: 350, mpRegen: 5, armor: 98, crit: 10, range: 150, speed: 330, regen: 26, pen: 10 } },
  { id: 'h_yeti', name: "ì˜ˆí‹°", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "ì¶”ìœ„ëŠ” ë¼ˆì†ê¹Œì§€ íŒŒê³ ë“¤ì§€.", stats: { ad: 62, hp: 3700, mp: 300, mpRegen: 5, armor: 85, crit: 5, range: 150, speed: 315, regen: 32, pen: 5 } },
  { id: 'h_spartacus', name: "ìŠ¤íŒŒë¥´íƒ€ì¿ ìŠ¤", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "ììœ ë¥¼ ìœ„í•´! ê²°ì½” êµ´ë³µí•˜ì§€ ë§ˆë¼!", stats: { ad: 65, hp: 3400, mp: 250, mpRegen: 6, armor: 95, crit: 10, range: 150, speed: 325, regen: 28, pen: 10 } },
  { id: 'h_titan', name: "íƒ€ì´íƒ„", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "ê³ ëŒ€ì˜ ê±°ì¸ì´ ê¹¨ì–´ë‚¬ë‹¤.", stats: { ad: 70, hp: 4000, mp: 300, mpRegen: 4, armor: 110, crit: 0, range: 150, speed: 305, regen: 45, pen: 0 } },
  { id: 'h_behemoth', name: "ë² í—¤ëª¨ìŠ¤", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "í¬ì•„ì•™! ë‹¤ ë°Ÿì•„ë²„ë¦¬ê² ë‹¤!", stats: { ad: 68, hp: 3800, mp: 200, mpRegen: 5, armor: 102, crit: 5, range: 150, speed: 310, regen: 40, pen: 5 } },
  { id: 'h_tortuga', name: "í† ë¥´íˆ¬ê°€", role: "ìˆ˜í˜¸ê¸°ì‚¬" as Role, concept: "ëŠë¦¬ì§€ë§Œ, í™•ì‹¤í•˜ê²Œ ì§€ì¼œì£¼ì§€.", stats: { ad: 55, hp: 3600, mp: 400, mpRegen: 6, armor: 120, crit: 0, range: 150, speed: 300, regen: 35, pen: 0 } },

  // =================================================================
  // 5. ì‹ ì‚´ì (GOD SLAYER) - ì›ê±°ë¦¬ ë”œëŸ¬ (ë¬¼ëª¸)
  // (ê¸°ì¡´ HP 1400ëŒ€ -> 1700~1850ëŒ€ë¡œ ìƒí–¥, ë°©ì–´ë ¥ 20 -> 30ëŒ€ë¡œ ìƒí–¥)
  // =================================================================
  { id: 'h_hawk', name: "í˜¸í¬", role: "ì‹ ì‚´ì" as Role, concept: "ë‚´ í™”ì‚´ì€ ë¹—ë‚˜ê°€ì§€ ì•Šì•„.", stats: { ad: 80, hp: 1750, mp: 300, mpRegen: 6, armor: 33, crit: 40, range: 600, speed: 330, regen: 8, pen: 25 } },
  { id: 'h_trigger', name: "íŠ¸ë¦¬ê±°", role: "ì‹ ì‚´ì" as Role, concept: "ì´ì•Œì€ ì¶©ë¶„í•´. ë„¤ ëª©ìˆ¨ì´ ë¶€ì¡±í•  ë¿.", stats: { ad: 85, hp: 1700, mp: 250, mpRegen: 7, armor: 30, crit: 35, range: 550, speed: 335, regen: 9, pen: 30 } },
  { id: 'h_nova', name: "ë…¸ë°”", role: "ì‹ ì‚´ì" as Role, concept: "ë¯¸ë˜ì˜ ê¸°ìˆ ë ¥ì„ ë§›ë´ë¼.", stats: { ad: 78, hp: 1800, mp: 400, mpRegen: 8, armor: 36, crit: 30, range: 625, speed: 325, regen: 8, pen: 20 } },
  { id: 'h_flint', name: "í”Œë¦°íŠ¸", role: "ì‹ ì‚´ì" as Role, concept: "í˜„ìƒê¸ˆì´ ê½¤ ì§­ì§¤í•˜ê² ì–´.", stats: { ad: 90, hp: 1850, mp: 320, mpRegen: 6, armor: 38, crit: 25, range: 525, speed: 340, regen: 10, pen: 35 } },
  { id: 'h_sylvia', name: "ì‹¤ë¹„ì•„", role: "ì‹ ì‚´ì" as Role, concept: "ë°”ëŒì´ ë‚˜ë¥¼ ì¸ë„í•´ìš”.", stats: { ad: 75, hp: 1650, mp: 350, mpRegen: 7, armor: 28, crit: 45, range: 650, speed: 320, regen: 7, pen: 22 } },
  { id: 'h_gambit', name: "ê°¬ë¹—", role: "ì‹ ì‚´ì" as Role, concept: "ì¸ìƒì€ ë„ë°•ì´ì§€. ì˜¬ì¸í•  í…ê°€?", stats: { ad: 82, hp: 1820, mp: 300, mpRegen: 9, armor: 34, crit: 50, range: 550, speed: 330, regen: 9, pen: 28 } },
  { id: 'h_robin', name: "ë¡œë¹ˆ", role: "ì‹ ì‚´ì" as Role, concept: "ê°€ë‚œí•œ ìë“¤ì„ ìœ„í•´, ë„¤ ëª©ìˆ¨ì„ ê±°ë‘ë§ˆ.", stats: { ad: 84, hp: 1780, mp: 280, mpRegen: 6, armor: 32, crit: 35, range: 625, speed: 335, regen: 9, pen: 30 } },
  { id: 'h_artemis', name: "ì•„ë¥´í…Œë¯¸ìŠ¤", role: "ì‹ ì‚´ì" as Role, concept: "ë‹¬ë¹› ì•„ë˜ì„œ, ì‚¬ëƒ¥ì„ ì‹œì‘í•˜ì§€.", stats: { ad: 88, hp: 1720, mp: 340, mpRegen: 7, armor: 30, crit: 40, range: 650, speed: 330, regen: 8, pen: 35 } },
  { id: 'h_apollo', name: "ì•„í´ë¡œ", role: "ì‹ ì‚´ì" as Role, concept: "íƒœì–‘ë³´ë‹¤ ëœ¨ê²ê²Œ, ìŒì•…ë³´ë‹¤ ì•„ë¦„ë‹µê²Œ.", stats: { ad: 80, hp: 1850, mp: 380, mpRegen: 8, armor: 36, crit: 30, range: 575, speed: 340, regen: 10, pen: 25 } },
  { id: 'h_kaiser', name: "ì¹´ì´ì €", role: "ì‹ ì‚´ì" as Role, concept: "í™©ì œì˜ íƒ„í™˜ì— ìë¹„ë€ ì—†ë‹¤.", stats: { ad: 95, hp: 1700, mp: 200, mpRegen: 5, armor: 28, crit: 25, range: 700, speed: 320, regen: 7, pen: 40 } }
];



==========================================
FILE PATH: src/data/heroes/index.ts
==========================================
// src/data/heroes/index.ts
import { Hero } from '../../types';
import { RAW_HERO_LIST } from './heroList';
import { HERO_SKILL_DATA } from './skillData';
import { getEmptyRecord, getEmptyUI, fallbackSkills } from './helpers';

export const INITIAL_HEROES: Hero[] = RAW_HERO_LIST.map(h => {
  // ìŠ¤íƒ¯ ë³´ì • ë° ê¸°ë³¸ê°’ ì„¤ì •
  const baseStats = {
    ad: h.stats.ad || 0,
    ap: (h.stats as any).ap || 0,
    hp: h.stats.hp || 1000,
    armor: h.stats.armor || 0,
    crit: h.stats.crit || 0,
    range: h.stats.range || 150,
    speed: h.stats.speed || 340,
    regen: h.stats.regen || 10,
    pen: h.stats.pen || 0,
    baseAtk: h.stats.ad || 50
  };

  return {
    ...h,
    stats: baseStats,
    // IDì— ë§ëŠ” ìŠ¤í‚¬ ë°ì´í„° í• ë‹¹ (ì—†ìœ¼ë©´ fallbackìš© ê¸°ë³¸ ìŠ¤í‚¬ ì£¼ì…)
    skills: HERO_SKILL_DATA[h.id] || fallbackSkills,
    record: getEmptyRecord(),
    ...getEmptyUI()
  } as Hero;
});



==========================================
FILE PATH: src/data/heroes/skillData.ts
==========================================
// ==========================================
// FILE PATH: /src/data/heroes/skillData.ts
// ==========================================
import { HeroSkillSet } from '../../types';

export const HERO_SKILL_DATA: Record<string, HeroSkillSet> = {
  // ===================== [ì§‘í–‰ê´€] =====================
  h_ragna: { 
    passive: { name: "íƒ€ì˜¤ë¥´ëŠ” íˆ¬ì§€", mechanic: "HEAL", val: 30, adRatio: 0.1, apRatio: 0, cost: 0, cd: 5, range: 0, duration: 0, isPassive: true },
    q: { name: "í™”ì—¼ ê°•íƒ€", mechanic: "DAMAGE", val: 120, adRatio: 1.1, apRatio: 0, cost: 40, cd: 6, range: 300, duration: 0 },
    w: { name: "ë¶ˆêµ´ì˜ ì™¸ì¹¨", mechanic: "SHIELD", val: 150, adRatio: 0.5, apRatio: 0, cost: 60, cd: 14, range: 0, duration: 4.0 },
    e: { name: "ëŒê²©", mechanic: "DASH", val: 450, adRatio: 0.6, apRatio: 0, cost: 50, cd: 10, range: 450, duration: 0.2 },
    r: { name: "ì§€ì˜¥ë¶ˆ í­ë°œ", mechanic: "EXECUTE", val: 400, adRatio: 2.0, apRatio: 0, cost: 100, cd: 100, range: 400, duration: 0 }
  },
  h_kensei: { 
    passive: { name: "ê²€ê¸°", mechanic: "DAMAGE", val: 20, adRatio: 0.2, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì¼ì„¬", mechanic: "DAMAGE", val: 140, adRatio: 1.2, apRatio: 0, cost: 45, cd: 5, range: 350, duration: 0 },
    w: { name: "í˜ë¦¬ê¸°", mechanic: "SHIELD", val: 100, adRatio: 0.8, apRatio: 0, cost: 50, cd: 12, range: 0, duration: 1.5 },
    e: { name: "ë°œë„ìˆ ", mechanic: "DASH", val: 500, adRatio: 0.5, apRatio: 0, cost: 40, cd: 9, range: 500, duration: 0.1 },
    r: { name: "ì˜¤ì˜: ì°¸ìˆ˜", mechanic: "STUN", val: 350, adRatio: 1.8, apRatio: 0, cost: 100, cd: 110, range: 550, duration: 1.5 }
  },
  h_baldur: { 
    passive: { name: "ë¹›ì˜ ê°€í˜¸", mechanic: "SHIELD", val: 50, adRatio: 0.1, apRatio: 0, cost: 0, cd: 15, range: 0, duration: 5.0, isPassive: true },
    q: { name: "ì‹¬íŒ", mechanic: "STUN", val: 100, adRatio: 0.9, apRatio: 0, cost: 60, cd: 10, range: 250, duration: 1.2 },
    w: { name: "ì¹˜ìœ ì˜ ë¹›", mechanic: "HEAL", val: 140, adRatio: 0.4, apRatio: 0, cost: 70, cd: 16, range: 0, duration: 0 },
    e: { name: "ì„±ìŠ¤ëŸ¬ìš´ ëŒì§„", mechanic: "DASH", val: 500, adRatio: 0.6, apRatio: 0, cost: 50, cd: 12, range: 500, duration: 0.3 },
    r: { name: "ì—¬ëª…", mechanic: "DAMAGE", val: 300, adRatio: 1.5, apRatio: 0, cost: 100, cd: 90, range: 600, duration: 0 }
  },
  h_freya: { 
    passive: { name: "ì „ì¥ì˜ ì¶¤", mechanic: "DAMAGE", val: 15, adRatio: 0.1, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "íˆ¬ì°½", mechanic: "DAMAGE", val: 110, adRatio: 1.0, apRatio: 0, cost: 40, cd: 6, range: 550, duration: 0 },
    w: { name: "ê¹ƒí„¸ ë°©íŒ¨", mechanic: "SHIELD", val: 100, adRatio: 0.3, apRatio: 0, cost: 55, cd: 13, range: 0, duration: 3.0 },
    e: { name: "ë¹„ìƒ", mechanic: "DASH", val: 550, adRatio: 0.5, apRatio: 0, cost: 60, cd: 14, range: 550, duration: 0.3 },
    r: { name: "ë°œí‚¤ë¦¬ì˜ ê°•ë¦¼", mechanic: "GLOBAL", val: 350, adRatio: 1.5, apRatio: 0, cost: 120, cd: 130, range: 20000, duration: 0 }
  },
  h_gorgon: { 
    passive: { name: "ì„í™”ì˜ ì‹œì„ ", mechanic: "STUN", val: 0, adRatio: 0, apRatio: 0, cost: 0, cd: 30, range: 400, duration: 1.0, isPassive: true },
    q: { name: "ë§¹ë…", mechanic: "DAMAGE", val: 100, adRatio: 0.8, apRatio: 0.3, cost: 50, cd: 5, range: 400, duration: 0 },
    w: { name: "ìœ„í˜‘", mechanic: "DAMAGE", val: 80, adRatio: 0.6, apRatio: 0, cost: 40, cd: 9, range: 300, duration: 0 },
    e: { name: "ê¼¬ë¦¬ì¹˜ê¸°", mechanic: "HOOK", val: 400, adRatio: 0.7, apRatio: 0, cost: 70, cd: 13, range: 450, duration: 0.5 },
    r: { name: "ë©”ë‘ì‚¬ì˜ ì €ì£¼", mechanic: "STUN", val: 250, adRatio: 1.1, apRatio: 0.7, cost: 100, cd: 110, range: 600, duration: 2.0 }
  },
  h_arthur: { 
    passive: { name: "ì™•ì˜ ê¶Œìœ„", mechanic: "DAMAGE", val: 15, adRatio: 0.1, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì—‘ìŠ¤ì¹¼ë¦¬ë²„", mechanic: "DAMAGE", val: 130, adRatio: 1.2, apRatio: 0, cost: 50, cd: 7, range: 300, duration: 0 },
    w: { name: "ì›íƒì˜ ê°€í˜¸", mechanic: "SHIELD", val: 120, adRatio: 0.4, apRatio: 0, cost: 60, cd: 15, range: 0, duration: 4.0 },
    e: { name: "ì™•ì˜ ì§„ê²©", mechanic: "DASH", val: 500, adRatio: 0.7, apRatio: 0, cost: 55, cd: 11, range: 500, duration: 0.3 },
    r: { name: "ì•½ì†ëœ ìŠ¹ë¦¬", mechanic: "EXECUTE", val: 450, adRatio: 1.8, apRatio: 0, cost: 100, cd: 130, range: 500, duration: 0 }
  },
  h_leonidas: { 
    passive: { name: "ìŠ¤íŒŒë¥´íƒ€", mechanic: "SHIELD", val: 60, adRatio: 0.2, apRatio: 0, cost: 0, cd: 18, range: 0, duration: 3.0, isPassive: true },
    q: { name: "ì°½ ì°Œë¥´ê¸°", mechanic: "DAMAGE", val: 120, adRatio: 1.1, apRatio: 0, cost: 45, cd: 5, range: 400, duration: 0 },
    w: { name: "ë°©íŒ¨ ë°€ì¹˜ê¸°", mechanic: "STUN", val: 90, adRatio: 0.5, apRatio: 0, cost: 60, cd: 12, range: 200, duration: 1.2 },
    e: { name: "í•¨ì„±", mechanic: "HEAL", val: 90, adRatio: 0.3, apRatio: 0, cost: 70, cd: 16, range: 0, duration: 0 },
    r: { name: "ìµœí›„ì˜ ì €í•­", mechanic: "SHIELD", val: 400, adRatio: 1.0, apRatio: 0, cost: 100, cd: 140, range: 0, duration: 6.0 }
  },
  h_musashi: { 
    passive: { name: "ì´ë„ë¥˜", mechanic: "DAMAGE", val: 20, adRatio: 0.3, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì‹­ì ë² ê¸°", mechanic: "DAMAGE", val: 130, adRatio: 1.3, apRatio: 0, cost: 40, cd: 6, range: 300, duration: 0 },
    w: { name: "íšŒí”¼", mechanic: "DASH", val: 400, adRatio: 0.2, apRatio: 0, cost: 50, cd: 8, range: 400, duration: 0.1 },
    e: { name: "ëª…ìƒ", mechanic: "HEAL", val: 70, adRatio: 0.3, apRatio: 0, cost: 60, cd: 15, range: 0, duration: 0 },
    r: { name: "ì˜¤ë¥œì˜ ì„œ", mechanic: "EXECUTE", val: 420, adRatio: 2.1, apRatio: 0, cost: 100, cd: 120, range: 400, duration: 0 }
  },
  h_lancelot: { 
    passive: { name: "í˜¸ìˆ˜ì˜ ê¸°ì‚¬", mechanic: "DAMAGE", val: 10, adRatio: 0.1, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì—°ì† ì°Œë¥´ê¸°", mechanic: "DASH", val: 550, adRatio: 1.0, apRatio: 0, cost: 50, cd: 7, range: 550, duration: 0.2 },
    w: { name: "íŒ¨ë§", mechanic: "SHIELD", val: 80, adRatio: 0.5, apRatio: 0, cost: 55, cd: 10, range: 0, duration: 1.5 },
    e: { name: "ê°€ë¥´ê¸°", mechanic: "DAMAGE", val: 110, adRatio: 0.9, apRatio: 0, cost: 45, cd: 8, range: 350, duration: 0 },
    r: { name: "ì•„ë¡ ë‹¤ì´íŠ¸", mechanic: "DAMAGE", val: 350, adRatio: 1.8, apRatio: 0, cost: 100, cd: 110, range: 400, duration: 0 }
  },
  h_siegfried: { 
    passive: { name: "ìš©ì˜ í”¼", mechanic: "SHIELD", val: 80, adRatio: 0.1, apRatio: 0, cost: 0, cd: 20, range: 0, duration: 5.0, isPassive: true },
    q: { name: "ë°œë­‰", mechanic: "DAMAGE", val: 140, adRatio: 1.3, apRatio: 0, cost: 50, cd: 8, range: 350, duration: 0 },
    w: { name: "ìš©ì˜ í¬íš¨", mechanic: "STUN", val: 70, adRatio: 0.4, apRatio: 0, cost: 70, cd: 16, range: 400, duration: 1.5 },
    e: { name: "ì¬ìƒ", mechanic: "HEAL", val: 100, adRatio: 0.3, apRatio: 0, cost: 60, cd: 20, range: 0, duration: 0 },
    r: { name: "ë“œë˜ê³¤ ìŠ¬ë ˆì´ì–´", mechanic: "EXECUTE", val: 500, adRatio: 2.3, apRatio: 0, cost: 100, cd: 130, range: 450, duration: 0 }
  },

  // ===================== [ì„ ì§€ì] =====================
  h_merlin: { 
    passive: { name: "ë§ˆë ¥ ê³¼ë¶€í•˜", mechanic: "DAMAGE", val: 25, adRatio: 0, apRatio: 0.3, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "í™”ì—¼êµ¬", mechanic: "DAMAGE", val: 150, adRatio: 0, apRatio: 1.3, cost: 60, cd: 5, range: 900, duration: 0 },
    w: { name: "ë§ˆë²• ë³´í˜¸ë§‰", mechanic: "SHIELD", val: 120, adRatio: 0, apRatio: 0.7, cost: 80, cd: 14, range: 0, duration: 3.0 },
    e: { name: "ì ë©¸", mechanic: "DASH", val: 450, adRatio: 0, apRatio: 0, cost: 90, cd: 15, range: 450, duration: 0.1 },
    r: { name: "ë©”í…Œì˜¤", mechanic: "GLOBAL", val: 500, adRatio: 0, apRatio: 2.5, cost: 150, cd: 140, range: 20000, duration: 0 }
  },
  h_crowley: { 
    passive: { name: "í‘ë§ˆìˆ ", mechanic: "HEAL", val: 15, adRatio: 0, apRatio: 0.2, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì €ì£¼ë°›ì€ íƒ„í™˜", mechanic: "DAMAGE", val: 120, adRatio: 0, apRatio: 1.0, cost: 50, cd: 4, range: 800, duration: 0 },
    w: { name: "ì˜í˜¼ í¡ìˆ˜", mechanic: "DAMAGE", val: 100, adRatio: 0, apRatio: 0.8, cost: 60, cd: 9, range: 700, duration: 0 },
    e: { name: "ê³µí¬", mechanic: "STUN", val: 60, adRatio: 0, apRatio: 0.5, cost: 80, cd: 16, range: 600, duration: 1.8 },
    r: { name: "ì§€ì˜¥ë¬¸", mechanic: "DAMAGE", val: 400, adRatio: 0, apRatio: 2.2, cost: 120, cd: 120, range: 900, duration: 0 }
  },
  h_elara: { 
    passive: { name: "ë³„ì˜ ì¶•ë³µ", mechanic: "HEAL", val: 40, adRatio: 0, apRatio: 0.4, cost: 0, cd: 10, range: 600, duration: 0, isPassive: true },
    q: { name: "ë¹›ì˜ í™”ì‚´", mechanic: "DAMAGE", val: 110, adRatio: 0, apRatio: 1.1, cost: 55, cd: 5, range: 950, duration: 0 },
    w: { name: "ì¹˜ìœ ", mechanic: "HEAL", val: 130, adRatio: 0, apRatio: 0.8, cost: 70, cd: 10, range: 700, duration: 0 },
    e: { name: "êµ¬ì†", mechanic: "STUN", val: 80, adRatio: 0, apRatio: 0.7, cost: 80, cd: 13, range: 800, duration: 1.5 },
    r: { name: "ì²œìƒì˜ ì‹¬íŒ", mechanic: "GLOBAL", val: 450, adRatio: 0, apRatio: 2.0, cost: 150, cd: 130, range: 20000, duration: 0 }
  },
  h_nix: { 
    passive: { name: "ì–´ë‘ ì˜ ì¥ë§‰", mechanic: "STEALTH", val: 0, adRatio: 0, apRatio: 0, cost: 0, cd: 25, range: 0, duration: 4.0, isPassive: true },
    q: { name: "ì–´ë‘ ì˜ êµ¬ì²´", mechanic: "DAMAGE", val: 130, adRatio: 0, apRatio: 1.2, cost: 60, cd: 6, range: 850, duration: 0 },
    w: { name: "ê·¸ë¦¼ì ì†ë°•", mechanic: "HOOK", val: 400, adRatio: 0, apRatio: 0.6, cost: 70, cd: 15, range: 800, duration: 1.0 },
    e: { name: "ì–´ë‘  ë„ì•½", mechanic: "DASH", val: 400, adRatio: 0, apRatio: 0.4, cost: 50, cd: 12, range: 400, duration: 0.2 },
    r: { name: "ì˜ì›í•œ ë°¤", mechanic: "STUN", val: 400, adRatio: 0, apRatio: 2.1, cost: 120, cd: 140, range: 1000, duration: 2.5 }
  },
  h_sol: { 
    passive: { name: "íƒœì–‘ì—´", mechanic: "DAMAGE", val: 15, adRatio: 0, apRatio: 0.2, cost: 0, cd: 0, range: 400, duration: 0, isPassive: true },
    q: { name: "í”Œë ˆì–´", mechanic: "DAMAGE", val: 160, adRatio: 0, apRatio: 1.4, cost: 65, cd: 7, range: 950, duration: 0 },
    w: { name: "íƒœì–‘ ë°©íŒ¨", mechanic: "SHIELD", val: 120, adRatio: 0, apRatio: 0.6, cost: 70, cd: 14, range: 0, duration: 4.0 },
    e: { name: "ì—´í’", mechanic: "DASH", val: 450, adRatio: 0, apRatio: 0.4, cost: 60, cd: 12, range: 450, duration: 0.2 },
    r: { name: "ìŠˆí¼ë…¸ë°”", mechanic: "DAMAGE", val: 550, adRatio: 0, apRatio: 2.7, cost: 150, cd: 150, range: 1100, duration: 0 }
  },
  h_gaia: { 
    passive: { name: "ëŒ€ì§€ì˜ ê°€í˜¸", mechanic: "SHIELD", val: 60, adRatio: 0, apRatio: 0.3, cost: 0, cd: 15, range: 0, duration: 5.0, isPassive: true },
    q: { name: "ì§€ì§„", mechanic: "DAMAGE", val: 120, adRatio: 0, apRatio: 1.0, cost: 55, cd: 7, range: 800, duration: 0 },
    w: { name: "ë©êµ´ ì†", mechanic: "STUN", val: 80, adRatio: 0, apRatio: 0.7, cost: 70, cd: 13, range: 750, duration: 1.5 },
    e: { name: "ì¬ìƒ", mechanic: "HEAL", val: 110, adRatio: 0, apRatio: 0.6, cost: 65, cd: 14, range: 600, duration: 0 },
    r: { name: "ëŒ€ìì—°ì˜ ë¶„ë…¸", mechanic: "GLOBAL", val: 400, adRatio: 0, apRatio: 2.0, cost: 130, cd: 130, range: 20000, duration: 0 }
  },
  h_nostra: { 
    passive: { name: "ì˜ˆì§€", mechanic: "DAMAGE", val: 20, adRatio: 0, apRatio: 0.2, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ìš´ëª…ì˜ ìˆ˜ë ˆë°”í€´", mechanic: "DAMAGE", val: 130, adRatio: 0, apRatio: 1.1, cost: 50, cd: 6, range: 900, duration: 0 },
    w: { name: "ì¬ì•™", mechanic: "STUN", val: 70, adRatio: 0, apRatio: 0.6, cost: 70, cd: 14, range: 700, duration: 1.5 },
    e: { name: "ì‹œê°„ ì™œê³¡", mechanic: "DASH", val: 400, adRatio: 0, apRatio: 0, cost: 60, cd: 18, range: 400, duration: 0.2 },
    r: { name: "ì¢…ë§ì˜ ì˜ˆì–¸", mechanic: "GLOBAL", val: 480, adRatio: 0, apRatio: 2.3, cost: 150, cd: 150, range: 20000, duration: 0 }
  },
  h_rasputin: { 
    passive: { name: "ë¶ˆë©¸", mechanic: "HEAL", val: 35, adRatio: 0, apRatio: 0.2, cost: 0, cd: 10, range: 0, duration: 0, isPassive: true },
    q: { name: "ë…ê·¹ë¬¼", mechanic: "DAMAGE", val: 110, adRatio: 0, apRatio: 1.0, cost: 50, cd: 5, range: 750, duration: 0 },
    w: { name: "ìµœë©´", mechanic: "STUN", val: 60, adRatio: 0, apRatio: 0.5, cost: 80, cd: 12, range: 650, duration: 2.0 },
    e: { name: "ìê°€ ì¹˜ìœ ", mechanic: "HEAL", val: 130, adRatio: 0, apRatio: 0.8, cost: 70, cd: 10, range: 0, duration: 0 },
    r: { name: "ê´´ìŠ¹ì˜ ì €ì£¼", mechanic: "DAMAGE", val: 380, adRatio: 0, apRatio: 1.9, cost: 120, cd: 120, range: 900, duration: 0 }
  },
  h_circe: { 
    passive: { name: "ë³€ì‹ ìˆ ", mechanic: "DAMAGE", val: 15, adRatio: 0, apRatio: 0.2, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ë…ì•½", mechanic: "DAMAGE", val: 120, adRatio: 0, apRatio: 1.1, cost: 55, cd: 6, range: 800, duration: 0 },
    w: { name: "ë³€ì´", mechanic: "STUN", val: 50, adRatio: 0, apRatio: 0.5, cost: 80, cd: 16, range: 600, duration: 1.5 },
    e: { name: "í™˜ì˜", mechanic: "STEALTH", val: 0, adRatio: 0, apRatio: 0, cost: 70, cd: 18, range: 0, duration: 3.0 },
    r: { name: "ë§ˆë…€ì˜ ì—°íšŒ", mechanic: "GLOBAL", val: 420, adRatio: 0, apRatio: 2.2, cost: 140, cd: 140, range: 20000, duration: 0 }
  },
  h_morgana: { 
    passive: { name: "íƒ€ë½", mechanic: "SHIELD", val: 40, adRatio: 0, apRatio: 0.3, cost: 0, cd: 12, range: 0, duration: 4.0, isPassive: true },
    q: { name: "ì–´ë‘ ì˜ ì†ë°•", mechanic: "STUN", val: 90, adRatio: 0, apRatio: 0.8, cost: 60, cd: 10, range: 900, duration: 2.0 },
    w: { name: "ê³ í†µì˜ ëŒ€ì§€", mechanic: "DAMAGE", val: 100, adRatio: 0, apRatio: 0.9, cost: 50, cd: 8, range: 800, duration: 0 },
    e: { name: "ë¸”ë™ ì‰´ë“œ", mechanic: "SHIELD", val: 150, adRatio: 0, apRatio: 0.7, cost: 80, cd: 16, range: 650, duration: 5.0 },
    r: { name: "ì˜í˜¼ì˜ ì¡±ì‡„", mechanic: "STUN", val: 380, adRatio: 0, apRatio: 2.0, cost: 120, cd: 130, range: 600, duration: 1.5 }
  },

  // ===================== [ì¶”ì ì] =====================
  h_kage: { 
    passive: { name: "ì•”ìŠµ", mechanic: "DAMAGE", val: 35, adRatio: 0.5, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ìˆ˜ë¦¬ê²€", mechanic: "DAMAGE", val: 110, adRatio: 1.1, apRatio: 0, cost: 40, cd: 4, range: 600, duration: 0 },
    w: { name: "ë¶„ì‹ ìˆ ", mechanic: "SHIELD", val: 70, adRatio: 0.4, apRatio: 0, cost: 50, cd: 14, range: 0, duration: 3.0 },
    e: { name: "ì€ì‹ ", mechanic: "STEALTH", val: 0, adRatio: 0, apRatio: 0, cost: 60, cd: 18, range: 0, duration: 5.0 },
    r: { name: "ì•”ì‚´ ë¹„ê¸°", mechanic: "EXECUTE", val: 450, adRatio: 2.5, apRatio: 0, cost: 100, cd: 100, range: 450, duration: 0 }
  },
  h_fenrir: { 
    passive: { name: "ì•¼ìˆ˜ì„±", mechanic: "DAMAGE", val: 20, adRatio: 0.3, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ë¬¼ì–´ëœ¯ê¸°", mechanic: "DAMAGE", val: 130, adRatio: 1.3, apRatio: 0, cost: 45, cd: 5, range: 250, duration: 0 },
    w: { name: "í¬íš¨", mechanic: "STUN", val: 40, adRatio: 0, apRatio: 0, cost: 50, cd: 15, range: 400, duration: 1.5 },
    e: { name: "ë„ì•½", mechanic: "DASH", val: 550, adRatio: 0.8, apRatio: 0, cost: 50, cd: 10, range: 550, duration: 0.2 },
    r: { name: "ë¼ê·¸ë‚˜ë¡œí¬ì˜ ëŠ‘ëŒ€", mechanic: "DAMAGE", val: 380, adRatio: 2.0, apRatio: 0, cost: 100, cd: 110, range: 0, duration: 0 }
  },
  h_viper: { 
    passive: { name: "ì‹ ê²½ë…", mechanic: "DAMAGE", val: 15, adRatio: 0.2, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ë…ì¹¨", mechanic: "DAMAGE", val: 90, adRatio: 1.0, apRatio: 0, cost: 35, cd: 4, range: 550, duration: 0 },
    w: { name: "ì—°ë§‰", mechanic: "STEALTH", val: 0, adRatio: 0, apRatio: 0, cost: 60, cd: 20, range: 0, duration: 4.0 },
    e: { name: "ë…ì‚¬ì˜ ì¶¤", mechanic: "DASH", val: 450, adRatio: 0.6, apRatio: 0, cost: 40, cd: 12, range: 450, duration: 0.2 },
    r: { name: "ì¹˜ëª…ì ì¸ ë§¹ë…", mechanic: "EXECUTE", val: 320, adRatio: 1.8, apRatio: 0, cost: 100, cd: 120, range: 600, duration: 0 }
  },
  h_specter: { 
    passive: { name: "ìœ ì²´í™”", mechanic: "DAMAGE", val: 20, adRatio: 0, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì˜í˜¼ ë² ê¸°", mechanic: "DAMAGE", val: 130, adRatio: 1.2, apRatio: 0, cost: 40, cd: 6, range: 350, duration: 0 },
    w: { name: "ë¹™ì˜", mechanic: "STUN", val: 70, adRatio: 0.5, apRatio: 0, cost: 70, cd: 16, range: 500, duration: 1.0 },
    e: { name: "ë²½ í†µê³¼", mechanic: "DASH", val: 600, adRatio: 0, apRatio: 0, cost: 50, cd: 14, range: 600, duration: 0.5 },
    r: { name: "ì‚¬ì‹ ì˜ ë‚«", mechanic: "EXECUTE", val: 500, adRatio: 2.4, apRatio: 0, cost: 100, cd: 130, range: 400, duration: 0 }
  },
  h_locust: { 
    passive: { name: "êµ°ì²´ì˜ ì˜ì‹", mechanic: "DAMAGE", val: 10, adRatio: 0.2, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ê°ˆí€´ì†", mechanic: "DAMAGE", val: 110, adRatio: 1.1, apRatio: 0, cost: 40, cd: 5, range: 300, duration: 0 },
    w: { name: "ê°‘ê° ê°•í™”", mechanic: "SHIELD", val: 100, adRatio: 0.3, apRatio: 0, cost: 50, cd: 12, range: 0, duration: 4.0 },
    e: { name: "ë„ì•½ ê³µê²©", mechanic: "DASH", val: 600, adRatio: 0.9, apRatio: 0, cost: 50, cd: 8, range: 600, duration: 0.3 },
    r: { name: "í¬ì‹", mechanic: "HEAL", val: 220, adRatio: 1.5, apRatio: 0, cost: 100, cd: 100, range: 300, duration: 0 }
  },
  h_scarlet: { 
    passive: { name: "í”¼ì˜ ê³„ì•½", mechanic: "DAMAGE", val: 25, adRatio: 0.2, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "í˜ˆê²©", mechanic: "DAMAGE", val: 140, adRatio: 1.4, apRatio: 0, cost: 0, cd: 5, range: 400, duration: 0 },
    w: { name: "ë¶‰ì€ ì•ˆê°œ", mechanic: "STEALTH", val: 0, adRatio: 0, apRatio: 0, cost: 0, cd: 18, range: 0, duration: 4.0 },
    e: { name: "íšŒì „ ë² ê¸°", mechanic: "DAMAGE", val: 100, adRatio: 1.0, apRatio: 0, cost: 0, cd: 8, range: 350, duration: 0 },
    r: { name: "ë¸”ëŸ¬ë“œ ë¬¸", mechanic: "EXECUTE", val: 450, adRatio: 2.3, apRatio: 0, cost: 0, cd: 110, range: 600, duration: 0 }
  },
  h_hattori: { 
    passive: { name: "ì¸ìˆ ", mechanic: "DAMAGE", val: 25, adRatio: 0.3, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì•”ì‚´ê²€", mechanic: "DAMAGE", val: 130, adRatio: 1.3, apRatio: 0, cost: 45, cd: 5, range: 350, duration: 0 },
    w: { name: "ì—°ë§‰íƒ„", mechanic: "STEALTH", val: 0, adRatio: 0, apRatio: 0, cost: 60, cd: 14, range: 0, duration: 3.5 },
    e: { name: "ê·¸ë¦¼ì ì´ë™", mechanic: "DASH", val: 550, adRatio: 0.6, apRatio: 0, cost: 50, cd: 10, range: 550, duration: 0.2 },
    r: { name: "ì²œë³¸ì•µ", mechanic: "EXECUTE", val: 420, adRatio: 2.2, apRatio: 0, cost: 100, cd: 110, range: 550, duration: 0 }
  },
  h_jack: { 
    passive: { name: "ëŸ°ë˜ì˜ ì•ˆê°œ", mechanic: "STEALTH", val: 0, adRatio: 0, apRatio: 0, cost: 0, cd: 20, range: 0, duration: 6.0, isPassive: true },
    q: { name: "ë‚˜ì´í”„", mechanic: "DAMAGE", val: 110, adRatio: 1.1, apRatio: 0, cost: 40, cd: 4, range: 600, duration: 0 },
    w: { name: "ê³µí¬ì‹¬", mechanic: "STUN", val: 60, adRatio: 0.5, apRatio: 0, cost: 60, cd: 12, range: 400, duration: 1.2 },
    e: { name: "ì”í˜¹í•œ ì¼ê²©", mechanic: "DAMAGE", val: 140, adRatio: 1.4, apRatio: 0, cost: 50, cd: 8, range: 300, duration: 0 },
    r: { name: "ì‚´ì¸ê·€ì˜ ë°¤", mechanic: "EXECUTE", val: 500, adRatio: 2.4, apRatio: 0, cost: 100, cd: 120, range: 500, duration: 0 }
  },
  h_arachne: { 
    passive: { name: "ê±°ë¯¸ì¤„", mechanic: "HOOK", val: 400, adRatio: 0.3, apRatio: 0, cost: 0, cd: 12, range: 450, duration: 0.5, isPassive: true },
    q: { name: "ë§¹ë… ì£¼ì…", mechanic: "DAMAGE", val: 100, adRatio: 1.0, apRatio: 0, cost: 40, cd: 5, range: 350, duration: 0 },
    w: { name: "ê±°ë¯¸ì¤„íƒ€ê¸°", mechanic: "DASH", val: 700, adRatio: 0.5, apRatio: 0, cost: 50, cd: 12, range: 700, duration: 0.2 },
    e: { name: "ê³ ì¹˜", mechanic: "STUN", val: 70, adRatio: 0.6, apRatio: 0, cost: 60, cd: 15, range: 500, duration: 1.5 },
    r: { name: "ì—¬ì™•ì˜ ì‚¬ëƒ¥", mechanic: "DAMAGE", val: 380, adRatio: 1.8, apRatio: 0, cost: 100, cd: 110, range: 600, duration: 0 }
  },
  h_goemon: { 
    passive: { name: "ì˜ì ", mechanic: "DAMAGE", val: 15, adRatio: 0.2, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì°¸ê²©", mechanic: "DAMAGE", val: 120, adRatio: 1.2, apRatio: 0, cost: 45, cd: 5, range: 300, duration: 0 },
    w: { name: "ë™ì „ ë˜ì§€ê¸°", mechanic: "DAMAGE", val: 90, adRatio: 0.9, apRatio: 0, cost: 40, cd: 8, range: 600, duration: 0 },
    e: { name: "ì§€ë¶• íƒ€ê¸°", mechanic: "DASH", val: 600, adRatio: 0.7, apRatio: 0, cost: 55, cd: 14, range: 600, duration: 0.3 },
    r: { name: "ëŒ€ë„ë‘‘ì˜ ì—°íšŒ", mechanic: "GLOBAL", val: 420, adRatio: 2.0, apRatio: 0, cost: 120, cd: 130, range: 1000, duration: 0 }
  },

  // ===================== [ìˆ˜í˜¸ê¸°ì‚¬] =====================
  h_aigis: { 
    passive: { name: "ì ˆëŒ€ ë°©ì–´", mechanic: "SHIELD", val: 70, adRatio: 0, apRatio: 0, cost: 0, cd: 15, range: 0, duration: 3.0, isPassive: true },
    q: { name: "ë°©íŒ¨ ë°€ì¹˜ê¸°", mechanic: "STUN", val: 90, adRatio: 0.6, apRatio: 0, cost: 50, cd: 10, range: 250, duration: 1.0 },
    w: { name: "ìˆ˜í˜¸ íƒœì„¸", mechanic: "SHIELD", val: 200, adRatio: 0.2, apRatio: 0, cost: 60, cd: 15, range: 0, duration: 4.0 },
    e: { name: "ê°€ë¡œë§‰ê¸°", mechanic: "DASH", val: 450, adRatio: 0, apRatio: 0, cost: 50, cd: 12, range: 450, duration: 0.2 },
    r: { name: "ì² ì˜¹ì„±", mechanic: "GLOBAL", val: 250, adRatio: 0, apRatio: 0, cost: 100, cd: 160, range: 20000, duration: 8.0 }
  },
  h_golem: { 
    passive: { name: "ë°”ìœ„ í”¼ë¶€", mechanic: "DAMAGE", val: 30, adRatio: 0, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì§€ë©´ ê°•íƒ€", mechanic: "DAMAGE", val: 110, adRatio: 0.8, apRatio: 0, cost: 40, cd: 8, range: 350, duration: 0 },
    w: { name: "ë‹¨ë‹¨í•´ì§€ê¸°", mechanic: "SHIELD", val: 180, adRatio: 0.3, apRatio: 0, cost: 50, cd: 14, range: 0, duration: 5.0 },
    e: { name: "ë°”ìœ„ ë˜ì§€ê¸°", mechanic: "STUN", val: 100, adRatio: 0.7, apRatio: 0, cost: 60, cd: 12, range: 600, duration: 1.2 },
    r: { name: "ëŒ€ì§€ì§„", mechanic: "STUN", val: 280, adRatio: 1.0, apRatio: 0, cost: 100, cd: 140, range: 800, duration: 2.0 }
  },
  h_paladin: { 
    passive: { name: "ì‹ ì„±í•œ ì˜¤ë¼", mechanic: "HEAL", val: 10, adRatio: 0, apRatio: 0.1, cost: 0, cd: 5, range: 500, duration: 0, isPassive: true },
    q: { name: "ì„±ìŠ¤ëŸ¬ìš´ ì¼ê²©", mechanic: "DAMAGE", val: 100, adRatio: 0.9, apRatio: 0, cost: 45, cd: 7, range: 300, duration: 0 },
    w: { name: "ì¶•ë³µ", mechanic: "HEAL", val: 130, adRatio: 0, apRatio: 0.5, cost: 70, cd: 12, range: 600, duration: 0 },
    e: { name: "ì‹¬íŒ", mechanic: "STUN", val: 80, adRatio: 0.6, apRatio: 0, cost: 60, cd: 15, range: 400, duration: 1.5 },
    r: { name: "ì‹ ì˜ ê°€í˜¸", mechanic: "GLOBAL", val: 350, adRatio: 0, apRatio: 0, cost: 120, cd: 180, range: 20000, duration: 5.0 }
  },
  h_treant: { 
    passive: { name: "ê´‘í•©ì„±", mechanic: "HEAL", val: 25, adRatio: 0, apRatio: 0, cost: 0, cd: 5, range: 0, duration: 0, isPassive: true },
    q: { name: "ë¿Œë¦¬ ë¬¶ê¸°", mechanic: "STUN", val: 70, adRatio: 0, apRatio: 0.4, cost: 60, cd: 10, range: 650, duration: 1.8 },
    w: { name: "ë‚˜ë¬´ ê»ì§ˆ", mechanic: "SHIELD", val: 140, adRatio: 0, apRatio: 0.3, cost: 50, cd: 16, range: 0, duration: 4.0 },
    e: { name: "ìì—°ì˜ ì†ê¸¸", mechanic: "HEAL", val: 100, adRatio: 0, apRatio: 0.4, cost: 70, cd: 14, range: 600, duration: 0 },
    r: { name: "ìˆ²ì˜ ë¶„ë…¸", mechanic: "DAMAGE", val: 320, adRatio: 0, apRatio: 1.0, cost: 100, cd: 130, range: 800, duration: 0 }
  },
  h_magnus: { 
    passive: { name: "ê±°ì¸ì˜ í˜", mechanic: "DAMAGE", val: 40, adRatio: 0.3, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì¶©ê²©íŒŒ", mechanic: "DAMAGE", val: 120, adRatio: 0.9, apRatio: 0, cost: 45, cd: 8, range: 400, duration: 0 },
    w: { name: "ë“¤ì´ë°›ê¸°", mechanic: "DASH", val: 550, adRatio: 0.8, apRatio: 0, cost: 55, cd: 12, range: 550, duration: 0.2 },
    e: { name: "ìœ„ì••", mechanic: "STUN", val: 60, adRatio: 0.5, apRatio: 0, cost: 60, cd: 15, range: 300, duration: 1.2 },
    r: { name: "ë’¤ì§‘ê¸°", mechanic: "HOOK", val: 200, adRatio: 1.2, apRatio: 0, cost: 100, cd: 100, range: 250, duration: 0.5 }
  },
  h_yeti: { 
    passive: { name: "ì„¤ì¸", mechanic: "DAMAGE", val: 20, adRatio: 0, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ì–¼ìŒ ë­‰ì¹˜", mechanic: "STUN", val: 80, adRatio: 0.7, apRatio: 0, cost: 50, cd: 9, range: 550, duration: 1.0 },
    w: { name: "í¬ì‹", mechanic: "HEAL", val: 150, adRatio: 0.5, apRatio: 0, cost: 60, cd: 18, range: 200, duration: 0 },
    e: { name: "ëˆˆì‚¬íƒœ", mechanic: "DAMAGE", val: 110, adRatio: 0.8, apRatio: 0, cost: 50, cd: 10, range: 450, duration: 0 },
    r: { name: "ì ˆëŒ€ ì˜ë„", mechanic: "STUN", val: 320, adRatio: 1.0, apRatio: 0, cost: 100, cd: 140, range: 800, duration: 2.5 }
  },
  h_spartacus: { 
    passive: { name: "ë…¸ì˜ˆì˜ í•´ë°©", mechanic: "DAMAGE", val: 25, adRatio: 0.3, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ê²€íˆ¬ì‚¬ì˜ ì¼ê²©", mechanic: "DAMAGE", val: 120, adRatio: 1.0, apRatio: 0, cost: 40, cd: 7, range: 300, duration: 0 },
    w: { name: "ë°©íŒ¨ ì¹˜ê¸°", mechanic: "STUN", val: 80, adRatio: 0.5, apRatio: 0, cost: 50, cd: 12, range: 250, duration: 1.2 },
    e: { name: "ë¶ˆêµ´", mechanic: "HEAL", val: 120, adRatio: 0.4, apRatio: 0, cost: 60, cd: 16, range: 0, duration: 0 },
    r: { name: "ë°˜ë€ì˜ ì‹œì‘", mechanic: "DAMAGE", val: 350, adRatio: 1.5, apRatio: 0, cost: 100, cd: 140, range: 600, duration: 0 }
  },
  h_titan: { 
    passive: { name: "ê±°ì¸ì˜ í”¼ë¶€", mechanic: "SHIELD", val: 70, adRatio: 0, apRatio: 0, cost: 0, cd: 20, range: 0, duration: 5.0, isPassive: true },
    q: { name: "ë‚´ë ¤ì°ê¸°", mechanic: "STUN", val: 100, adRatio: 0.8, apRatio: 0, cost: 55, cd: 10, range: 350, duration: 1.0 },
    w: { name: "ì§€ì§„", mechanic: "DAMAGE", val: 130, adRatio: 0.7, apRatio: 0, cost: 50, cd: 14, range: 500, duration: 0 },
    e: { name: "ì² ë²½", mechanic: "SHIELD", val: 200, adRatio: 0.3, apRatio: 0, cost: 70, cd: 18, range: 0, duration: 5.0 },
    r: { name: "ë¼ê·¸ë‚˜ë¡œí¬", mechanic: "GLOBAL", val: 400, adRatio: 1.2, apRatio: 0, cost: 150, cd: 160, range: 1000, duration: 0 }
  },
  h_behemoth: { 
    passive: { name: "ê´´ìˆ˜", mechanic: "DAMAGE", val: 40, adRatio: 0, apRatio: 0, cost: 0, cd: 0, range: 0, duration: 0, isPassive: true },
    q: { name: "ëŒì§„", mechanic: "DASH", val: 550, adRatio: 0.7, apRatio: 0, cost: 50, cd: 12, range: 550, duration: 0.3 },
    w: { name: "ì§€ë©´ ë¶•ê´´", mechanic: "STUN", val: 90, adRatio: 0.6, apRatio: 0, cost: 60, cd: 15, range: 400, duration: 1.2 },
    e: { name: "ë‘êº¼ìš´ ê°€ì£½", mechanic: "SHIELD", val: 180, adRatio: 0.2, apRatio: 0, cost: 55, cd: 16, range: 0, duration: 4.0 },
    r: { name: "í¬ì‹", mechanic: "EXECUTE", val: 320, adRatio: 1.5, apRatio: 0, cost: 100, cd: 130, range: 300, duration: 0 }
  },
  h_tortuga: { 
    passive: { name: "ë“±ê»ì§ˆ", mechanic: "SHIELD", val: 80, adRatio: 0, apRatio: 0, cost: 0, cd: 25, range: 0, duration: 5.0, isPassive: true },
    q: { name: "ë¬¼ëŒ€í¬", mechanic: "DAMAGE", val: 100, adRatio: 0.6, apRatio: 0.4, cost: 40, cd: 8, range: 600, duration: 0 },
    w: { name: "ê»ì§ˆ ìˆ¨ê¸°", mechanic: "SHIELD", val: 250, adRatio: 0, apRatio: 0.5, cost: 60, cd: 20, range: 0, duration: 6.0 },
    e: { name: "íšŒì „ ê³µê²©", mechanic: "STUN", val: 80, adRatio: 0.7, apRatio: 0, cost: 50, cd: 14, range: 400, duration: 1.0 },
    r: { name: "í•´ì¼", mechanic: "GLOBAL", val: 350, adRatio: 0, apRatio: 1.5, cost: 120, cd: 150, range: 1200, duration: 0 }
  },

  // ===================== [ì‹ ì‚´ì] =====================
  h_hawk: { 
    passive: { name: "ë§¤ì˜ ëˆˆ", mechanic: "DAMAGE", val: 15, adRatio: 0.5, apRatio: 0, cost: 0, cd: 0, range: 700, duration: 0, isPassive: true },
    q: { name: "ì •ë°€ ì‚¬ê²©", mechanic: "DAMAGE", val: 140, adRatio: 1.4, apRatio: 0, cost: 50, cd: 6, range: 1000, duration: 0 },
    w: { name: "ì†ì‚¬", mechanic: "DAMAGE", val: 100, adRatio: 1.0, apRatio: 0, cost: 40, cd: 10, range: 600, duration: 0 },
    e: { name: "íšŒí”¼ ê¸°ë™", mechanic: "DASH", val: 450, adRatio: 0.3, apRatio: 0, cost: 50, cd: 14, range: 450, duration: 0.2 },
    r: { name: "ê´€í†µìƒ", mechanic: "EXECUTE", val: 420, adRatio: 2.0, apRatio: 0, cost: 100, cd: 110, range: 1200, duration: 0 }
  },
  h_trigger: { 
    passive: { name: "ë”ë¸” íƒ­", mechanic: "DAMAGE", val: 20, adRatio: 0.4, apRatio: 0, cost: 0, cd: 0, range: 550, duration: 0, isPassive: true },
    q: { name: "ë‚œì‚¬", mechanic: "DAMAGE", val: 130, adRatio: 1.2, apRatio: 0, cost: 45, cd: 5, range: 600, duration: 0 },
    w: { name: "ìˆ˜ë¥˜íƒ„", mechanic: "DAMAGE", val: 110, adRatio: 0.8, apRatio: 0, cost: 50, cd: 12, range: 700, duration: 0 },
    e: { name: "ìŠ¬ë¼ì´ë”©", mechanic: "DASH", val: 500, adRatio: 0.4, apRatio: 0, cost: 40, cd: 10, range: 500, duration: 0.3 },
    r: { name: "ë¶ˆê½ƒë†€ì´", mechanic: "GLOBAL", val: 480, adRatio: 1.8, apRatio: 0, cost: 120, cd: 130, range: 2500, duration: 0 }
  },
  h_nova: { 
    passive: { name: "ì—ë„ˆì§€ ì¶©ì „", mechanic: "DAMAGE", val: 15, adRatio: 0.3, apRatio: 0.2, cost: 0, cd: 0, range: 600, duration: 0, isPassive: true },
    q: { name: "í”Œë¼ì¦ˆë§ˆ", mechanic: "DAMAGE", val: 150, adRatio: 1.3, apRatio: 0, cost: 55, cd: 7, range: 900, duration: 0 },
    w: { name: "ì¤‘ë ¥íƒ„", mechanic: "STUN", val: 70, adRatio: 0.5, apRatio: 0, cost: 65, cd: 15, range: 800, duration: 1.2 },
    e: { name: "ì¶”ì§„ê¸°", mechanic: "DASH", val: 550, adRatio: 0.5, apRatio: 0, cost: 60, cd: 18, range: 550, duration: 0.4 },
    r: { name: "ê¶¤ë„ í­ê²©", mechanic: "GLOBAL", val: 500, adRatio: 2.2, apRatio: 0, cost: 140, cd: 150, range: 20000, duration: 0 }
  },
  h_flint: { 
    passive: { name: "í™”ì•½ ëƒ„ìƒˆ", mechanic: "DAMAGE", val: 25, adRatio: 0.3, apRatio: 0, cost: 0, cd: 0, range: 500, duration: 0, isPassive: true },
    q: { name: "ì‚°íƒ„ ì‚¬ê²©", mechanic: "DAMAGE", val: 160, adRatio: 1.5, apRatio: 0, cost: 50, cd: 8, range: 400, duration: 0 },
    w: { name: "ì—°ë§‰íƒ„", mechanic: "STEALTH", val: 0, adRatio: 0, apRatio: 0, cost: 60, cd: 20, range: 0, duration: 3.5 },
    e: { name: "ì™€ì´ì–´", mechanic: "DASH", val: 650, adRatio: 0.6, apRatio: 0, cost: 50, cd: 16, range: 650, duration: 0.5 },
    r: { name: "ë°ìŠ¤í˜ë¼ë„", mechanic: "DAMAGE", val: 420, adRatio: 2.5, apRatio: 0, cost: 100, cd: 120, range: 800, duration: 0 }
  },
  h_sylvia: { 
    passive: { name: "ë°”ëŒì˜ ì†ì‚­ì„", mechanic: "DAMAGE", val: 15, adRatio: 0.4, apRatio: 0, cost: 0, cd: 0, range: 650, duration: 0, isPassive: true },
    q: { name: "ë°”ëŒ í™”ì‚´", mechanic: "DAMAGE", val: 130, adRatio: 1.3, apRatio: 0, cost: 45, cd: 6, range: 1000, duration: 0 },
    w: { name: "ë°€ì³ë‚´ê¸°", mechanic: "DAMAGE", val: 90, adRatio: 0.6, apRatio: 0, cost: 50, cd: 12, range: 500, duration: 0 },
    e: { name: "ë°”ëŒíƒ€ê¸°", mechanic: "DASH", val: 500, adRatio: 0.4, apRatio: 0, cost: 40, cd: 14, range: 500, duration: 0.3 },
    r: { name: "í­í’ìš°", mechanic: "DAMAGE", val: 380, adRatio: 1.8, apRatio: 0, cost: 100, cd: 110, range: 900, duration: 0 }
  },
  h_gambit: { 
    passive: { name: "ë„ë°•ì‚¬ì˜ í–‰ìš´", mechanic: "DAMAGE", val: 20, adRatio: 0.5, apRatio: 0, cost: 0, cd: 0, range: 550, duration: 0, isPassive: true },
    q: { name: "ì¹´ë“œ íˆ¬ì²™", mechanic: "DAMAGE", val: 140, adRatio: 1.2, apRatio: 0, cost: 40, cd: 5, range: 750, duration: 0 },
    w: { name: "ì†ì„ìˆ˜", mechanic: "STEALTH", val: 0, adRatio: 0, apRatio: 0, cost: 60, cd: 18, range: 0, duration: 3.0 },
    e: { name: "íŒëˆ ì˜¬ë¦¬ê¸°", mechanic: "DAMAGE", val: 0, adRatio: 0.4, apRatio: 0, cost: 50, cd: 10, range: 0, duration: 0 },
    r: { name: "ë¡œì—´ ìŠ¤íŠ¸ë ˆì´íŠ¸", mechanic: "EXECUTE", val: 500, adRatio: 2.4, apRatio: 0, cost: 120, cd: 130, range: 1200, duration: 0 }
  },
  h_robin: { 
    passive: { name: "ì˜ì ", mechanic: "DAMAGE", val: 15, adRatio: 0.2, apRatio: 0, cost: 0, cd: 0, range: 600, duration: 0, isPassive: true },
    q: { name: "ì •í™•í•œ ì‚¬ê²©", mechanic: "DAMAGE", val: 140, adRatio: 1.3, apRatio: 0, cost: 45, cd: 6, range: 1100, duration: 0 },
    w: { name: "í™”ì‚´ë¹„", mechanic: "DAMAGE", val: 110, adRatio: 1.0, apRatio: 0, cost: 55, cd: 10, range: 800, duration: 0 },
    e: { name: "ìˆ²ìœ¼ë¡œ ë„ì£¼", mechanic: "DASH", val: 500, adRatio: 0.4, apRatio: 0, cost: 40, cd: 14, range: 500, duration: 0.3 },
    r: { name: "ë¡œë¹ˆì˜ í™”ì‚´", mechanic: "EXECUTE", val: 420, adRatio: 2.1, apRatio: 0, cost: 100, cd: 110, range: 1300, duration: 0 }
  },
  h_artemis: { 
    passive: { name: "ë‹¬ì˜ ì‚¬ëƒ¥ê¾¼", mechanic: "DAMAGE", val: 10, adRatio: 0.4, apRatio: 0, cost: 0, cd: 0, range: 650, duration: 0, isPassive: true },
    q: { name: "ì›”ê´‘ í™”ì‚´", mechanic: "DAMAGE", val: 130, adRatio: 1.2, apRatio: 0.3, cost: 40, cd: 5, range: 900, duration: 0 },
    w: { name: "ë« ì„¤ì¹˜", mechanic: "STUN", val: 60, adRatio: 0.5, apRatio: 0, cost: 60, cd: 12, range: 700, duration: 1.5 },
    e: { name: "ë‹¬ë¹› ì§ˆì£¼", mechanic: "DASH", val: 550, adRatio: 0.5, apRatio: 0, cost: 50, cd: 15, range: 550, duration: 0.4 },
    r: { name: "ì‚¬ëƒ¥ ê°œì‹œ", mechanic: "DAMAGE", val: 400, adRatio: 1.9, apRatio: 0, cost: 100, cd: 120, range: 1000, duration: 0 }
  },
  h_apollo: { 
    passive: { name: "íƒœì–‘ì˜ ì „ì°¨", mechanic: "DAMAGE", val: 25, adRatio: 0.3, apRatio: 0.2, cost: 0, cd: 0, range: 550, duration: 0, isPassive: true },
    q: { name: "ìŒíŒŒ ê³µê²©", mechanic: "DAMAGE", val: 120, adRatio: 1.1, apRatio: 0.4, cost: 50, cd: 6, range: 850, duration: 0 },
    w: { name: "ëˆˆë¶€ì‹  ë¹›", mechanic: "STUN", val: 50, adRatio: 0, apRatio: 0.6, cost: 65, cd: 14, range: 600, duration: 1.0 },
    e: { name: "ì „ì°¨ ëŒì§„", mechanic: "DASH", val: 550, adRatio: 0.6, apRatio: 0, cost: 60, cd: 16, range: 550, duration: 0.3 },
    r: { name: "íƒœì–‘ í­ë°œ", mechanic: "GLOBAL", val: 450, adRatio: 2.0, apRatio: 0.5, cost: 120, cd: 140, range: 1500, duration: 0 }
  },
  h_kaiser: { 
    passive: { name: "í™©ì œì˜ ìœ„ì—„", mechanic: "DAMAGE", val: 30, adRatio: 0.5, apRatio: 0, cost: 0, cd: 0, range: 700, duration: 0, isPassive: true },
    q: { name: "ê´€í†µíƒ„", mechanic: "DAMAGE", val: 150, adRatio: 1.4, apRatio: 0, cost: 55, cd: 8, range: 1000, duration: 0 },
    w: { name: "ì§€íœ˜", mechanic: "DAMAGE", val: 0, adRatio: 0, apRatio: 0, cost: 40, cd: 15, range: 0, duration: 0 },
    e: { name: "ì „ìˆ  ì´ë™", mechanic: "DASH", val: 500, adRatio: 0.4, apRatio: 0, cost: 50, cd: 12, range: 500, duration: 0.3 },
    r: { name: "ê¶¤ë©¸ ì‚¬ê²©", mechanic: "EXECUTE", val: 550, adRatio: 2.5, apRatio: 0, cost: 150, cd: 150, range: 3000, duration: 0 } 
  }
};


==========================================
FILE PATH: src/data/heroes.ts
==========================================
export * from './heroes/index';


==========================================
FILE PATH: src/data/initialImages.ts
==========================================
export const INITIAL_CUSTOM_IMAGES: Record<string, string> = {
  // [ì „ì¥ ë§µ]
  'map_bg': '/images/map.png',

  // [ì‹  (GODS)]
  'god_izman': '/images/gods/god_izman.png',
  'god_dante': '/images/gods/god_dante.png',

  // [ì—­í• êµ° (ROLES)]
  'role_executor': '/images/roles/role_executor.png',
  'role_tracker': '/images/roles/role_tracker.png',
  'role_prophet': '/images/roles/role_prophet.png',
  'role_slayer': '/images/roles/role_slayer.png',
  'role_guardian': '/images/roles/role_guardian.png',

  'role_executor_bg': '/images/roles/role_executor_bg.png',
  'role_tracker_bg': '/images/roles/role_tracker_bg.png',
  'role_prophet_bg': '/images/roles/role_prophet_bg.png',
  'role_slayer_bg': '/images/roles/role_slayer_bg.png',
  'role_guardian_bg': '/images/roles/role_guardian_bg.png',

  // [ì•„ì´í…œ (ITEMS)] - ëˆ„ë½ëœ ê²ƒë“¤ ì „ë¶€ ì¶”ê°€
  // 1. ì‹ ë°œ
  'i_boots_1': '/images/items/i_boots_1.png',
  'i_boots_2': '/images/items/i_boots_2.png',
  'i_boots_3': '/images/items/i_boots_3.png',
  'i_boots_4': '/images/items/i_boots_4.png',
  'i_boots_5': '/images/items/i_boots_5.png',

  // 2. ë¬´ê¸°
  'i_wep_1': '/images/items/i_wep_1.png',
  'i_wep_2': '/images/items/i_wep_2.png',
  'i_wep_3': '/images/items/i_wep_3.png',
  'i_wep_4': '/images/items/i_wep_4.png',
  'i_wep_5': '/images/items/i_wep_5.png',
  'i_wep_6': '/images/items/i_wep_6.png',
  'i_wep_7': '/images/items/i_wep_7.png',
  'i_wep_8': '/images/items/i_wep_8.png',
  'i_wep_9': '/images/items/i_wep_9.png',
  'i_wep_10': '/images/items/i_wep_10.png',

  // 3. ë§ˆë„êµ¬
  'i_art_1': '/images/items/i_art_1.png',
  'i_art_2': '/images/items/i_art_2.png',
  'i_art_3': '/images/items/i_art_3.png',
  'i_art_4': '/images/items/i_art_4.png',
  'i_art_5': '/images/items/i_art_5.png',
  'i_art_6': '/images/items/i_art_6.png',
  'i_art_7': '/images/items/i_art_7.png',
  'i_art_8': '/images/items/i_art_8.png',
  'i_art_9': '/images/items/i_art_9.png',
  'i_art_10': '/images/items/i_art_10.png',

  // 4. ë°©ì–´êµ¬
  'i_armor_1': '/images/items/i_armor_1.png',
  'i_armor_2': '/images/items/i_armor_2.png',
  'i_armor_3': '/images/items/i_armor_3.png',
  'i_armor_4': '/images/items/i_armor_4.png',
  'i_armor_5': '/images/items/i_armor_5.png',
  'i_armor_6': '/images/items/i_armor_6.png',
  'i_armor_7': '/images/items/i_armor_7.png',
  'i_armor_8': '/images/items/i_armor_8.png',
  'i_armor_9': '/images/items/i_armor_9.png',
  'i_armor_10': '/images/items/i_armor_10.png',

  // 5. ì¥ì‹ êµ¬
  'i_acc_1': '/images/items/i_acc_1.png',
  'i_acc_2': '/images/items/i_acc_2.png',
  'i_acc_3': '/images/items/i_acc_3.png',
  'i_acc_4': '/images/items/i_acc_4.png',
  'i_acc_5': '/images/items/i_acc_5.png',

  // 6. ê¶ŒëŠ¥ (Power)
  'p_izman_low': '/images/items/p_izman_low.png',
  'p_izman_mid': '/images/items/p_izman_mid.png',
  'p_izman_high': '/images/items/p_izman_high.png',
  'p_dante_low': '/images/items/p_dante_low.png',
  'p_dante_mid': '/images/items/p_dante_mid.png',
  'p_dante_high': '/images/items/p_dante_high.png',

  // [ì˜ì›… (HEROES)]
  'h_ragna': '/images/heroes/h_ragna.png',
  'h_kensei': '/images/heroes/h_kensei.png',
  'h_baldur': '/images/heroes/h_baldur.png',
  'h_freya': '/images/heroes/h_freya.png',
  'h_gorgon': '/images/heroes/h_gorgon.png',
  'h_arthur': '/images/heroes/h_arthur.png',
  'h_leonidas': '/images/heroes/h_leonidas.png',
  'h_musashi': '/images/heroes/h_musashi.png',
  'h_lancelot': '/images/heroes/h_lancelot.png',
  'h_siegfried': '/images/heroes/h_siegfried.png',

  'h_merlin': '/images/heroes/h_merlin.png',
  'h_crowley': '/images/heroes/h_crowley.png',
  'h_elara': '/images/heroes/h_elara.png',
  'h_nix': '/images/heroes/h_nix.png',
  'h_sol': '/images/heroes/h_sol.png',
  'h_gaia': '/images/heroes/h_gaia.png',
  'h_nostra': '/images/heroes/h_nostra.png',
  'h_rasputin': '/images/heroes/h_rasputin.png',
  'h_circe': '/images/heroes/h_circe.png',
  'h_morgana': '/images/heroes/h_morgana.png',

  'h_kage': '/images/heroes/h_kage.png',
  'h_fenrir': '/images/heroes/h_fenrir.png',
  'h_viper': '/images/heroes/h_viper.png',
  'h_specter': '/images/heroes/h_specter.png',
  'h_locust': '/images/heroes/h_locust.png',
  'h_scarlet': '/images/heroes/h_scarlet.png',
  'h_hattori': '/images/heroes/h_hattori.png',
  'h_jack': '/images/heroes/h_jack.png',
  'h_arachne': '/images/heroes/h_arachne.png',
  'h_goemon': '/images/heroes/h_goemon.png',

  'h_aigis': '/images/heroes/h_aigis.png',
  'h_golem': '/images/heroes/h_golem.png',
  'h_paladin': '/images/heroes/h_paladin.png',
  'h_treant': '/images/heroes/h_treant.png',
  'h_magnus': '/images/heroes/h_magnus.png',
  'h_yeti': '/images/heroes/h_yeti.png',
  'h_spartacus': '/images/heroes/h_spartacus.png',
  'h_titan': '/images/heroes/h_titan.png',
  'h_behemoth': '/images/heroes/h_behemoth.png',
  'h_tortuga': '/images/heroes/h_tortuga.png',

  'h_hawk': '/images/heroes/h_hawk.png',
  'h_trigger': '/images/heroes/h_trigger.png',
  'h_nova': '/images/heroes/h_nova.png',
  'h_flint': '/images/heroes/h_flint.png',
  'h_sylvia': '/images/heroes/h_sylvia.png',
  'h_gambit': '/images/heroes/h_gambit.png',
  'h_robin': '/images/heroes/h_robin.png',
  'h_artemis': '/images/heroes/h_artemis.png',
  'h_apollo': '/images/heroes/h_apollo.png',
  'h_kaiser': '/images/heroes/h_kaiser.png',
};



==========================================
FILE PATH: src/data/items.ts
==========================================
// ==========================================
// FILE PATH: /src/data/items.ts
// ==========================================
import { Item } from '../types';

export const INITIAL_ITEMS: Item[] = [
  // =================================================================
  // 1. BOOTS (ì‹ ë°œ) - ì´ë™ì†ë„ í•„ìˆ˜í…œ (5ê°œ)
  // =================================================================
  { id: 'i_boots_1', name: 'ë‚¡ì€ ì—¬í–‰í™”', cost: 300, ad: 0, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 25, regen: 0, mpRegen: 0, pen: 0, type: 'BOOTS', description: 'ê°€ë³ê³  ì§ˆê¸´ ê°€ì£½ìœ¼ë¡œ ë§Œë“  ì‹ ë°œì…ë‹ˆë‹¤.' },
  { id: 'i_boots_2', name: 'ëŒí’ì˜ ë¶€ì¸ ', cost: 1100, ad: 10, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 45, regen: 0, mpRegen: 0, pen: 0, type: 'BOOTS', description: 'ë°”ëŒì„ ê°€ë¥´ëŠ” ë“¯í•œ ê°€ë²¼ì›€ì„ ì„ ì‚¬í•©ë‹ˆë‹¤.' },
  { id: 'i_boots_3', name: 'ë¹„ì „ì˜ êµ¬ë‘', cost: 1100, ad: 0, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 45, regen: 0, mpRegen: 0, pen: 15, type: 'BOOTS', description: 'ë§ˆë²•ì˜ íë¦„ì„ ì›í™œí•˜ê²Œ í•´ì¤ë‹ˆë‹¤.' },
  { id: 'i_boots_4', name: 'ê°•ì²  ë§ì‹ ', cost: 1200, ad: 0, ap: 0, hp: 0, mp: 0, armor: 25, crit: 0, speed: 45, regen: 0, mpRegen: 0, pen: 0, type: 'BOOTS', description: 'ë‹¨ë‹¨í•œ ê°•ì² ë¡œ ë³´ê°•ëœ ì „íˆ¬í™”ì…ë‹ˆë‹¤.' },
  { id: 'i_boots_5', name: 'ê·¸ë¦¼ì ë°œê±¸ìŒ', cost: 900, ad: 0, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 65, regen: 0, mpRegen: 0, pen: 0, type: 'BOOTS', description: 'ë°œì†Œë¦¬ë¥¼ ì£½ì´ê³  ë¹ ë¥´ê²Œ ì´ë™í•©ë‹ˆë‹¤.' },

  // =================================================================
  // 2. WEAPON (ë¬´ê¸°) - ë¬¼ë¦¬ ê³µê²©ë ¥, ì¹˜ëª…íƒ€, ê´€í†µ (10ê°œ)
  // =================================================================
  { id: 'i_wep_1', name: 'ìš©ë³‘ì˜ ê²€', cost: 350, ad: 10, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'WEAPON', description: 'ì „ì¥ì—ì„œ í”íˆ ë³¼ ìˆ˜ ìˆëŠ” ì² ê²€ì…ë‹ˆë‹¤.' },
  { id: 'i_wep_2', name: 'ì¤‘ì¥ë³´ë³‘ì˜ ëŒ€ê²€', cost: 1300, ad: 45, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'WEAPON', description: 'ë¬´ê²Œê°ì´ ëŠê»´ì§€ëŠ” íŒŒê´´ì ì¸ ëŒ€ê²€ì…ë‹ˆë‹¤.' },
  { id: 'i_wep_3', name: 'ì‹¬íŒì˜ ëŒ€ê²€', cost: 3400, ad: 75, ap: 0, hp: 0, mp: 0, armor: 0, crit: 25, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'WEAPON', description: 'ì£„ì¸ì„ ë‹¨ì£„í•˜ëŠ” ì¹˜ëª…ì ì¸ ì¼ê²©ì…ë‹ˆë‹¤.' },
  { id: 'i_wep_4', name: 'ì§„í™ë¹› ì•½íƒˆì', cost: 3200, ad: 55, ap: 0, hp: 300, mp: 0, armor: 0, crit: 0, speed: 0, regen: 20, mpRegen: 0, pen: 0, type: 'WEAPON', description: 'ì ì˜ ìƒëª…ë ¥ì„ í¡ìˆ˜í•˜ëŠ” ì €ì£¼ë°›ì€ ê²€ì…ë‹ˆë‹¤.' },
  { id: 'i_wep_5', name: 'ë¼ˆ ë¶„ì‡„ê¸°', cost: 2800, ad: 40, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 35, type: 'WEAPON', description: 'ë‘êº¼ìš´ ê°‘ì˜·ë„ ì¢…ì´ì²˜ëŸ¼ ëš«ì–´ë²„ë¦½ë‹ˆë‹¤.' },
  { id: 'i_wep_6', name: 'ì¹ í‘ì˜ ë„ë¼', cost: 3100, ad: 50, ap: 0, hp: 450, mp: 0, armor: 0, crit: 0, speed: 10, regen: 0, mpRegen: 0, pen: 15, type: 'WEAPON', description: 'ê²€ì€ ë¬´ì‡ ë¡œ ì£¼ì¡°ëœ ë¬µì§í•œ ë„ë¼ì…ë‹ˆë‹¤.' },
  { id: 'i_wep_7', name: 'í™˜ì˜ì˜ ìŒê²€', cost: 2600, ad: 30, ap: 0, hp: 0, mp: 0, armor: 0, crit: 35, speed: 15, regen: 0, mpRegen: 0, pen: 0, type: 'WEAPON', description: 'ëˆˆì— ë³´ì´ì§€ ì•Šì„ ë§Œí¼ ë¹ ë¥¸ ì—°ê²©ì„ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.' },
  { id: 'i_wep_8', name: 'ë°¤ì˜ ì¶”ì ì', cost: 3000, ad: 65, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 20, type: 'WEAPON', description: 'ì–´ë‘  ì†ì—ì„œ ë¹›ì„ ë°œí•˜ëŠ” ì•”ì‚´ìì˜ ë¹„ìˆ˜ì…ë‹ˆë‹¤.' },
  { id: 'i_wep_9', name: 'ë‡Œì „ì°½', cost: 2900, ad: 55, ap: 0, hp: 0, mp: 0, armor: 0, crit: 15, speed: 10, regen: 0, mpRegen: 0, pen: 0, type: 'WEAPON', description: 'ì°Œë¥¼ ë•Œë§ˆë‹¤ ì „ë¥˜ê°€ íë¥´ëŠ” ì°½ì…ë‹ˆë‹¤.' },
  { id: 'i_wep_10', name: 'ë¶€ì‹ëœ ì¹¼ë‚ ', cost: 900, ad: 25, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 10, type: 'WEAPON', description: 'ìƒì²˜ê°€ ì‰½ê²Œ ì•„ë¬¼ì§€ ì•Šê²Œ ë§Œë“­ë‹ˆë‹¤.' },

  // =================================================================
  // 3. ARTIFACT (ë§ˆë„êµ¬) - ì£¼ë¬¸ë ¥, ë§ˆë‚˜, ë§ˆë‚˜ì¬ìƒ (10ê°œ)
  // =================================================================
  { id: 'i_art_1', name: 'ë§ˆë²• ì…ë¬¸ì„œ', cost: 435, ad: 0, ap: 25, hp: 0, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'ARTIFACT', description: 'ë§ˆë²•ì‚¬ì˜ ê¸°ì´ˆ ì†Œì–‘ì„ ë‹´ì€ ì±…ì…ë‹ˆë‹¤.' },
  { id: 'i_art_2', name: 'ê³ ëŒ€ ë£¬ì„', cost: 1100, ad: 0, ap: 40, hp: 0, mp: 350, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 8, type: 'ARTIFACT', description: 'ì˜¤ë˜ëœ ë§ˆë ¥ì´ ê¹ƒë“  ëŒì…ë‹ˆë‹¤.' },
  { id: 'i_art_3', name: 'ëŒ€ë§ˆë²•ì‚¬ì˜ ì™•ê´€', cost: 3600, ad: 0, ap: 130, hp: 0, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'ARTIFACT', description: 'ì „ì„¤ì ì¸ ëŒ€ë§ˆë²•ì‚¬ê°€ ì°©ìš©í–ˆë˜ ì™•ê´€ì…ë‹ˆë‹¤.' },
  { id: 'i_art_4', name: 'ì‹¬ì—°ì˜ ìˆ˜ì •êµ¬', cost: 2800, ad: 0, ap: 75, hp: 0, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 45, type: 'ARTIFACT', description: 'ë§ˆë²• ì €í•­ì„ ë¬´ë ¥í™”í•˜ëŠ” ê³µí—ˆì˜ í˜ì´ ë‹´ê²¨ìˆìŠµë‹ˆë‹¤.' },
  { id: 'i_art_5', name: 'ì²œë‘¥ì˜ ì§€íŒ¡ì´', cost: 3200, ad: 0, ap: 95, hp: 0, mp: 500, armor: 0, crit: 0, speed: 5, regen: 0, mpRegen: 0, pen: 10, type: 'ARTIFACT', description: 'í­ë°œì ì¸ ì—ë„ˆì§€ë¥¼ ë°©ì¶œí•©ë‹ˆë‹¤.' },
  { id: 'i_art_6', name: 'ì„í™”ì˜ ë¶€ì ', cost: 2900, ad: 0, ap: 80, hp: 0, mp: 0, armor: 50, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'ARTIFACT', description: 'ìœ„ê¸° ìƒí™©ì—ì„œ ëª¸ì„ ëŒì²˜ëŸ¼ ë‹¨ë‹¨í•˜ê²Œ ë§Œë“­ë‹ˆë‹¤.' },
  { id: 'i_art_7', name: 'ì§€í˜œì˜ ì„±ë°°', cost: 3000, ad: 0, ap: 85, hp: 250, mp: 800, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 15, type: 'ARTIFACT', description: 'ë§ˆë¥´ì§€ ì•ŠëŠ” ë§ˆë‚˜ì˜ ìƒ˜ì…ë‹ˆë‹¤.' },
  { id: 'i_art_8', name: 'ì—­ë³‘ì˜ ì„œ', cost: 2500, ad: 0, ap: 85, hp: 300, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 15, type: 'ARTIFACT', description: 'ì¹˜ìœ í•  ìˆ˜ ì—†ëŠ” ë§¹ë…ì˜ ê¸°ë¡ì…ë‹ˆë‹¤.' },
  { id: 'i_art_9', name: 'ì—í…Œë¥´ ì¹¼ë‚ ', cost: 3000, ad: 0, ap: 110, hp: 0, mp: 0, armor: 0, crit: 0, speed: 15, regen: 0, mpRegen: 0, pen: 0, type: 'ARTIFACT', description: 'ë§ˆë ¥ì„ ì¹¼ë‚  í˜•íƒœë¡œ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.' },
  { id: 'i_art_10', name: 'ì‘ì¶•ëœ ë§ˆë ¥ì„', cost: 400, ad: 0, ap: 0, hp: 0, mp: 300, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 5, type: 'ARTIFACT', description: 'ìˆœìˆ˜í•œ ë§ˆë‚˜ ê²°ì •ì²´ì…ë‹ˆë‹¤.' },

  // =================================================================
  // 4. ARMOR (ë°©ì–´êµ¬) - ì²´ë ¥, ë°©ì–´ë ¥, ì²´ë ¥ì¬ìƒ (10ê°œ)
  // =================================================================
  { id: 'i_armor_1', name: 'ìˆ˜ìŠµ ê¸°ì‚¬ì˜ ê°‘ì˜·', cost: 300, ad: 0, ap: 0, hp: 0, mp: 0, armor: 18, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ê°€ì¥ ê¸°ì´ˆì ì¸ ì² ì œ ë°©ì–´êµ¬ì…ë‹ˆë‹¤.' },
  { id: 'i_armor_2', name: 'ìƒëª…ì˜ ë³´ì„', cost: 400, ad: 0, ap: 0, hp: 180, mp: 0, armor: 0, crit: 0, speed: 0, regen: 2, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ì€ì€í•œ ìƒëª…ë ¥ì„ ë‚´ë¿œëŠ” ë³´ì„ì…ë‹ˆë‹¤.' },
  { id: 'i_armor_3', name: 'í™”ì—¼ì˜ íŒê¸ˆ', cost: 2800, ad: 0, ap: 0, hp: 550, mp: 0, armor: 55, crit: 0, speed: 0, regen: 10, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ì£¼ë³€ì˜ ì ì„ íƒœìš°ëŠ” ì—´ê¸°ë¥¼ ë°œì‚°í•©ë‹ˆë‹¤.' },
  { id: 'i_armor_4', name: 'ì¹¼ë‚  ê»ì§ˆ', cost: 2700, ad: 0, ap: 0, hp: 400, mp: 0, armor: 75, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ê³µê²©í•˜ëŠ” ì ì—ê²Œ ìƒì²˜ë¥¼ ì…íˆëŠ” ê°‘ì˜·ì…ë‹ˆë‹¤.' },
  { id: 'i_armor_5', name: 'ë¶ˆì‚¬ì˜ ì‹¬ì¥', cost: 3000, ad: 0, ap: 0, hp: 900, mp: 0, armor: 0, crit: 0, speed: 0, regen: 40, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ê²½ì´ë¡œìš´ íšŒë³µë ¥ì„ ë¶€ì—¬í•©ë‹ˆë‹¤.' },
  { id: 'i_armor_6', name: 'ìƒëª…ì˜ ë‚˜ë¬´ ê»ì§ˆ', cost: 2900, ad: 0, ap: 0, hp: 500, mp: 0, armor: 45, crit: 0, speed: 0, regen: 20, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ëª¨ë“  ì¹˜ìœ  íš¨ê³¼ë¥¼ ì¦í­ì‹œí‚µë‹ˆë‹¤.' },
  { id: 'i_armor_7', name: 'ìš”ìƒˆì˜ ë°©ë²½', cost: 2900, ad: 0, ap: 0, hp: 450, mp: 0, armor: 70, crit: 0, speed: -5, regen: 0, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ì¹˜ëª…íƒ€ í”¼í•´ë¥¼ ë§‰ì•„ë‚´ëŠ” ê²¬ê³ í•œ ë°©íŒ¨ì…ë‹ˆë‹¤.' },
  { id: 'i_armor_8', name: 'ëŒê²©ëŒ€ì¥ì˜ ê°‘ì˜·', cost: 2800, ad: 0, ap: 0, hp: 350, mp: 0, armor: 50, crit: 0, speed: 25, regen: 0, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ì „ì¥ìœ¼ë¡œ ë¹ ë¥´ê²Œ ëŒì§„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.' },
  { id: 'i_armor_9', name: 'ì„ìƒì˜ ì‹¬ì¥', cost: 3200, ad: 0, ap: 0, hp: 0, mp: 0, armor: 90, crit: 0, speed: 0, regen: 10, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ì ì§„ í•œê°€ìš´ë°ì„œë„ ë²„í‹¸ ìˆ˜ ìˆëŠ” ë‹¨ë‹¨í•¨ì…ë‹ˆë‹¤.' },
  { id: 'i_armor_10', name: 'ìˆ˜í˜¸ìì˜ íœë˜íŠ¸', cost: 1500, ad: 0, ap: 0, hp: 0, mp: 0, armor: 35, crit: 0, speed: 0, regen: 10, mpRegen: 0, pen: 0, type: 'ARMOR', description: 'ì•„êµ°ì—ê²Œ ë³´í˜¸ì˜ ê¸°ìš´ì„ ë‚˜ëˆ•ë‹ˆë‹¤.' },

  // =================================================================
  // 5. ACCESSORY (ì¥ì‹ êµ¬) - í•˜ì´ë¸Œë¦¬ë“œ, ë³´ì¡° ìŠ¤íƒ¯ (5ê°œ)
  // =================================================================
  { id: 'i_acc_1', name: 'í•™ìì˜ ë°˜ì§€', cost: 400, ad: 0, ap: 18, hp: 70, mp: 50, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 4, pen: 0, type: 'ACCESSORY', description: 'ë§ˆë²• ì…ë¬¸ìì—ê²Œ ì í•©í•œ ë°˜ì§€ì…ë‹ˆë‹¤.' },
  { id: 'i_acc_2', name: 'ì „ì‚¬ì˜ ëª©ê±¸ì´', cost: 450, ad: 10, ap: 0, hp: 90, mp: 0, armor: 0, crit: 0, speed: 0, regen: 3, mpRegen: 0, pen: 0, type: 'ACCESSORY', description: 'ì „íˆ¬ì˜ ê¸°ë³¸ì´ ë˜ëŠ” ê²€ì…ë‹ˆë‹¤.' },
  { id: 'i_acc_3', name: 'ë‚˜ë¬´ ë°©íŒ¨', cost: 450, ad: 0, ap: 0, hp: 100, mp: 0, armor: 0, crit: 0, speed: 0, regen: 8, mpRegen: 0, pen: 0, type: 'ACCESSORY', description: 'ì´ˆë°˜ ìƒì¡´ë ¥ì„ ë†’ì—¬ì¤ë‹ˆë‹¤.' },
  { id: 'i_acc_4', name: 'ë¶€ì„œì§„ ëª¨ë˜ì‹œê³„', cost: 750, ad: 0, ap: 0, hp: 0, mp: 0, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'ACCESSORY', description: 'ì‹œê°„ì„ ë©ˆì¶”ëŠ” ë§ˆë²•ì´ ê¹ƒë“¤ì–´ ìˆìŠµë‹ˆë‹¤.' },
  { id: 'i_acc_5', name: 'ë¹›ë‚˜ëŠ” íŒŒí¸', cost: 700, ad: 0, ap: 0, hp: 0, mp: 300, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 0, pen: 0, type: 'ACCESSORY', description: 'ìŠ¤í‚¬ ì‚¬ìš© í›„ í‰íƒ€ë¥¼ ê°•í™”í•©ë‹ˆë‹¤.' },

  // =================================================================
  // 6. POWER (ê¶ŒëŠ¥) - ì‹ ì˜ ì¶•ë³µì´ ê¹ƒë“  ê¶ê·¹ ì•„ì´í…œ (ì´ 6ê°œ)
  // =================================================================

  // [ì´ì¦ˆë§ˆí•œì˜ ê¶ŒëŠ¥ - íŒŒê´´/í”¼/ì†ë„]
  { 
    id: 'p_izman_low', name: 'ì´ì¦ˆë§ˆí•œì˜ ë¶ˆì”¨', cost: 1500, 
    ad: 40, ap: 0, hp: 0, mp: 0, armor: 0, crit: 10, speed: 5, regen: 0, mpRegen: 0, pen: 5, 
    type: 'POWER', description: '[ì´ì¦ˆë§ˆí•œ] íŒŒê´´ì‹ ì˜ í˜ì´ ë¯¸ì•½í•˜ê²Œ ê¹ƒë“  ë¶ˆì”¨ì…ë‹ˆë‹¤.' 
  },
  { 
    id: 'p_izman_mid', name: 'ì´ì¦ˆë§ˆí•œì˜ í•ë¹› ë‚«', cost: 3200, 
    ad: 80, ap: 0, hp: 300, mp: 0, armor: 0, crit: 20, speed: 10, regen: 20, mpRegen: 0, pen: 15, 
    type: 'POWER', description: '[ì´ì¦ˆë§ˆí•œ] ì ì˜ í”¼ë¥¼ ê°ˆêµ¬í•˜ëŠ” ì €ì£¼ë°›ì€ ë‚«ì…ë‹ˆë‹¤.' 
  },
  { 
    id: 'p_izman_high', name: 'ì´ì¦ˆë§ˆí•œì˜ ë©¸ë§', cost: 5500, 
    ad: 150, ap: 0, hp: 500, mp: 0, armor: 0, crit: 50, speed: 20, regen: 40, mpRegen: 0, pen: 40, 
    type: 'POWER', description: '[ì´ì¦ˆë§ˆí•œ] ì„¸ìƒì˜ ì¢…ë§ì„ ë¶ˆëŸ¬ì˜¤ëŠ” íŒŒê´´ì‹ ì˜ ì§„ì •í•œ í˜ì…ë‹ˆë‹¤.' 
  },

  // [ë‹¨í…Œì˜ ê¶ŒëŠ¥ - ëƒ‰ê¸°/ì§€í˜œ/ë¶ˆë©¸]
  { 
    id: 'p_dante_low', name: 'ë‹¨í…Œì˜ ëƒ‰ê¸° íŒŒí¸', cost: 1500, 
    ad: 0, ap: 50, hp: 100, mp: 200, armor: 0, crit: 0, speed: 0, regen: 0, mpRegen: 5, pen: 0, 
    type: 'POWER', description: '[ë‹¨í…Œ] ìˆ˜í˜¸ì‹ ì˜ ëƒ‰ê¸°ê°€ ì„œë ¤ìˆëŠ” íŒŒí¸ì…ë‹ˆë‹¤.' 
  },
  { 
    id: 'p_dante_mid', name: 'ë‹¨í…Œì˜ ì„œë¦¬ ê°‘ì£¼', cost: 3200, 
    ad: 0, ap: 80, hp: 600, mp: 400, armor: 60, crit: 0, speed: 0, regen: 10, mpRegen: 10, pen: 0, 
    type: 'POWER', description: '[ë‹¨í…Œ] ì–´ë–¤ ê³µê²©ë„ ë§‰ì•„ë‚´ëŠ” ì ˆëŒ€ì ì¸ ë°©ì–´êµ¬ì…ë‹ˆë‹¤.' 
  },
  { 
    id: 'p_dante_high', name: 'ë‹¨í…Œì˜ ì ˆëŒ€ ì˜ë„', cost: 5500, 
    ad: 0, ap: 200, hp: 1000, mp: 1000, armor: 100, crit: 0, speed: 0, regen: 30, mpRegen: 30, pen: 20, 
    type: 'POWER', description: '[ë‹¨í…Œ] ëª¨ë“  ê²ƒì„ ì–¼ì–´ë¶™ê²Œ ë§Œë“œëŠ” ìˆ˜í˜¸ì‹ ì˜ ì§„ì •í•œ ê¶ŒëŠ¥ì…ë‹ˆë‹¤.' 
  }
];


==========================================
FILE PATH: src/data/jungle/jungleDefaults.ts
==========================================
// ==========================================
// FILE PATH: /src/data/jungle/jungleDefaults.ts
// ==========================================
import { JungleSettings, JungleMonsterStats } from '../../types/jungle';

const BASE: JungleMonsterStats = {
  name: '', hp: 1200, atk: 60, def: 20, 
  gold: 80, xp: 120, respawnTime: 90, 
  isBuffMob: false, 
  buffs: [] 
};

export const DEFAULT_JUNGLE_CONFIG: JungleSettings = {
  density: 100,
  camps: {
    // 1. [Blue Top] ìˆ˜ì • ë™êµ´: ì¤‘ì•™ ê¸¸ê°€ê°€ ì•„ë‹ˆë¼ 'ì¢Œì¸¡ ë‘¥ì§€'ë¡œ ì´ë™
    TOP_BLUE: {
      id: 'TOP_BLUE',
      name: 'ìˆ˜ì • ë™êµ´ (Blue Top)',
      monsters: [
        // ë©”ì¸: ì¢Œì¸¡ ë²½ìª½ ê¹Šìˆ™ì´
        { spotId: 'main', x: 28, y: 45, stats: { ...BASE, name: 'ìˆ˜ì • íŒŒìˆ˜ê¾¼', hp: 2000, isBuffMob: true, buffs: [{type: 'REGEN', value: 50}] } }, 
        // ì«„ëª¹: ë‘¥ì§€ ì•ˆì—ì„œ ë©”ì¸ì„ ê°ì‹¸ë„ë¡
        { spotId: 'sub1', x: 18, y: 35, stats: { ...BASE, name: 'ìˆ˜ì • ë„ë§ˆë±€', hp: 600, gold: 30, xp: 40 } },
        { spotId: 'sub2', x: 18, y: 55, stats: { ...BASE, name: 'ìˆ˜ì • ë„ë§ˆë±€', hp: 600, gold: 30, xp: 40 } },
        { spotId: 'sub3', x: 40, y: 45, stats: { ...BASE, name: 'ìˆ˜ì • ë„ë§ˆë±€', hp: 600, gold: 30, xp: 40 } }
      ]
    },

    // 2. [Blue Bot] ë¶‰ì€ ìˆ²: ì¤‘ì•™ ì‚¼ê±°ë¦¬ê°€ ì•„ë‹ˆë¼ 'ìš°ì¸¡ í•˜ë‹¨ ë‘¥ì§€'ë¡œ ì´ë™
    BOT_BLUE: {
      id: 'BOT_BLUE',
      name: 'ë¶‰ì€ ìˆ² (Blue Bot)',
      monsters: [
        // ë©”ì¸: ìš°ì¸¡ ë‘¥ì§€ ì•ˆìª½
        { spotId: 'main', x: 72, y: 60, stats: { ...BASE, name: 'ìš©ì•” ê±°ë¶', hp: 2200, isBuffMob: true, buffs: [{type: 'ATK', value: 15}] } }, 
        // ì«„ëª¹: ë‘¥ì§€ í…Œë‘ë¦¬
        { spotId: 'sub1', x: 62, y: 50, stats: { ...BASE, name: 'ë¶ˆê½ƒ ì„í”„', hp: 800, gold: 40, xp: 50 } }, 
        { spotId: 'sub2', x: 82, y: 50, stats: { ...BASE, name: 'ë¶ˆê½ƒ ì„í”„', hp: 800, gold: 40, xp: 50 } }, 
        { spotId: 'sub3', x: 72, y: 75, stats: { ...BASE, name: 'ë¶ˆê½ƒ ì„í”„', hp: 800, gold: 40, xp: 50 } }
      ]
    },
    
    // 3. [Red Top] ë©”ë§ˆë¥¸ í˜‘ê³¡: ì¢Œì¸¡ ìƒë‹¨ ë‘¥ì§€ (ì´ì „ ìˆ˜ì • ìœ ì§€)
    TOP_RED: {
      id: 'TOP_RED',
      name: 'ë©”ë§ˆë¥¸ í˜‘ê³¡ (Red Top)',
      monsters: [
        { spotId: 'main', x: 30, y: 30, stats: { ...BASE, name: 'í™©ì•¼ì˜ í¬ì‹ì', hp: 2200, isBuffMob: true, buffs: [{type: 'ATK', value: 15}] } }, 
        { spotId: 'sub1', x: 20, y: 40, stats: { ...BASE, name: 'ì‚¬ë§‰ ì „ê°ˆ', hp: 800, gold: 40, xp: 50 } }, 
        { spotId: 'sub2', x: 40, y: 40, stats: { ...BASE, name: 'ì‚¬ë§‰ ì „ê°ˆ', hp: 800, gold: 40, xp: 50 } }, 
        { spotId: 'sub3', x: 30, y: 50, stats: { ...BASE, name: 'ì‚¬ë§‰ ì „ê°ˆ', hp: 800, gold: 40, xp: 50 } }  
      ]
    },

    // 4. [Red Bot] ì‹¬ì—°ì˜ ëŠª: ìš°ì¸¡ ìƒë‹¨ ë‘¥ì§€ (ì´ì „ ìˆ˜ì • ìœ ì§€)
    BOT_RED: {
      id: 'BOT_RED',
      name: 'ì‹¬ì—°ì˜ ëŠª (Red Bot)',
      monsters: [
        { spotId: 'main', x: 65, y: 35, stats: { ...BASE, name: 'ì‹¬ì—°ì˜ ì£¼ì‹œì', hp: 2000, isBuffMob: true, buffs: [{type: 'HASSTE', value: 20}] } }, 
        { spotId: 'sub1', x: 55, y: 25, stats: { ...BASE, name: 'ì§„í™ ê´´ë¬¼', hp: 700, gold: 30, xp: 40 } },
        { spotId: 'sub2', x: 75, y: 25, stats: { ...BASE, name: 'ì§„í™ ê´´ë¬¼', hp: 700, gold: 30, xp: 40 } },
        { spotId: 'sub3', x: 65, y: 50, stats: { ...BASE, name: 'ì§„í™ ê´´ë¬¼', hp: 700, gold: 30, xp: 40 } }
      ]
    }
  }
};



==========================================
FILE PATH: src/data/jungle.ts
==========================================
// ==========================================
// FILE PATH: /src/data/jungle.ts
// ==========================================

export const JUNGLE_CONFIG = {
  NAME: "í˜¼ëˆì˜ ê· ì—´ (Chaos Rift)",
  DESCRIPTION: "ì „ì¥ì˜ í‹ˆìƒˆì— ì¡´ì¬í•˜ëŠ” ë¶ˆì•ˆì •í•œ ì°¨ì›ì…ë‹ˆë‹¤. ì´ê³³ì—ëŠ” ì–´ëŠ ì§„ì˜ì—ë„ ì†í•˜ì§€ ì•ŠëŠ” 'ì´ê³„ì˜ í¬ë¦¬ì²˜'ë“¤ì´ ì„œì‹í•©ë‹ˆë‹¤.",

  // 2. ê¸°ë³¸ ë°¸ëŸ°ìŠ¤ ìˆ˜ì¹˜ (0~100)
  DEFAULT_SETTINGS: {
    density: 50, // ë°€ë„
    yield: 50,   // í’ìš”ë„
    attack: 30,  // í¬ë¦¬ì²˜ ê³µê²©ë ¥
    defense: 20, // í¬ë¦¬ì²˜ ë°©ì–´ë ¥
    threat: 0    
  },

  // 3. ì‹œë®¬ë ˆì´ì…˜ ê³„ìˆ˜
  BASE_SPAWN_RATE: 0.13,  
  BASE_GOLD: 18,          
  BASE_XP_INTERVAL: 12,   
  BASE_DAMAGE_TAKEN: 10,  
  BASE_REGEN: 15          
};


==========================================
FILE PATH: src/data/roles.ts
==========================================
// === FILE: src/data/roles.ts ===

import { Role } from '../types';
import { Shield, Swords, Zap, Crosshair, Skull } from 'lucide-react';

export interface RoleInfo {
  role: Role;
  name: string;      // ì˜ë¬¸ëª… (EXECUTOR ë“±)
  icon: any;         // ì•„ì´ì½˜ ì»´í¬ë„ŒíŠ¸
  color: string;     // ëŒ€í‘œ ìƒ‰ìƒ
  concept: string;   // í•œì¤„ ìš”ì•½ (ë”°ì˜´í‘œ ë‚´ìš©)
  desc: string;      // ìƒì„¸ ì„¤ëª…
  traitName: string; // ê³ ìœ  íŠ¹ì„± ì´ë¦„
  traitEffect: string; // ê³ ìœ  íŠ¹ì„± íš¨ê³¼ ì„¤ëª…
  simEffect: string;   // ì‹œë®¬ë ˆì´ì…˜ ë°˜ì˜ ì„¤ëª…
}

export const ROLE_DATA: Record<Role, RoleInfo> = {
  'ì§‘í–‰ê´€': {
    role: 'ì§‘í–‰ê´€', 
    name: 'EXECUTOR', 
    icon: Shield, // (ê¸°ì¡´ ì•„ì´ì½˜ ìœ ì§€)
    color: '#e74c3c',
    concept: 'ì‹ ì˜ ëœ»ì„ ì§€ìƒì— ì§‘í–‰í•˜ëŠ” ë¬´ìë¹„í•œ íˆ¬ì‚¬',
    desc: 'ìµœì „ì„ ì—ì„œ ì ì˜ ì§„í˜•ì„ ë¶•ê´´ì‹œí‚¤ê³ , 1:1 ëŒ€ê²°ì—ì„œ ë¬¼ëŸ¬ì„œì§€ ì•ŠëŠ” ê³ ë…í•œ ì „ì‚¬ë“¤ì…ë‹ˆë‹¤.',
    traitName: '[ê²°íˆ¬ì˜ ì„œì•½]',
    traitEffect: 'ì£¼ë³€ì— ì•„êµ°ì´ ì—†ì„ ë•Œ(ì†”ë¡œ ë¼ì¸ì „ ì‹œ) í”¼í•´ëŸ‰ +10%, ë°©ì–´ë ¥ +10%.',
    simEffect: 'ë¼ì¸ì „ ë‹¨ê³„ì—ì„œ 1:1 í‚¬ í™•ë¥  ë³´ì •.'
  },
  'ì¶”ì ì': {
    role: 'ì¶”ì ì', 
    name: 'TRACKER', 
    icon: Swords, 
    color: '#2ecc71',
    concept: 'ë³´ì´ì§€ ì•ŠëŠ” ê³³ì—ì„œ ì´ë‹¨ì„ ì‚¬ëƒ¥í•˜ëŠ” ê·¸ë¦¼ì',
    desc: 'ì •í•´ì§„ ë¼ì¸ ì—†ì´ ì „ì¥ì„ ëˆ„ë¹„ë©°, ë³€ìˆ˜ë¥¼ ì°½ì¶œí•˜ê³  ì£¼ìš” ëª©í‘œë¬¼(ê±°ì‹ ë³‘/ì£¼ì‹œì)ì„ í™•ë³´í•©ë‹ˆë‹¤.',
    traitName: '[ì‚¬ëƒ¥ê¾¼ì˜ ë³¸ëŠ¥]',
    traitEffect: 'ëª¬ìŠ¤í„°/ì˜¤ë¸Œì íŠ¸ ì²˜ì¹˜ ì‹œ ê³¨ë“œ íšë“ëŸ‰ +20%. ë‹¤ë¥¸ ë¼ì¸ ê°œì…(ê°±í‚¹) ì‹œ ì„±ê³µë¥  ì¦ê°€.',
    simEffect: 'ì •ê¸€ëŸ¬ì˜ ì„±ì¥ ì†ë„ ë³´ì •, ì˜¤ë¸Œì íŠ¸ ë§‰íƒ€ í™•ë¥  ë³´ì •.'
  },
  'ì„ ì§€ì': {
    role: 'ì„ ì§€ì', 
    name: 'PROPHET', 
    icon: Zap, 
    color: '#3498db',
    concept: 'ì˜¤ë¼í´ì˜ ê³„ì‹œë¥¼ í•´ì„í•˜ì—¬ ë§ˆë²•ìœ¼ë¡œ êµ¬í˜„í•˜ëŠ” ì',
    desc: 'ì „ì¥ì˜ ì¤‘ì‹¬ì—ì„œ ê°•ë ¥í•œ ê´‘ì—­ ë§ˆë²•ìœ¼ë¡œ ì ì„ ì“¸ì–´ë²„ë¦¬ê³ , ì „í™©ì„ ê¿°ëš«ì–´ ë´…ë‹ˆë‹¤.',
    traitName: '[ë§ˆë ¥ì˜ íë¦„]',
    traitEffect: 'ë ˆë²¨ì´ ì˜¤ë¥¼ìˆ˜ë¡ ìŠ¤í‚¬ ê°€ì†(ì¿¨íƒ€ì„ ê°ì†Œ) íš¨ê³¼ê°€ ì¶”ê°€ë¡œ ë¶™ìŒ.',
    simEffect: 'ì¤‘í›„ë°˜ êµì „ ì‹œ ìŠ¤í‚¬ ì ìˆ˜ ê³„ì‚° ê°€ì¤‘ì¹˜ ëŒ€í­ ìƒìŠ¹.'
  },
  'ì‹ ì‚´ì': {
    role: 'ì‹ ì‚´ì', 
    name: 'GOD SLAYER', 
    icon: Crosshair, 
    color: '#f1c40f',
    concept: 'ì‹ ì¡°ì°¨ ì£½ì¼ ìˆ˜ ìˆëŠ” ê¸ˆë‹¨ì˜ ë¬´ê¸°ë¥¼ ë‹¤ë£¨ëŠ” ì',
    desc: 'ì´ˆë°˜ì—” ì•½í•˜ì§€ë§Œ, ì„±ì¥ì´ ëë‚˜ëŠ” ìˆœê°„ ì‹ (ìˆ˜í˜¸ì)ê³¼ ê±°ì‹ ë³‘ì„ ìˆœì‹ê°„ì— íŒŒê´´í•˜ëŠ” í•µì‹¬ í™”ë ¥ì…ë‹ˆë‹¤.',
    traitName: '[ê±°ì¸ í•™ì‚´ì]',
    traitEffect: 'êµ¬ì¡°ë¬¼(íƒ€ì›Œ, ì–µì œê¸°, ìˆ˜í˜¸ì) ë° ê±°ì‹ ë³‘ì—ê²Œ ì…íˆëŠ” í”¼í•´ëŸ‰ +30%.',
    simEffect: 'ê³µì„± ëª¨ë“œì¼ ë•Œ íƒ€ì›Œ ì² ê±° ì†ë„ ê°€ì†.'
  },
  'ìˆ˜í˜¸ê¸°ì‚¬': {
    role: 'ìˆ˜í˜¸ê¸°ì‚¬', 
    name: 'GUARDIAN', 
    icon: Skull, 
    color: '#9b59b6',
    concept: 'ë™ë£Œë¥¼ ìœ„í•´ ê¸°êº¼ì´ í¬ìƒí•˜ëŠ” ì‹ ë…ì˜ ë°©íŒ¨',
    desc: 'ì•„êµ°(íŠ¹íˆ ì‹ ì‚´ì)ì„ ë³´í˜¸í•˜ê³ , ì ì˜ ê³µê²©ì„ ëŒ€ì‹  ë°›ì•„ë‚´ë©° ì „ì„ ì„ ìœ ì§€í•©ë‹ˆë‹¤.',
    traitName: '[í¬ìƒì˜ ì„±ì—­]',
    traitEffect: 'ê°™ì€ ë¼ì¸ì— ìˆëŠ” ì•„êµ°ì˜ ìƒì¡´ìœ¨ì„ 20% ì˜¬ë ¤ì¤Œ. (ìì‹ ì´ ëŒ€ì‹  ì£½ì„ í™•ë¥  ì¦ê°€)',
    simEffect: 'ë´‡ ë¼ì¸ì „ì—ì„œ ì‹ ì‚´ìê°€ ì£½ì„ í™•ë¥ ì„ ë‚®ì¶”ê³ , ìì‹ ì˜ ë°ìŠ¤ í™•ë¥ ì„ ë†’ì„.'
  }
};


==========================================
FILE PATH: src/data/types/hero.ts
==========================================
// src/types/hero.ts
export type Role = 'ì§‘í–‰ê´€' | 'ì„ ì§€ì' | 'ìˆ˜í˜¸ê¸°ì‚¬' | 'ì¶”ì ì' | 'ì‹ ì‚´ì';
export type Tier = 'OP' | '1' | '2' | '3' | '4' | '5';

// [NEW] íŠ¹ìˆ˜ ìŠ¤í‚¬ ë©”ì»¤ë‹ˆì¦˜
export type SkillMechanic = 
  | 'NONE' | 'STUN' | 'HOOK' | 'DASH' | 'STEALTH' 
  | 'SHIELD' | 'HEAL' | 'EXECUTE' | 'GLOBAL';

export interface HeroStats {
  ad: number;      // ê³µê²©ë ¥ (ìŠ¤í‚¬/í‰íƒ€ ê³„ìˆ˜ìš©)
  baseAtk: number; // [NEW] ê¸°ë³¸ í‰íƒ€ ë°ë¯¸ì§€ (ê¹¡ë€)
  ap: number;      // ì£¼ë¬¸ë ¥
  hp: number;      // ì²´ë ¥
  armor: number;   // ë°©ì–´ë ¥
  crit: number;    // ì¹˜ëª…íƒ€
  range: number;   // ì‚¬ê±°ë¦¬
  speed: number;   // ì´ì†
  regen: number;   // ì¬ìƒ
  pen: number;     // ê´€í†µ
}

// ìŠ¤í‚¬ ìƒì„¸ êµ¬ì¡°
export interface SkillDetail {
  name: string;
  mechanic: SkillMechanic;
  val: number;
  adRatio: number;
  apRatio: number;
  cd: number;
  isPassive?: boolean;
}

// ìŠ¤í‚¬ì…‹ (P, Q, W, E, R)
export interface HeroSkillSet {
  passive: SkillDetail;
  q: SkillDetail;
  w: SkillDetail;
  e: SkillDetail;
  r: SkillDetail;
}

export interface HeroRecord {
  totalMatches: number; totalWins: number; totalPicks: number; totalBans: number;
  totalKills: number; totalDeaths: number; totalAssists: number;
  totalDamage: number; totalDamageTaken: number; totalCs: number; totalGold: number;
  recentResults: boolean[]; 
}

export interface Hero {
  id: string; name: string; role: Role;
  stats: HeroStats;
  skills: HeroSkillSet;

  // (í•˜ìœ„ í˜¸í™˜ìš© - ì‚¬ìš© ì•ˆí•¨)
  skill?: any; skillLevels?: any; 

  record: HeroRecord;
  tier: Tier; rank: number; rankChange: number;
  recentWinRate: number; pickRate: number; banRate: number;
  avgKda: string; kdaRatio: string;
  avgDpm: string; avgDpg: string; avgCs: string; avgGold: string;
}


==========================================
FILE PATH: src/data/types/index.ts
==========================================
// ==========================================
// FILE PATH: /src/types/index.ts
// ==========================================

// ------------------------------------------------------------------
// 1. ê¸°ë³¸ ìƒìˆ˜ ë° ìŠ¤í‚¬ ê´€ë ¨
// ------------------------------------------------------------------
export type Role = 'ì§‘í–‰ê´€' | 'ì„ ì§€ì' | 'ìˆ˜í˜¸ê¸°ì‚¬' | 'ì¶”ì ì' | 'ì‹ ì‚´ì';
export type Tier = 'OP' | '1' | '2' | '3' | '4' | '5';
export type SkillMechanic = 
  | 'DAMAGE' | 'HEAL' | 'SHIELD' | 'HOOK' | 'DASH' 
  | 'STUN' | 'STEALTH' | 'EXECUTE' | 'GLOBAL' | 'NONE';

export interface HeroStats {
  ad: number;      // ê³µê²©ë ¥
  ap: number;      // ì£¼ë¬¸ë ¥
  hp: number;      // ì²´ë ¥
  armor: number;   // ë°©ì–´ë ¥
  crit: number;    // ì¹˜ëª…íƒ€ìœ¨
  range: number;   // ì‚¬ê±°ë¦¬
  speed: number;   // ì´ë™ì†ë„
  regen: number;   // ì²´ë ¥ ì¬ìƒ
  pen: number;     // ê´€í†µë ¥
  baseAtk: number; // ê¸°ë³¸ ê³µê²©ë ¥
}

export interface SkillDetail {
  name: string; 
  mechanic: SkillMechanic; 
  val: number;
  adRatio: number; 
  apRatio: number; 
  cd: number; 
  range?: number; 
  duration?: number; 
  isPassive?: boolean;
}

export interface HeroSkillSet {
  passive: SkillDetail; q: SkillDetail; w: SkillDetail; e: SkillDetail; r: SkillDetail;
}

export interface HeroRecord {
  totalMatches: number; totalWins: number; totalPicks: number; totalBans: number;
  totalKills: number; totalDeaths: number; totalAssists: number;
  totalDamage: number; totalDamageTaken: number; totalCs: number; totalGold: number;
  recentResults: boolean[]; 
}

export interface Hero {
  id: string; name: string; role: Role; stats: HeroStats; skills: HeroSkillSet;
  record: HeroRecord; tier: Tier; rank: number; rankChange: number;
  recentWinRate: number; pickRate: number; banRate: number;
  avgKda: string; kdaRatio: string;
  avgDpm: string; avgDpg: string; avgCs: string; avgGold: string;
}

// ------------------------------------------------------------------
// 2. ì•„ì´í…œ(Item) ë° ìƒì  ê´€ë ¨
// ------------------------------------------------------------------
export interface Item {
  id: string;
  name: string;
  cost: number;
  ad: number; ap: number; hp: number; armor: number; crit: number; speed: number;
  type: 'WEAPON' | 'ARMOR' | 'ACCESSORY' | 'POWER'; 
  description?: string;
}

export interface ItemStatData {
  itemId: string;
  totalPicks: number;
  totalWins: number;
  totalKills: number;
  totalDeaths: number;
  totalAssists: number;
}

// ------------------------------------------------------------------
// 3. ê²Œì„ ì„¤ì • (Gods, Battle, Tier, Role)
// ------------------------------------------------------------------
export interface ObjectStats { hp: number; armor: number; rewardGold: number; }
export interface ColossusSettings extends ObjectStats { attack: number; }
export interface WatcherSettings extends ObjectStats { buffType: 'COMBAT' | 'GOLD'; buffAmount: number; buffDuration: number; }

// [ì‹ ê·œ] ì •ê¸€(í˜¼ëˆì˜ ê· ì—´) ì„¤ì • íƒ€ì… ì •ì˜
export interface JungleSettings {
  density: number; // ë°€ë„ (0~100)
  threat: number;  // ìœ„í˜‘ë„ (0~100)
  yield: number;   // í’ìš”ë„ (0~100)
}

export interface BattlefieldSettings {
  tower: ObjectStats; 
  colossus: ColossusSettings; 
  watcher: WatcherSettings;
  jungle: JungleSettings; // [ì¶”ê°€ë¨]
}

// [ì‹ ê·œ] ì—­í• êµ° ë°¸ëŸ°ìŠ¤ ì„¤ì •ê°’ êµ¬ì¡°ì²´
export interface RoleSettings {
  executor: { damage: number; defense: number }; // ì§‘í–‰ê´€ (í”¼í•´ëŸ‰%, ë°©ì–´ë ¥%)
  tracker: { gold: number; smiteChance: number }; // ì¶”ì ì (ê³¨ë“œ%, ê°•íƒ€ë°°ìœ¨)
  prophet: { cdrPerLevel: number }; // ì„ ì§€ì (ë ˆë²¨ë‹¹ ì¿¨ê°%)
  slayer: { structureDamage: number }; // ì‹ ì‚´ì (êµ¬ì¡°ë¬¼ í”¼í•´ëŸ‰%)
  guardian: { survivalRate: number }; // ìˆ˜í˜¸ê¸°ì‚¬ (ìƒì¡´ìœ¨ ë³´ì •%)
}

export interface TierConfig { challenger: number; master: number; ace: number; joker: number; gold: number; silver: number; bronze: number; }
export interface AIConfig { provider: 'GEMINI' | 'OPENAI'; apiKey: string; model: string; enabled: boolean; }

// ------------------------------------------------------------------
// 4. ìœ ì €(User) ë° í†µê³„
// ------------------------------------------------------------------
export interface MatchHistory { 
  season: number; result: 'WIN' | 'LOSE'; heroName: string; kda: string; lpChange: number; date: string; 
}

export interface UserHeroStat {
  matches: number; wins: number; kills: number; deaths: number; assists: number;
}

export interface UserProfile { 
  id: number; name: string; mainHeroId: string; score: number; 
  tier: string; winRate: number; totalGames: number; 
  history: MatchHistory[]; heroStats: Record<string, UserHeroStat>; preferredLane: string;
  mostChamps: any[]; laneStats: any[];
}

export interface TierStat { name: string; minScore: number; count: number; percent: number; color: string; }
export interface UserStatus { totalGames: number; playingUsers: number; queuingUsers: number; avgWaitTime: number; tierDistribution: TierStat[]; }

export interface GodStats { 
  totalMatches: number; 
  izmanWins: number; izmanAvgKills: string; izmanAvgTime: string; 
  danteWins: number; danteAvgKills: string; danteAvgTime: string; 
  avgGameDuration: number; guardianDeathRate: number; godAwakenRate: number; 
}

// ------------------------------------------------------------------
// 5. ì¸ê²Œì„(LiveMatch) ë° ì‹œë®¬ë ˆì´ì…˜ ë¡œê·¸
// ------------------------------------------------------------------
export type EventType = 'KILL' | 'TOWER' | 'COLOSSUS' | 'WATCHER' | 'START';
export interface GameLog { time: number; message: string; type: EventType; team?: 'BLUE' | 'RED'; }
export interface TimelineEvent { time: number; type: EventType; killerId: string; victimId: string; message: string; }

export interface LivePlayer { 
  name: string; heroId: string; kills: number; deaths: number; assists: number; 
  gold: number; cs: number; currentHp: number; maxHp: number; level: number; 
  items: Item[]; 
  totalDamageDealt: number; // ëˆ„ì  í”¼í•´ëŸ‰
  x: number; y: number; lane: 'TOP' | 'MID' | 'BOT' | 'JUNGLE'; buffs: string[]; 
  mmr: number; 
}

export interface TowerStatus { top: number; mid: number; bot: number; }

export interface TeamStats { 
  towers: TowerStatus; colossus: number; watcher: number; fury: number; 
  nexusHp: number; maxNexusHp: number;
  activeBuffs: { siegeUnit: boolean; voidPower: boolean; voidBuffEndTime?: number; };
}

export interface LiveMatch { 
  id: string; blueTeam: LivePlayer[]; redTeam: LivePlayer[]; bans: { blue: string[]; red: string[]; }; 
  startTime: number; duration: number; currentDuration: number; avgTier: string; 
  score: { blue: number, red: number }; stats: { blue: TeamStats; red: TeamStats; };
  timeline: TimelineEvent[]; logs: GameLog[]; 
}

// ------------------------------------------------------------------
// 6. ì»¤ë®¤ë‹ˆí‹°(Community)
// ------------------------------------------------------------------
export interface Comment { id: number; author: string; authorTier: string; content: string; timestamp: string; }

export interface Post { 
  id: number; author: string; authorTier: string; title: string; content: string; 
  category: 'ê³µëµ' | 'ìœ ë¨¸' | 'ì§•ì§•' | 'ë¶„ì„' | 'ì¡ë‹´' | 'ì§ˆë¬¸' | 'ìë‘' | 'ê³µì§€'; 
  views: number; upvotes: number; downvotes: number; 
  comments: number; commentList: Comment[]; createdAt: number; potential: number; isBest: boolean; displayTime: string; 
}

// ------------------------------------------------------------------
// 7. ì „ì²´ ê²Œì„ ìƒíƒœ (GameState)
// ------------------------------------------------------------------
export interface GameState {
  season: number; day: number; hour: number; minute: number;
  isPlaying: boolean; gameSpeed: number;
  userSentiment: number; ccu: number; totalUsers: number;

  userStatus: UserStatus; 
  topRankers: UserProfile[];
  godStats: GodStats; 

  liveMatches: LiveMatch[];

  // ì„¤ì • ê´€ë ¨
  tierConfig: TierConfig;
  battleSettings: BattleSettings;
  fieldSettings: BattlefieldSettings; 

  // [ì‹ ê·œ] ì—­í• êµ° ì„¤ì •
  roleSettings: RoleSettings;

  aiConfig: AIConfig;
  itemStats: Record<string, ItemStatData>;
}


==========================================
FILE PATH: src/data/types/match.ts
==========================================
// ==========================================
// FILE PATH: /src/data/types/match.ts
// ==========================================

export type EventType = 'KILL' | 'TOWER' | 'COLOSSUS' | 'WATCHER' | 'START' | 'LEVELUP' | 'RECALL_CANCEL';

export interface GameLog {
  time: number;
  message: string;
  type: EventType;
  team?: 'BLUE' | 'RED';
}

export interface TimelineEvent {
  time: number; 
  type: EventType;
  killerId: string; 
  victimId: string; 
  message: string;
}

export interface VisualEffect {
  id: string;
  type: 'PROJECTILE' | 'EXPLOSION' | 'AREA' | 'HIT';
  x: number;
  y: number;
  targetX?: number; 
  targetY?: number; 
  color: string;
  size: number;
  duration: number; 
  maxDuration: number; 
}

export interface LivePlayer {
  name: string; 
  heroId: string;
  kills: number; deaths: number; assists: number;
  gold: number; // í˜„ì¬ ì†Œì§€ê¸ˆ (ì•„ì´í…œ ì‚¬ë©´ ì¤„ì–´ë“¦)
  totalGold: number; // [ì‹ ê·œ] ëˆ„ì  íšë“ ê³¨ë“œ (í†µê³„ìš©)
  cs: number;
  currentHp: number; maxHp: number;
  currentMp: number; maxMp: number; mpRegen: number;
  level: number; items: any[]; 
  totalDamageDealt: number;
  x: number; y: number; lane: 'TOP' | 'MID' | 'BOT' | 'JUNGLE';
  buffs: string[]; mmr: number; respawnTimer: number;
  cooldowns?: { q:number, w:number, e:number, r:number };
  stats: { brain: number, mechanics: number };
  lastAttackTime?: number;       
  lastAttackedTargetId?: string;
  killStreak: number; bounty: number;
  isRecalling: boolean; currentRecallTime: number; recallCooldown: number;
  activeSkill?: { key: 'q' | 'w' | 'e' | 'r'; timestamp: number; };
}

export interface TowerStatus { top: number; mid: number; bot: number; }

export interface TeamStats {
  towers: TowerStatus; 
  laneHealth: { top: number; mid: number; bot: number };
  colossus: number; watcher: number; fury: number;
  nexusHp: number; maxNexusHp: number;
  activeBuffs: { siegeUnit: boolean; voidPower: boolean; voidBuffEndTime?: number; };
}

export interface LiveMatch {
  id: string;
  status: 'DRAFTING' | 'PLAYING' | 'ENDED';
  draft?: any;
  blueTeam: LivePlayer[]; redTeam: LivePlayer[];
  bans: { blue: string[]; red: string[]; };
  startTime: number; duration: number; currentDuration: number; avgTier: string;
  score: { blue: number, red: number };
  stats: { blue: TeamStats; red: TeamStats; };
  timeline: TimelineEvent[]; logs: GameLog[];
  
  nextColossusSpawnTime?: number;
  nextWatcherSpawnTime?: number;
  objectives: {
      colossus: { hp: number; maxHp: number; status: 'ALIVE'|'DEAD'; nextSpawnTime: number };
      watcher: { hp: number; maxHp: number; status: 'ALIVE'|'DEAD'; nextSpawnTime: number };
  };
  minions: any[];
  projectiles: any[];
  jungleMobs: any[];
  visualEffects: VisualEffect[];
}



==========================================
FILE PATH: src/data/types/user.ts
==========================================
// src/types/user.ts
export interface MatchHistory {
  season: number; result: 'WIN' | 'LOSE'; heroName: string; kda: string; lpChange: number; date: string;
}
export interface UserProfile {
  id: number; name: string; mainHeroId: string; score: number;
  tier: string; winRate: number; totalGames: number;
  history: MatchHistory[];
  mostChamps: { name: string, winRate: number, kda: string }[];
  laneStats: { role: string, winRate: number }[];
}
export interface TierStat {
  name: string; minScore: number; count: number; percent: number; color: string;
}
export interface UserStatus {
  totalGames: number; playingUsers: number; queuingUsers: number; avgWaitTime: number;
  tierDistribution: TierStat[];
}
export interface TierConfig {
  challenger: number; master: number; ace: number; joker: number;
  gold: number; silver: number; bronze: number;
}


==========================================
FILE PATH: src/engine/CoreEngine.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/CoreEngine.ts
// ==========================================
import { GameState, Hero, Post } from '../types';
import { updateLiveMatches } from './match/MatchUpdater';
import { createLiveMatches } from './match/MatchCreator';
import { finishMatch } from './match/MatchSettlement';
import { initUserPool, userPool, getTopRankers } from './system/UserManager'; 
import { UserActivitySystem } from './system/UserActivitySystem';
import { analyzeHeroMeta, calculateUserEcosystem } from './system/RankingSystem';
import { updatePostInteractions, generatePostAsync } from './system/CommunityEngine';
import { calculateTargetSentiment, smoothSentiment } from './system/SentimentEngine';

export class CoreEngine {
  static processTick(
    initialState: GameState,
    initialHeroes: Hero[],
    initialPosts: Post[],
    totalDelta: number,
    stepSize: number, // ê³ ì • ìŠ¤í… (0.1)
    updateStateCallback: (
        updates: Partial<GameState>, 
        newHeroes: Hero[], 
        newPosts: Post[], 
        remainingTime: number
    ) => void
  ) {
    try {
      let currentState = { ...initialState };
      let currentHeroes = initialHeroes;
      let currentPosts = [...initialPosts];
      
      let remainingTime = totalDelta;
      
      // [ìµœì í™” í•µì‹¬] Loop Guard (í•œ í”„ë ˆì„ì— ìµœëŒ€ 50ë²ˆê¹Œì§€ë§Œ ê³„ì‚°)
      // 60ë°°ì†ì¼ ë•Œ 0.1ì´ˆ ë‹¨ìœ„ë©´ ì´ë¡ ìƒ 600ë²ˆ ëŒì•„ì•¼ í•˜ëŠ”ë°, ë¸Œë¼ìš°ì €ê°€ ì£½ì„ ìˆ˜ ìˆìœ¼ë‹ˆ ëŠì–´ì„œ ê°.
      // ë‚¨ì€ ì‹œê°„ì€ remainingTimeìœ¼ë¡œ ë°˜í™˜ë˜ì–´ ë‹¤ìŒ í”„ë ˆì„ì— ì´ì–´ì„œ ì²˜ë¦¬ë¨.
      let loopCount = 0;
      const MAX_LOOPS = 50; 

      while (remainingTime >= stepSize && loopCount < MAX_LOOPS) {
        const result = this.executeSingleStep(currentState, currentHeroes, currentPosts, stepSize);
        
        currentState = { ...currentState, ...result.stateUpdates };
        if (result.newHeroes) currentHeroes = result.newHeroes;
        if (result.newPosts) currentPosts = result.newPosts;

        remainingTime -= stepSize;
        loopCount++;
      }

      // ë‚¨ì€ ì‹œê°„(remainingTime)ì„ ì½œë°±ìœ¼ë¡œ ëŒë ¤ì¤Œ -> gameSliceì˜ timeBufferì— ì €ì¥ë¨
      updateStateCallback(currentState, currentHeroes, currentPosts, remainingTime);

    } catch (err) {
      console.error("Critical Engine Error:", err);
    }
  }

  private static executeSingleStep(
    state: GameState,
    heroes: Hero[],
    posts: Post[],
    deltaSeconds: number
  ) {
    let { hour, minute, second, day, totalUsers, tierConfig, liveMatches, godStats, itemStats } = state;

    // A. ì‹œê°„ íë¦„
    second += deltaSeconds;
    if (second >= 60) {
      const extraMinutes = Math.floor(second / 60);
      second %= 60;
      minute += extraMinutes;
      if (minute >= 60) {
        const extraHours = Math.floor(minute / 60);
        minute %= 60;
        hour += extraHours;
        if (hour >= 24) {
          const extraDays = Math.floor(hour / 24);
          hour %= 24;
          day += extraDays;
        }
      }
    }

    const currentTotalMinutes = day * 1440 + hour * 60 + Math.floor(minute);
    const isNewMinute = Math.floor(minute) !== Math.floor(state.minute);
    const isNewHour = Math.floor(hour) !== Math.floor(state.hour);

    if (!userPool || userPool.length === 0) {
      if (heroes.length > 0) initUserPool(heroes, totalUsers);
      return { stateUpdates: { second, minute, hour, day }, newHeroes: heroes, newPosts: posts };
    }

    if (isNewMinute && Math.floor(minute) % 10 === 0) {
       UserActivitySystem.updateTraffic(hour + (minute/60), userPool);
    }

    // B. ë§¤ì¹˜ ì—…ë°ì´íŠ¸
    let updatedMatches = [...liveMatches];
    const nextGodStats = { ...godStats };
    const nextItemStats = { ...itemStats }; 

    try {
      const processedMatches = updateLiveMatches(updatedMatches, heroes, deltaSeconds);
      
      updatedMatches = processedMatches.map(m => ({
          ...m,
          logs: m.logs.length > 15 ? m.logs.slice(-15) : [...m.logs],
      }));

      const isMatchEnded = (m: any) => (m.stats.blue.nexusHp <= 0 || m.stats.red.nexusHp <= 0);
      const endedMatches = updatedMatches.filter(m => isMatchEnded(m));
      updatedMatches = updatedMatches.filter(m => !isMatchEnded(m));

      endedMatches.forEach(match => {
        try {
          const result = finishMatch(match, heroes, day, hour, state.battleSettings, tierConfig);
          nextGodStats.totalMatches++;
          if (result.isBlueWin) nextGodStats.danteWins++; else nextGodStats.izmanWins++;

          [...match.blueTeam, ...match.redTeam].forEach(p => {
              if(!p.items) return;
              p.items.forEach((item: any) => {
                  if (!nextItemStats[item.id]) nextItemStats[item.id] = { itemId: item.id, totalPicks: 0, totalWins: 0, totalKills: 0, totalDeaths: 0, totalAssists: 0 };
                  const st = nextItemStats[item.id];
                  st.totalPicks++;
                  const isWin = (match.blueTeam.includes(p) && result.isBlueWin) || (match.redTeam.includes(p) && !result.isBlueWin);
                  if (isWin) st.totalWins++;
                  st.totalKills += p.kills; st.totalDeaths += p.deaths; st.totalAssists += p.assists;
              });
          });
        } catch (settleError) {
            console.error("Match Settlement Failed:", settleError);
        }
      });

    } catch (matchError) {
      console.warn("Match Update Skipped:", matchError);
    }

    // C. ë§¤ì¹˜ ìƒì„±
    if (Math.floor(second) % 10 === 0 && Math.floor(second - deltaSeconds) % 10 !== 0) { 
        if (updatedMatches.length < 60) {
            const onlineUsers = userPool.filter(u => u && u.status !== 'OFFLINE').length;
            const idleUsers = userPool.filter(u => u && u.status === 'IDLE');
            if (idleUsers.length >= 10) {
                const newMatches = createLiveMatches(heroes, onlineUsers, Date.now(), tierConfig);
                updatedMatches = [...updatedMatches, ...newMatches.slice(0, 3)];
            }
        }
    }

    // D. í†µê³„ ì—…ë°ì´íŠ¸ (1ì‹œê°„ì— í•œë²ˆ)
    let finalHeroes = heroes;
    let finalPosts = posts;
    let nextUserStatus = state.userStatus;
    let nextTopRankers = state.topRankers;
    let nextSentiment = state.userSentiment;

    if (isNewHour) { 
      if (userPool.length > 0) {
          try {
            finalHeroes = analyzeHeroMeta([...heroes]);
            const onlineUsers = userPool.filter(u => u && u.status !== 'OFFLINE').length;
            nextUserStatus = calculateUserEcosystem(onlineUsers, userPool.length, tierConfig);
            userPool.sort((a, b) => (b.score || 0) - (a.score || 0));
            userPool.forEach((u, idx) => { if(u) { u.rank = idx + 1; u.isChallenger = (u.score >= tierConfig.master && u.rank <= tierConfig.challengerRank); } });
            nextTopRankers = getTopRankers(finalHeroes, tierConfig);
            nextSentiment = smoothSentiment(nextSentiment, calculateTargetSentiment(state, finalHeroes, finalPosts));
            
            if (state.aiConfig && state.aiConfig.enabled && Math.random() < 0.5) {
                generatePostAsync(Date.now(), finalHeroes, tierConfig, currentTotalMinutes, state.aiConfig, userPool, state.battleSettings, state.fieldSettings).then(()=>{}).catch(()=>{});
            }
          } catch (updateError) {}
      }
    }
    
    if (isNewMinute && Math.floor(minute) % 10 === 0) {
        finalPosts = updatePostInteractions(finalPosts, currentTotalMinutes);
    }

    return {
      stateUpdates: {
        second, minute, hour, day,
        totalUsers: userPool.length, 
        userStatus: nextUserStatus,
        topRankers: nextTopRankers,
        godStats: nextGodStats, 
        itemStats: nextItemStats, 
        liveMatches: updatedMatches,
        userSentiment: nextSentiment
      },
      newHeroes: finalHeroes,
      newPosts: finalPosts
    };
  }
}



==========================================
FILE PATH: src/engine/data/MapData.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/data/MapData.ts
// ==========================================

export interface Vector2 { x: number; y: number; }

export const BASES = {
  BLUE: { x: 5, y: 95 },
  RED: { x: 95, y: 5 }
};

// ë‹¨ìˆœ ê±°ë¦¬ ê³„ì‚° (ì„œë²„ ë¡œì§ìš©)
export const getDistance = (a: {x:number, y:number}, b: {x:number, y:number}) => {
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
};

export const POI = { 
  // [ìˆ˜ì •] ê±°ì‹ ë³‘ ìœ„ì¹˜ë¥¼ ë§µì˜ 10~11ì‹œ ë°©í–¥(ë°”ë¡  ë‘¥ì§€)ìœ¼ë¡œ ì´ë™
  BARON: { x: 25, y: 30 },    
  // [ìˆ˜ì •] ì£¼ì‹œì ìœ„ì¹˜ë¥¼ ë§µì˜ 4~5ì‹œ ë°©í–¥(ìš© ë‘¥ì§€)ìœ¼ë¡œ ì´ë™
  DRAGON: { x: 75, y: 70 },   
  TOP_RIVER: { x: 20, y: 20 },
  BOT_RIVER: { x: 80, y: 80 }
};

export const getTowerSafeZone = (lane: string, isBlue: boolean) => {
    if (lane === 'TOP') return isBlue ? {x: 5, y: 20} : {x: 20, y: 5};
    if (lane === 'MID') return isBlue ? {x: 20, y: 80} : {x: 80, y: 20}; 
    if (lane === 'BOT') return isBlue ? {x: 80, y: 95} : {x: 95, y: 80};
    return isBlue ? BASES.BLUE : BASES.RED;
};



==========================================
FILE PATH: src/engine/match/actions/FarmAction.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/actions/FarmAction.ts
// ==========================================
import { LiveMatch, Hero, LivePlayer, Minion, BattleSettings } from '../../../types';
import { TargetEvaluator } from '../ai/evaluators/TargetEvaluator';
import { calculateUnitDamage } from '../systems/DamageCalculator'; 
// [ìˆ˜ì •] ê²½ë¡œ ì˜¤ë¥˜ ìˆ˜ì •: systems -> logics
import { distributeRewards, MINION_REWARD } from '../logics/CombatLogic';

export class FarmAction {
  static tryFarm(
    attacker: LivePlayer,
    attackerHero: Hero,
    match: LiveMatch,
    enemies: { minions: Minion[] },
    atkStats: any,
    isBlue: boolean,
    settings: BattleSettings,
    heroes: Hero[]
  ): boolean {
    
    if (!enemies.minions || enemies.minions.length === 0) return false;

    // 1. íƒ€ê²Ÿ ì„ ì • (ê°€ì¥ í”¼ ì ì€ ë†ˆ)
    const potentialTargets = [...enemies.minions].sort((a,b) => a.hp - b.hp);
    const targetMinion = potentialTargets[0]; 

    if (!targetMinion) return false;

    // 2. ë‚´ ë°ë¯¸ì§€ ê³„ì‚°
    const myDamage = calculateUnitDamage(attacker, atkStats, targetMinion, isBlue, settings);

    // 3. ì²˜í˜• ì„ê³„ê°’ (ë§‰íƒ€ ê°)
    let executeThreshold = myDamage * 2.5; 
    
    // ìˆ˜í˜¸ê¸°ì‚¬(ì„œí¬í„°)ëŠ” ë§‰íƒ€ ì–‘ë³´ (5% í™•ë¥ ë¡œë§Œ ë§‰íƒ€ ì¹¨ - íƒ€ê³¤ì‚° í„°íŠ¸ë¦¬ê¸°ìš©)
    if (attackerHero.role === 'ìˆ˜í˜¸ê¸°ì‚¬') {
        if (Math.random() < 0.05) executeThreshold = myDamage * 6.0; 
        else return false; 
    }

    // 4. í‚¬ ê°€ëŠ¥í•œ íƒ€ê²Ÿ ì¬ê²€ìƒ‰
    const killableTarget = TargetEvaluator.selectFarmTarget(attacker, enemies.minions, executeThreshold);

    if (killableTarget) {
        // ë°ë¯¸ì§€ ì ìš©
        if (killableTarget.hp <= executeThreshold) {
            killableTarget.hp = 0; // ì²˜í˜•
        } else {
            killableTarget.hp -= myDamage;
        }
        
        attacker.totalDamageDealt += myDamage;

        // ì²˜ì¹˜ ì‹œ ë³´ìƒ
        if (killableTarget.hp <= 0) {
            const reward = (MINION_REWARD as any)[killableTarget.type] || MINION_REWARD.MELEE;
            distributeRewards(match, killableTarget, attacker, isBlue ? 'BLUE' : 'RED', reward, heroes);

            if (killableTarget.type === 'SUMMONED_COLOSSUS') {
                match.logs.push({ 
                    time: Math.floor(match.currentDuration), 
                    message: `âš”ï¸ [${attackerHero.name}]ê°€ ì ì˜ ê±°ì‹ ë³‘ì„ ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤!`, 
                    type: 'KILL', team: isBlue ? 'BLUE' : 'RED' 
                });
            }
        }
        return true; 
    }

    return false; 
  }
}



==========================================
FILE PATH: src/engine/match/actions/HeroCombatAction.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/actions/HeroCombatAction.ts
// ==========================================
import { LiveMatch, Hero, LivePlayer, BattleSettings, RoleSettings } from '../../../types';
import { TargetEvaluator } from '../ai/evaluators/TargetEvaluator';
import { calculateHeroDamage } from '../systems/DamageCalculator'; // [ìˆ˜ì •]
import { distributeAssist } from '../systems/RewardSystem'; // [ìˆ˜ì •]

export class HeroCombatAction {
  static tryCombat(
    attacker: LivePlayer,
    attackerHero: Hero,
    match: LiveMatch,
    enemies: { heroes: LivePlayer[] },
    atkStats: any,
    isBlue: boolean,
    settings: BattleSettings,
    roleSettings: RoleSettings,
    watcherBuffType: string,
    heroes: Hero[]
  ): boolean {
    if (!enemies.heroes || enemies.heroes.length === 0) return false;

    // 1. íƒ€ê²Ÿ ì„ ì •
    const defender = TargetEvaluator.selectBestTarget(attacker, attackerHero, enemies.heroes, heroes);
    
    if (defender) {
        attacker.lastAttackTime = match.currentDuration;
        attacker.lastAttackedTargetId = defender.heroId;

        const defenderHero = heroes.find(h => h.id === defender.heroId);
        if (defenderHero) {
            // 2. ë°ë¯¸ì§€ ê³„ì‚°
            const defArmor = (defender.level * 3) + (defenderHero.stats.armor || 30);
            const defStats = { ...defenderHero.stats, armor: defArmor };

            const damage = calculateHeroDamage(
                attacker, defender, atkStats, defStats, attackerHero, 
                isBlue, settings, roleSettings, watcherBuffType
            );
            
            defender.currentHp -= damage;
            attacker.totalDamageDealt += damage;

            // 3. ì²˜ì¹˜ ì²˜ë¦¬
            if (defender.currentHp <= 0) {
                attacker.kills++; 
                defender.deaths++; 
                attacker.gold += 300;
                
                // [ì¤‘ìš”] RewardSystem ì‚¬ìš©
                distributeAssist(match, attacker, defender, isBlue);

                if (isBlue) match.score.blue++; else match.score.red++;
                
                match.logs.push({ 
                    time: Math.floor(match.currentDuration), 
                    message: `ğŸ’€ [${attackerHero.name}]ê°€ [${defenderHero.name}] ì²˜ì¹˜!`, 
                    type: 'KILL', team: isBlue ? 'BLUE' : 'RED' 
                });
                
                defender.currentHp = 0;
                defender.respawnTimer = 10 + (defender.level * 2);
            }
        }
        return true; 
    }

    return false;
  }
}



==========================================
FILE PATH: src/engine/match/ai/AIUtils.ts
==========================================
import { LivePlayer, LiveMatch } from '../../../types';
// [ìˆ˜ì •] ê²½ë¡œ ìˆ˜ì •: ../../utils -> ../utils
import { Vector } from '../utils/Vector';
import { BASES } from '../constants/MapConstants';

export class AIUtils {
  static dist(a: {x:number, y:number}, b: {x:number, y:number}): number {
    // aë‚˜ bê°€ ì—†ì„ ê²½ìš° ë°©ì–´ ì½”ë“œ
    if (!a || !b) return 9999;
    return Vector.dist({x: a.x, y: a.y}, {x: b.x, y: b.y});
  }

  static hpPercent(unit: LivePlayer): number {
    return unit.maxHp > 0 ? unit.currentHp / unit.maxHp : 0;
  }

  static mpPercent(unit: LivePlayer): number {
    return unit.maxMp > 0 ? unit.currentMp / unit.maxMp : 0;
  }

  static getCombatPower(unit: LivePlayer): number {
    // items ë°°ì—´ ì•ˆì „ ì ‘ê·¼
    const itemCount = unit.items ? unit.items.length : 0;
    return (unit.level * 100) + (this.hpPercent(unit) * 1000) + (itemCount * 150);
  }

  static getMyBasePos(isBlue: boolean): {x: number, y: number} {
    return isBlue ? BASES.BLUE : BASES.RED;
  }

  static getNextObjectivePos(player: LivePlayer, match: LiveMatch, isBlue: boolean): {x: number, y: number} {
    if (player.lane === 'JUNGLE') return { x: 50, y: 50 }; 

    const enemyStats = isBlue ? match.stats.red : match.stats.blue;
    const laneKey = player.lane.toLowerCase(); 
    
    // ì•ˆì „í•˜ê²Œ ì ‘ê·¼
    const towers = enemyStats.towers as any;
    const brokenCount = towers && towers[laneKey] !== undefined ? towers[laneKey] : 0;

    if (brokenCount >= 3) {
      return isBlue ? BASES.RED : BASES.BLUE;
    }

    const tier = brokenCount + 1;
    return this.calculateTowerPos(player.lane, tier, !isBlue); 
  }

  private static calculateTowerPos(lane: string, tier: number, isBlueSide: boolean) {
    let start = isBlueSide ? BASES.BLUE : BASES.RED;
    let end = isBlueSide ? BASES.RED : BASES.BLUE;

    let ratio = 0;
    if (tier === 1) ratio = 0.5; 
    else if (tier === 2) ratio = 0.75;
    else ratio = 0.9;

    let tx = start.x + (end.x - start.x) * ratio;
    let ty = start.y + (end.y - start.y) * ratio;

    if (lane === 'TOP') {
        if (isBlueSide) ty = 10; else tx = 10;
    } else if (lane === 'BOT') {
        if (isBlueSide) tx = 90; else ty = 90;
    }
    
    return { x: tx, y: ty };
  }
}



==========================================
FILE PATH: src/engine/match/ai/evaluators/EconomyEvaluator.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/evaluators/EconomyEvaluator.ts
// ==========================================
import { LivePlayer, LiveMatch } from '../../../../types';
import { AIUtils } from '../AIUtils';
import { Perception } from '../Perception';

/**
 * ê²½ì œ(Economy) ìƒíƒœë¥¼ ë¶„ì„í•˜ì—¬ ì‡¼í•‘ì„ ìœ„í•œ ê·€í™˜ ì—¬ë¶€ë¥¼ ê²°ì •í•©ë‹ˆë‹¤.
 */
export class EconomyEvaluator {

  /**
   * ì‡¼í•‘ì„ ìœ„í•´ ê·€í™˜í•´ì•¼ í•˜ëŠ”ì§€ íŒë‹¨í•©ë‹ˆë‹¤.
   * @param player í”Œë ˆì´ì–´
   * @param match ë§¤ì¹˜ ì •ë³´
   * @returns ê·€í™˜ í•„ìš” ì—¬ë¶€ (true/false)
   */
  static shouldRecallForShopping(player: LivePlayer, match: LiveMatch): boolean {
    // 1. [ì ˆëŒ€ ë¶ˆê°€ ì¡°ê±´] êµì „ ì¤‘ì´ê±°ë‚˜ ìœ„í—˜í•œ ìƒí™©ì´ë©´ ì‡¼í•‘ ê¸ˆì§€
    if (this.isInCombatOrDanger(player, match)) return false;

    // 2. [ê¸°ë³¸ ì¡°ê±´] ê³¨ë“œê°€ ë„ˆë¬´ ì ìœ¼ë©´ ê³ ë ¤ ê°€ì¹˜ ì—†ìŒ
    if (player.gold < 500) return false;

    const brain = player.stats.brain; // 0 ~ 100
    const itemCount = player.items.length;
    const currentGold = player.gold;

    // 3. [ì§€ëŠ¥í˜• íŒë‹¨] ì•„ì´í…œ ë³´ìœ  ìƒí™©ì— ë”°ë¥¸ ëª©í‘œ ê³¨ë“œ ì„¤ì •
    let targetGoldThreshold = 99999;

    if (itemCount === 0) {
      // ì‹œì‘ ì•„ì´í…œë„ ì—†ë‹¤ë©´ ë¹ ë¥´ê²Œ ë³µê·€ (ë³´í†µ ê²Œì„ ì‹œì‘ ì§í›„)
      targetGoldThreshold = 500;
    } 
    else if (itemCount < 2) {
      // ì´ˆë°˜: í•˜ìœ„í…œ í•˜ë‚˜ ì‚´ ëˆ (ë¡±ì†Œë“œ/ì¦í­ì˜ê³ ì„œ ê¸‰ + @)
      targetGoldThreshold = 1100; 
    } 
    else if (itemCount < 6) {
      // ì¤‘í›„ë°˜: ì½”ì–´ ì•„ì´í…œ ì™„ì„± ë¹„ìš© (ëŒ€ëµ 2800~3200 ì‚¬ì´)
      // ì´ë¯¸ ê°€ì§„ ëˆì´ ë§ìœ¼ë©´ ë°”ë¡œ ê°
      targetGoldThreshold = 2500;
    } 
    else {
      // í’€í…œ: ì˜ì•½ì´ë‚˜ ìƒìœ„í…œ êµì²´ìš© (ë§¤ìš° ë†’ì€ ê³¨ë“œ í•„ìš”)
      targetGoldThreshold = 3500;
    }

    // [ë‡Œì§€ì»¬ ë³´ì •]
    // ë‡Œì§€ì»¬ì´ ë†’ìœ¼ë©´(>70), ëˆì´ ë”± ëª¨ì˜€ì„ ë•Œ ì¹¼ê°™ì´ ì§‘ì— ê° (íš¨ìœ¨ì„±)
    // ë‡Œì§€ì»¬ì´ ë‚®ìœ¼ë©´(<40), ëˆì´ ë§ì•„ë„ ë¼ì¸ ë” ë¨¹ìœ¼ë ¤ê³  ë²„íŒ€ (íƒìš•)
    if (brain > 70) targetGoldThreshold *= 0.9; // 10% ì¼ì° ê°
    else if (brain < 40) targetGoldThreshold *= 1.5; // 50% ë” ëª¨ì•„ì•¼ ê°

    // 4. [ìƒí™© íŒë‹¨] ë¼ì¸ ìƒíƒœ ì²´í¬ (Wave Management)
    // ëˆì´ ìˆì–´ë„ ë¼ì¸ì´ ìš°ë¦¬ íƒ€ì›Œì— ë°•íˆê³  ìˆìœ¼ë©´ ê°€ë©´ ì•ˆë¨ (ê²½í—˜ì¹˜ ì†ì‹¤)
    const isLineBad = this.isWavePushingMyTower(player, match);
    
    // ë‡Œì§€ì»¬ì´ ì¢‹ìœ¼ë©´ ë¼ì¸ ì†ì‹¤ì„ ê±±ì •í•´ì„œ ê·€í™˜ì„ ë¯¸ë£¸
    if (brain > 50 && isLineBad && currentGold < targetGoldThreshold * 1.5) {
        return false;
    }

    // 5. ìµœì¢… ê²°ì •
    return currentGold >= targetGoldThreshold;
  }

  /**
   * í˜„ì¬ êµì „ ì¤‘ì´ê±°ë‚˜ ìœ„í˜‘ì„ ë°›ê³  ìˆëŠ”ì§€ í™•ì¸
   */
  private static isInCombatOrDanger(player: LivePlayer, match: LiveMatch): boolean {
    // ìµœê·¼ì— ê³µê²©í–ˆê±°ë‚˜ ê³µê²©ë°›ìŒ (5ì´ˆ ì´ë‚´)
    const now = match.currentDuration;
    if ((player.lastAttackTime && now - player.lastAttackTime < 5) || 
        (player.lastAttackedTargetId && now - (player as any).lastHitTime < 5)) {
        return true;
    }

    // ì£¼ë³€ì— ì ì´ ìˆìŒ (ì‹œì•¼ ë²”ìœ„ ë‚´)
    const nearby = Perception.analyzeNearbySituation(player, match, 15);
    if (nearby.enemies.length > 0) return true;

    // íƒ€ì›Œ ì–´ê·¸ë¡œ
    if (Perception.isUnderTowerAggro(player, match)) return true;

    return false;
  }

  /**
   * ì  ë¯¸ë‹ˆì–¸ì´ ìš°ë¦¬ íƒ€ì›Œ ê·¼ì²˜ì— ìˆëŠ”ì§€ í™•ì¸ (ë¼ì¸ ì†ì‹¤ ë°©ì§€)
   */
  private static isWavePushingMyTower(player: LivePlayer, match: LiveMatch): boolean {
    if (player.lane === 'JUNGLE') return false;

    const isBlue = match.blueTeam.includes(player);
    const myTeamColor = isBlue ? 'BLUE' : 'RED';
    const checkRange = 20;

    // ë‚´ íƒ€ì›Œ ìœ„ì¹˜ ì¶”ì • (ê°„ëµí™”: í˜„ì¬ ë‚´ ìœ„ì¹˜ê°€ íƒ€ì›Œ ê·¼ì²˜ë¼ê³  ê°€ì •í•˜ê±°ë‚˜, ê¸°ì§€ ê±°ë¦¬ë¡œ íŒë‹¨)
    // ì •í™•íˆëŠ” MapConstantsì˜ íƒ€ì›Œ ì¢Œí‘œë¥¼ ê°€ì ¸ì™€ì•¼ í•˜ì§€ë§Œ, 
    // ì—¬ê¸°ì„œëŠ” í”Œë ˆì´ì–´ê°€ ë¼ì¸ì— ì„œ ìˆë‹¤ê³  ê°€ì •í•˜ê³  ì£¼ë³€ ì  ë¯¸ë‹ˆì–¸ ìˆ˜ë¥¼ ë´…ë‹ˆë‹¤.
    
    const minions = match.minions || [];
    const enemyMinionsNearMe = minions.filter(m => 
        m.lane === player.lane && 
        m.team !== myTeamColor && 
        m.hp > 0 && 
        AIUtils.dist(player, m) < checkRange
    );

    // ë‚´ ì£¼ë³€ì— ì  ë¯¸ë‹ˆì–¸ì´ 3ë§ˆë¦¬ ì´ìƒì´ë©´ "ë¼ì¸ì´ í˜•ì„±ë˜ì–´ ìˆë‹¤"ê³  íŒë‹¨
    // ì—¬ê¸°ì„œ ì•„êµ° ë¯¸ë‹ˆì–¸ì´ ì—†ìœ¼ë©´ "ë°•íˆëŠ” ë¼ì¸"ì„.
    if (enemyMinionsNearMe.length >= 3) {
        const allyMinionsNearMe = minions.filter(m => 
            m.lane === player.lane && 
            m.team === myTeamColor && 
            m.hp > 0 && 
            AIUtils.dist(player, m) < checkRange
        );
        
        // ì  ë¯¸ë‹ˆì–¸ì€ ìˆëŠ”ë° ì•„êµ° ë¯¸ë‹ˆì–¸ì´ ì ë‹¤ -> ë¼ì¸ì´ ë°€ë¦¬ëŠ” ì¤‘ -> ì§‘ ê°€ì§€ ë§ˆë¼
        if (allyMinionsNearMe.length < 2) return true;
    }

    return false;
  }
}



==========================================
FILE PATH: src/engine/match/ai/evaluators/GankEvaluator.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/evaluators/GankEvaluator.ts
// ==========================================
import { LivePlayer, LiveMatch, Hero } from '../../../../types';
import { AIUtils } from '../AIUtils';
import { BASES } from '../../constants/MapConstants';

export class GankEvaluator {
  static evaluate(player: LivePlayer, match: LiveMatch, hero: Hero): LivePlayer | null {
    const isJungler = player.lane === 'JUNGLE';
    const isMid = player.lane === 'MID';
    const brain = player.stats.brain;
    
    // ë¡œë° ì¡°ê±´: ë‡Œì§€ì»¬ 60 ì´ìƒì´ë©´ ë¼ì´ë„ˆë„ ë¡œë°ê° ë´„
    if (!isJungler && !isMid && brain < 60) return null;

    const isBlue = match.blueTeam.includes(player);
    const enemies = isBlue ? match.redTeam : match.blueTeam;
    const enemyBase = isBlue ? BASES.RED : BASES.BLUE;

    let bestTarget: LivePlayer | null = null;
    let maxScore = 0;

    for (const enemy of enemies) {
      if (enemy.currentHp <= 0 || enemy.respawnTimer > 0) continue;
      if (enemy.lane === 'JUNGLE') continue;

      let score = 0;

      // A. ê±°ë¦¬ ì ìˆ˜
      const dist = AIUtils.dist(player, enemy);
      if (dist > 70) continue;
      score += (70 - dist) * 1.5;

      // B. ì²´ë ¥ ì ìˆ˜ (ë”¸í”¼ ëƒ„ìƒˆ)
      const hpPer = AIUtils.hpPercent(enemy);
      if (hpPer < 0.5) score += (1 - hpPer) * 200; // ê°€ì¤‘ì¹˜ ëŒ€í­ ìƒí–¥

      // C. ë¼ì¸ ìƒí™© (Overextension)
      const distFromEnemyBase = AIUtils.dist(enemy, enemyBase);
      if (distFromEnemyBase > 35) { // ì ì´ ë¼ì¸ì„ ë°€ê³  ìˆìŒ
        score += (distFromEnemyBase - 35) * 4;
      } else {
        score -= 50; // íƒ€ì›Œ í—ˆê¹… ì¤‘ì´ë©´ ê°±í‚¹ ë¹„ì¶”ì²œ
      }

      // D. [ë‡Œì§€ì»¬] ì•„êµ° í˜¸ì‘ ê°€ëŠ¥ ì—¬ë¶€
      // ë˜‘ë˜‘í•˜ë©´ ì•„êµ°ì´ ê·¼ì²˜ì— ìˆì„ ë•Œë§Œ ê°±í‚¹ ê°
      if (brain > 70) {
          const allyNearby = (isBlue ? match.blueTeam : match.redTeam).find(
              a => a !== player && a.currentHp > 0 && AIUtils.dist(a, enemy) < 20
          );
          if (allyNearby) score += 50;
          else score -= 30; // í˜¸ì‘ ì—†ìœ¼ë©´ ê°ì 
      } else {
          // ë©ì²­í•˜ë©´ ê·¸ëƒ¥ ë“¤ì–´ê° (ì ìˆ˜ ë³´ì • ì—†ìŒ)
      }

      // E. ì—­í• êµ° ë³´ì • (ë´‡ ê°±í‚¹ ì„ í˜¸)
      if (enemy.lane === 'BOT') score += 20;

      if (score > 60 && score > maxScore) {
        maxScore = score;
        bestTarget = enemy;
      }
    }

    return bestTarget;
  }
}



==========================================
FILE PATH: src/engine/match/ai/evaluators/KillEvaluator.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/evaluators/KillEvaluator.ts
// ==========================================
import { LivePlayer, Hero, BattleSettings, RoleSettings, LiveMatch } from '../../../../types';
import { AIUtils } from '../AIUtils';
import { getLevelScaledStats, calculateTotalStats } from '../../utils/StatUtils';
import { applyRoleBonus } from '../../systems/RoleManager';
import { Perception } from '../Perception';

export class KillEvaluator {
  
  static evaluateKillChance(
    attacker: LivePlayer, 
    target: LivePlayer, 
    heroes: Hero[],
    match: LiveMatch,
    settings: BattleSettings,
    roleSettings: RoleSettings
  ): number {
    const atkHero = heroes.find(h => h.id === attacker.heroId);
    const defHero = heroes.find(h => h.id === target.heroId);
    if (!atkHero || !defHero) return 0;

    // 1. ê¸°ë³¸ ë°ë¯¸ì§€ ê³„ì‚°
    const atkBase = getLevelScaledStats(atkHero.stats, attacker.level);
    const atkTotal = calculateTotalStats({ ...atkHero, stats: atkBase }, attacker.items);
    const { damageMod } = applyRoleBonus(attacker, atkHero.role, false, [], roleSettings);
    const comboDmg = (atkTotal.ad * 2.5 + atkTotal.ap * 2.0 + 100) * damageMod;
    
    const defBase = getLevelScaledStats(defHero.stats, target.level);
    const defTotal = calculateTotalStats({ ...defHero, stats: defBase }, target.items);
    const defMitigation = 100 / (100 + defTotal.armor);
    const estimatedRealDmg = comboDmg * defMitigation;

    let killScore = 0;
    const currentHp = target.currentHp;

    // 2. 1:1 ìŠ¹ì‚° ê³„ì‚°
    if (currentHp <= estimatedRealDmg) {
        killScore += 500; 
        if (AIUtils.hpPercent(target) < 0.15) killScore += 1000; 
    } else {
        killScore += (estimatedRealDmg / currentHp) * 50;
    }

    // =========================================================
    // [í•µì‹¬ ì¶”ê°€] ìƒí™© íŒë‹¨ (Context Awareness)
    // =========================================================
    
    // A. ì  ì§€ì›êµ° ì²´í¬ (Target's Backup)
    // íƒ€ê²Ÿ ì£¼ë³€ 15ê±°ë¦¬ ë‚´ì— ë‹¤ë¥¸ ì ì´ ëª‡ ëª…ì´ë‚˜ ìˆëŠ”ê°€?
    const isBlueAttacker = match.blueTeam.includes(attacker);
    const enemies = isBlueAttacker ? match.redTeam : match.blueTeam;
    
    const enemiesNearTarget = enemies.filter(e => 
        e !== target && e.currentHp > 0 && AIUtils.dist(target, e) < 15
    ).length;

    // ì ì´ ë­‰ì³ìˆìœ¼ë©´ ì ìˆ˜ ëŒ€í­ ì‚­ê° (ìì‚´ í–‰ìœ„ ë°©ì§€)
    if (enemiesNearTarget > 0) {
        killScore -= (enemiesNearTarget * 1000); // í•œ ëª…ë‹¹ -1000ì  (ì ˆëŒ€ ëª» ë“¤ì–´ê°€ê²Œ)
        
        // ë‹¨, ë‚´ ë‡Œì§€ì»¬ì´ ë‚®ìœ¼ë©´(40 ë¯¸ë§Œ) ìƒí™© íŒŒì•… ëª»í•˜ê³  ê¼´ì•„ë°•ìŒ
        if (attacker.stats.brain < 40) {
            killScore += (enemiesNearTarget * 800); // í˜ë„í‹° ìƒì‡„ (ë©ì²­í•¨ êµ¬í˜„)
        }
        
        // ê´‘ì—­ ë”œëŸ¬(ì„ ì§€ì)ëŠ” ë­‰ì¹œ ì ì—ê²Œ ì ìˆ˜ ê°€ì‚° (ë‹¨, ë„ˆë¬´ ë§ìœ¼ë©´ ìœ„í—˜)
        if (atkHero.role === 'ì„ ì§€ì' && enemiesNearTarget <= 2) {
            killScore += 500; 
        }
    }

    // B. ì„±ì¥ ì°¨ì´ (Level Gap)
    // ì  ë ˆë²¨ì´ ë‚˜ë³´ë‹¤ ë†’ìœ¼ë©´ ì«„ì•„ì•¼ í•¨
    const levelDiff = target.level - attacker.level;
    if (levelDiff > 0) {
        killScore -= (levelDiff * 300); // 1ë ˆë²¨ ì°¨ì´ë‹¹ -300ì 
    } else if (levelDiff < 0) {
        killScore += (Math.abs(levelDiff) * 100); // ì–‘í•™ ë³´ë„ˆìŠ¤
    }

    // C. íƒ€ì›Œ ë‹¤ì´ë¸Œ ì²´í¬
    const underTower = Perception.isInActiveEnemyTowerRange({x: target.x, y: target.y}, match, isBlueAttacker);
    if (underTower) {
        killScore -= 2000; // ê¸°ë³¸ì ìœ¼ë¡œ ë‹¤ì´ë¸Œ ê¸ˆì§€
        
        // ë‡Œì§€ì»¬ ë†’ê³  + í™•ì‹¤í•œ í‚¬ê° + ë‚´ í”¼ ë§ìŒ -> ì˜ˆì™¸ì  í—ˆìš©
        if (attacker.stats.brain > 60 && currentHp < estimatedRealDmg * 0.8 && AIUtils.hpPercent(attacker) > 0.7) {
            killScore += 1500; 
        }
    }

    return killScore;
  }

  static isWorthTrading(attacker: LivePlayer, target: LivePlayer): boolean {
    const brain = attacker.stats.brain;
    // ë©ì²­í•˜ë©´ ë¬´ì¡°ê±´ ì‹¸ì›€
    if (brain < 40) return true;
    
    // ì„±ì¥ ì°¨ì´ ì‹¬í•˜ë©´ ë¤ë¹„ì§€ ì•ŠìŒ
    if (target.level >= attacker.level + 2) return false;
    
    // ë‚´ í”¼ê°€ ë„ˆë¬´ ì—†ìœ¼ë©´ ë”œêµí™˜ ì†í•´
    if (AIUtils.hpPercent(attacker) < 0.3 && AIUtils.hpPercent(target) > 0.5) return false;

    return true;
  }
}



==========================================
FILE PATH: src/engine/match/ai/evaluators/PsychologyEvaluator.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/evaluators/PsychologyEvaluator.ts
// ==========================================
import { LivePlayer, LiveMatch } from '../../../../types';

export class PsychologyEvaluator {
  
  /**
   * í”Œë ˆì´ì–´ì˜ í˜„ì¬ ì‹¬ë¦¬ ìƒíƒœ(Morale)ë¥¼ ë°°ìœ¨ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
   * 1.0 = í‰ì •ì‹¬
   * > 1.0 = ê³ ì–‘ë¨ (ì ê·¹ì , ê³µê²©ì )
   * < 1.0 = ìœ„ì¶•ë¨ (ì†Œê·¹ì , ë°©ì–´ì )
   */
  static getMorale(player: LivePlayer, match: LiveMatch): number {
    let morale = 1.0;

    // 1. KDA ê¸°ë°˜ ìì‹ ê°
    const kda = player.deaths === 0 ? player.kills : player.kills / player.deaths;
    
    if (kda > 3.0) morale += 0.2; // ìºë¦¬ ì¤‘
    if (kda > 5.0) morale += 0.3; // í•™ì‚´ ì¤‘ (ë§¤ìš° ê³µê²©ì )
    if (player.deaths > player.kills + 2) morale -= 0.2; // ë§ë¦¼
    if (player.deaths > 5 && player.kills === 0) morale -= 0.3; // ë©˜íƒˆ ë¶•ê´´

    // 2. ì—°ì† í‚¬/ë°ìŠ¤ (Streak)
    if (player.killStreak >= 3) morale += 0.2; // ì‹ ë‚¨
    
    // 3. íŒ€ ìƒí™© (ê³¨ë“œ ì°¨ì´)
    // ì •í™•í•œ ê³¨ë“œ ì°¨ì´ ê³„ì‚°ì€ ë¬´ê±°ìš°ë¯€ë¡œ íƒ€ì›Œ ìˆ˜ë¡œ ëŒ€ëµ íŒë‹¨
    const isBlue = match.blueTeam.includes(player);
    const myStats = isBlue ? match.stats.blue : match.stats.red;
    const enemyStats = isBlue ? match.stats.red : match.stats.blue;
    
    const myTowers = myStats.towers.top + myStats.towers.mid + myStats.towers.bot;
    const enemyTowers = enemyStats.towers.top + enemyStats.towers.mid + enemyStats.towers.bot;

    if (enemyTowers - myTowers >= 2) morale += 0.1; // ìš°ë¦¬ê°€ ìœ ë¦¬í•¨
    if (myTowers - enemyTowers >= 2) morale -= 0.1; // ìš°ë¦¬ê°€ ë¶ˆë¦¬í•¨ (ì‚¬ë ¤ì•¼ í•¨)

    // 4. ë‡Œì§€ì»¬ì— ë”°ë¥¸ ë©˜íƒˆ ë³´ì •
    const brain = player.stats.brain;
    
    // ë‡Œì§€ì»¬ì´ ë†’ìœ¼ë©´(>70): ë¶ˆë¦¬í•´ë„ ì¹¨ì°©í•¨ (morale ê°ì  ì™„í™”)
    if (brain > 70 && morale < 1.0) {
        morale = (morale + 1.0) / 2; // íšŒë³µ íƒ„ë ¥ì„±
    }
    // ë‡Œì§€ì»¬ì´ ë‚®ìœ¼ë©´(<30): ìœ ë¦¬í•˜ë©´ ë˜ì§ (morale ê³¼ë„ ìƒìŠ¹)
    else if (brain < 30 && morale > 1.2) {
        morale += 0.3; // ë‡Œì ˆ ëª¨ë“œ
    }

    // ìµœì†Œ 0.5 ~ ìµœëŒ€ 2.0 ì œí•œ
    return Math.max(0.5, Math.min(2.0, morale));
  }
}



==========================================
FILE PATH: src/engine/match/ai/evaluators/RecallInterrupter.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/evaluators/RecallInterrupter.ts
// ==========================================
import { LivePlayer } from '../../../../types';
import { AIUtils } from '../AIUtils';

export class RecallInterrupter {
  
  /**
   * ì ì˜ ê·€í™˜ì„ ë°©í•´í•´ì•¼ í•˜ëŠ”ì§€ íŒë‹¨í•˜ê³ , ìš°ì„ ìˆœìœ„ ì ìˆ˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
   */
  static getInterruptionScore(attacker: LivePlayer, target: LivePlayer): number {
    // 1. ê·€í™˜ ì¤‘ì´ ì•„ë‹ˆë©´ ë¬´ì‹œ
    if (!target.isRecalling) return 0;

    let score = 0;
    const hpPercent = AIUtils.hpPercent(target);

    // 2. ê¸°ë³¸ ë°©í•´ ì ìˆ˜ (ê·€í™˜ ìì²´ë¥¼ ëŠëŠ” ê²ƒë§Œìœ¼ë¡œë„ ì´ë“)
    score += 500;

    // 3. ë”¸í”¼ì¼ìˆ˜ë¡ ì ìˆ˜ í­ì¦ (ì§‘ì— ëª» ê°€ê²Œ í•˜ê³  ì£½ì—¬ì•¼ í•¨)
    if (hpPercent < 0.3) {
        score += 2000; // ë”¸í”¼ ê·€í™˜ì€ ëˆˆì— ë¶ˆì„ ì¼œê³  ëŠìŒ
    } else if (hpPercent < 0.6) {
        score += 1000;
    }

    // 4. ê·€í™˜ ì™„ë£Œ ì§ì „ì¼ìˆ˜ë¡ ì ìˆ˜ ìƒìŠ¹ (ë‹¤ê¸‰í•¨)
    // recallTimeì´ ë³´í†µ 10ì´ˆë¼ë©´, 8ì´ˆ ë„˜ê²Œ ì§„í–‰ëì„ ë•Œ ë” ê¸‰í•˜ê²Œ ëŠìœ¼ë ¤ í•¨
    if (target.currentRecallTime > 7.0) {
        score += 1500;
    }

    // 5. ê±°ë¦¬ í˜ë„í‹° (ë„ˆë¬´ ë©€ë©´ í¬ê¸°)
    const dist = AIUtils.dist(attacker, target);
    if (dist > 15) {
        score -= (dist * 20); // ë©€ë©´ ì ìˆ˜ ê¹ì„
    }

    // 6. ë‡Œì§€ì»¬ ë³´ì • (ë˜‘ë˜‘í•œ AIëŠ” ê·€í™˜ì„ ë” ì˜ ëŠìŒ)
    if (attacker.stats.brain > 60) {
        score *= 1.2;
    }

    return Math.max(0, score);
  }
}



==========================================
FILE PATH: src/engine/match/ai/evaluators/TargetEvaluator.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/evaluators/TargetEvaluator.ts
// ==========================================
import { LivePlayer, Hero, Minion, LiveMatch } from '../../../../types';
import { AIUtils } from '../AIUtils';
import { Perception } from '../Perception';
import { RecallInterrupter } from './RecallInterrupter';
import { PsychologyEvaluator } from './PsychologyEvaluator';
// [ìˆ˜ì •] ê²½ë¡œ ìˆ˜ì •: ../ai/memory -> ../memory (ì´ë¯¸ ai í´ë” ë‚´ë¶€ì— ìˆìœ¼ë¯€ë¡œ)
import { PersonalMemory } from '../memory/PersonalMemory';

export class TargetEvaluator {
  static selectBestTarget(
    attacker: LivePlayer, 
    attackerHero: Hero, 
    enemiesInRange: LivePlayer[], 
    heroes: Hero[],
    match?: LiveMatch
  ): LivePlayer | null {
    if (enemiesInRange.length === 0) return null;

    const brain = attacker.stats.brain; 
    let bestTarget: LivePlayer | null = null;
    let maxScore = -99999;
    
    // [ì‹¬ë¦¬ ìƒíƒœ ë°˜ì˜]
    const morale = match ? PsychologyEvaluator.getMorale(attacker, match) : 1.0;
    const aggressionThreshold = morale < 0.8 ? 100 : -5000; 

    const myRange = (attackerHero.stats.range / 100);

    for (const enemy of enemiesInRange) {
      const enemyHero = heroes.find(h => h.id === enemy.heroId);
      if (!enemyHero) continue;

      let score = 0;

      // 1. ê¸°ë³¸ ì ìˆ˜ (ì²´ë ¥, í‚¬ê°)
      const dmg = attackerHero.stats.ad * 2 + attackerHero.stats.ap * 1.5;
      if (enemy.currentHp < dmg) score += 5000; 
      else score += (1 - AIUtils.hpPercent(enemy)) * 200;

      // ê±°ë¦¬ í˜ë„í‹°
      const dist = AIUtils.dist(attacker, enemy);
      score -= dist * 5;

      // ---------------------------------------------------------
      // [ì‹ ê·œ] ì²œì  ê´€ê³„ ë°˜ì˜ (íŠ¸ë¼ìš°ë§ˆ)
      // ---------------------------------------------------------
      const threatScore = PersonalMemory.getThreatLevel(attacker, enemy.heroId);
      if (threatScore > 0) {
          if (brain > 40) {
              score -= threatScore; 
          }
      }

      // ---------------------------------------------------------
      // [ì‹ ê·œ] ë©˜íƒˆ(Morale) ë°˜ì˜
      // ---------------------------------------------------------
      score *= morale;

      // ê·€í™˜ ë°©í•´ ì ìˆ˜
      const interruptScore = RecallInterrupter.getInterruptionScore(attacker, enemy);
      score += interruptScore;

      // 2. íƒ€ì›Œ ìƒí™© íŒë‹¨ (Smart Tower Check)
      if (match) {
          const isBlue = match.blueTeam.includes(attacker);
          const enemyPos = {x: enemy.x, y: enemy.y};
          
          if (Perception.isInActiveEnemyTowerRange(enemyPos, match, isBlue)) {
              const hasMinion = Perception.isSafeToSiege(attacker, match, enemyPos);
              const canPoke = myRange > 5.0;

              if (!hasMinion && !canPoke) {
                  let penalty = 2000;
                  
                  if (morale > 1.5 && brain < 30) penalty = 0; 
                  
                  if (AIUtils.hpPercent(enemy) < 0.15) penalty -= 1000;
                  if (interruptScore > 1000) penalty -= 500;

                  score -= penalty;
              } else if (!hasMinion && canPoke) {
                   score -= 100;
              }
          }
      }

      if (score > aggressionThreshold && score > maxScore) {
        maxScore = score;
        bestTarget = enemy;
      }
    }
    return bestTarget;
  }

  static selectFarmTarget(
    attacker: LivePlayer,
    minionsInRange: Minion[],
    killThreshold: number 
  ): Minion | null {
    if (minionsInRange.length === 0) return null;
    const killable = minionsInRange.filter(m => m.hp <= killThreshold);
    if (killable.length > 0) return killable.sort((a,b)=>a.hp-b.hp)[0];
    if (attacker.level < 6 && attacker.lane !== 'JUNGLE') return null;
    return minionsInRange[0];
  }
}



==========================================
FILE PATH: src/engine/match/ai/MacroBrain.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/MacroBrain.ts
// ==========================================
import { LivePlayer, LiveMatch, Hero } from '../../../types';
import { Perception } from './Perception';
import { AIUtils } from './AIUtils';
import { PathSystem } from '../systems/PathSystem';
import { GankEvaluator } from './evaluators/GankEvaluator';
import { KillEvaluator } from './evaluators/KillEvaluator';
import { EconomyEvaluator } from './evaluators/EconomyEvaluator';
import { BASES } from '../constants/MapConstants';
import { LaningLogic } from '../logics/LaningLogic';
import { RoamingLogic } from '../logics/RoamingLogic';
import { SquadSystem } from './tactics/SquadSystem';
import { TacticalScorer } from './tactics/TacticalScorer';
import { TeamTactics } from './tactics/TeamTactics';
import { ObservationSystem } from './perception/ObservationSystem'; // [ì‹ ê·œ]
import { useGameStore } from '../../../store/useGameStore';

export type MacroAction = 'RECALL' | 'DEFEND' | 'FIGHT' | 'FARM' | 'PUSH' | 'WAIT' | 'OBJECTIVE' | 'SUPPORT' | 'GANK' | 'FLEE' | 'FINISH' | 'ASSEMBLE' | 'LANING' | 'CHASE';

export interface MacroDecision {
  action: MacroAction;
  targetPos: { x: number, y: number };
  targetUnit?: LivePlayer;
  reason: string;
}

export class MacroBrain {
  static decide(player: LivePlayer, match: LiveMatch, hero: Hero): MacroDecision {
    const isBlue = match.blueTeam.includes(player);
    const myBase = AIUtils.getMyBasePos(isBlue);
    const distToBase = AIUtils.dist(player, myBase);

    // [0] ìš°ë¬¼ ë³µê·€ ì™„ë£Œ
    if (distToBase < 5) {
      const hpP = AIUtils.hpPercent(player);
      const mpP = AIUtils.mpPercent(player);
      if (hpP < 0.95 || (player.maxMp > 0 && mpP < 0.95)) {
        return { action: 'RECALL', targetPos: myBase, reason: 'ìš°ë¬¼ íšŒë³µ ì¤‘' };
      }
    }

    // [1] ìƒì¡´ íŒë‹¨
    if (Perception.needsRecall(player)) {
        if (distToBase < 25) return { action: 'FLEE', targetPos: myBase, reason: 'ìš°ë¬¼ ì´ë™' };
        if (Perception.analyzeNearbySituation(player, match, 15).enemies.length > 0) return { action: 'FLEE', targetPos: myBase, reason: 'êµì „ ì´íƒˆ' };
        return { action: 'RECALL', targetPos: myBase, reason: 'ê¸´ê¸‰ ì •ë¹„' };
    }
    
    if (Perception.isUnderTowerAggro(player, match)) {
        const situation = Perception.analyzeSituation(player, match);
        const isTank = player.maxHp > 3500 && AIUtils.hpPercent(player) > 0.6;
        if (!situation.isEnemyWipedOut && !isTank) {
            return { action: 'FLEE', targetPos: myBase, reason: 'ğŸš¨ íƒ€ì›Œ ì–´ê·¸ë¡œ!' };
        }
    }

    // [2] íŒ€ ì˜¤ë”
    const teamOrder = TeamTactics.analyzeTeamStrategy(match, isBlue);
    if (teamOrder.type !== 'FREE') {
        const targetPos = teamOrder.targetPos || myBase;
        if (teamOrder.type === 'ALL_PUSH') return { action: 'FINISH', targetPos, reason: teamOrder.reason };
        if (teamOrder.type === 'SIEGE_MID') {
            const nearby = Perception.analyzeNearbySituation(player, match, 15);
            if (nearby.enemies.length > 0) {
                const pushScore = TacticalScorer.getPushScore(player, match, targetPos);
                if (pushScore > 200) return { action: 'PUSH', targetPos, reason: 'ğŸ”¥ ì  ë¬´ì‹œ! íƒ€ì›Œ ì ì‚¬!' };
                const target = nearby.enemies[0];
                return { action: 'FIGHT', targetPos: {x:target.x, y:target.y}, targetUnit: target, reason: 'âš”ï¸ ê³µì„± ì¤‘ êµì „' };
            }
            return { action: 'PUSH', targetPos, reason: teamOrder.reason };
        }
        if (teamOrder.type === 'ALL_DEFEND') return { action: 'DEFEND', targetPos, reason: teamOrder.reason };
    }

    // [3] êµì „ & í‚¬ê° & [ì‹ ê·œ] ì¶”ê²©(Chase)
    const nearby = Perception.analyzeNearbySituation(player, match, 25);
    if (nearby.enemies.length > 0) {
        if (SquadSystem.shouldInitiateFight(player, match)) {
            const target = nearby.enemies[0];
            return { action: 'FIGHT', targetPos: {x:target.x, y:target.y}, targetUnit: target, reason: 'âš”ï¸ í•œíƒ€ ê°œì‹œ!' };
        }
        for (const enemy of nearby.enemies) {
            const { battleSettings, roleSettings } = useGameStore.getState().gameState;
            const globalHeroes = useGameStore.getState().heroes;
            const killScore = KillEvaluator.evaluateKillChance(player, enemy, globalHeroes, match, battleSettings, roleSettings);
            if (killScore > 500) {
                // ê³µê²©í•œ ì  ê¸°ì–µ (ì¶”ê²©ìš©)
                player.lastAttackedTargetId = enemy.heroId;
                player.lastAttackTime = match.currentDuration;
                return { action: 'FIGHT', targetPos: {x:enemy.x, y:enemy.y}, targetUnit: enemy, reason: 'ğŸ©¸ í‚¬ê°!' };
            }
        }
    }
    
    // [ì‹ ê·œ] ì‹œì•¼ì—” ì—†ì§€ë§Œ, ë°©ê¸ˆ ë†“ì¹œ ì  ì¶”ê²© (Bush Checking)
    if (player.lastAttackedTargetId) {
        const lastPos = ObservationSystem.getLastKnownPosition(player, player.lastAttackedTargetId, match.currentDuration);
        if (lastPos) {
            // ë‚´ê°€ ê·¸ ìœ„ì¹˜ì— ë„ì°©í–ˆìœ¼ë©´ ì¶”ê²© ì¢…ë£Œ
            if (AIUtils.dist(player, lastPos) < 2.0) {
                player.lastAttackedTargetId = undefined;
            } else {
                return { action: 'CHASE', targetPos: lastPos, reason: 'ğŸƒ ë„ë§ì¹œ ì  ì¶”ê²©' };
            }
        }
    }

    // [4] ê²½ì œì  ê·€í™˜
    if (EconomyEvaluator.shouldRecallForShopping(player, match)) {
        return { action: 'RECALL', targetPos: myBase, reason: 'ğŸ’° ì•„ì´í…œ êµ¬ë§¤' };
    }

    // [5] ë¼ì¸ì „/ë¡œë°
    if (player.lane !== 'JUNGLE' && match.currentDuration < 900) {
        const laningDecision = LaningLogic.decide(player, match, hero);
        if (laningDecision && !Perception.isSuicideMove(player, laningDecision.targetPos, match)) return laningDecision;
        
        const roamDecision = RoamingLogic.checkRoaming(player, match, hero);
        if (roamDecision) return roamDecision;
    }

    // [6] ê¸°ë³¸ ìš´ì˜
    if (player.lane !== 'JUNGLE') {
        const towerPos = AIUtils.getNextObjectivePos(player, match, isBlue);
        if (Perception.isSafeToSiege(player, match, towerPos)) {
            return { action: 'PUSH', targetPos: towerPos, reason: 'ê³µì„±' };
        } else {
            const safeWaitPos = { x: towerPos.x + (isBlue ? -10 : 10), y: towerPos.y + (isBlue ? -10 : 10) };
            return { action: 'WAIT', targetPos: safeWaitPos, reason: 'ëŒ€ê¸°' };
        }
    }

    const nextPath = PathSystem.getNextWaypoint(player, isBlue, match);
    return { action: 'FARM', targetPos: nextPath, reason: 'ì •ê¸€ë§' };
  }
}



==========================================
FILE PATH: src/engine/match/ai/mechanics/ComboPatterns.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/mechanics/ComboPatterns.ts
// ==========================================
import { Role } from '../../../../types';

export type SkillKey = 'q' | 'w' | 'e' | 'r';
export type ComboSequence = SkillKey[];

/**
 * ì—­í• êµ°ë³„ ê¸°ë³¸ ì½¤ë³´ íŒ¨í„´ ì •ì˜
 * (ë‚˜ì¤‘ì— ì˜ì›…ë³„ ê³ ìœ  ì½¤ë³´ë¡œ í™•ì¥ ê°€ëŠ¥)
 */
export const ROLE_COMBOS: Record<Role, ComboSequence[]> = {
  'ì¶”ì ì': [ // ì•”ì‚´ì: ì§„ì… -> CC/ë”œ -> í­ë”œ -> ë§ˆë¬´ë¦¬
    ['e', 'w', 'q', 'r'], 
    ['e', 'q', 'w'],
    ['w', 'q']
  ],
  'ì„ ì§€ì': [ // ë§ˆë²•ì‚¬: CCê±¸ê³  -> í­ë”œ -> ê¶
    ['e', 'q', 'r'],
    ['w', 'q'],
    ['q', 'r']
  ],
  'ì§‘í–‰ê´€': [ // ë¸Œë£¨ì €: ì§„ì… -> í‰ìº”(Q) -> ë²„í‹°ê¸°(W)
    ['e', 'q', 'w'],
    ['q', 'w']
  ],
  'ìˆ˜í˜¸ê¸°ì‚¬': [ // íƒ±ì»¤: ì§„ì… -> CC -> ë²„í‹°ê¸°
    ['e', 'w', 'q'],
    ['r', 'w']
  ],
  'ì‹ ì‚´ì': [ // ì›ë”œ: ìƒì¡´ê¸°/ë²„í”„ ì•„ë¼ê³  ë”œë§ê¸° ìœ„ì£¼
    ['q', 'w'],
    ['r']
  ]
};



==========================================
FILE PATH: src/engine/match/ai/mechanics/ComboSystem.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/mechanics/ComboSystem.ts
// ==========================================
import { LivePlayer, Hero } from '../../../../types';
import { ROLE_COMBOS, ComboSequence, SkillKey } from './ComboPatterns';
import { AIUtils } from '../AIUtils';

// í”Œë ˆì´ì–´ë³„ í˜„ì¬ ì½¤ë³´ ìƒíƒœë¥¼ ì €ì¥ (íƒ€ì… ìˆ˜ì • ì—†ì´ í™•ì¥)
interface ComboState {
  sequence: ComboSequence;
  currentIndex: number;
  targetId: string;
  startTime: number;
}

// ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€ë¥¼ ìœ„í•´ WeakMap ì‚¬ìš© (í”Œë ˆì´ì–´ ê°ì²´ê°€ ì‚¬ë¼ì§€ë©´ ìƒíƒœë„ ì‚¬ë¼ì§)
const comboMemory = new WeakMap<LivePlayer, ComboState>();

export class ComboSystem {

  /**
   * í˜„ì¬ ìƒí™©ì— ë§ëŠ” ìµœì ì˜ ìŠ¤í‚¬(ì½¤ë³´)ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
   */
  static getNextSkill(
    player: LivePlayer, 
    target: LivePlayer, 
    hero: Hero, 
    dist: number,
    currentTime: number
  ): string | null {
    
    // 1. í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ì½¤ë³´ê°€ ìˆëŠ”ì§€ í™•ì¸
    let state = comboMemory.get(player);

    // ì½¤ë³´ ìœ íš¨ì„± ê²€ì‚¬ (íƒ€ê²Ÿì´ ë°”ë€Œì—ˆê±°ë‚˜, ì‹œê°„ì´ ë„ˆë¬´ ì§€ë‚¬ìœ¼ë©´ ë¦¬ì…‹)
    if (state) {
      if (state.targetId !== target.heroId || (currentTime - state.startTime > 5)) {
        comboMemory.delete(player);
        state = undefined;
      }
    }

    // 2. ì½¤ë³´ê°€ ì—†ë‹¤ë©´ ìƒˆë¡œ ì‹œì‘
    if (!state) {
      const bestCombo = this.selectBestCombo(player, target, hero, dist);
      if (bestCombo) {
        state = {
          sequence: bestCombo,
          currentIndex: 0,
          targetId: target.heroId,
          startTime: currentTime
        };
        comboMemory.set(player, state);
      }
    }

    // 3. ì½¤ë³´ ì§„í–‰
    if (state) {
      // í˜„ì¬ ë‹¨ê³„ì˜ ìŠ¤í‚¬ì„ ì“¸ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
      const skillKey = state.sequence[state.currentIndex];
      
      if (this.canUseSkill(player, hero, skillKey, dist)) {
        // [ë‡Œì§€ì»¬ ë°˜ì˜] ë‡Œì§€ì»¬ì´ ë†’ìœ¼ë©´ ìŠ¤í‚¬ ì‚¬ì´ ë”œë ˆì´(í‰ìº”)ë¥¼ ì¤„ì„
        // ì—¬ê¸°ì„œëŠ” ì¦‰ì‹œ ë°˜í™˜í•˜ì—¬ ì‹¤í–‰
        
        // ë‹¤ìŒ ë‹¨ê³„ë¡œ ì¸ë±ìŠ¤ ì¦ê°€ (ì‹¤í–‰ì€ MicroBrainì´ í•¨)
        state.currentIndex++;
        if (state.currentIndex >= state.sequence.length) {
          comboMemory.delete(player); // ì½¤ë³´ ë
        }
        return skillKey;
      } 
      else {
        // ìŠ¤í‚¬ ì¿¨íƒ€ì„ì´ê±°ë‚˜ ë§ˆë‚˜ ë¶€ì¡± ë“±ìœ¼ë¡œ ëª» ì“°ë©´?
        // ë‡Œì§€ì»¬ì´ ë†’ìœ¼ë©´: ê¸°ë‹¤ë¦¼ (ì½¤ë³´ ìœ ì§€)
        // ë‡Œì§€ì»¬ì´ ë‚®ìœ¼ë©´: ì½¤ë³´ ê¹¨ê³  ì•„ë¬´ê±°ë‚˜ ì”€
        if (player.stats.brain < 50) {
            comboMemory.delete(player);
        }
        // ëª» ì“°ë©´ null ë°˜í™˜ (í‰íƒ€ ì¹˜ê±°ë‚˜ ë¬´ë¹™í•˜ê²Œ ë¨)
        return null;
      }
    }

    return null;
  }

  private static selectBestCombo(player: LivePlayer, target: LivePlayer, hero: Hero, dist: number): ComboSequence | null {
    const combos = ROLE_COMBOS[hero.role];
    if (!combos || combos.length === 0) return null;

    // í‚¬ê°ì´ë©´ ê¶ê·¹ê¸° í¬í•¨ëœ ì½¤ë³´ ì„ í˜¸
    const targetHp = AIUtils.hpPercent(target);
    const useUltCombo = targetHp < 0.5 && this.canUseSkill(player, hero, 'r', dist);

    for (const combo of combos) {
      // 1. ê¶ê·¹ê¸° ì¡°ê±´ ì²´í¬
      if (combo.includes('r') && !useUltCombo) continue;

      // 2. ì²« ìŠ¤í‚¬ì´ ì‚¬ìš© ê°€ëŠ¥í•œì§€ ì²´í¬ (ì§„ì… ê°€ëŠ¥ ì—¬ë¶€)
      if (this.canUseSkill(player, hero, combo[0], dist)) {
        return combo;
      }
    }
    
    return null;
  }

  private static canUseSkill(player: LivePlayer, hero: Hero, key: SkillKey, dist: number): boolean {
    const skill = hero.skills[key];
    const cooldown = (player.cooldowns as any)[key];
    const cost = skill.cost || 0;
    
    // ì¿¨íƒ€ì„ & ë§ˆë‚˜ ì²´í¬
    if (cooldown > 0 || player.currentMp < cost) return false;

    // ì‚¬ê±°ë¦¬ ì²´í¬ (íƒ€ê²ŸíŒ… ìŠ¤í‚¬ì¸ ê²½ìš°ë§Œ)
    // ì¼ë¶€ ìŠ¤í‚¬(ë²„í”„/ì´ë™ê¸°)ì€ ì‚¬ê±°ë¦¬ ë¬´ê´€í•˜ê²Œ ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤ê³  ê°€ì •í•  ìˆ˜ë„ ìˆìœ¼ë‚˜, 
    // ì—¬ê¸°ì„œëŠ” ê°„ë‹¨í•˜ê²Œ ëª¨ë“  ìŠ¤í‚¬ì— ì‚¬ê±°ë¦¬ ì²´í¬ (ë‹¨, 0ì´ë©´ ìê°€ë²„í”„ë¡œ ê°„ì£¼)
    if (skill.range > 0 && dist > (skill.range / 100) + 1.0) return false;

    return true;
  }
}



==========================================
FILE PATH: src/engine/match/ai/mechanics/ItemOptimizer.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/mechanics/ItemOptimizer.ts
// ==========================================
import { LivePlayer, Hero, Role } from '../../../../types';

interface StatWeights {
  ad: number; ap: number; hp: number; armor: number; 
  crit: number; speed: number; pen: number; regen: number; mp: number; mpRegen: number;
}

// ê¸°ë³¸ ì—­í• êµ°ë³„ ê°€ì¤‘ì¹˜
const BASE_WEIGHTS: Record<Role, StatWeights> = {
  'ì§‘í–‰ê´€': { ad: 1.2, hp: 0.8, armor: 0.8, regen: 0.5, pen: 1.0, speed: 0.5, crit: 0.5, ap: 0, mp: 0.2, mpRegen: 0.2 },
  'ì¶”ì ì': { ad: 1.5, speed: 1.5, pen: 1.2, crit: 1.0, hp: 0.2, armor: 0.2, regen: 0.2, ap: 0, mp: 0.2, mpRegen: 0.2 },
  'ì„ ì§€ì': { ap: 1.5, mp: 1.2, mpRegen: 1.2, pen: 0.8, hp: 0.3, speed: 0.5, armor: 0.2, regen: 0.1, ad: 0, crit: 0 },
  'ì‹ ì‚´ì': { ad: 1.5, crit: 1.5, speed: 1.0, pen: 1.2, hp: 0.1, armor: 0.1, regen: 0.2, ap: 0, mp: 0.2, mpRegen: 0.2 },
  'ìˆ˜í˜¸ê¸°ì‚¬': { hp: 1.5, armor: 1.5, regen: 1.5, mp: 0.5, speed: 0.3, ad: 0.2, ap: 0.2, pen: 0, crit: 0, mpRegen: 0.3 },
};

export class ItemOptimizer {
  
  /**
   * ì  íŒ€ì˜ ì„±ì¥ ìƒíƒœë¥¼ ë¶„ì„í•˜ì—¬ í˜„ì¬ í”Œë ˆì´ì–´ì—ê²Œ ìµœì í™”ëœ ì•„ì´í…œ ê°€ì¤‘ì¹˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
   */
  static getDynamicWeights(
    player: LivePlayer, 
    hero: Hero, 
    enemies: LivePlayer[], 
    heroes: Hero[]
  ): StatWeights {
    // 1. ê¸°ë³¸ ê°€ì¤‘ì¹˜ ë³µì‚¬
    const weights = { ...BASE_WEIGHTS[hero.role] };
    const brain = player.stats.brain;

    // ë‡Œì§€ì»¬ì´ ë‚®ìœ¼ë©´(50 ë¯¸ë§Œ) ê·¸ëƒ¥ ì¶”ì²œ í…œíŠ¸ë¦¬(ê¸°ë³¸ ê°€ì¤‘ì¹˜)ëŒ€ë¡œ ê°
    if (brain < 50) return weights;

    // 2. ì  ìœ„í˜‘ ë¶„ì„ (ê°€ì¥ ì˜ í° ì  3ëª… ê¸°ì¤€)
    const topThreats = [...enemies]
      .sort((a, b) => b.gold - a.gold)
      .slice(0, 3);

    let threatAD = 0;
    let threatAP = 0;
    let threatTank = 0;

    for (const enemy of topThreats) {
      const eHero = heroes.find(h => h.id === enemy.heroId);
      if (!eHero) continue;

      // ì•„ì´í…œ ìŠ¤íƒ¯ í•©ì‚°
      const itemAD = enemy.items.reduce((s, i) => s + (i.ad || 0), 0);
      const itemAP = enemy.items.reduce((s, i) => s + (i.ap || 0), 0);
      const itemArmor = enemy.items.reduce((s, i) => s + (i.armor || 0), 0);
      const itemHP = enemy.items.reduce((s, i) => s + (i.hp || 0), 0);

      const totalAD = eHero.stats.ad + itemAD;
      const totalAP = eHero.stats.ap + itemAP;
      const totalTankiness = itemArmor + (itemHP / 10);

      threatAD += totalAD;
      threatAP += totalAP;
      threatTank += totalTankiness;
    }

    // 3. ê°€ì¤‘ì¹˜ ë™ì  ì¡°ì • (Counter Building)

    // A. ì ì´ ë„ˆë¬´ ì•„í”” (ë°©ì–´ ì•„ì´í…œ ê°€ì¤‘ì¹˜ ì¦ê°€)
    if (threatAD > threatAP * 1.5) {
        // ì ì´ ì˜¬AD -> ë°©ì–´ë ¥(Armor) ì¤‘ìš”ë„ ê¸‰ìƒìŠ¹
        weights.armor = (weights.armor || 0.1) * 2.5;
        // ë”œëŸ¬ë¼ë„ ìµœì†Œí•œì˜ ë°©ì–´ë ¥ ì±™ê¸°ê²Œ ìœ ë„
        if (weights.armor < 0.5) weights.armor = 0.5;
    } 
    else if (threatAP > threatAD * 1.5) {
        // ì ì´ ì˜¬AP -> ì²´ë ¥(HP) ë° ì¬ìƒ ì¤‘ìš”ë„ ìƒìŠ¹ (ë§ˆì €í…œì´ ë”°ë¡œ ì—†ìœ¼ë¯€ë¡œ ì²´ë ¥ìœ¼ë¡œ ë²„íŒ€)
        weights.hp = (weights.hp || 0.1) * 2.0;
        weights.regen = (weights.regen || 0.1) * 2.0;
        // ë°©ì–´ë ¥ íš¨ìœ¨ ê°ì†Œ (AP ìƒëŒ€ë¡œëŠ” ì“¸ëª¨ ì—†ìŒ)
        weights.armor *= 0.5;
    }

    // B. ì ì´ ë„ˆë¬´ ë‹¨ë‹¨í•¨ (ê´€í†µë ¥ ê°€ì¤‘ì¹˜ ì¦ê°€)
    if (threatTank > 300) { // ì ë“¤ì´ íƒ±í…œì„ ë‘ë¦„
        weights.pen = (weights.pen || 0.1) * 2.5; // ê´€í†µë ¥ í•„ìˆ˜
        // íƒ±ì»¤ ìƒëŒ€ë¡œëŠ” ì¹˜ëª…íƒ€ë‚˜ ê¹¡ë€ë³´ë‹¤ëŠ” ê´€í†µì´ íš¨ìœ¨ì 
    }

    // C. ë‚´ê°€ ë„ˆë¬´ ë§ì´ ì£½ìŒ (ìƒì¡´í…œ ìš°ì„ )
    const kdaRatio = player.deaths === 0 ? player.kills : player.kills / player.deaths;
    if (player.deaths >= 4 && kdaRatio < 0.5) {
        weights.hp *= 1.5;
        weights.armor *= 1.2;
    }

    return weights;
  }
}



==========================================
FILE PATH: src/engine/match/ai/mechanics/TeamCoordination.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/mechanics/TeamCoordination.ts
// ==========================================
import { LivePlayer, Hero } from '../../../../types';
import { StatusManager } from '../../systems/StatusManager';

export class TeamCoordination {
  
  /**
   * [CC ì—°ê³„ íŒë‹¨]
   * íƒ€ê²Ÿì´ ì´ë¯¸ ê¸°ì ˆ ìƒíƒœë¼ë©´, ìŠ¤í‚¬ ì‚¬ìš©ì„ ì ì‹œ ë³´ë¥˜(Hold)í•´ì•¼ í•˜ëŠ”ì§€ íŒë‹¨í•©ë‹ˆë‹¤.
   * @param target íƒ€ê²Ÿ í”Œë ˆì´ì–´
   * @param skillMechanic ì‚¬ìš©í•  ìŠ¤í‚¬ì˜ ë©”ì»¤ë‹ˆì¦˜
   */
  static shouldHoldCC(target: LivePlayer, skillMechanic: string): boolean {
    // CCê¸°ê°€ ì•„ë‹ˆë©´ ì—°ê³„í•  í•„ìš” ì—†ìŒ
    if (skillMechanic !== 'STUN' && skillMechanic !== 'HOOK') return false;

    // íƒ€ê²Ÿì´ ê¸°ì ˆ ì¤‘ì¸ì§€ í™•ì¸
    if (StatusManager.isStunned(target)) {
        const remainingTime = StatusManager.getRemainingStunTime(target);
        
        // ê¸°ì ˆ ì‹œê°„ì´ 0.5ì´ˆ ì´ìƒ ë‚¨ì•˜ìœ¼ë©´ ìŠ¤í‚¬ ì•„ë‚Œ (ì¤‘ì²© ë°©ì§€)
        // 0.5ì´ˆ ë¯¸ë§Œì´ë©´ ë®ì–´ì”Œì›Œì„œ ì—°ê³„(Chain) ì‹œì „
        if (remainingTime > 0.5) {
            return true; // Hold
        }
    }
    return false; // Use now
  }
}



==========================================
FILE PATH: src/engine/match/ai/memory/PersonalMemory.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/memory/PersonalMemory.ts
// ==========================================
import { LivePlayer } from '../../../../types';

// í”Œë ˆì´ì–´ë³„ ê¸°ì–µ ì €ì¥ì†Œ (íƒ€ì… í™•ì¥ ì—†ì´ WeakMap í™œìš©)
// Key: Player ê°ì²´ -> Value: { [enemyHeroId]: { deathsFrom: number, killsOn: number } }
interface MemoryData {
  interactions: Record<string, { deathsFrom: number; killsOn: number }>;
}

const memoryStore = new WeakMap<LivePlayer, MemoryData>();

export class PersonalMemory {
  
  /**
   * í‚¬ ë°œìƒ ì‹œ ê¸°ì–µ ì—…ë°ì´íŠ¸
   */
  static recordEvent(killer: LivePlayer, victim: LivePlayer) {
    // 1. í”¼í•´ì ì…ì¥: "ì–˜ê°€ ë‚  ì£½ì˜€ì–´" (ê³µí¬ +1)
    this.updateMemory(victim, killer.heroId, 'deathsFrom');
    
    // 2. ê°€í•´ì ì…ì¥: "ì–˜ëŠ” ë‚´ ë°¥ì´ì•¼" (ìì‹ ê° +1)
    this.updateMemory(killer, victim.heroId, 'killsOn');
  }

  /**
   * íŠ¹ì • ì ì— ëŒ€í•œ íŠ¸ë¼ìš°ë§ˆ(ê³µí¬) ì ìˆ˜ ë°˜í™˜
   * (ì ìˆ˜ê°€ ë†’ì„ìˆ˜ë¡ ë¬´ì„œìš´ ì )
   */
  static getThreatLevel(me: LivePlayer, enemyId: string): number {
    const mem = memoryStore.get(me);
    if (!mem || !mem.interactions[enemyId]) return 0;

    const data = mem.interactions[enemyId];
    // ë§ì´ ì£½ì—ˆì„ìˆ˜ë¡ ë¬´ì„­ê³ , ë‚´ê°€ ì£½ì¸ ì  ìˆìœ¼ë©´ ëœ ë¬´ì„œì›€
    return (data.deathsFrom * 200) - (data.killsOn * 100);
  }

  private static updateMemory(player: LivePlayer, targetId: string, field: 'deathsFrom' | 'killsOn') {
    let mem = memoryStore.get(player);
    if (!mem) {
      mem = { interactions: {} };
      memoryStore.set(player, mem);
    }

    if (!mem.interactions[targetId]) {
      mem.interactions[targetId] = { deathsFrom: 0, killsOn: 0 };
    }

    mem.interactions[targetId][field]++;
  }
}



==========================================
FILE PATH: src/engine/match/ai/MicroBrain.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/MicroBrain.ts
// ==========================================
import { LivePlayer, Hero, LiveMatch } from '../../../types';
import { EvasionSystem } from './tactics/EvasionSystem';
import { TacticalComputer } from './tactics/TacticalComputer';
import { AIUtils } from './AIUtils';
import { useGameStore } from '../../../store/useGameStore';
import { ComboSystem } from './mechanics/ComboSystem';
import { SkillBrain } from './tactics/SkillBrain';
import { ObservationSystem } from './perception/ObservationSystem'; 
import { TeamCoordination } from './mechanics/TeamCoordination'; // [ì‹ ê·œ]

export interface MicroDecision {
  type: 'ATTACK' | 'MOVE';
  targetPos: { x: number, y: number };
  skillKey?: string; 
}

export class MicroBrain {
  static control(
    player: LivePlayer, 
    target: LivePlayer, 
    hero: Hero, 
    isBlue: boolean
  ): MicroDecision {
    
    let match: LiveMatch | undefined;
    try { 
        match = useGameStore.getState().gameState.liveMatches.find(m => 
            m.blueTeam.includes(player) || m.redTeam.includes(player)
        );
    } catch(e){}

    if (!match) return { type: 'MOVE', targetPos: {x: target.x, y: target.y} };

    ObservationSystem.updateObservations(player, match);

    // 1. íˆ¬ì‚¬ì²´ íšŒí”¼
    const dodgePos = EvasionSystem.getDodgeVector(player, match);
    if (dodgePos) return { type: 'MOVE', targetPos: dodgePos };

    // 2. ì½¤ë³´ ë° ìŠ¤í‚¬ ì‚¬ìš©
    const dist = AIUtils.dist(player, target);
    let bestSkill: string | null = null;

    bestSkill = ComboSystem.getNextSkill(player, target, hero, dist, match.currentDuration);

    if (!bestSkill) {
        bestSkill = SkillBrain.getBestSkill(player, target, hero, dist);
    }

    if (bestSkill) {
        // [í•µì‹¬] CC ì—°ê³„ íŒë‹¨ (TeamCoordination)
        // ì•„êµ°ì´ ê¸°ì ˆì„ ê±¸ì–´ë†¨ìœ¼ë©´ ë‚´ CCê¸°ëŠ” ì•„ë‚Œ (Hold)
        const skillInfo = hero.skills[bestSkill as 'q'|'w'|'e'|'r'];
        
        if (TeamCoordination.shouldHoldCC(target, skillInfo.mechanic)) {
            // ìŠ¤í‚¬ ì“°ëŠ” ëŒ€ì‹  í‰íƒ€ë‚˜ ë¬´ë¹™ (ê¸°ë‹¤ë¦¼)
            // ê·¸ëƒ¥ ê³µê²© ì‚¬ê±°ë¦¬ ì•ˆì´ë©´ í‰íƒ€, ì•„ë‹ˆë©´ ì ‘ê·¼
            const range = (hero.stats.range / 100);
            if (dist <= range + 1.0) {
                return { type: 'ATTACK', targetPos: { x: target.x, y: target.y } };
            }
            return { type: 'MOVE', targetPos: { x: target.x, y: target.y } };
        }

        // ì˜ˆì¸¡ ì‚¬ê²©
        const aimPos = ObservationSystem.getPredictedPosition(player, target, 15.0);
        
        return { 
            type: 'ATTACK', 
            targetPos: aimPos, 
            skillKey: bestSkill 
        };
    }

    // 3. ìŠ¤ë§ˆíŠ¸ í¬ì§€ì…”ë‹ (ì¹´ì´íŒ…)
    const range = (hero.stats.range / 100);
    const optimalPos = TacticalComputer.getSiegePosition(player, target, match, range);

    const distToOptimal = AIUtils.dist(player, optimalPos);
    
    if (distToOptimal < 2.0 && dist <= range + 1.0) {
        return { type: 'ATTACK', targetPos: { x: target.x, y: target.y } };
    }

    return { type: 'MOVE', targetPos: optimalPos };
  }
}



==========================================
FILE PATH: src/engine/match/ai/pathing/JunglePathFinder.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/pathing/JunglePathFinder.ts
// ==========================================
import { LivePlayer, LiveMatch } from '../../../../types';
import { Vector2 } from '../../utils/Vector';
import { BASES } from '../../constants/MapConstants';
import { AIUtils } from '../AIUtils';

export class JunglePathFinder {
  
  static getNextCamp(player: LivePlayer, match: LiveMatch): Vector2 {
    const mobs = match.jungleMobs || [];
    const aliveMobs = mobs.filter(m => m.isAlive);

    // ëª¬ìŠ¤í„° ì—†ìœ¼ë©´ ë¯¸ë“œ ê°•ê°€ë¡œ ì´ë™í•´ì„œ ì‹¸ì›€ ìœ ë„
    if (aliveMobs.length === 0) {
        return { x: 50, y: 50 };
    }

    let bestTarget: Vector2 | null = null;
    let minScore = 99999;

    const isBlue = match.blueTeam.includes(player);

    for (const mob of aliveMobs) {
        let dist = AIUtils.dist(player, mob);
        
        // ë‚´ ì§„ì˜ ì •ê¸€ ìš°ì„ ìˆœìœ„ (ì•ˆì „ ì§€í–¥)
        const isMySide = isBlue ? (mob.x + mob.y < 100) : (mob.x + mob.y > 100);
        if (!isMySide && player.level < 4) dist += 50; 

        // ë²„í”„ ëª¹ ìš°ì„ 
        if (mob.type === 'GOLEM') dist -= 20;

        if (dist < minScore) {
            minScore = dist;
            bestTarget = { x: mob.x, y: mob.y };
        }
    }

    if (bestTarget) return bestTarget;
    return isBlue ? BASES.BLUE : BASES.RED;
  }
}



==========================================
FILE PATH: src/engine/match/ai/perception/ObservationSystem.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/perception/ObservationSystem.ts
// ==========================================
import { LivePlayer, LiveMatch } from '../../../../types';
import { Vector, Vector2 } from '../../../match/utils/Vector';
import { AIUtils } from '../AIUtils';

// ì ì˜ ë§ˆì§€ë§‰ ìœ„ì¹˜ì™€ ì‹œê°„, ì†ë„ ë²¡í„°ë¥¼ ì €ì¥
interface TraceData {
  lastPos: Vector2;
  velocity: Vector2;
  timestamp: number;
}

const traceMemory = new WeakMap<LivePlayer, Record<string, TraceData>>();

export class ObservationSystem {

  /**
   * ë§¤ í”„ë ˆì„ í˜¸ì¶œë˜ì–´ ì ë“¤ì˜ ì›€ì§ì„ì„ ì¶”ì í•˜ê³  ê¸°ì–µì„ ê°±ì‹ í•©ë‹ˆë‹¤.
   */
  static updateObservations(observer: LivePlayer, match: LiveMatch) {
    const isBlue = match.blueTeam.includes(observer);
    const enemies = isBlue ? match.redTeam : match.blueTeam;
    
    let memory = traceMemory.get(observer);
    if (!memory) {
        memory = {};
        traceMemory.set(observer, memory);
    }

    const now = match.currentDuration;

    enemies.forEach(enemy => {
        // ì‹œì•¼ ë‚´ì— ìˆëŠ” ì ë§Œ ì •ë³´ ê°±ì‹ 
        const dist = AIUtils.dist(observer, enemy);
        const isVisible = dist <= 15; // ê¸°ë³¸ ì‹œì•¼ 15

        if (isVisible && enemy.currentHp > 0) {
            // ì†ë„ ë²¡í„° ê³„ì‚° (ì´ì „ ìœ„ì¹˜ì™€ ë¹„êµ)
            const prevData = memory![enemy.heroId];
            let velocity = { x: 0, y: 0 };
            
            if (prevData) {
                // dtê°€ ì§§ì•„ì„œ ë…¸ì´ì¦ˆê°€ ì‹¬í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ê°„ë‹¨í•œ ì´ë™ í‰ê·  ëŠë‚Œìœ¼ë¡œ ì²˜ë¦¬
                // (í˜„ì¬ëŠ” 0.1ì´ˆ í‹±ì´ë¯€ë¡œ ë‹¨ìˆœ ì°¨ì´ê°’ ì‚¬ìš©)
                velocity = Vector.sub({ x: enemy.x, y: enemy.y }, prevData.lastPos);
            }

            memory![enemy.heroId] = {
                lastPos: { x: enemy.x, y: enemy.y },
                velocity: velocity,
                timestamp: now
            };
        }
    });
  }

  /**
   * [ì¶”ì ] ì‹œì•¼ì—ì„œ ì‚¬ë¼ì§„ ì ì˜ ë§ˆì§€ë§‰ ìœ„ì¹˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
   * (3ì´ˆ ì´ë‚´ì˜ ì •ë³´ë§Œ ìœ íš¨)
   */
  static getLastKnownPosition(observer: LivePlayer, targetId: string, currentTime: number): Vector2 | null {
    const memory = traceMemory.get(observer);
    if (!memory || !memory[targetId]) return null;

    const data = memory[targetId];
    // 3ì´ˆê°€ ì§€ë‚¬ìœ¼ë©´ ë†“ì¹œ ê²ƒìœ¼ë¡œ ê°„ì£¼
    if (currentTime - data.timestamp > 3.0) return null;

    return data.lastPos;
  }

  /**
   * [ì˜ˆì¸¡ ì‚¬ê²©] íƒ€ê²Ÿì˜ ì´ë™ ë°©í–¥ì„ ê³ ë ¤í•œ ë¯¸ë˜ ì¢Œí‘œë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
   */
  static getPredictedPosition(
    observer: LivePlayer, 
    target: LivePlayer, 
    projectileSpeed: number, // íˆ¬ì‚¬ì²´ ì†ë„ (ë³´í†µ 15~20)
    delay: number = 0.2 // ì‹œì „ ì‹œê°„
  ): Vector2 {
    const memory = traceMemory.get(observer);
    const data = memory ? memory[target.heroId] : null;

    // ë°ì´í„°ê°€ ì—†ê±°ë‚˜ ì†ë„ê°€ ê±°ì˜ ì—†ìœ¼ë©´ í˜„ì¬ ìœ„ì¹˜ ë°˜í™˜
    if (!data || Vector.mag(data.velocity) < 0.01) {
        return { x: target.x, y: target.y };
    }

    const dist = AIUtils.dist(observer, target);
    const travelTime = (dist / projectileSpeed) + delay;

    // [ë‡Œì§€ì»¬ ë³´ì •] 
    // ë‡Œì§€ì»¬ì´ ë†’ìœ¼ë©´(>70) ì˜ˆì¸¡ì„ ì •í™•íˆ í•˜ê³ , ë‚®ìœ¼ë©´(<30) ì—‰ëš±í•œ ê³³(ì§€ë‚˜ì¹œ ì˜ˆì¸¡)ì„ ì¨
    const brain = observer.stats.brain;
    let accuracy = 1.0;
    
    if (brain > 70) accuracy = 1.0; // ì™„ë²½ ì˜ˆì¸¡
    else if (brain < 40) accuracy = 0.5; // ë°˜ë§Œ ì˜ˆì¸¡ (ëœ ì¨)
    else accuracy = 0.8;

    // ë¯¸ë˜ ìœ„ì¹˜ = í˜„ì¬ ìœ„ì¹˜ + (ì†ë„ * ì‹œê°„ * ì •í™•ë„)
    // velocityëŠ” 0.1ì´ˆë‹¹ ì´ë™ëŸ‰ì´ë¯€ë¡œ, travelTime(ì´ˆ)ì„ 0.1ë¡œ ë‚˜ëˆ ì„œ ê³±í•´ì•¼ í•¨
    const frames = travelTime / 0.1;
    const predictionVector = Vector.mult(data.velocity, frames * accuracy);

    return Vector.add({ x: target.x, y: target.y }, predictionVector);
  }
}



==========================================
FILE PATH: src/engine/match/ai/Perception.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/Perception.ts
// ==========================================
import { LivePlayer, LiveMatch } from '../../../types';
import { AIUtils } from './AIUtils';
import { POI, getDistance } from '../../data/MapData';
import { TOWER_COORDS } from '../constants/MapConstants';

export interface ThreatInfo { isThreatened: boolean; enemyUnit: any; distance: number; }
export interface GameSituation { 
    myTeamAlive: number; 
    enemyTeamAlive: number; 
    isEnemyWipedOut: boolean; 
    hasNumberAdvantage: boolean;
    powerDifference: number; 
    combatPowerRatio: number;
    hasSiegeBuff: boolean; 
    isNexusVulnerable: boolean; 
}
export interface NearbyInfo { allies: LivePlayer[]; enemies: LivePlayer[]; allyPower: number; enemyPower: number; }

export class Perception {

  static calculateTeamPower(team: LivePlayer[]): number {
    return team.reduce((sum, p) => {
        if (!p || p.currentHp <= 0) return sum;
        let power = (p.level * 100) + ((p.gold || 0) / 10);
        power *= AIUtils.hpPercent(p);
        const cooldowns = p.cooldowns || { q:0, w:0, e:0, r:0 };
        if ((cooldowns as any).r <= 0) power *= 1.2;
        return sum + power;
    }, 0);
  }

  static analyzeNearbySituation(player: LivePlayer, match: LiveMatch, range: number = 25): NearbyInfo {
    const isBlue = match.blueTeam.includes(player);
    const myTeam = isBlue ? match.blueTeam : match.redTeam;
    const enemyTeam = isBlue ? match.redTeam : match.blueTeam;
    
    // [ìˆ˜ì •] Grid ì œê±°í•˜ê³  for ë£¨í”„ ë°©ì‹ìœ¼ë¡œ ì›ë³µ (ì •í™•ë„ 100% ë³´ì¥)
    const nearbyAllies: LivePlayer[] = [];
    const nearbyEnemies: LivePlayer[] = [];

    // ì•„êµ° íƒìƒ‰
    for (const p of myTeam) {
        if (p !== player && p.currentHp > 0) {
            if (AIUtils.dist(player, p) <= range) nearbyAllies.push(p);
        }
    }

    // ì êµ° íƒìƒ‰
    for (const p of enemyTeam) {
        if (p.currentHp > 0) {
            if (AIUtils.dist(player, p) <= range) nearbyEnemies.push(p);
        }
    }
    
    const allyPower = this.calculateTeamPower([player, ...nearbyAllies]);
    const enemyPower = this.calculateTeamPower(nearbyEnemies);

    return { allies: nearbyAllies, enemies: nearbyEnemies, allyPower, enemyPower };
  }

  static isUnderTowerAggro(player: LivePlayer, match: LiveMatch): boolean {
    const isBlue = match.blueTeam.includes(player);
    const enemyStats = isBlue ? match.stats.red : match.stats.blue;
    const towerCoords = isBlue ? TOWER_COORDS.RED : TOWER_COORDS.BLUE;
    const lanes = ['top', 'mid', 'bot'] as const;

    let nearbyTowerPos = null;

    if (enemyStats.nexusHp > 0 && AIUtils.dist(player, towerCoords.NEXUS) <= 13) {
        nearbyTowerPos = towerCoords.NEXUS;
    } 
    else {
        for (const lane of lanes) {
            const brokenCount = (enemyStats.towers as any)[lane];
            if (brokenCount < 3) {
                const tier = brokenCount + 1;
                // @ts-ignore
                const tPos = towerCoords[lane.toUpperCase()][tier - 1];
                if (tPos && AIUtils.dist(player, tPos) <= 13) {
                    nearbyTowerPos = tPos;
                    break;
                }
            }
        }
    }

    if (!nearbyTowerPos) return false;

    const myMinions = match.minions || [];
    const hasMeatShield = myMinions.some(m => 
        m.team === (isBlue ? 'BLUE' : 'RED') && 
        m.hp > 0 && 
        AIUtils.dist(m, nearbyTowerPos) < 13
    );

    if (!hasMeatShield) return true;

    const lastAttackAge = match.currentDuration - (player.lastAttackTime || 0);
    if (lastAttackAge < 2.0 && player.lastAttackedTargetId) {
        const enemies = isBlue ? match.redTeam : match.blueTeam;
        const targetIsHero = enemies.some(e => e.heroId === player.lastAttackedTargetId);
        if (targetIsHero) return true; 
    }

    return false;
  }
  
  static isInActiveEnemyTowerRange(pos: {x:number, y:number}, match: LiveMatch, isBlue: boolean): boolean {
    const enemyStats = isBlue ? match.stats.red : match.stats.blue;
    const towerCoords = isBlue ? TOWER_COORDS.RED : TOWER_COORDS.BLUE;
    const lanes = ['top', 'mid', 'bot'] as const;

    for (const lane of lanes) {
        const brokenCount = (enemyStats.towers as any)[lane];
        if (brokenCount < 3) {
            const tier = brokenCount + 1;
            // @ts-ignore
            const tPos = towerCoords[lane.toUpperCase()][tier - 1];
            if (tPos && AIUtils.dist(pos, tPos) <= 16) return true;
        }
    }
    if (enemyStats.nexusHp > 0) {
        if (AIUtils.dist(pos, towerCoords.NEXUS) <= 18) return true;
    }
    return false;
  }

  static isSuicideMove(player: LivePlayer, targetPos: {x:number, y:number}, match: LiveMatch): boolean {
      const isBlue = match.blueTeam.includes(player);
      if (this.isInActiveEnemyTowerRange(targetPos, match, isBlue)) {
          const allies = isBlue ? match.blueTeam : match.redTeam;
          const nearbyAllies = allies.filter(a => a !== player && a.currentHp > 0 && AIUtils.dist(a, targetPos) < 15);
          
          if (nearbyAllies.length >= 2 && player.maxHp > 3000 && AIUtils.hpPercent(player) > 0.6) {
              return false; 
          }

          if (AIUtils.hpPercent(player) < 0.4) return true;
          if (!this.isSafeToSiege(player, match, targetPos)) return true;
      }
      return false;
  }

  static isSafeToSiege(player: LivePlayer, match: LiveMatch, targetPos: {x:number, y:number}): boolean {
    const isBlue = match.blueTeam.includes(player);
    const myMinions = match.minions || [];
    const nearbyMinions = myMinions.filter(m => m.team === (isBlue ? 'BLUE' : 'RED') && m.hp > 0 && getDistance(m, targetPos) < 15);
    
    if (nearbyMinions.length > 0) return true; 
    if (match.currentDuration > 1500 && AIUtils.hpPercent(player) > 0.8) return true;
    
    const isTank = player.maxHp > 3500 && player.currentHp > player.maxHp * 0.9;
    return isTank; 
  }

  static analyzeSituation(player: LivePlayer, match: LiveMatch): GameSituation {
    const isBlue = match.blueTeam.includes(player);
    const allies = isBlue ? match.blueTeam : match.redTeam;
    const enemies = isBlue ? match.redTeam : match.blueTeam;
    const enemyStats = isBlue ? match.stats.red : match.stats.blue;
    const myStats = isBlue ? match.stats.blue : match.stats.red;
    
    const myAlive = allies.filter(p => p.currentHp > 0 && p.respawnTimer <= 0).length;
    const enemyAlive = enemies.filter(p => p.currentHp > 0 && p.respawnTimer <= 0).length;
    
    const myPower = this.calculateTeamPower(allies);
    const enemyPower = this.calculateTeamPower(enemies);
    const powerRatio = myPower / Math.max(1, enemyPower);

    const isNexusVulnerable = enemyStats.towers.top >= 3 || enemyStats.towers.mid >= 3 || enemyStats.towers.bot >= 3;
    
    return { 
        myTeamAlive: myAlive, 
        enemyTeamAlive: enemyAlive, 
        isEnemyWipedOut: enemyAlive === 0, 
        hasNumberAdvantage: myAlive > enemyAlive, 
        powerDifference: myPower - enemyPower, 
        combatPowerRatio: powerRatio,
        hasSiegeBuff: myStats.activeBuffs.siegeUnit, 
        isNexusVulnerable 
    };
  }

  static needsRecall(player: LivePlayer): boolean {
    const brain = player.stats?.brain || 50; 
    const iq = Math.max(0, Math.min(100, brain)) / 100;
    const threshold = 0.25 - (iq * 0.15); 
    const lowMp = player.maxMp > 0 && (player.currentMp / player.maxMp) < 0.1;
    return AIUtils.hpPercent(player) < threshold || lowMp;
  }

  static findNearbyEnemy(player: LivePlayer, match: LiveMatch, isBlue: boolean): LivePlayer | null {
    const enemies = isBlue ? match.redTeam : match.blueTeam;
    const sightRange = 20;
    let target: LivePlayer | null = null;
    let minDist = 999;
    for (const enemy of enemies) {
      if (enemy.currentHp <= 0 || enemy.respawnTimer > 0) continue;
      const d = AIUtils.dist(player, enemy);
      if (d <= sightRange && d < minDist) { minDist = d; target = enemy; }
    }
    return target;
  }
}



==========================================
FILE PATH: src/engine/match/ai/tactics/EvasionSystem.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/tactics/EvasionSystem.ts
// ==========================================
import { LivePlayer, LiveMatch, Projectile } from '../../../../types';
import { Vector, Vector2 } from '../../../match/utils/Vector';
import { AIUtils } from '../AIUtils';

export class EvasionSystem {
  
  /**
   * ë‚ ì•„ì˜¤ëŠ” íˆ¬ì‚¬ì²´ë¥¼ í”¼í•˜ê¸° ìœ„í•œ ì´ë™ ë²¡í„°ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
   * ìœ„í˜‘ì´ ì—†ìœ¼ë©´ null ë°˜í™˜
   */
  static getDodgeVector(player: LivePlayer, match: LiveMatch): Vector2 | null {
    const mechanics = player.stats.mechanics; // 0 ~ 100
    
    // í”¼ì§€ì»¬ì´ ë‚®ìœ¼ë©´(40 ì´í•˜) í”¼í•  ìƒê°ì„ ì•ˆ í•¨ (ê·¸ëŒ€ë¡œ ë§ìŒ)
    if (mechanics < 40) return null;

    // ê°ì§€ ë²”ìœ„ (í”¼ì§€ì»¬ì´ ë†’ì„ìˆ˜ë¡ ë©€ë¦¬ì„œ ë´„)
    const detectRange = 5 + (mechanics / 10); 

    let closestThreat: Projectile | null = null;
    let minDist = 999;

    // 1. ë‚˜ì—ê²Œ ë‚ ì•„ì˜¤ëŠ” ì  íˆ¬ì‚¬ì²´ íƒìƒ‰
    const enemyTeam = match.blueTeam.includes(player) ? 'RED' : 'BLUE';
    
    for (const p of match.projectiles || []) {
        if (p.team !== enemyTeam) continue; // ì•„êµ° ê±´ ë¬´ì‹œ
        
        const dist = AIUtils.dist(player, p);
        if (dist < detectRange && dist < minDist) {
            // íˆ¬ì‚¬ì²´ê°€ ë‚˜ë¥¼ í–¥í•˜ê³  ìˆëŠ”ì§€ ë‚´ì (Dot Product)ìœ¼ë¡œ í™•ì¸ (ê³ ê¸‰ ë¡œì§)
            // ì—¬ê¸°ì„  ë‹¨ìˆœí•˜ê²Œ ê±°ë¦¬ë§Œ ì²´í¬
            minDist = dist;
            closestThreat = p;
        }
    }

    // 2. íšŒí”¼ ê¸°ë™ ê³„ì‚° (Side Step)
    if (closestThreat) {
        // ë°˜ì‘ì†ë„ ì²´í¬: í”¼ì§€ì»¬ 100ì´ë©´ 100% ë°˜ì‘, 50ì´ë©´ 50% í™•ë¥ ë¡œ ë©ë•Œë¦¼
        if (Math.random() * 100 > mechanics) return null;

        const threatPos = { x: closestThreat.x, y: closestThreat.y };
        const myPos = { x: player.x, y: player.y };
        
        // íˆ¬ì‚¬ì²´ ì§„í–‰ ë°©í–¥
        // (íˆ¬ì‚¬ì²´ì˜ ì†ë„ ë²¡í„°ë¥¼ ëª¨ë¥´ë¯€ë¡œ, íˆ¬ì‚¬ì²´->ë‚˜ì˜ ë²¡í„°ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì‚¼ìŒ)
        const incomingDir = Vector.sub(myPos, threatPos);
        
        // íˆ¬ì‚¬ì²´ ì§„í–‰ ë°©í–¥ì˜ ìˆ˜ì§ ë²¡í„°(Perpendicular) ê³„ì‚°
        // (x, y) -> (-y, x)
        let dodgeDir = { x: -incomingDir.y, y: incomingDir.x };
        
        // ì •ê·œí™” í›„ ì´ë™
        dodgeDir = Vector.normalize(dodgeDir);
        
        // ë¡œê·¸(ê°€ë”)
        if (Math.random() < 0.01) {
            // console.log(`${player.name}ê°€ íˆ¬ì‚¬ì²´ íšŒí”¼ ì‹œë„!`);
        }

        // í˜„ì¬ ìœ„ì¹˜ì—ì„œ íšŒí”¼ ë°©í–¥ìœ¼ë¡œ 3ë§Œí¼ ì´ë™í•œ ì§€ì  ë°˜í™˜
        return Vector.add(myPos, Vector.mult(dodgeDir, 3));
    }

    return null;
  }
}



==========================================
FILE PATH: src/engine/match/ai/tactics/RoleAI.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/tactics/RoleAI.ts
// ==========================================
import { LivePlayer, Hero } from '../../../../types';
import { MicroDecision } from '../MicroBrain';
import { TacticalComputer } from './TacticalComputer';
import { AIUtils } from '../AIUtils';

export class RoleAI {
  
  static getDecision(
    player: LivePlayer, 
    target: LivePlayer, 
    hero: Hero, 
    enemies: LivePlayer[],
    allies: LivePlayer[],
    isBlue: boolean
  ): MicroDecision {
    const brain = player.stats.brain;
    const role = hero.role;
    const dist = AIUtils.dist(player, target);
    const range = (hero.stats.range / 100) + 1.0;

    // 1. [ì‹ ì‚´ì/ì„ ì§€ì] (ì›ê±°ë¦¬ ë”œëŸ¬) -> ì¹´ì´íŒ… í•„ìˆ˜
    if (role === 'ì‹ ì‚´ì' || role === 'ì„ ì§€ì') {
        // ë‡Œì§€ì»¬ 40 ì´í•˜ëŠ” ê·¸ëƒ¥ ë§ëšë”œ (ì œìë¦¬ ê³µê²©)
        if (brain < 40 && dist <= range) {
            return { type: 'ATTACK', targetPos: { x: target.x, y: target.y } };
        }

        // ì¹´ì´íŒ… ìœ„ì¹˜ ê³„ì‚°
        const kitingPos = TacticalComputer.getOptimalKitingPosition(player, target, enemies, range);
        
        // ê³µê²© ê°€ëŠ¥í•˜ë©´ ê³µê²©, ì•„ë‹ˆë©´ ë¬´ë¹™
        // (Attack Move ë¡œì§: ì¿¨íƒ€ì„ê³¼ ê±°ë¦¬ë¥¼ ê³ ë ¤)
        if (dist <= range) {
             // ë‡Œì§€ì»¬ì´ ë†’ìœ¼ë©´ ë¬´ë¹™ìƒ· (ì´ë™ -> ê³µê²© -> ì´ë™)
             // ì—¬ê¸°ì„  ë‹¨ìˆœí™”: 50% í™•ë¥ ë¡œ ìœ„ì¹˜ ì¬ì¡°ì • (ë¬´ë¹™), 50% í™•ë¥ ë¡œ ê³µê²©
             if (Math.random() < (brain / 200)) { 
                 return { type: 'MOVE', targetPos: kitingPos };
             }
             return { type: 'ATTACK', targetPos: { x: target.x, y: target.y } };
        } else {
            return { type: 'MOVE', targetPos: kitingPos };
        }
    }

    // 2. [ì¶”ì ì] (ì•”ì‚´ì) -> ì§„ì… ê° ë³´ê¸°
    if (role === 'ì¶”ì ì') {
        // ì ì˜ ì£¼ìš” ìŠ¤í‚¬(CC)ì´ ë¹ ì¡ŒëŠ”ì§€ ì²´í¬í•˜ëŠ” ì²™ (ë‡Œì§€ì»¬ ë°˜ì˜)
        const isSafeToEnter = brain < 50 || Math.random() > 0.3; 
        
        if (isSafeToEnter) {
            // ì•”ì‚´ ì‹œë„: ì ì—ê²Œ ë¶™ìŒ
            if (dist > 2.0) {
                return { type: 'MOVE', targetPos: { x: target.x, y: target.y } };
            }
            return { type: 'ATTACK', targetPos: { x: target.x, y: target.y } };
        } else {
            // ê°„ë³´ê¸° (Flanking)
            const flankPos = TacticalComputer.getFlankingPosition(player, target);
            return { type: 'MOVE', targetPos: flankPos };
        }
    }

    // 3. [ìˆ˜í˜¸ê¸°ì‚¬] (íƒ±ì»¤) -> ì•„êµ° ë³´í˜¸ ë° ì•ë¼ì¸
    if (role === 'ìˆ˜í˜¸ê¸°ì‚¬') {
        // ê°€ì¥ ê°•í•œ ì•„êµ°(ë”œëŸ¬) ì°¾ê¸°
        const carry = allies.find(a => a !== player && (a.role === 'ì‹ ì‚´ì' || a.role === 'ì„ ì§€ì') && a.currentHp > 0);
        
        if (carry && brain > 60) {
            // ì•„êµ° ë”œëŸ¬ê°€ ìœ„í˜‘ë°›ëŠ”ì§€ í™•ì¸
            const threat = enemies.find(e => AIUtils.dist(carry, e) < 10);
            if (threat) {
                // í•„ë§(Peeling): ì ê³¼ ì•„êµ° ì‚¬ì´ë¡œ ì´ë™
                const peelPos = TacticalComputer.getPeelingPosition(player, carry, threat);
                // ì´ë™ í›„ ì ì´ ì‚¬ê±°ë¦¬ ë‚´ë©´ ê³µê²© (CC ê±¸ê¸° ìœ„í•´)
                if (AIUtils.dist(player, threat) < range) {
                    return { type: 'ATTACK', targetPos: { x: threat.x, y: threat.y } };
                }
                return { type: 'MOVE', targetPos: peelPos };
            }
        }
    }

    // [ê¸°ë³¸] ì§‘í–‰ê´€ ë° ê¸°íƒ€ -> ë‹¥ê³µ
    if (dist > range * 0.8) {
        return { type: 'MOVE', targetPos: { x: target.x, y: target.y } };
    }
    return { type: 'ATTACK', targetPos: { x: target.x, y: target.y } };
  }
}



==========================================
FILE PATH: src/engine/match/ai/tactics/SkillBrain.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/tactics/SkillBrain.ts
// ==========================================
import { LivePlayer, Hero } from '../../../../types';
import { AIUtils } from '../AIUtils';

export class SkillBrain {
  /**
   * í˜„ì¬ ìƒí™©ì—ì„œ ì‚¬ìš©í•  ìµœì ì˜ ìŠ¤í‚¬ì„ íŒë‹¨í•©ë‹ˆë‹¤.
   * @returns ì‚¬ìš©í•  ìŠ¤í‚¬ í‚¤ ('q' | 'w' | 'e' | 'r') ë˜ëŠ” null
   */
  static getBestSkill(
    player: LivePlayer, 
    target: LivePlayer, 
    hero: Hero, 
    dist: number
  ): string | null {
    // ì¿¨íƒ€ì„ ë° ë§ˆë‚˜ ì²´í¬ í—¬í¼
    const canUse = (key: string) => {
        const skill = (hero.skills as any)[key];
        const cooldown = (player.cooldowns as any)[key];
        const cost = skill.cost || 0;
        return cooldown <= 0 && player.currentMp >= cost;
    };

    const brain = player.stats.brain; // 0 ~ 100
    const targetHpPercent = AIUtils.hpPercent(target);

    // 1. [ê¶ê·¹ê¸°(R) íŒë‹¨] - í‚¬ê°ì´ê±°ë‚˜ í•œíƒ€ì¼ ë•Œ
    if (canUse('r')) {
        const rSkill = hero.skills.r;
        
        // ë‡Œì§€ì»¬ ë†’ìœ¼ë©´: í™•ì‹¤í•œ í‚¬ê°ì¼ ë•Œë§Œ ê¶ ì”€
        if (brain > 60) {
            if (targetHpPercent < 0.4) return 'r'; // ë§ˆë¬´ë¦¬
        } else {
            // ë‡Œì§€ì»¬ ë‚®ìœ¼ë©´: ê·¸ëƒ¥ ì¿¨ ëŒë©´ ì”€ (ë¸Œë¡ ì¦ˆ)
            if (targetHpPercent < 0.8) return 'r'; 
        }
    }

    // 2. [ì£¼ë ¥ê¸°(Q) íŒë‹¨] - ë”œêµí™˜
    if (canUse('q')) {
        // ì‚¬ê±°ë¦¬ ì²´í¬
        if (dist <= 6) return 'q'; // ì‚¬ê±°ë¦¬ ë‚´ë©´ ë°œì‚¬
    }

    // 3. [CCê¸°/ìœ í‹¸ê¸°(W, E) íŒë‹¨]
    // ì ì´ ë„ë§ê°€ê±°ë‚˜(ì²´ë ¥ ë‚®ìŒ) ë‚´ê°€ ìœ„í—˜í•  ë•Œ
    if (targetHpPercent < 0.3 && canUse('e')) return 'e'; // ì¶”ê²©/ë§ˆë¬´ë¦¬
    if (AIUtils.hpPercent(player) < 0.4 && canUse('w')) return 'w'; // ìƒì¡´ìš©

    return null;
  }
}



==========================================
FILE PATH: src/engine/match/ai/tactics/SquadSystem.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/tactics/SquadSystem.ts
// ==========================================
import { LivePlayer, LiveMatch } from '../../../../types';
import { AIUtils } from '../AIUtils';
import { Vector, Vector2 } from '../../../match/utils/Vector';
import { BASES } from '../../constants/MapConstants';

export class SquadSystem {
  
  /**
   * [ì „ëµì  ì§‘ê²°ì§€ ê³„ì‚°]
   * ì•„êµ°ë“¤ì´ ëª¨ì—¬ì•¼ í•  ìµœì ì˜ ì¥ì†Œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
   * 1. ì•„êµ° ë³¸ëŒ€ê°€ ìˆëŠ” ê³³
   * 2. ë˜ëŠ” ê°€ì¥ ë§ì´ ë°€ë¦° ë¼ì¸ì˜ ìµœì „ë°© ë¯¸ë‹ˆì–¸ ìœ„ì¹˜
   */
  static getAssemblyPoint(player: LivePlayer, match: LiveMatch): Vector2 | null {
    const isBlue = match.blueTeam.includes(player);
    const allies = isBlue ? match.blueTeam : match.redTeam;
    
    // ì‚´ì•„ìˆëŠ” ì•„êµ°ë“¤ë§Œ ê³ ë ¤
    const activeAllies = allies.filter(a => a.currentHp > 0 && a.respawnTimer <= 0 && a !== player);
    
    if (activeAllies.length < 2) return null; // ë­‰ì¹  ì•„êµ°ì´ ì—†ìŒ

    // 1. ì•„êµ° êµ°ì§‘ ì¤‘ì‹¬ì  (Centroid) ê³„ì‚°
    let sumX = 0, sumY = 0;
    activeAllies.forEach(a => { sumX += a.x; sumY += a.y; });
    const centerX = sumX / activeAllies.length;
    const centerY = sumY / activeAllies.length;
    const centerPos = { x: centerX, y: centerY };

    // 2. ë§Œì•½ ì•„êµ°ë“¤ì´ í©ì–´ì ¸ ìˆë‹¤ë©´? -> ëª©í‘œë¬¼(ë¯¸ë“œ/ì˜¤ë¸Œì íŠ¸) ì¤‘ì‹¬ìœ¼ë¡œ ëª¨ì„
    // ì•„êµ°ë“¤ì´ ì„œë¡œ 30 ì´ìƒ ë–¨ì–´ì ¸ ìˆìœ¼ë©´ í©ì–´ì§„ ê²ƒìœ¼ë¡œ ê°„ì£¼
    const spread = activeAllies.reduce((s, a) => s + AIUtils.dist(a, centerPos), 0) / activeAllies.length;
    
    if (spread > 30) {
        // ê°€ì¥ ì˜ í° ì•„êµ°(ìºë¦¬)ì—ê²Œ í•©ë¥˜
        const carry = activeAllies.sort((a,b) => b.gold - a.gold)[0];
        if (carry) return { x: carry.x, y: carry.y };
        
        // ì•„ë‹ˆë©´ ë¯¸ë“œ ì¤‘ì•™ìœ¼ë¡œ
        return { x: 50, y: 50 };
    }

    return centerPos;
  }

  /**
   * [í•œíƒ€ ê°œì‹œ ì—¬ë¶€ íŒë‹¨]
   * ì§€ê¸ˆ ì‹¸ì›€ì„ ê±¸ì–´ì•¼ í•˜ëŠ”ê°€?
   */
  static shouldInitiateFight(player: LivePlayer, match: LiveMatch): boolean {
    const nearby = this.getNearbyStats(player, match, 25);
    
    // 1. ìˆ˜ì  ìš°ìœ„ (5vs4, 4vs3 ë“±)
    if (nearby.allyCount > nearby.enemyCount) return true;

    // 2. ì „íˆ¬ë ¥ ìš°ìœ„ (1.2ë°° ì´ìƒ)
    if (nearby.powerRatio > 1.2) return true;

    // 3. ë‚´ê°€ íƒ±ì»¤ê³ , ì•„êµ° ë”œëŸ¬ê°€ ë’¤ì— ìˆìœ¼ë©´ ì´ë‹ˆì‹œ
    if (player.role === 'ìˆ˜í˜¸ê¸°ì‚¬' && nearby.allyCount >= 3 && nearby.powerRatio > 0.9) return true;

    return false;
  }

  private static getNearbyStats(player: LivePlayer, match: LiveMatch, range: number) {
      const isBlue = match.blueTeam.includes(player);
      const allies = isBlue ? match.blueTeam : match.redTeam;
      const enemies = isBlue ? match.redTeam : match.blueTeam;

      const nearbyAllies = allies.filter(a => a.currentHp > 0 && AIUtils.dist(player, a) <= range);
      const nearbyEnemies = enemies.filter(e => e.currentHp > 0 && AIUtils.dist(player, e) <= range);

      const allyPower = nearbyAllies.reduce((s, a) => s + AIUtils.getCombatPower(a), 0);
      const enemyPower = nearbyEnemies.reduce((s, e) => s + AIUtils.getCombatPower(e), 0);

      return {
          allyCount: nearbyAllies.length,
          enemyCount: nearbyEnemies.length,
          powerRatio: allyPower / Math.max(1, enemyPower)
      };
  }
}



==========================================
FILE PATH: src/engine/match/ai/tactics/TacticalComputer.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/tactics/TacticalComputer.ts
// ==========================================
import { LivePlayer, LiveMatch, Hero } from '../../../../types';
import { Vector, Vector2 } from '../../../match/utils/Vector';
import { AIUtils } from '../AIUtils';
import { TOWER_COORDS } from '../../../match/constants/MapConstants';
import { Perception } from '../Perception';

export class TacticalComputer {

  /**
   * [ì¹´ì´íŒ…/ë¬´ë¹™ ë¡œì§]
   * ì ì˜ ìœ„í˜‘ì„ í”¼í•˜ë©´ì„œ ê³µê²© ì‚¬ê±°ë¦¬ë¥¼ ìœ ì§€í•˜ëŠ” ìµœì ì˜ ìœ„ì¹˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
   */
  static getOptimalKitingPosition(
    player: LivePlayer, 
    target: LivePlayer, 
    enemies: LivePlayer[], 
    range: number
  ): Vector2 {
    const myPos = { x: player.x, y: player.y };
    const targetPos = { x: target.x, y: target.y };
    
    // 1. ê¸°ë³¸ ë²¡í„°: íƒ€ê²Ÿì„ í–¥í•œ ë°©í–¥
    let moveDir = Vector.sub(targetPos, myPos);
    const distToTarget = Vector.mag(moveDir);
    
    // ì‚¬ê±°ë¦¬ ìœ ì§€
    const optimalDist = range * (0.8 + (player.stats.brain / 500)); 

    if (distToTarget < optimalDist) {
        // ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ë’¤ë¡œ ë¹ ì§
        moveDir = Vector.mult(moveDir, -1);
    }

    // 2. ìœ„í˜‘ íšŒí”¼
    let avoidForce = { x: 0, y: 0 };
    for (const enemy of enemies) {
        if (enemy === target) continue;
        const dist = AIUtils.dist(player, enemy);
        const awarenessRange = 5 + (player.stats.brain / 10);
        
        if (dist < awarenessRange) {
            let push = Vector.sub(myPos, { x: enemy.x, y: enemy.y });
            push = Vector.normalize(push);
            push = Vector.mult(push, (awarenessRange - dist) * 2.0);
            avoidForce = Vector.add(avoidForce, push);
        }
    }

    const finalDir = Vector.add(Vector.normalize(moveDir), avoidForce);
    return Vector.add(myPos, Vector.mult(Vector.normalize(finalDir), 5));
  }

  /**
   * [ì•”ì‚´ì ë¡œì§]
   * ì ì˜ ì¸¡ë©´ì´ë‚˜ í›„ë°©ì„ ë…¸ë¦¬ëŠ” ë²¡í„°ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
   */
  static getFlankingPosition(player: LivePlayer, target: LivePlayer): Vector2 {
    const isBlue = player.lane !== 'JUNGLE' ? player.x < 50 : true;
    const flankOffsetX = isBlue ? 10 : -10;
    return { x: target.x + flankOffsetX, y: target.y + (Math.random() * 10 - 5) };
  }

  /**
   * [íƒ±ì»¤ ë¡œì§]
   * ì•„êµ° ë”œëŸ¬ì™€ ì  ì‚¬ì´ì— ìœ„ì¹˜í•˜ë ¤ëŠ” ì¢Œí‘œ ê³„ì‚°
   */
  static getPeelingPosition(player: LivePlayer, allyCarry: LivePlayer, nearestEnemy: LivePlayer): Vector2 {
    const allyPos = { x: allyCarry.x, y: allyCarry.y };
    const enemyPos = { x: nearestEnemy.x, y: nearestEnemy.y };
    return Vector.lerp(allyPos, enemyPos, 0.3);
  }

  /**
   * [ìŠ¤ë§ˆíŠ¸ íƒ€ì›Œ ê³µëµ]
   * ì ì´ íƒ€ì›Œ ì•ˆì— ìˆì„ ë•Œ, ë‚´ê°€ ì„œ ìˆì–´ì•¼ í•  ìµœì ì˜ ìœ„ì¹˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
   */
  static getSiegePosition(
    player: LivePlayer, 
    target: LivePlayer, 
    match: LiveMatch,
    attackRange: number
  ): Vector2 {
    const isBlue = match.blueTeam.includes(player);
    const myPos = { x: player.x, y: player.y };
    const targetPos = { x: target.x, y: target.y };

    // 1. ê°€ì¥ ê°€ê¹Œìš´ ìœ„í˜‘ì ì¸ ì  íƒ€ì›Œ ì°¾ê¸°
    const towerInfo = this.getNearestEnemyTower(player, match, isBlue);
    if (!towerInfo) return targetPos;

    const towerPos = towerInfo.pos;
    const towerRange = 13.0; 

    const targetDistToTower = AIUtils.dist(target, towerPos);

    // 2. ìƒí™©ë³„ ìœ„ì¹˜ ì„ ì •
    
    // Case A: ë¯¸ë‹ˆì–¸ì´ ì–´ê·¸ë¡œë¥¼ ëŒì–´ì£¼ê³  ìˆìŒ -> ì•ˆì „í•˜ê²Œ ì§„ì…
    if (Perception.isSafeToSiege(player, match, towerPos)) {
        return targetPos;
    }

    // Case B: ë¯¸ë‹ˆì–¸ ì—†ìŒ (ë§¨ëª¸)
    if (player.stats.brain < 30) return targetPos; // ë©ì²­í•˜ë©´ ê·¸ëƒ¥ ë“¤ì–´ê°

    // (1) ì ì´ íƒ€ì›Œ ê¹Šìˆ™ì´ ìˆìŒ (ëª» ë•Œë¦¬ëŠ” ìœ„ì¹˜) -> íƒ€ì›Œ ì‚¬ê±°ë¦¬ ë°– ëŒ€ê¸°
    if (targetDistToTower < towerRange - attackRange) {
        return this.getPointOnCircleEdge(towerPos, myPos, towerRange + 1.0);
    }

    // (2) ì ì´ íƒ€ì›Œ ê°€ì¥ìë¦¬ì— ìˆìŒ -> ë°–ì—ì„œ ì¹  ìˆ˜ ìˆìœ¼ë©´ ì¹¨
    if (attackRange > 5.0) { // ì›ê±°ë¦¬
        const safeSpot = this.getPointOnCircleEdge(towerPos, targetPos, towerRange + 0.5);
        if (AIUtils.dist(safeSpot, targetPos) <= attackRange) {
            return safeSpot;
        }
    }

    // (3) ê·¼ê±°ë¦¬ì¸ë° ë¯¸ë‹ˆì–¸ ì—†ìŒ -> ëŒ€ê¸°
    return this.getPointOnCircleEdge(towerPos, targetPos, towerRange + 1.5);
  }

  // ì›ì˜ ì¤‘ì‹¬(center)ì—ì„œ targetì„ ë°”ë¼ë³´ëŠ” ë°©í–¥ìœ¼ë¡œ radiusë§Œí¼ ë–¨ì–´ì§„ ì§€ì  ë°˜í™˜
  private static getPointOnCircleEdge(center: Vector2, target: Vector2, radius: number): Vector2 {
    const dir = Vector.normalize(Vector.sub(target, center));
    return Vector.add(center, Vector.mult(dir, radius));
  }

  private static getNearestEnemyTower(player: LivePlayer, match: LiveMatch, isBlue: boolean) {
      const enemyStats = isBlue ? match.stats.red : match.stats.blue;
      const towerCoords = isBlue ? TOWER_COORDS.RED : TOWER_COORDS.BLUE;
      const lanes = ['top', 'mid', 'bot'] as const;
      
      let nearest = null;
      let minDist = 999;

      // ë ˆì¸ íƒ€ì›Œ
      for (const lane of lanes) {
          const brokenCount = (enemyStats.towers as any)[lane];
          if (brokenCount < 3) {
              const tier = brokenCount + 1;
              // @ts-ignore
              const tPos = towerCoords[lane.toUpperCase()][tier - 1];
              const d = AIUtils.dist(player, tPos);
              if (d < minDist) { minDist = d; nearest = { pos: tPos }; }
          }
      }
      // ë„¥ì„œìŠ¤
      if (enemyStats.nexusHp > 0) {
          const d = AIUtils.dist(player, towerCoords.NEXUS);
          if (d < minDist) { minDist = d; nearest = { pos: towerCoords.NEXUS }; }
      }

      if (minDist > 30) return null;
      return nearest;
  }
}



==========================================
FILE PATH: src/engine/match/ai/tactics/TacticalScorer.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/tactics/TacticalScorer.ts
// ==========================================
import { LivePlayer, LiveMatch, Hero } from '../../../../types';
import { AIUtils } from '../AIUtils';
import { Perception } from '../Perception';

export class TacticalScorer {
  
  /**
   * [ì „íˆ¬ ì ìˆ˜] ì‹¸ì›€ì„ ê±¸ì—ˆì„ ë•Œì˜ ì´ë“ ê³„ì‚°
   * - í˜„ìƒê¸ˆì´ ë†’ì„ìˆ˜ë¡ ì ìˆ˜ ëŒ€í­ ìƒìŠ¹
   * - ë‚´ ì „íˆ¬ë ¥ì´ ë†’ì„ìˆ˜ë¡ ìƒìŠ¹
   * - ë‚´ê°€ í˜„ìƒê¸ˆì´ ë§ìœ¼ë©´(ì œì••ê³¨ë“œ í—Œë‚© ìœ„í—˜) ì ìˆ˜ í•˜ë½
   */
  static getFightScore(player: LivePlayer, target: LivePlayer, match: LiveMatch): number {
    const myPower = AIUtils.getCombatPower(player);
    const enemyPower = AIUtils.getCombatPower(target);
    
    // 1. ì „íˆ¬ë ¥ ê²©ì°¨ (1.0 = ë™ë“±)
    let score = (myPower / Math.max(1, enemyPower)) * 50;

    // 2. í˜„ìƒê¸ˆ(Bounty) ë§¤ë¦¬íŠ¸
    // í˜„ìƒê¸ˆ 100ê³¨ë“œë‹¹ 10ì  ì¶”ê°€ (1000ê³¨ë“œë©´ +100ì  -> ëˆˆëŒì•„ê°€ì„œ ë¤ë¹”)
    const enemyBounty = target.bounty || 0;
    score += (enemyBounty / 100) * 10;

    // 3. ë¦¬ìŠ¤í¬ ê´€ë¦¬ (ë‚´ ëª©ìˆ¨ê°’)
    // ë‚´ í˜„ìƒê¸ˆì´ ë†’ìœ¼ë©´ ëª¸ì„ ì‚¬ë ¤ì•¼ í•¨
    const myBounty = player.bounty || 0;
    if (myBounty > 300) {
        score -= (myBounty / 100) * 5; 
    }

    // 4. ì²´ë ¥ ìƒí™©
    const hpDiff = AIUtils.hpPercent(player) - AIUtils.hpPercent(target);
    score += hpDiff * 30;

    // 5. ë‡Œì§€ì»¬ ë°˜ì˜ (ë‡Œì§€ì»¬ì´ ë†’ìœ¼ë©´ ìŠ¹ì‚° ì—†ëŠ” ì‹¸ì›€ ì ìˆ˜ë¥¼ ê¹ìŒ)
    if (player.stats.brain > 70 && myPower < enemyPower) {
        score -= 50; 
    }

    return score;
  }

  /**
   * [ì˜¤ë¸Œì íŠ¸ ì ìˆ˜] ë°”ë¡ /ìš©ì„ ë¨¹ì–´ì•¼ í•˜ëŠ” ì •ë„
   * - ê²Œì„ ì‹œê°„ì´ ëŠ¦ì„ìˆ˜ë¡ ì ìˆ˜ ìƒìŠ¹
   * - ì•„êµ°ì´ ê·¼ì²˜ì— ë§ì„ìˆ˜ë¡ ìƒìŠ¹
   */
  static getObjectiveScore(player: LivePlayer, match: LiveMatch, objPos: {x:number, y:number}): number {
    let score = 0;
    
    // 1. ê²Œì„ ì‹œê°„ ê°€ì¤‘ì¹˜ (20ë¶„ ë„˜ì–´ê°€ë©´ ì˜¤ë¸Œì íŠ¸ ì¤‘ìš”ë„ ê¸‰ìƒìŠ¹)
    const timeWeight = Math.min(3.0, match.currentDuration / 600); // 10ë¶„=1.0, 30ë¶„=3.0
    score += 20 * timeWeight;

    // 2. ê±°ë¦¬ (ê°€ê¹Œìš¸ìˆ˜ë¡ ìœ ë¦¬)
    const dist = AIUtils.dist(player, objPos);
    score -= dist * 0.5;

    // 3. ì•„êµ° í•©ë¥˜ ì—¬ë¶€
    const isBlue = match.blueTeam.includes(player);
    const allies = isBlue ? match.blueTeam : match.redTeam;
    const alliesNearObj = allies.filter(a => a.currentHp > 0 && AIUtils.dist(a, objPos) < 30).length;
    
    if (alliesNearObj >= 2) score += 40; // ë­‰ì¹˜ë©´ ì‚°ë‹¤

    // 4. ì •ê¸€ëŸ¬ ê°€ì¤‘ì¹˜
    if (player.lane === 'JUNGLE') score += 50;

    return score;
  }

  /**
   * [ê³µì„± ì ìˆ˜] íƒ€ì›Œë¥¼ ë°€ì–´ì•¼ í•˜ëŠ” ì •ë„
   * - ì•ì— ì ì´ ì—†ìœ¼ë©´ ì ìˆ˜ í­ë“±
   * - ê³µì„± ë²„í”„(ê±°ì‹ ë³‘) ìˆìœ¼ë©´ ì ìˆ˜ ìƒìŠ¹
   */
  static getPushScore(player: LivePlayer, match: LiveMatch, towerPos: {x:number, y:number}): number {
    let score = 40; // ê¸°ë³¸ ì ìˆ˜

    // 1. ì•ˆì „ í™•ë³´ ì—¬ë¶€
    if (Perception.isSafeToSiege(player, match, towerPos)) {
        score += 30;
    }

    // 2. ê³µì„± ë²„í”„ ë³´ìœ 
    const isBlue = match.blueTeam.includes(player);
    const hasBuff = isBlue ? match.stats.blue.activeBuffs.siegeUnit : match.stats.red.activeBuffs.siegeUnit;
    if (hasBuff) score += 50; // ê±°ì‹ ë³‘ì´ë‘ ê°™ì´ ë°€ì

    // 3. ì  ìˆ˜ë¹„ ë¶€ì¬ í™•ì¸
    const nearbyEnemy = Perception.findNearbyEnemy(player, match, isBlue);
    if (!nearbyEnemy) score += 20; // í”„ë¦¬ ê³µì„±

    return score;
  }

  /**
   * [íŒŒë° ì ìˆ˜] ì„±ì¥í•´ì•¼ í•˜ëŠ” ì •ë„
   * - ì´ˆë°˜ì¼ìˆ˜ë¡ ë†’ìŒ
   * - í…œ ì‚´ ëˆì´ ëª¨ì´ê¸° ì§ì „ì´ë©´ ë†’ìŒ
   */
  static getFarmScore(player: LivePlayer, match: LiveMatch): number {
    let score = 30;

    // 1. ì´ˆë°˜ ê°€ì¤‘ì¹˜ (10ë¶„ ì „ì—” íŒŒë°ì´ ì¤‘ìš”)
    if (match.currentDuration < 600) score += 20;

    // 2. í…œ ë‚˜ì˜¤ê¸° ì§ì „ (ê³¨ë“œ ì• ë§¤í•  ë•Œ)
    const nextItemCost = 3000; // ëŒ€ëµì ì¸ ì½”ì–´í…œ ê°€ê²©
    if (player.gold > 2000 && player.gold < 3000) score += 30;

    return score;
  }
}



==========================================
FILE PATH: src/engine/match/ai/tactics/TeamTactics.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/ai/tactics/TeamTactics.ts
// ==========================================
import { LiveMatch, LivePlayer } from '../../../../types';
import { AIUtils } from '../AIUtils';
import { BASES, TOWER_COORDS } from '../../constants/MapConstants';

export type TeamOrderType = 'FREE' | 'ALL_PUSH' | 'ALL_DEFEND' | 'SIEGE_MID' | 'RETREAT';

export interface TeamOrder {
  type: TeamOrderType;
  targetPos?: { x: number, y: number };
  reason: string;
}

export class TeamTactics {
  
  /**
   * í•´ë‹¹ íŒ€ì˜ í˜„ì¬ ì „ëµì  ìƒíƒœë¥¼ ê²°ì •í•©ë‹ˆë‹¤.
   */
  static analyzeTeamStrategy(match: LiveMatch, isBlueTeam: boolean): TeamOrder {
    const allies = isBlueTeam ? match.blueTeam : match.redTeam;
    const enemies = isBlueTeam ? match.redTeam : match.blueTeam;
    const enemyBase = isBlueTeam ? BASES.RED : BASES.BLUE;
    const myBase = isBlueTeam ? BASES.BLUE : BASES.RED;

    // 1. ìƒì¡´ì ìˆ˜ ë¹„êµ (ìˆ˜ì  ìš°ìœ„)
    const activeAllies = allies.filter(p => p.currentHp > 0 && p.respawnTimer <= 0);
    const activeEnemies = enemies.filter(p => p.currentHp > 0 && p.respawnTimer <= 0);
    
    const allyCount = activeAllies.length;
    const enemyCount = activeEnemies.length;
    const advantage = allyCount - enemyCount; // ì–‘ìˆ˜ë©´ ìš°ë¦¬ê°€ ìœ ë¦¬

    // 2. ë¼ì¸ ìƒí™© (ë¯¸ë“œ ì–µì œê¸° ë°€ë ¸ëŠ”ì§€)
    const enemyStats = isBlueTeam ? match.stats.red : match.stats.blue;
    const myStats = isBlueTeam ? match.stats.blue : match.stats.red;
    
    const isEnemyInhibitorDown = enemyStats.towers.mid >= 3;
    const isMyInhibitorDown = myStats.towers.mid >= 3;

    // --------------------------------------------------------
    // [ì „ëµ 1] ì—˜ë¦¬ì „ / ëë‚´ê¸° (Game Ending)
    // ì¡°ê±´: ì ì´ ê±°ì˜ ì „ë©¸í–ˆê±°ë‚˜(2ëª… ì´ìƒ ì°¨ì´), 20ë¶„ ë„˜ì—ˆëŠ”ë° ìˆ˜ì  ìš°ìœ„ì¼ ë•Œ
    // --------------------------------------------------------
    if (match.currentDuration > 900) { // 15ë¶„ ì´í›„
        if (enemyCount === 0 || (advantage >= 2 && isEnemyInhibitorDown)) {
            return { 
                type: 'ALL_PUSH', 
                targetPos: enemyBase, 
                reason: 'ğŸš€ ì  ê¶¤ë©¸! ì „ì› ë„¥ì„œìŠ¤ ëŒê²©!' 
            };
        }
    }

    // --------------------------------------------------------
    // [ì „ëµ 2] ê¸´ê¸‰ ìˆ˜ë¹„ (Emergency Defense)
    // ì¡°ê±´: ìš°ë¦¬ ì–µì œê¸°ê°€ ë°€ë ¸ê³ , ì ì´ ìš°ë¦¬ ê¸°ì§€ ê·¼ì²˜ì— 2ëª… ì´ìƒ ìˆìŒ
    // --------------------------------------------------------
    if (isMyInhibitorDown) {
        const enemiesInBase = activeEnemies.filter(e => AIUtils.dist(e, myBase) < 30).length;
        if (enemiesInBase >= 2) {
            return { 
                type: 'ALL_DEFEND', 
                targetPos: myBase, 
                reason: 'ğŸ›¡ï¸ ë³¸ì§„ ìœ„í—˜! ì „ì› ìˆ˜ë¹„!' 
            };
        }
    }

    // --------------------------------------------------------
    // [ì „ëµ 3] ìŠ¤ë…¸ìš°ë³¼ë§ (Siege)
    // ì¡°ê±´: ìˆ˜ì  ìš°ìœ„(1ëª… ì´ìƒ) ì´ê³  ì•„êµ°ì´ 3ëª… ì´ìƒ ë­‰ì³ìˆìŒ -> ë¯¸ë“œ ê³ ì†ë„ë¡œ
    // --------------------------------------------------------
    if (advantage >= 1 && allyCount >= 3) {
        const midObjective = AIUtils.getNextObjectivePos(activeAllies[0], match, isBlueTeam); // ë¯¸ë“œ íƒ€ì›Œ ì¢Œí‘œ
        return { 
            type: 'SIEGE_MID', 
            targetPos: midObjective, 
            reason: 'ğŸ”¥ ìˆ˜ì  ìš°ìœ„! ë¯¸ë“œ ì••ë°•!' 
        };
    }

    // --------------------------------------------------------
    // [ì „ëµ 4] ì •ë¹„ ë° ë¶„ì‚° (Free)
    // íŠ¹ë³„í•œ ìƒí™© ì•„ë‹ˆë©´ ê°ì íŒë‹¨ (ë¼ì¸ì „, ì •ê¸€ë§)
    // --------------------------------------------------------
    return { type: 'FREE', reason: 'ììœ  í–‰ë™' };
  }
}



==========================================
FILE PATH: src/engine/match/BattleLogic.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/BattleLogic.ts
// ==========================================
import { LivePlayer, Hero } from '../../types';
import { getDistance, Vector2 } from '../data/MapData';

// ìœ ë‹›ì˜ í˜„ì¬ ìƒíƒœ
export type UnitState = 'IDLE' | 'MOVING' | 'ATTACKING' | 'RECALLING' | 'DEAD';

// --- [ì´ë™ ë¡œì§] ---
// ëª©í‘œ ì§€ì ê¹Œì§€ ì´ë™. ë„ì°©í–ˆìœ¼ë©´ true ë°˜í™˜
export const moveUnit = (p: LivePlayer, target: Vector2, dt: number, speedVal: number) => {
  const dist = getDistance(p, target);

  // ì•„ì£¼ ê°€ê¹ë‹¤ë©´ ë„ì°© ì²˜ë¦¬
  if (dist <= 1.0) return true; 

  // ë§µ í¬ê¸° 100 ê¸°ì¤€, ì†ë„ ìŠ¤ì¼€ì¼ ë³´ì • (ëŒ€ëµì ì¸ ê²Œì„ ì†ë„ ì¡°ì ˆ)
  // speedVal(ì´ì†)ì´ ë³´í†µ 300~400 ì •ë„ì´ë¯€ë¡œ 1/100 ì •ë„ë¡œ ì¤„ì—¬ì„œ ì´ë™
  const speed = (speedVal / 100) * dt * 0.8; 

  // [ìˆ˜ì •] ê±°ë¦¬ê°€ ë„ˆë¬´ ê°€ê¹Œìš°ë©´(0ì— ìˆ˜ë ´í•˜ë©´) ë‚˜ëˆ„ê¸° 0 ì—ëŸ¬ ë°œìƒ ê°€ëŠ¥í•˜ë¯€ë¡œ ë°©ì–´
  if (dist > 0.001) {
      const dx = (target.x - p.x) / dist;
      const dy = (target.y - p.y) / dist;

      p.x += dx * speed;
      p.y += dy * speed;
  }

  // ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šê²Œ ì œí•œ (0~100)
  p.x = Math.max(0, Math.min(100, p.x));
  p.y = Math.max(0, Math.min(100, p.y));

  return false;
};

// --- [íƒ€ê²ŸíŒ… ë¡œì§] ---
// ì‚¬ê±°ë¦¬ ë‚´ì˜ ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
export const findTarget = (me: LivePlayer, enemies: LivePlayer[], range: number): LivePlayer | null => {
  let target = null;
  // ë§µ í¬ê¸°ê°€ 100ì´ë¯€ë¡œ, ì‚¬ê±°ë¦¬(ë³´í†µ 500~600)ë¥¼ ë§µ ë‹¨ìœ„(5~6)ë¡œ ë³€í™˜
  let minDist = range / 10; 

  for (const e of enemies) {
    // ì‚´ì•„ìˆê³  ë¶€í™œ ëŒ€ê¸°ì¤‘ì´ ì•„ë‹Œ ì ë§Œ íƒ€ê²ŸíŒ…
    if (e.currentHp > 0 && e.respawnTimer <= 0) {
      const d = getDistance(me, e);
      if (d < minDist) {
        minDist = d;
        target = e;
      }
    }
  }
  return target;
};

// --- [ê³µê²© ì‹¤í–‰ ë¡œì§] ---
// *Note: ì‹¤ì œ ë°ë¯¸ì§€ ê³„ì‚°ì€ CombatPhase.tsì—ì„œ í†µí•© ì²˜ë¦¬í•˜ë¯€ë¡œ, ì—¬ê¸°ì„œëŠ” ìŠ¤í‚¬ ì‚¬ìš© í…ìŠ¤íŠ¸ ì²˜ë¦¬ ë“±ë§Œ ë‹´ë‹¹í•  ìˆ˜ë„ ìˆìŒ
// í•˜ì§€ë§Œ í˜„ì¬ êµ¬ì¡°ìƒ ì´ í•¨ìˆ˜ëŠ” PlayerSystem ë“±ì—ì„œ ì§ì ‘ í˜¸ì¶œë˜ì§€ ì•Šê³  CombatPhaseë¡œ ëŒ€ì²´ë˜ì—ˆìŠµë‹ˆë‹¤.
// í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•´ í•¨ìˆ˜ í˜•íƒœë§Œ ìœ ì§€í•˜ê±°ë‚˜, íŠ¹ì • ìƒí™©(ë°˜ê²© ë“±)ì—ì„œ ì“¸ ìˆ˜ ìˆë„ë¡ ë‚¨ê²¨ë‘¡ë‹ˆë‹¤.
export const executeAttack = (
  attacker: LivePlayer, 
  target: LivePlayer, 
  hero: Hero, 
  dt: number,
  logs: any[],
  time: number
) => {
  // CombatPhase.ts ì—ì„œ ì²˜ë¦¬ë˜ë¯€ë¡œ ì—¬ê¸° ë¡œì§ì€ ë¹„ì›Œë‘ê±°ë‚˜ ë‹¨ìˆœí™” ê°€ëŠ¥
  // (í˜„ì¬ ì‹œë®¬ë ˆì´ì…˜ êµ¬ì¡°ì—ì„œëŠ” CombatPhaseê°€ ë©”ì¸ì´ë¯€ë¡œ ì´ í•¨ìˆ˜ëŠ” ì‚¬ìš©ë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŒ)
};


==========================================
FILE PATH: src/engine/match/constants/MapConstants.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/constants/MapConstants.ts
// ==========================================
import { Vector2 } from '../utils/Vector';

export const MAP_SIZE = 100;

export const BASES = {
  BLUE: { x: 5, y: 95 },
  RED: { x: 95, y: 5 }
};

export const FOUNTAIN_AREAS = {
  BLUE: { x: 0, y: 85, w: 15, h: 15 }, 
  RED: { x: 85, y: 0, w: 15, h: 15 }   
};

export const MOVEMENT_SETTINGS = {
  SEPARATION_DIST: 2.0, 
  WAYPOINT_TOLERANCE: 3.0, 
  ARRIVAL_TOLERANCE: 1.0, 
  MAX_FORCE: 0.5, 
};

// [í•µì‹¬] ë¼ì¸ë³„ ê²©ì „ì§€ (ë¯¸ë‹ˆì–¸ì´ ë§Œë‚˜ëŠ” ê³³)
// ë§µ ì´ë¯¸ì§€ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì¢Œí‘œë¥¼ ì§ì ‘ ì§€ì •í•©ë‹ˆë‹¤.
export const LANE_FRONTS = {
    TOP: { x: 20, y: 25 },  // íƒ‘ ë¼ì¸ ì¤‘ì•™ (ê°•ê°€ìª½)
    MID: { x: 50, y: 50 },  // ë¯¸ë“œ ì •ì¤‘ì•™
    BOT: { x: 80, y: 75 }   // ë´‡ ë¼ì¸ ì¤‘ì•™
};

export const TOWER_COORDS = {
  BLUE: {
    TOP: [{x: 8, y: 35}, {x: 8, y: 55}, {x: 10, y: 75}],
    MID: [{x: 40, y: 60}, {x: 30, y: 70}, {x: 22, y: 78}],
    BOT: [{x: 75, y: 92}, {x: 50, y: 90}, {x: 25, y: 88}],
    NEXUS: {x: 12, y: 88}
  },
  RED: {
    TOP: [{x: 45, y: 10}, {x: 65, y: 12}, {x: 80, y: 15}],
    MID: [{x: 60, y: 40}, {x: 70, y: 30}, {x: 78, y: 22}],
    BOT: [{x: 92, y: 65}, {x: 92, y: 45}, {x: 88, y: 25}],
    NEXUS: {x: 88, y: 12}
  }
};

export const POI = { 
  BARON: { x: 25, y: 28 },
  DRAGON: { x: 78, y: 72 },
  TOP_RIVER: { x: 20, y: 20 },
  BOT_RIVER: { x: 80, y: 80 },
  JUNGLE_SPOTS: [
    { x: 15, y: 42 }, { x: 50, y: 82 }, 
    { x: 58, y: 22 }, { x: 82, y: 55 }
  ]
};

// ì›¨ì´í¬ì¸íŠ¸ë„ ë‹¨ìˆœí™”
export const WAYPOINTS: Record<string, Vector2[]> = {
  TOP: [ BASES.BLUE, { x: 8, y: 35 }, LANE_FRONTS.TOP, { x: 45, y: 10 }, BASES.RED ],
  MID: [ BASES.BLUE, { x: 25, y: 75 }, LANE_FRONTS.MID, { x: 75, y: 25 }, BASES.RED ],
  BOT: [ BASES.BLUE, { x: 75, y: 92 }, LANE_FRONTS.BOT, { x: 92, y: 65 }, BASES.RED ],
  JUNGLE: POI.JUNGLE_SPOTS
};



==========================================
FILE PATH: src/engine/MatchEngine.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/MatchEngine.ts
// ==========================================

// ì´ì œ ì‹¤ì œ ë¡œì§ì€ ì•„ë˜ íŒŒì¼ë“¤ë¡œ ë¶„ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.
// ì´ íŒŒì¼ì€ í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•´ í•¨ìˆ˜ë“¤ì„ ë‹¤ì‹œ ë‚´ë³´ë‚´ê¸°ë§Œ í•©ë‹ˆë‹¤.

export { createLiveMatches } from './match/MatchCreator';
export { updateLiveMatches } from './match/MatchUpdater';
export { finishMatch } from './match/MatchSettlement';


==========================================
FILE PATH: src/engine/match/logics/ColossusLogic.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/logics/ColossusLogic.ts
// ==========================================
import { LiveMatch, Minion, BattleSettings } from '../../../types';
import { BASES, WAYPOINTS, TOWER_COORDS } from '../constants/MapConstants';
import { Collision } from '../utils/Collision';

// ë°©ì–´ë ¥ ì ìš© ë°ë¯¸ì§€ ê³µì‹
const calcMitigatedDamage = (rawDmg: number, armor: number) => {
  const reduction = 100 / (100 + armor);
  return rawDmg * reduction;
};

export class ColossusLogic {
  
  static update(colossus: Minion, match: LiveMatch, settings: BattleSettings, dt: number) {
    const isBlue = colossus.team === 'BLUE';
    
    // 1. ìµœìš°ì„  ëª©í‘œ: ë¯¸ë“œ ë¼ì¸ì˜ ë‹¤ìŒ êµ¬ì¡°ë¬¼
    const structureTarget = this.findNextStructure(colossus, match);
    
    let distToStructure = 999;
    if (structureTarget) {
        const dx = structureTarget.x - colossus.x;
        const dy = structureTarget.y - colossus.y;
        distToStructure = Math.sqrt(dx*dx + dy*dy);
    }

    // ê³µê²© ì‚¬ê±°ë¦¬ (ê±°ì‹ ë³‘ì€ ë©ì¹˜ê°€ í¬ë‹ˆê¹Œ 12)
    const ATTACK_RANGE = 12;

    // 2. í–‰ë™ ê²°ì •
    if (structureTarget && distToStructure <= ATTACK_RANGE) {
        // [ê³µì„±] ì‚¬ê±°ë¦¬ ì•ˆì´ë©´ ê³µê²©
        this.processAttack(colossus, structureTarget, 'STRUCTURE', match, settings, dt, isBlue);
    } 
    else {
        // [ì§„ê²©] ì‚¬ê±°ë¦¬ ë°–ì´ë©´ ì´ë™
        // ê¸¸ì„ ë§‰ëŠ” ì ì´ ìˆëŠ”ì§€ í™•ì¸
        const nearbyEnemy = this.findBlockingEnemy(colossus, match);
        
        if (nearbyEnemy) {
            // ê¸¸ ë§‰ëŠ” ì  ì²˜ë¦¬
            this.processAttack(colossus, nearbyEnemy, nearbyEnemy.heroId ? 'HERO' : 'MINION', match, settings, dt, isBlue);
        } else {
            // êµ¬ì¡°ë¬¼ì´ ê°€ê¹Œìš°ë©´(30ì´ë‚´) ì›¨ì´í¬ì¸íŠ¸ ë¬´ì‹œí•˜ê³  êµ¬ì¡°ë¬¼ë¡œ ì§ì§„
            if (structureTarget && distToStructure < 30) {
                this.moveToTarget(colossus, structureTarget, dt);
            } else {
                // ë©€ë©´ ì›¨ì´í¬ì¸íŠ¸ ë”°ë¼ ì´ë™
                this.processWaypointMovement(colossus, isBlue, dt);
            }
        }
    }
  }

  // ê³µê²© ì‹¤í–‰
  private static processAttack(
    me: Minion, 
    target: any, 
    type: string, 
    match: LiveMatch, 
    settings: BattleSettings, 
    dt: number,
    isBlue: boolean
  ) {
    // ê±°ì‹ ë³‘ ê³µì† (ì•½ê°„ ëŠë¦¼)
    if (Math.random() > dt * 1.5) return; 

    // ì„¤ì •ê°’ ë¡œë“œ
    const s = settings.siege || { 
        superDmg: 1.0, colossusToHero: 1.0, colossusToT1: 0.4 
    };
    const fieldTowers = settings.fieldSettings?.towers || ({} as any);
    
    let dmgFactor = 1.0;
    let targetArmor = 50; // ê¸°ë³¸ ë°©ì–´ë ¥

    if (type === 'STRUCTURE') {
        if (target.isNexus) {
            dmgFactor = s.colossusToNexus ?? 0.05; // ë„¥ì„œìŠ¤ ë°ë¯¸ì§€ ê³„ìˆ˜
            targetArmor = fieldTowers.nexus?.armor || 200;
        } else {
            const laneKey = me.lane.toLowerCase();
            const enemyStats = isBlue ? match.stats.red : match.stats.blue;
            const tier = ((enemyStats.towers as any)[laneKey] || 0) + 1;
            
            if (tier === 1) { 
                dmgFactor = s.colossusToT1 ?? 0.4; 
                targetArmor = fieldTowers.t1?.armor || 80; 
            }
            else if (tier === 2) { 
                dmgFactor = s.colossusToT2 ?? 0.2; 
                targetArmor = fieldTowers.t2?.armor || 120; 
            }
            else { 
                dmgFactor = s.colossusToT3 ?? 0.1; 
                targetArmor = fieldTowers.t3?.armor || 150; 
            }
        }
    } else if (type === 'HERO') {
        dmgFactor = s.colossusToHero ?? 0.3;
        targetArmor = (target.level * 3) + 40;
    }

    // ìµœì¢… ë°ë¯¸ì§€ ê³„ì‚°
    const baseMult = s.superDmg ?? 1.0;
    const rawDmg = me.atk * baseMult * dmgFactor;
    const finalDmg = Math.max(1, calcMitigatedDamage(rawDmg, targetArmor));

    // ë°ë¯¸ì§€ ì ìš©
    if (type === 'STRUCTURE') {
        const enemyStats = isBlue ? match.stats.red : match.stats.blue;
        if (target.isNexus) {
            enemyStats.nexusHp -= finalDmg;
        } else {
            const laneKey = me.lane.toLowerCase();
            // ì²´ë ¥ ë°ì´í„° ì•ˆì „ ì´ˆê¸°í™”
            if (!(enemyStats as any).laneHealth) {
                 (enemyStats as any).laneHealth = { top: 10000, mid: 10000, bot: 10000 };
            }
            
            // [ìˆ˜ì •ì™„ë£Œ] í™•ë¥  ì œê±° -> ì‹¤ì œ ì²´ë ¥ ê¹ê¸°
            (enemyStats as any).laneHealth[laneKey] -= finalDmg;

            if ((enemyStats as any).laneHealth[laneKey] <= 0) {
                (enemyStats.towers as any)[laneKey]++;
                match.logs.push({ 
                    time: Math.floor(match.currentDuration), 
                    message: `ğŸ¤– ê±°ì‹ ë³‘ì´ ${laneKey.toUpperCase()} íƒ€ì›Œë¥¼ íŒŒê´´í–ˆìŠµë‹ˆë‹¤!`, 
                    type: 'TOWER', team: isBlue ? 'BLUE' : 'RED' 
                });
                // ë‹¤ìŒ íƒ€ì›Œ ì²´ë ¥ ë¦¬ì…‹ (ì„ì‹œ)
                (enemyStats as any).laneHealth[laneKey] = 15000;
            }
        }
    } else {
        target.hp -= finalDmg;
        if (target.currentHp !== undefined) target.currentHp -= finalDmg;
    }
  }

  // ì§ì§„ ì´ë™
  private static moveToTarget(me: Minion, target: {x:number, y:number}, dt: number) {
    const dx = target.x - me.x;
    const dy = target.y - me.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const speed = 10;

    if (dist > 0.1) {
        me.x += (dx / dist) * speed * dt * 0.1;
        me.y += (dy / dist) * speed * dt * 0.1;
    }
  }

  // ì›¨ì´í¬ì¸íŠ¸ ì´ë™
  private static processWaypointMovement(me: Minion, isBlue: boolean, dt: number) {
    const waypoints = WAYPOINTS['MID'];
    if (!waypoints) return;

    const path = isBlue ? waypoints : [...waypoints].reverse();
    let targetPos = path[me.pathIdx];
    
    if (!targetPos) targetPos = isBlue ? BASES.RED : BASES.BLUE;

    const dx = targetPos.x - me.x;
    const dy = targetPos.y - me.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    if (dist < 3) {
        if (me.pathIdx < path.length - 1) {
            me.pathIdx++;
        }
    } else {
        const speed = 10;
        me.x += (dx / dist) * speed * dt * 0.1;
        me.y += (dy / dist) * speed * dt * 0.1;
    }
  }

  private static findNextStructure(me: Minion, match: LiveMatch) {
    const isBlue = me.team === 'BLUE';
    const enemyStats = isBlue ? match.stats.red : match.stats.blue;
    const brokenCount = enemyStats.towers.mid; // ë¯¸ë“œë§Œ ë´„

    let targetPos = null;
    let isNexus = false;

    if (brokenCount < 3) {
        const tier = brokenCount + 1;
        const coords = isBlue ? TOWER_COORDS.RED : TOWER_COORDS.BLUE;
        targetPos = coords.MID[tier - 1];
    } else {
        const coords = isBlue ? TOWER_COORDS.RED : TOWER_COORDS.BLUE;
        targetPos = coords.NEXUS;
        isNexus = true;
    }

    if (!targetPos) return null;
    return { ...targetPos, isNexus };
  }

  private static findBlockingEnemy(me: Minion, match: LiveMatch) {
    const isBlue = me.team === 'BLUE';
    const enemyTeam = isBlue ? 'RED' : 'BLUE';
    const enemyHeroes = isBlue ? match.redTeam : match.blueTeam;
    
    // ì½”ì•ì˜ ì  ì˜ì›… (ê±°ë¦¬ 8)
    const closeHero = enemyHeroes.find(h => h.currentHp > 0 && Collision.inRange(me, h, 8));
    if (closeHero) return closeHero;

    // ì½”ì•ì˜ ì  ë¯¸ë‹ˆì–¸ (ê±°ë¦¬ 8)
    if (match.minions) {
        const closeMinion = match.minions.find(m => m.team === enemyTeam && m.hp > 0 && Collision.inRange(me, m, 8));
        if (closeMinion) return closeMinion;
    }
    
    return null;
  }
}



==========================================
FILE PATH: src/engine/match/logics/CombatLogic.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/logics/CombatLogic.ts
// ==========================================
import { LiveMatch, LivePlayer, RoleSettings, BattleSettings, Hero } from '../../../types';
import { getDistance } from '../../data/MapData';
import { applyRoleBonus } from '../systems/RoleManager';

export const MINION_REWARD = {
    'MELEE': { gold: 21, xp: 60 },
    'RANGED': { gold: 14, xp: 30 },
    'SIEGE': { gold: 60, xp: 90 },
    'SUMMONED_COLOSSUS': { gold: 150, xp: 200 }
};

export const calcMitigatedDamage = (rawDmg: number, armor: number) => {
  const reduction = 100 / (100 + armor);
  return rawDmg * reduction;
};

export const calculateHeroDamage = (
    attacker: any, defender: any, atkStats: any, defStats: any, attackerHero: any, 
    isBlue: boolean, settings: BattleSettings, roleSettings: RoleSettings, buffType: string
) => {
    const god = isBlue ? settings.dante : settings.izman;
    const atkRatio = god?.atkRatio || 1.0;
    const itemAD = attacker.items.reduce((s:number, i:any) => s + (i.ad||0), 0);
    const totalAD = (atkStats.baseAtk + atkStats.ad + itemAD) * atkRatio;

    const itemCrit = attacker.items.reduce((s:number, i:any) => s + (i.crit||0), 0);
    let isCrit = Math.random() < (atkStats.crit + itemCrit) / 100;
    let rawDmg = totalAD * (isCrit ? 1.5 : 1.0); 

    const defGod = isBlue ? settings.izman : settings.dante; 
    const defRatio = defGod?.defRatio || 1.0;
    const itemArmor = defender.items.reduce((s:number, i:any) => s + (i.armor||0), 0);
    const totalArmor = (defStats.armor + itemArmor) * defRatio;
    
    const itemPen = attacker.items.reduce((s:number, i:any) => s + (i.pen||0), 0);
    const effectiveArmor = Math.max(0, totalArmor - (atkStats.pen + itemPen));
    
    const finalDamage = calcMitigatedDamage(rawDmg, effectiveArmor);
    
    const { damageMod } = applyRoleBonus(attacker, attackerHero.role, false, [], roleSettings);
    let result = finalDamage * damageMod;

    if (buffType === 'COMBAT') result *= 1.1; 

    // [í•µì‹¬] ë°ë¯¸ì§€ ê³„ìˆ˜ 0.6ìœ¼ë¡œ í•˜í–¥ (ì „íˆ¬ ì‹œê°„ ì¦ê°€)
    return Math.max(1, Math.floor(result * 0.6));
};

export const calculateUnitDamage = (
    attacker: any, atkStats: any, targetUnit: any, isBlue: boolean, settings: BattleSettings
) => {
    const god = isBlue ? settings.dante : settings.izman;
    const atkRatio = god?.atkRatio || 1.0;
    const itemAD = attacker.items.reduce((s:number, i:any) => s + (i.ad||0), 0);
    const totalAD = (atkStats.baseAtk + atkStats.ad + itemAD) * atkRatio;

    let dmgMod = 1.0;
    if (targetUnit.type === 'SUMMONED_COLOSSUS') dmgMod = 0.05; 
    if (attacker.buffs && attacker.buffs.includes('WATCHER_BUFF')) dmgMod *= 1.2;

    const targetArmor = targetUnit.armor || 0;
    const finalDmg = calcMitigatedDamage(totalAD, targetArmor) * dmgMod;
    return Math.floor(finalDmg);
};

export const calculateMinionToHeroDamage = (minion: any, hero: any) => {
    let damage = minion.atk || 20;
    if (hero.lastAttackTime && (Date.now()/1000 - hero.lastAttackTime) < 2) {
        damage *= 1.2;
    }
    const armor = (hero.level * 3) + 30; 
    return calcMitigatedDamage(damage, armor);
};

export const distributeRewards = (
    match: LiveMatch, 
    deadUnitPos: {x:number, y:number}, 
    killer: LivePlayer | null, 
    killerTeam: 'BLUE'|'RED', 
    reward: { gold: number, xp: number },
    heroes: Hero[] 
) => {
    if (killer) {
        killer.cs++;
        killer.gold += reward.gold;
        if (killer.totalGold === undefined) killer.totalGold = killer.gold;
        killer.totalGold += reward.gold;
        
        // ì„œí¬í„° ê³¨ë“œ ê³µìœ 
        const killerHero = heroes.find(h => h.id === killer.heroId);
        if (killerHero && killerHero.role === 'ìˆ˜í˜¸ê¸°ì‚¬') {
            const allies = killerTeam === 'BLUE' ? match.blueTeam : match.redTeam;
            const nearestAlly = allies.find(a => a !== killer && a.currentHp > 0 && getDistance(killer, a) < 15);
            if (nearestAlly) {
                nearestAlly.gold += reward.gold;
                nearestAlly.totalGold += reward.gold;
                nearestAlly.cs++;
            }
        }
    }
    
    const allies = killerTeam === 'BLUE' ? match.blueTeam : match.redTeam;
    const beneficiaries = allies.filter(p => p.currentHp > 0 && p.respawnTimer <= 0 && getDistance(p, deadUnitPos) < 18);

    if (beneficiaries.length > 0) {
        const xpPerPerson = Math.floor(reward.xp / beneficiaries.length);
        beneficiaries.forEach(p => { (p as any).exp = ((p as any).exp || 0) + xpPerPerson; });
    }
};

export const distributeAssist = (match: LiveMatch, killer: LivePlayer, victim: LivePlayer, isBlue: boolean) => {
    const allies = isBlue ? match.blueTeam : match.redTeam;
    const assists = allies.filter(p => p !== killer && p.currentHp > 0 && getDistance(p, victim) < 25);
    const baseReward = 150; 

    assists.forEach(p => {
        p.assists++;
        p.gold += baseReward; 
        if(p.totalGold === undefined) p.totalGold = p.gold;
        p.totalGold += baseReward;
        (p as any).exp = ((p as any).exp || 0) + 100;
    });
};



==========================================
FILE PATH: src/engine/match/logics/LaningLogic.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/logics/LaningLogic.ts
// ==========================================
import { LivePlayer, LiveMatch, Hero } from '../../../types';
import { AIUtils } from '../ai/AIUtils';
import { PathSystem } from '../systems/PathSystem'; 
import { MacroDecision } from '../ai/MacroBrain';
import { Collision } from '../utils/Collision';
import { TOWER_COORDS } from '../constants/MapConstants';

export class LaningLogic {
  
  static decide(player: LivePlayer, match: LiveMatch, hero: Hero): MacroDecision | null {
    if (player.lane === 'JUNGLE') return null;

    const isBlue = match.blueTeam.includes(player);
    
    // [1. ìƒì¡´ ìš°ì„ ] ì²´ë ¥ì´ 30% ì´í•˜ë©´ ë¬´ì¡°ê±´ í›„í‡´ (Wait/Recall)
    if (AIUtils.hpPercent(player) < 0.3) {
        // ì•„êµ° íƒ€ì›Œë¡œ í›„í‡´
        const myTower = this.getMyFrontTower(player.lane, isBlue, match);
        return { action: 'FLEE', targetPos: myTower, reason: 'ì²´ë ¥ ë¶€ì¡±' };
    }

    // ì‹œì•¼ ë²”ìœ„ (45)
    const SIGHT_RANGE = 45; 
    
    // 2. ì  ì˜ì›… íƒìƒ‰
    const enemies = isBlue ? match.redTeam : match.blueTeam;
    const nearbyEnemyHero = enemies.find(e => e.currentHp > 0 && AIUtils.dist(player, e) < SIGHT_RANGE);

    if (nearbyEnemyHero) {
        // í‚¬ê°ì´ê±°ë‚˜ ì²´ë ¥ì´ ì¶©ë¶„í•˜ë©´ ì‹¸ì›€
        return { 
            action: 'FIGHT', 
            targetPos: { x: nearbyEnemyHero.x, y: nearbyEnemyHero.y }, 
            targetUnit: nearbyEnemyHero, 
            reason: 'êµì „' 
        };
    }

    // 3. ì  ë¯¸ë‹ˆì–¸ íƒìƒ‰ & íŒŒë°
    const minions = match.minions || [];
    const enemyMinions = minions.filter(m => 
        m.lane === player.lane && 
        m.team !== (isBlue ? 'BLUE' : 'RED') && 
        m.hp > 0 && 
        AIUtils.dist(player, m) < SIGHT_RANGE
    );

    if (enemyMinions.length > 0) {
        const target = enemyMinions.sort((a,b) => AIUtils.dist(player, a) - AIUtils.dist(player, b))[0];
        const range = hero.stats.range / 100;
        
        if (AIUtils.dist(player, target) <= range + 2) {
             return { action: 'FARM', targetPos: { x: target.x, y: target.y }, targetUnit: target as any, reason: 'íŒŒë°' };
        } else {
             return { action: 'MOVE', targetPos: { x: target.x, y: target.y }, reason: 'ë¯¸ë‹ˆì–¸ ì ‘ê·¼' };
        }
    }

    // 4. í•  ì¼ ì—†ìœ¼ë©´ ì „ì„ ìœ¼ë¡œ ì´ë™
    const nextPos = PathSystem.getNextWaypoint(player, isBlue, match);
    return { action: 'MOVE', targetPos: nextPos, reason: 'ì „ì„  ë³µê·€' };
  }

  private static getMyFrontTower(lane: string, isBlue: boolean, match: LiveMatch) {
    const stats = isBlue ? match.stats.blue : match.stats.red;
    const broken = (stats.towers as any)[lane.toLowerCase()] || 0;
    const tier = Math.min(3, broken + 1);
    
    const coords = isBlue ? TOWER_COORDS.BLUE : TOWER_COORDS.RED;
    // @ts-ignore
    return coords[lane][tier-1] || coords.NEXUS;
  }
}



==========================================
FILE PATH: src/engine/match/logics/MinionLogic.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/logics/MinionLogic.ts
// ==========================================
import { LiveMatch, Minion, BattleSettings, Hero } from '../../../types';
import { WAYPOINTS, TOWER_COORDS } from '../constants/MapConstants';
import { Collision } from '../utils/Collision';
import { SpatialGrid } from '../utils/SpatialGrid';
import { distributeRewards, calcMitigatedDamage, MINION_REWARD } from './CombatLogic'; 

const MINION_SPEED = 15;

export class MinionLogic {

  static processSingleMinion(
      m: Minion, match: LiveMatch, settings: BattleSettings, dt: number, 
      enemyGrids: { minions: SpatialGrid, heroes: SpatialGrid },
      shouldThink: boolean, heroes: Hero[] 
  ) {
    if (m.type === 'SUMMONED_COLOSSUS') return;

    const isBlue = m.team === 'BLUE';
    const range = m.type === 'MELEE' ? 6 : 16;
    
    let targetType = 'MINION';
    let target: any = null;
    
    // 1. êµ¬ì¡°ë¬¼ ìš°ì„  í™•ì¸ (ê°€ê¹Œìš°ë©´ ì¹¨)
    const structure = this.findEnemyStructure(m, match);
    if (structure) {
        const dist = Math.sqrt(Math.pow(structure.x - m.x, 2) + Math.pow(structure.y - m.y, 2));
        if (dist <= range + 2) {
            target = structure;
            targetType = 'STRUCTURE';
        }
    }

    // 2. ë¯¸ë‹ˆì–¸
    if (!target) {
        const nearbyEnemyMinions = enemyGrids.minions.getNearbyUnits(m);
        target = Collision.findNearest(m, nearbyEnemyMinions, range);
        targetType = 'MINION';
    }

    // 3. ì˜ì›…
    if (!target) {
        const nearbyEnemyHeroes = enemyGrids.heroes.getNearbyUnits(m);
        target = Collision.findNearest(m, nearbyEnemyHeroes, range);
        if (target) targetType = 'HERO';
    }

    if (target) {
        m.targetId = target.id || target.heroId || 'structure';
        this.attackTarget(m, target, targetType, match, settings, dt, isBlue, heroes);
    } else {
        m.targetId = undefined;
        this.move(m, isBlue, dt);
    }
  }

  private static attackTarget(
      m: Minion, target: any, type: string, match: LiveMatch, 
      settings: BattleSettings, dt: number, isBlue: boolean, heroes: Hero[]
  ) {
    if (type !== 'STRUCTURE' && (!target || target.hp <= 0 || target.currentHp <= 0)) {
        m.targetId = undefined;
        return;
    }

    // ê³µê²© ì†ë„: 1ì´ˆì— 1ëŒ€ ì •ë„ ë•Œë¦°ë‹¤ê³  ê°€ì •
    if (Math.random() > dt * 1.0) return; 

    const s = settings.siege || { minionDmg: 1.0, cannonDmg: 1.0, dmgToHero: 1.0 };
    let damage = (m.atk || 10);

    if (type === 'STRUCTURE') {
        // [ìì—°ìŠ¤ëŸ¬ìš´ ìƒì„±]
        // ëŒ€í¬ ë¯¸ë‹ˆì–¸: êµ¬ì¡°ë¬¼ì— 2.5ë°° (ê³µì„±ìš©)
        // ì¼ë°˜ ë¯¸ë‹ˆì–¸: êµ¬ì¡°ë¬¼ì— 0.6ë°° (ì² ê±° ëŠë¦¼)
        if (m.type === 'SIEGE') damage *= 2.5;
        else damage *= 0.6;

        const laneKey = m.lane.toLowerCase();
        const enemyStats = isBlue ? match.stats.red : match.stats.blue;
        
        const fieldTowers = settings.fieldSettings?.towers || ({} as any);
        const targetArmor = (target.isNexus ? fieldTowers.nexus?.armor : 50) || 50;
        
        // ë¯¸ë‹ˆì–¸ì€ ê´€í†µë ¥ì´ ì—†ìœ¼ë¯€ë¡œ ë°©ì–´ë ¥ì— ì •ì§í•˜ê²Œ ë§‰í˜
        const realDmg = calcMitigatedDamage(damage, targetArmor);

        if (target.isNexus) {
            enemyStats.nexusHp -= realDmg;
        } else {
            if (!(enemyStats as any).laneHealth) (enemyStats as any).laneHealth = { top: 10000, mid: 10000, bot: 10000 };
            (enemyStats as any).laneHealth[laneKey] -= realDmg;

            if ((enemyStats as any).laneHealth[laneKey] <= 0) {
                (enemyStats.towers as any)[laneKey]++;
                match.logs.push({ 
                    time: Math.floor(match.currentDuration), 
                    message: `ğŸ”¥ ë¯¸ë‹ˆì–¸ì´ ${laneKey.toUpperCase()} íƒ€ì›Œ íŒŒê´´!`, 
                    type: 'TOWER', team: isBlue ? 'BLUE' : 'RED' 
                });
                const currentBroken = (enemyStats.towers as any)[laneKey];
                if (currentBroken < 3) {
                     const nextTierStats = (fieldTowers as any)[`t${currentBroken + 1}`];
                     (enemyStats as any).laneHealth[laneKey] = nextTierStats?.hp || 15000;
                }
            }
        }
    } 
    else {
        // ìœ ë‹› ê³µê²©
        let armor = target.armor || 0;
        if (type === 'HERO') armor = (target.level * 3) + 30;
        const realDmg = calcMitigatedDamage(damage, armor);
        
        if (type === 'HERO') target.currentHp -= realDmg;
        else target.hp -= realDmg;

        if (type === 'MINION' && target.hp <= 0) {
            const reward = (MINION_REWARD as any)[target.type] || MINION_REWARD.MELEE;
            distributeRewards(match, target, null, isBlue ? 'BLUE' : 'RED', reward, heroes);
        }
    }
  }

  private static move(m: Minion, isBlue: boolean, dt: number) {
    const waypoints = WAYPOINTS[m.lane];
    if (!waypoints) return; 

    const path = isBlue ? waypoints : [...waypoints].reverse();
    const targetPos = path[m.pathIdx];

    if (!targetPos) return;

    const dx = targetPos.x - m.x;
    const dy = targetPos.y - m.y;
    const distSq = dx*dx + dy*dy;

    if (distSq < 4.0) { 
      m.pathIdx = Math.min(m.pathIdx + 1, path.length - 1);
    } else {
      const dist = Math.sqrt(distSq);
      m.x += (dx / dist) * MINION_SPEED * dt * 0.1;
      m.y += (dy / dist) * MINION_SPEED * dt * 0.1;
    }
  }

  private static findEnemyStructure(m: Minion, match: LiveMatch) {
    if (m.lane === 'JUNGLE') return null; 

    const isBlue = m.team === 'BLUE';
    const enemyStats = isBlue ? match.stats.red : match.stats.blue;
    const laneKey = m.lane.toLowerCase();
    const brokenCount = (enemyStats.towers as any)[laneKey];
    
    let targetPos = null;
    let isNexus = false;

    if (brokenCount < 3) {
        const tier = brokenCount + 1;
        const coords = isBlue ? TOWER_COORDS.RED : TOWER_COORDS.BLUE;
        // @ts-ignore
        targetPos = coords[m.lane][tier - 1];
    } else {
        const coords = isBlue ? TOWER_COORDS.RED : TOWER_COORDS.BLUE;
        targetPos = coords.NEXUS;
        isNexus = true;
    }

    if (!targetPos) return null;

    const dx = m.x - targetPos.x;
    const dy = m.y - targetPos.y;
    if ((dx*dx + dy*dy) < 225) return { ...targetPos, isNexus };
    
    return null;
  }
}



==========================================
FILE PATH: src/engine/match/logics/RoamingLogic.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/logics/RoamingLogic.ts
// ==========================================
import { LivePlayer, LiveMatch, Hero } from '../../../types';
import { AIUtils } from '../ai/AIUtils';
import { MacroDecision } from '../ai/MacroBrain';
import { TOWER_COORDS } from '../constants/MapConstants';

export class RoamingLogic {
  
  static checkRoaming(player: LivePlayer, match: LiveMatch, hero: Hero): MacroDecision | null {
    // 1. ê¸°ë³¸ ì¡°ê±´ ì²´í¬
    // - ë´‡(ì›ë”œ/ì„œí¿)ì€ ë¼ì¸ì „ ë‹¨ê³„ì—ì„œ ë¡œë° ì˜ ì•ˆê° (ì¼ë‹¨ ì œì™¸)
    // - ì •ê¸€ëŸ¬ëŠ” ë³„ë„ ë¡œì§ ë”°ë¦„
    if (player.lane === 'BOT' || player.lane === 'JUNGLE') return null;
    
    // - ì²´ë ¥/ë§ˆë‚˜ê°€ ì¶©ë¶„í•´ì•¼ í•¨ (70% ì´ìƒ)
    if (AIUtils.hpPercent(player) < 0.7 || AIUtils.mpPercent(player) < 0.4) return null;

    // - ë‡Œì§€ì»¬ (Brain) ìŠ¤íƒ¯
    const brain = player.stats.brain; // 0 ~ 100

    // 2. ë¼ì¸ ìƒí™© ì²´í¬ (Wave Management)
    const isBlue = match.blueTeam.includes(player);
    const minions = match.minions || [];
    
    // ë‚´ ë¼ì¸ì˜ ì  ë¯¸ë‹ˆì–¸ ìˆ˜
    const enemyMinions = minions.filter(m => 
        m.lane === player.lane && 
        m.team !== (isBlue ? 'BLUE' : 'RED') && 
        m.hp > 0
    );

    // [ë‡Œì§€ì»¬ íŒë‹¨ 1] ë¼ì¸ ê´€ë¦¬
    // ë‡Œì§€ì»¬ì´ 50 ì´ìƒì´ë©´: ì  ë¯¸ë‹ˆì–¸ì´ ë§ì„ ë•Œ(ë°›ì•„ë¨¹ì–´ì•¼ í•  ë•Œ)ëŠ” ë¡œë° ì•ˆ ê°
    if (brain >= 50 && enemyMinions.length > 2) {
        // ë‹¨, ì  ë¯¸ë‹ˆì–¸ì´ ìš°ë¦¬ íƒ€ì›Œ ê·¼ì²˜ì— ìˆìœ¼ë©´ ì ˆëŒ€ ì•ˆ ê° (ë‡Œì§€ì»¬ 30 ì´ìƒ)
        const myTower = this.getMyTowerPos(player.lane, 1, isBlue);
        const closestMinionDist = enemyMinions.reduce((min, m) => Math.min(min, AIUtils.dist(m, myTower)), 999);
        
        if (closestMinionDist < 20) return null; // ë°›ì•„ë¨¹ì–´ë¼
    }
    // ë‡Œì§€ì»¬ì´ ë‚®ìœ¼ë©´(50 ë¯¸ë§Œ): ë¼ì¸ì´ ë°•íˆë“  ë§ë“  ë¡œë° ê°ˆ ìˆ˜ë„ ìˆìŒ (íŠ¸ë¡¤)

    // 3. ë¡œë° ëŒ€ìƒ íƒìƒ‰ (Target Selection)
    // ë¯¸ë“œëŠ” TOP/BOT ë‘˜ ë‹¤ ê°€ëŠ¥, íƒ‘ì€ MIDë§Œ (í…”ë ˆí¬íŠ¸ ë¯¸êµ¬í˜„ì´ë¯€ë¡œ)
    const targetLanes = player.lane === 'MID' ? ['TOP', 'BOT'] : ['MID'];
    
    let bestTarget = null;
    let maxScore = 0;

    const enemies = isBlue ? match.redTeam : match.blueTeam;

    for (const enemy of enemies) {
        if (enemy.currentHp <= 0 || !targetLanes.includes(enemy.lane)) continue;

        let score = 0;

        // A. ì  ì²´ë ¥ ì ìˆ˜ (ë”¸í”¼ì¼ìˆ˜ë¡ ì ìˆ˜ ë†’ìŒ)
        const hpPer = AIUtils.hpPercent(enemy);
        if (hpPer < 0.5) score += (1 - hpPer) * 100;
        else if (brain > 60) continue; // ë‡Œì§€ì»¬ ì¢‹ìœ¼ë©´ í’€í”¼ ë¡œë° ì•ˆê°

        // B. ì•„êµ° í˜¸ì‘ ì—¬ë¶€
        // í•´ë‹¹ ë¼ì¸ì— ì•„êµ°ì´ ì‚´ì•„ìˆì–´ì•¼ í•¨
        const allyInLane = (isBlue ? match.blueTeam : match.redTeam).find(a => a.lane === enemy.lane && a.currentHp > 0);
        if (!allyInLane) continue; // ì•„êµ° ì—†ìœ¼ë©´ ì•ˆ ê°

        // C. ë¼ì¸ ìƒí™© (Overextension)
        // ì ì´ ìš°ë¦¬ íƒ€ì›Œìª½ìœ¼ë¡œ ê¹Šìˆ™ì´ ë“¤ì–´ì™€ ìˆìœ¼ë©´ ì ìˆ˜ ëŒ€í­ ìƒìŠ¹
        const enemyDistToMyBase = AIUtils.dist(enemy, AIUtils.getMyBasePos(isBlue));
        if (enemyDistToMyBase < 60) score += 50; // ê¹Šìˆ™í•¨

        // D. ë‡Œì§€ì»¬ ë³´ì •
        // ë‡Œì§€ì»¬ì´ ë†’ìœ¼ë©´ ìŠ¹ì‚° ê³„ì‚°ì„ ë” ê¹ê¹í•˜ê²Œ í•¨
        if (brain > 70 && hpPer > 0.4 && score < 30) continue;

        if (score > 40 && score > maxScore) {
            maxScore = score;
            bestTarget = enemy;
        }
    }

    if (bestTarget) {
        return {
            action: 'GANK',
            targetPos: { x: bestTarget.x, y: bestTarget.y },
            targetUnit: bestTarget,
            reason: `ë¡œë° (ìŠ¹ì‚°: ${Math.floor(maxScore)}%)`
        };
    }

    return null;
  }

  private static getMyTowerPos(lane: string, tier: number, isBlue: boolean) {
    const coords = isBlue ? TOWER_COORDS.BLUE : TOWER_COORDS.RED;
    // @ts-ignore
    return coords[lane][tier-1] || coords.NEXUS;
  }
}



==========================================
FILE PATH: src/engine/match/logics/StructureLogic.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/logics/StructureLogic.ts
// ==========================================
import { LivePlayer, Minion, LiveMatch } from '../../../types';
import { getDistance } from '../../data/MapData';
import { calcMitigatedDamage } from './CombatLogic';
import { FOUNTAIN_AREAS } from '../constants/MapConstants';

export class StructureLogic {
  
  // --- [1. ìš°ë¬¼ ë ˆì´ì € (Spawn Laser)] ---
  // ì ì´ ìš°ë¬¼ì— ë“¤ì–´ì˜¤ë©´ ì´ˆë‹¹ ìµœëŒ€ ì²´ë ¥ì˜ 20% ê³ ì • í”¼í•´ (ë¬´ì¡°ê±´ ì£½ìŒ)
  static processFountainDefense(match: LiveMatch, dt: number) {
    const processTeam = (team: LivePlayer[], isEnemyBlue: boolean) => {
      const area = isEnemyBlue ? FOUNTAIN_AREAS.BLUE : FOUNTAIN_AREAS.RED;
      
      team.forEach(p => {
        if (p.currentHp <= 0) return;
        
        // ìš°ë¬¼ êµ¬ì—­ ì•ˆì— ìˆëŠ”ì§€ ì²´í¬
        const inFountain = 
          p.x >= area.x && p.x <= area.x + area.w &&
          p.y >= area.y && p.y <= area.y + area.h;

        if (inFountain) {
          // ì ˆëŒ€ í”¼í•´ (ë°©ì–´ë ¥ ë¬´ì‹œ, ë¬´ì  ë¬´ì‹œ)
          const trueDamage = p.maxHp * 0.2 * dt; 
          p.currentHp -= trueDamage;
          
          // ë¡œê·¸ ë‚¨ê¸°ê¸° (ë„ˆë¬´ ìì£¼ëŠ” ë§ê³ )
          if (p.currentHp <= 0) {
            match.logs.push({
              time: Math.floor(match.currentDuration),
              message: `âš¡ [ìš°ë¬¼ ë ˆì´ì €]ê°€ ${p.name}ì„ ì†Œë©¸ì‹œì¼°ìŠµë‹ˆë‹¤.`,
              type: 'KILL',
              team: isEnemyBlue ? 'BLUE' : 'RED'
            });
          }
        }
      });
    };

    // ë¸”ë£¨íŒ€ ìš°ë¬¼ -> ë ˆë“œíŒ€ ê³µê²©
    processTeam(match.redTeam, true);
    // ë ˆë“œíŒ€ ìš°ë¬¼ -> ë¸”ë£¨íŒ€ ê³µê²©
    processTeam(match.blueTeam, false);
  }

  // --- [2. íƒ€ì›Œ íƒ€ê²ŸíŒ…] ---
  static selectTowerTarget(
    towerPos: { x: number, y: number },
    enemies: { heroes: LivePlayer[], minions: Minion[] },
    allies: LivePlayer[], 
    range: number,
    currentTime: number
  ): { unit: any, type: 'HERO' | 'MINION' } | null {
    
    // 1. ì‚¬ê±°ë¦¬ ë‚´ ì  ì‹ë³„
    const nearbyMinions = enemies.minions.filter(m => m.hp > 0 && getDistance(m, towerPos) <= range);
    const nearbyEnemyHeroes = enemies.heroes.filter(h => h.currentHp > 0 && h.respawnTimer <= 0 && getDistance(h, towerPos) <= range);

    if (nearbyMinions.length === 0 && nearbyEnemyHeroes.length === 0) return null;

    // 2. [ì–´ê·¸ë¡œ 0ìˆœìœ„] ì•„êµ° ì˜ì›…ì„ ê³µê²©í•œ ì  ì˜ì›… (Call for Help)
    const AGGRO_DURATION = 2.0; 
    const aggroTarget = nearbyEnemyHeroes.find(enemy => {
        if (!enemy.lastAttackTime || !enemy.lastAttackedTargetId) return false;
        if (currentTime - enemy.lastAttackTime > AGGRO_DURATION) return false;
        
        // ì ì´ ë•Œë¦° ëŒ€ìƒì´ ì•„êµ°ì¸ì§€ í™•ì¸
        return allies.some(a => a.heroId === enemy.lastAttackedTargetId);
    });

    if (aggroTarget) return { unit: aggroTarget, type: 'HERO' };

    // 3. [ì¼ë°˜ ìš°ì„ ìˆœìœ„] ë¯¸ë‹ˆì–¸ > ì˜ì›… (ê±°ë¦¬ìˆœ)
    if (nearbyMinions.length > 0) {
        nearbyMinions.sort((a, b) => getDistance(a, towerPos) - getDistance(b, towerPos));
        return { unit: nearbyMinions[0], type: 'MINION' };
    } 
    
    // ë¯¸ë‹ˆì–¸ì´ ì—†ìœ¼ë©´ ì˜ì›… ê³µê²©
    nearbyEnemyHeroes.sort((a, b) => getDistance(a, towerPos) - getDistance(b, towerPos));
    return { unit: nearbyEnemyHeroes[0], type: 'HERO' };
  }

  // --- [3. íƒ€ì›Œ ë°ë¯¸ì§€ ì ìš©] ---
  static applyTowerDamage(
    target: { unit: any, type: 'HERO' | 'MINION' },
    towerStats: any,
    dt: number,
    isNexus: boolean,
    hasMinionsNearby: boolean
  ) {
    // ë„¥ì„œìŠ¤/íƒ€ì›Œ ê¸°ë³¸ ê³µê²©ë ¥ ëŒ€í­ ìƒí–¥
    const baseAtk = towerStats.atk || (isNexus ? 1000 : 400); 
    let damage = baseAtk * dt;

    // [ë°±ë„ì–´ ë°©ì§€] ì£¼ë³€ì— ë¯¸ë‹ˆì–¸ ì—†ì´ ì˜ì›… í˜¼ìë©´ ë°ë¯¸ì§€ 5ë°° (ì ˆëŒ€ ëª» ë²„í‹°ê²Œ)
    if (target.type === 'HERO' && !hasMinionsNearby) {
        damage *= 5.0; 
    }

    // [ì˜ì›… ëŒ€ìƒ ì¶”ê°€ í”¼í•´] ì²´ë ¥ ë¹„ë¡€ ë°ë¯¸ì§€ ì¶”ê°€ (íƒ±ì»¤ë„ ë…¹ê²Œ ë§Œë“¬)
    if (target.type === 'HERO') {
        const hpPercentDmg = target.unit.maxHp * 0.05 * dt; // ì´ˆë‹¹ 5% ì²´ë ¥ ë¹„ë¡€
        damage += hpPercentDmg;
    }

    // ë°©ì–´ë ¥ ì ìš©
    let armor = 0;
    if (target.type === 'HERO') {
        armor = (target.unit.level * 3) + 50; // ì˜ì›… ë°©ì–´ë ¥ ì¶”ì •ì¹˜
    }

    const realDamage = calcMitigatedDamage(damage, armor);

    if (target.type === 'HERO') {
        target.unit.currentHp -= realDamage;
    } else {
        target.unit.hp -= realDamage;
    }
  }
}



==========================================
FILE PATH: src/engine/match/logics/TowerLogic.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/logics/TowerLogic.ts
// ==========================================
import { LivePlayer, Minion, LiveMatch } from '../../../types';
import { getDistance } from '../../data/MapData';
import { calcMitigatedDamage } from './CombatLogic';

export class TowerLogic {
  static selectTarget(
    towerPos: { x: number, y: number },
    enemies: { heroes: LivePlayer[], minions: Minion[] },
    allies: LivePlayer[], 
    range: number,
    currentTime: number
  ): { unit: any, type: 'HERO' | 'MINION' } | null {
    
    const nearbyMinions = enemies.minions.filter(m => m.hp > 0 && getDistance(m, towerPos) <= range);
    const nearbyEnemyHeroes = enemies.heroes.filter(h => h.currentHp > 0 && h.respawnTimer <= 0 && getDistance(h, towerPos) <= range);

    if (nearbyMinions.length === 0 && nearbyEnemyHeroes.length === 0) return null;

    // 1. [ì–´ê·¸ë¡œ] ì•„êµ° ì˜ì›…ì„ ì¹œ ì  ì˜ì›…
    const AGGRO_DURATION = 2.0; 
    const aggroTarget = nearbyEnemyHeroes.find(enemy => {
        if (!enemy.lastAttackTime || !enemy.lastAttackedTargetId) return false;
        const timeSinceAttack = currentTime - enemy.lastAttackTime;
        if (timeSinceAttack > AGGRO_DURATION) return false;
        const victim = allies.find(a => a.heroId === enemy.lastAttackedTargetId);
        return !!victim;
    });

    if (aggroTarget) return { unit: aggroTarget, type: 'HERO' };

    // 2. ë¯¸ë‹ˆì–¸ (ê°€ê¹Œìš´ ìˆœ)
    if (nearbyMinions.length > 0) {
        nearbyMinions.sort((a, b) => getDistance(a, towerPos) - getDistance(b, towerPos));
        return { unit: nearbyMinions[0], type: 'MINION' };
    } 
    
    // 3. ì˜ì›… (ë¯¸ë‹ˆì–¸ ì—†ìœ¼ë©´)
    nearbyEnemyHeroes.sort((a, b) => getDistance(a, towerPos) - getDistance(b, towerPos));
    return { unit: nearbyEnemyHeroes[0], type: 'HERO' };
  }

  static applyDamage(
    match: LiveMatch,
    target: { unit: any, type: 'HERO' | 'MINION' },
    towerStats: any,
    dt: number,
    isNexus: boolean,
    hasMinionsNearby: boolean,
    defendingTeamColor: 'BLUE' | 'RED'
  ) {
    const baseAtk = towerStats.atk || (isNexus ? 1000 : 300);
    
    // ê¸°ë³¸ íƒ€ì›Œ ê³µê²©ë ¥
    let damage = baseAtk * dt;

    // [ë°±ë„ì–´ íŒ¨ë„í‹°] ë¯¸ë‹ˆì–¸ ì—†ì´ ì˜ì›… í˜¼ìë©´ ë°ë¯¸ì§€ 3ë°° (ë§¤ìš° ì•„í””)
    if (target.type === 'HERO' && !hasMinionsNearby) {
        damage *= 3.0;
    }

    if (target.type === 'HERO') {
        // ì˜ì›… ë°©ì–´ë ¥ ì ìš©
        let armor = (target.unit.level * 3) + (target.unit.items?.length * 10);
        const realDmg = calcMitigatedDamage(damage, armor);
        
        target.unit.currentHp -= realDmg;
        
        if (target.unit.currentHp <= 0) {
            target.unit.currentHp = 0;
            // ë¶€í™œ ì‹œê°„: 5ì´ˆ + ë ˆë²¨ë‹¹ 3ì´ˆ (ìì—°ìŠ¤ëŸ¬ìš´ ì¦ê°€)
            const respawnTime = 5 + (target.unit.level * 3);
            target.unit.respawnTimer = Math.floor(respawnTime);

            if (defendingTeamColor === 'BLUE') match.score.blue++;
            else match.score.red++;

            target.unit.deaths++;
            
            match.logs.push({
                time: Math.floor(match.currentDuration),
                message: `ğŸ’€ [${target.unit.name}] íƒ€ì›Œì— ì²˜í˜•ë‹¹í–ˆìŠµë‹ˆë‹¤!`,
                type: 'KILL',
                team: defendingTeamColor
            });
        }
    } else {
        // ë¯¸ë‹ˆì–¸ì€ ë°©ì–´ë ¥ 0ìœ¼ë¡œ ê°€ì •í•˜ê³  ë”œ ë°•í˜ (ìˆœì‚­ ë°©ì§€ ìœ„í•´ ë¯¸ë‹ˆì–¸ ì²´ë ¥ ì„¸íŒ… ì¤‘ìš”)
        target.unit.hp -= damage;
    }
  }
}



==========================================
FILE PATH: src/engine/match/MatchCreator.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/MatchCreator.ts
// ==========================================
import { Hero, LiveMatch, LivePlayer, TierConfig } from '../../types';
import { userPool, getTierNameHelper } from '../system/UserManager';
import { useGameStore } from '../../store/useGameStore';

export function createLiveMatches(heroes: Hero[], ccu: number, currentTime: number, config: TierConfig): LiveMatch[] {
  const idleUsers = userPool.filter(u => u.status === 'IDLE');
  if (idleUsers.length < 10) return [];

  const matchesToMake = Math.min(Math.floor(idleUsers.length / 10), 100); 
  const newMatches: LiveMatch[] = [];
  const candidates = [...idleUsers].sort(() => Math.random() - 0.5);

  const state = useGameStore.getState().gameState;
  const positions = state.fieldSettings.positions; 

  const blueBase = positions.towers.blue.nexus;
  const redBase = positions.towers.red.nexus;
  
  const t1Hp = state.fieldSettings.towers?.t1?.hp || 5000;
  const nexusHp = state.fieldSettings.towers?.nexus?.hp || 30000;

  for (let i = 0; i < matchesToMake; i++) {
    const batch = candidates.slice(i * 10, (i + 1) * 10);

    const createPlayer = (user: any, idx: number, isBlue: boolean): LivePlayer => {
      const lanes = ['TOP', 'JUNGLE', 'MID', 'BOT', 'BOT']; 
      const lane = lanes[idx] as any;
      const base = isBlue ? blueBase : redBase;

      return {
        name: user.name, heroId: '', 
        kills: 0, deaths: 0, assists: 0, 
        gold: 500, totalGold: 500, // [ìˆ˜ì •] ì´ˆê¸° ê³¨ë“œ ì„¤ì •
        cs: 0, totalDamageDealt: 0, 
        currentHp: 1000, maxHp: 1000, currentMp: 300, maxMp: 300, mpRegen: 5,
        level: 1, items: [], 
        x: base.x, y: base.y, 
        lane: lane, buffs: [], mmr: user.hiddenMmr, respawnTimer: 0,
        stats: { brain: user.brain || 50, mechanics: user.mechanics || 50 },
        cooldowns: { q: 0, w: 0, e: 0, r: 0 },
        isRecalling: false,
        currentRecallTime: 0,
        recallCooldown: 0,
        killStreak: 0,
        bounty: 0
      };
    };

    const blueUsers = batch.slice(0, 5);
    const redUsers = batch.slice(5, 10);
    batch.forEach(u => u.status = 'INGAME');

    const jungleMobs = positions.jungle.map((pos, idx) => ({
        id: `jungle_${idx}`, campId: idx, type: idx % 2 === 0 ? 'WOLF' : 'GOLEM',
        x: pos.x, y: pos.y, 
        hp: 1000, maxHp: 1000, atk: 50, respawnTimer: 0, isAlive: true
    }));

    newMatches.push({
      id: `m_${currentTime}_${Math.random().toString(36).substr(2, 5)}`,
      status: 'DRAFTING', 
      draft: { isBlueTurn: true, turnIndex: 0, timer: 10, decisionTime: 5, phase: 'BAN' },
      bans: { blue: [], red: [] }, 
      blueTeam: blueUsers.map((u, i) => createPlayer(u, i, true)),
      redTeam: redUsers.map((u, i) => createPlayer(u, i, false)),
      startTime: currentTime, duration: 3600, currentDuration: 0, 
      score: { blue: 0, red: 0 }, 
      stats: {
        blue: { 
            towers: {top:0,mid:0,bot:0}, laneHealth: {top:t1Hp, mid:t1Hp, bot:t1Hp},
            colossus: 0, watcher: 0, fury: 0, nexusHp: nexusHp, maxNexusHp: nexusHp, activeBuffs: { siegeUnit: false, voidPower: false } 
        },
        red: { 
            towers: {top:0,mid:0,bot:0}, laneHealth: {top:t1Hp, mid:t1Hp, bot:t1Hp},
            colossus: 0, watcher: 0, fury: 0, nexusHp: nexusHp, maxNexusHp: nexusHp, activeBuffs: { siegeUnit: false, voidPower: false } 
        }
      },
      timeline: [], avgTier: getTierNameHelper(batch[0].score, config), logs: [], 
      
      nextColossusSpawnTime: state.fieldSettings.colossus.initialSpawnTime, 
      nextWatcherSpawnTime: state.fieldSettings.watcher.initialSpawnTime,
      objectives: {
        colossus: { hp: 0, maxHp: 10000, status: 'DEAD', nextSpawnTime: state.fieldSettings.colossus.initialSpawnTime },
        watcher: { hp: 0, maxHp: 10000, status: 'DEAD', nextSpawnTime: state.fieldSettings.watcher.initialSpawnTime }
      },
      minions: [], projectiles: [], 
      jungleMobs: jungleMobs as any,
      visualEffects: []
    });
  }
  return newMatches;
}



==========================================
FILE PATH: src/engine/match/MatchSettlement.ts
==========================================
import { Hero, LiveMatch, LivePlayer, TierConfig } from '../../types';
import { userPool } from '../system/UserManager';

const getNextTierInfo = (currentScore: number, config: TierConfig) => {
  // Configê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©
  if (!config) return null;
  if (currentScore < config.bronze) return { name: 'ë¸Œë¡ ì¦ˆ', cut: config.bronze, key: 'bronze' };
  if (currentScore < config.silver) return { name: 'ì‹¤ë²„', cut: config.silver, key: 'silver' };
  if (currentScore < config.gold) return { name: 'ê³¨ë“œ', cut: config.gold, key: 'gold' };
  if (currentScore < config.joker) return { name: 'ì¡°ì»¤', cut: config.joker, key: 'joker' };
  if (currentScore < config.ace) return { name: 'ì—ì´ìŠ¤', cut: config.ace, key: 'ace' };
  if (currentScore < config.master) return { name: 'ë§ˆìŠ¤í„°', cut: config.master, key: 'master' };
  return null; 
};

export function finishMatch(
  match: LiveMatch, 
  heroes: Hero[], 
  day: number, 
  hour: number, 
  battleSettings: any,
  tierConfig: TierConfig
) {
  // [Safety] í•„ìˆ˜ ë°ì´í„° ê²€ì¦
  if (!match || !match.stats || !match.score) return { isBlueWin: false, blueKills: 0, redKills: 0, duration: 0 };

  let isBlueWin = match.score.blue > match.score.red;
  if (match.stats.red.nexusHp <= 0) isBlueWin = true;       
  else if (match.stats.blue.nexusHp <= 0) isBlueWin = false; 

  const blueKills = match.blueTeam.reduce((sum, p) => sum + (p.kills || 0), 0);
  const redKills = match.redTeam.reduce((sum, p) => sum + (p.kills || 0), 0);

  // [Safety] ìœ ì € í’€ì´ ë¹„ì–´ìˆìœ¼ë©´ ì •ì‚° ì¤‘ë‹¨
  if (!userPool) return { isBlueWin, blueKills, redKills, duration: match.currentDuration };

  const participantNames = new Set([...match.blueTeam, ...match.redTeam].map(p => p.name));

  userPool.forEach(u => {
    if (u && participantNames.has(u.name)) {
      u.status = 'RESTING';
      u.restTimer = 5 + Math.floor(Math.random() * 5); 
    }
  });

  // ë°´ í†µê³„
  const allBans = [...(match.bans?.blue || []), ...(match.bans?.red || [])];
  allBans.forEach(banId => {
    if (banId) {
        const hero = heroes.find(h => h.id === banId);
        if (hero && hero.record) hero.record.totalBans++; 
    }
  });

  const processTeam = (team: LivePlayer[], win: boolean) => {
    if (!Array.isArray(team)) return;

    team.forEach(player => {
      const hero = heroes.find(h => h.id === player.heroId);
      // ìœ ì € ì°¾ê¸° (ì—†ì–´ë„ ì£½ì§€ ì•Šê²Œ ì²˜ë¦¬)
      const user = userPool.find(u => u && u.name === player.name) as any;

      if (hero && hero.record) {
        hero.record.totalMatches++; 
        hero.record.totalPicks++; 
        if (win) hero.record.totalWins++;

        hero.record.totalKills += (player.kills || 0); 
        hero.record.totalDeaths += (player.deaths || 0); 
        hero.record.totalAssists += (player.assists || 0); 

        const itemsValue = (player.items || []).reduce((sum, item) => sum + (item.cost || 0), 0);
        hero.record.totalGold += ((player.gold || 0) + itemsValue);
        hero.record.totalDamage += (player.totalDamageDealt || 0); 
        hero.record.totalCs += (player.cs || 0);

        if (!hero.record.recentResults) hero.record.recentResults = [];
        hero.record.recentResults.push(win); 
        if (hero.record.recentResults.length > 1000) hero.record.recentResults.shift();
      }

      if (user) {
        // [Safety] ìœ ì € ë°ì´í„° êµ¬ì¡° ë³´ì¥
        if (!user.history) user.history = [];
        if (!user.heroStats) user.heroStats = {};

        user.wins += win ? 1 : 0; 
        user.losses += win ? 0 : 1;

        let lpChange = win ? 25 : -20;
        let kdaStr = `${player.kills}/${player.deaths}/${player.assists}`;
        let historyMsg = win ? 'WIN' : 'LOSE';

        if (user.promoStatus) {
            lpChange = 0; 
            if (win) {
                user.promoStatus.wins++;
                historyMsg = 'PROMO WIN';
                if (user.promoStatus.wins >= user.promoStatus.targetWins) {
                    const nextTier = getNextTierInfo(user.score, tierConfig);
                    if (nextTier) {
                        user.score = nextTier.cut + 50; 
                        historyMsg = `ğŸ‰ ìŠ¹ê¸‰! (${nextTier.name})`;
                    }
                    user.promoStatus = null;
                }
            } else {
                user.promoStatus.losses++;
                historyMsg = 'PROMO LOSS';
                const totalGames = user.promoStatus.targetWins * 2 - 1;
                const maxLosses = totalGames - user.promoStatus.targetWins + 1;
                if (user.promoStatus.losses >= maxLosses) {
                    user.score -= 40; 
                    historyMsg = 'âŒ ìŠ¹ê¸‰ ì‹¤íŒ¨';
                    user.promoStatus = null;
                }
            }
        } else {
            const oldScore = user.score || 0;
            user.score = Math.max(0, oldScore + lpChange);
            const nextTier = getNextTierInfo(oldScore, tierConfig);
            if (nextTier && user.score >= nextTier.cut) {
                user.score = nextTier.cut - 1; 
                const promoMatches = tierConfig.promos ? (tierConfig.promos[nextTier.key as keyof typeof tierConfig.promos] || 3) : 3;
                user.promoStatus = {
                    targetTier: nextTier.name,
                    wins: 0,
                    losses: 0,
                    targetWins: Math.ceil(promoMatches / 2)
                };
                historyMsg = `ğŸ”¥ ${nextTier.name} ìŠ¹ê¸‰ì „!`;
            }
        }

        user.history.unshift({ 
          season: 1, 
          result: historyMsg, 
          heroName: hero?.name || 'Unknown', 
          kda: kdaStr, 
          lpChange: lpChange, 
          date: `Day ${day} ${hour}:00` 
        });
        if (user.history.length > 20) user.history.pop();

        if (!user.heroStats[player.heroId]) user.heroStats[player.heroId] = { matches:0, wins:0, kills:0, deaths:0, assists:0 };
        const st = user.heroStats[player.heroId];
        st.matches++; if(win) st.wins++; st.kills+=player.kills; st.deaths+=player.deaths; st.assists+=player.assists;
      }
    });
  };

  try {
    processTeam(match.blueTeam, isBlueWin);
    processTeam(match.redTeam, !isBlueWin);
  } catch (err) {
    console.error("Error in match settlement:", err);
  }

  return { isBlueWin, blueKills, redKills, duration: match.currentDuration };
}



==========================================
FILE PATH: src/engine/match/MatchUpdater.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/MatchUpdater.ts
// ==========================================
import { Hero, LiveMatch } from '../../types';
import { useGameStore } from '../../store/useGameStore';

import { processDraftTurn } from './systems/BanPickEngine'; 
import { updatePlayerBehavior } from './systems/PlayerSystem'; 
import { updateNeutralObjectives } from './systems/ObjectiveSystem'; 
import { processGrowthPhase } from './phases/GrowthPhase';
import { processSiegePhase } from './phases/SiegePhase';
import { processCombatPhase } from './phases/CombatPhase';
import { updateLivePlayerStats } from './systems/ItemManager'; 
import { BASES } from '../data/MapData';

import { MinionSystem } from './systems/MinionSystem';
import { JungleSystem } from './systems/JungleSystem';
import { ProjectileSystem } from './systems/ProjectileSystem';
import { ColossusLogic } from './logics/ColossusLogic';
import { VisualSystem } from './systems/VisualSystem';

export function updateLiveMatches(matches: LiveMatch[], heroes: Hero[], delta: number): LiveMatch[] {
  const state = useGameStore.getState();
  const shopItems = state.shopItems || []; 
  const gameSpeed = state.gameState.gameSpeed;
  const isHighSpeed = gameSpeed > 5;

  const { battleSettings, fieldSettings, roleSettings } = state.gameState;

  // [ì•ˆì „ì¥ì¹˜] ì„¤ì •ê°’ ëˆ„ë½ ë°©ì§€
  const safeField = fieldSettings || { 
    colossus: { hp: 15000, armor: 80, rewardGold: 100, respawnTime: 300, attack: 50 },
    watcher: { hp: 20000, armor: 120, rewardGold: 150, buffType: 'COMBAT', buffAmount: 20, buffDuration: 180, respawnTime: 420 }, 
    tower: { hp: 30000, armor: 200, rewardGold: 150 }, 
    jungle: { density: 50, yield: 50, attack: 30, defense: 20, threat: 0, xp: 160, gold: 80 }
  };

  const safeRole = roleSettings || {
    executor: { damage: 15, defense: 15 },
    tracker: { gold: 20, smiteChance: 1.5 },
    prophet: { cdrPerLevel: 2 },
    slayer: { structureDamage: 30 },
    guardian: { survivalRate: 20 }
  };

  return matches.map(m => {
    if (!Array.isArray(m.minions)) m.minions = [];
    if (!Array.isArray(m.projectiles)) m.projectiles = [];
    if (!Array.isArray(m.jungleMobs)) m.jungleMobs = [];
    if (!Array.isArray(m.logs)) m.logs = [];
    if (!Array.isArray(m.visualEffects)) m.visualEffects = [];

    if (isHighSpeed && m.status === 'PLAYING') {
       if (m.logs.length > 0) m.logs = [];
       if (m.visualEffects.length > 0) m.visualEffects = [];
    }

    const match = { ...m, logs: [...m.logs], blueTeam: [...m.blueTeam], redTeam: [...m.redTeam] };

    // [í•µì‹¬] ì§„í–‰ ì¤‘ì¸ ê²Œì„ ë°ì´í„° ë§ˆì´ê·¸ë ˆì´ì…˜ (Total Gold ë³µêµ¬)
    [...match.blueTeam, ...match.redTeam].forEach(p => {
        // totalGoldê°€ ì—†ê±°ë‚˜ ì´ìƒí•˜ë©´ ë³µêµ¬ (í˜„ì¬ ê³¨ë“œ + ì•„ì´í…œ ê°€ì¹˜)
        if (p.totalGold === undefined || p.totalGold < p.gold) {
            const itemValue = p.items.reduce((sum, i) => sum + (i.cost || 0), 0);
            p.totalGold = Math.floor(p.gold + itemValue);
        }
        // ì¢Œí‘œ NaN ë°©ì§€
        if (isNaN(p.x)) p.x = 50;
        if (isNaN(p.y)) p.y = 50;
    });

    if (match.stats.blue.nexusHp <= 0 || match.stats.red.nexusHp <= 0) {
        return match;
    }

    if (match.status === 'DRAFTING') {
       if (!match.draft) return match;
       match.draft.timer -= delta;
       let loopGuard = 0;
       
       while (match.draft.timer <= 0 && match.status === 'DRAFTING' && loopGuard < 25) {
           loopGuard++;
           processDraftTurn(match, heroes, 50);
           match.draft.turnIndex++;
           const nextDecisionTime = 2 + Math.random() * 8;
           match.draft.timer += (30 + nextDecisionTime);
           match.draft.decisionTime = nextDecisionTime; 

           if (match.draft.turnIndex >= 20) {
               match.status = 'PLAYING';
               if (!isHighSpeed) {
                   match.logs.push({ time: 0, message: "ë¯¸ë‹ˆì–¸ ìƒì„±! ì „êµ° ì¶œê²©!", type: 'START' });
               }

               const initPlayer = (p: any, isBlue: boolean) => {
                   const h = heroes.find(x => x.id === p.heroId);
                   if(h) { 
                       p.level = 1; p.items = []; (p as any).exp = 0;
                       updateLivePlayerStats(p, h);
                       p.currentHp = p.maxHp; p.currentMp = p.maxMp; p.respawnTimer = 0;
                       p.totalDamageDealt = 0;
                       p.x = isBlue ? BASES.BLUE.x : BASES.RED.x;
                       p.y = isBlue ? BASES.BLUE.y : BASES.RED.y;
                       (p as any).pathIdx = 0;
                       p.cooldowns = { q:0, w:0, e:0, r:0 };
                       p.isRecalling = false;
                       p.currentRecallTime = 0;
                       p.killStreak = 0;
                       p.bounty = 0;
                       p.totalGold = 500; // ì´ˆê¸° ê³¨ë“œ ì„¤ì •
                   }
               };
               match.blueTeam.forEach(p => initPlayer(p, true));
               match.redTeam.forEach(p => initPlayer(p, false));
               
               match.minions = []; match.projectiles = []; match.jungleMobs = [];
               break; 
           }
       }
       return match;
    }

    match.currentDuration += delta;

    processGrowthPhase(match, battleSettings, safeField, heroes, delta);
    updateNeutralObjectives(match, safeField, delta);

    [...match.blueTeam, ...match.redTeam].forEach(player => {
        updatePlayerBehavior(player, match, heroes, shopItems, safeRole, delta);
    });

    processSiegePhase(match, heroes, safeField, safeRole, battleSettings, delta);

    const watcherSettings = safeField.watcher;
    processCombatPhase(
        match, heroes, battleSettings, safeRole, 
        watcherSettings?.buffType || 'COMBAT', 
        watcherSettings?.buffAmount || 20, 
        delta
    );

    if (match.minions) {
        match.minions.forEach(m => {
            if (m.type === 'SUMMONED_COLOSSUS') {
                ColossusLogic.update(m, match, battleSettings, delta);
            }
        });
    }

    MinionSystem.update(match, battleSettings, delta, heroes);
    JungleSystem.update(match, delta);
    ProjectileSystem.update(match, delta);
    
    if (!isHighSpeed) {
        VisualSystem.update(match, delta);
    }

    return match;
  });
}



==========================================
FILE PATH: src/engine/match/phases/CombatPhase.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/phases/CombatPhase.ts
// ==========================================
import { LiveMatch, Hero, BattleSettings, RoleSettings } from '../../../types';
import { getLevelScaledStats } from '../utils/StatUtils';
import { TargetEvaluator } from '../ai/evaluators/TargetEvaluator';
import { Collision } from '../utils/Collision';
import { 
    calculateHeroDamage, 
    calculateUnitDamage, 
    distributeAssist, 
    distributeRewards,
    MINION_REWARD 
} from '../logics/CombatLogic';
import { PersonalMemory } from '../ai/memory/PersonalMemory';

// [ìˆ˜ì •] Grid ì‹œìŠ¤í…œ ì œê±° -> ì•ˆì •ì ì¸ ë°°ì—´ ìˆœíšŒ ë°©ì‹ìœ¼ë¡œ ë¡¤ë°±
export const processCombatPhase = (
  match: LiveMatch, 
  heroes: Hero[], 
  settings: BattleSettings, 
  roleSettings: RoleSettings, 
  watcherBuffType: string, 
  watcherBuffAmount: number,
  dt: number
) => {
  const blueAlive = match.blueTeam.filter(p => p.currentHp > 0 && p.respawnTimer <= 0);
  const redAlive = match.redTeam.filter(p => p.currentHp > 0 && p.respawnTimer <= 0);

  if (blueAlive.length === 0 && redAlive.length === 0) return;

  // ëª¨ë“  ì‚´ì•„ìˆëŠ” ìœ ë‹› ì„ì–´ì„œ ìˆœì°¨ ì²˜ë¦¬ (ê³µí‰ì„±)
  const allAttackers = [...blueAlive, ...redAlive];
  // Fisher-Yates Shuffleë¡œ ëœë¤ì„± í™•ë³´
  for (let i = allAttackers.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [allAttackers[i], allAttackers[j]] = [allAttackers[j], allAttackers[i]];
  }

  allAttackers.forEach(attacker => {
      const isBlue = match.blueTeam.includes(attacker);
      // ì êµ° ë¦¬ìŠ¤íŠ¸ ì‹ë³„
      const enemies = isBlue ? redAlive : blueAlive;
      const enemyMinions = match.minions ? match.minions.filter(m => m.team !== (isBlue ? 'BLUE' : 'RED') && m.hp > 0) : [];

      const attackerHero = heroes.find(h => h.id === attacker.heroId);
      if (!attackerHero) return;

      const atkStats = getLevelScaledStats(attackerHero.stats, attacker.level);
      // ì‚¬ê±°ë¦¬ (í”½ì…€ ë‹¨ìœ„ ë³€í™˜)
      const attackRange = atkStats.range / 100;

      let farmed = false;

      // 1. [ë¯¸ë‹ˆì–¸ ê³µê²©] - ë¼ì¸ í´ë¦¬ì–´
      if (match.minions && attacker.lane !== 'JUNGLE') {
          // ì‚¬ê±°ë¦¬ ë‚´ ë¯¸ë‹ˆì–¸ í•„í„°ë§
          const minionsInRange = enemyMinions.filter(m => Collision.inRange(attacker, m, attackRange));

          if (minionsInRange.length > 0) {
              const myDamage = calculateUnitDamage(attacker, atkStats, 5, isBlue, settings);
              let executeThreshold = myDamage * 2.5; 
              
              const targetMinion = TargetEvaluator.selectFarmTarget(attacker, minionsInRange, executeThreshold);

              if (targetMinion) {
                  // [ì´í™íŠ¸ ì œê±°ë¨] í‰íƒ€ íˆ¬ì‚¬ì²´ ì½”ë“œ ì‚­ì œ

                  // ë°ë¯¸ì§€ ì ìš©
                  if (targetMinion.hp <= executeThreshold) targetMinion.hp = 0; 
                  else targetMinion.hp -= myDamage;
                  
                  attacker.totalDamageDealt += myDamage;

                  if (targetMinion.hp <= 0) {
                      const reward = (MINION_REWARD as any)[targetMinion.type] || MINION_REWARD.MELEE;
                      attacker.cs++;
                      attacker.gold += reward.gold;
                      distributeRewards(match, targetMinion, attacker, isBlue ? 'BLUE' : 'RED', reward, heroes);
                  }
                  farmed = true;
              }
          }
      }

      // ë¯¸ë‹ˆì–¸ì„ ì•ˆ ì³¤ìœ¼ë©´ ì˜ì›… ê³µê²© ì‹œë„
      if (!farmed) {
          // ê³µì† ì‹œë®¬ë ˆì´ì…˜ (ê°„ë‹¨í•˜ê²Œ í”„ë ˆì„ í™•ë¥ ë¡œ ì²˜ë¦¬)
          if (Math.random() < dt * 2.0) {
              // ì‚¬ê±°ë¦¬ ë‚´ ì  ì˜ì›… í•„í„°ë§
              const targetsInRange = enemies.filter(e => Collision.inRange(attacker, e, attackRange));

              if (targetsInRange.length > 0) {
                  const defender = TargetEvaluator.selectBestTarget(attacker, attackerHero, targetsInRange, heroes, match);
                  
                  if (defender) {
                    // [ì´í™íŠ¸ ì œê±°ë¨] í‰íƒ€ íˆ¬ì‚¬ì²´ ì½”ë“œ ì‚­ì œ

                    attacker.lastAttackTime = match.currentDuration;
                    attacker.lastAttackedTargetId = defender.heroId;

                    const defenderHero = heroes.find(h => h.id === defender.heroId);
                    if (defenderHero) {
                        const defStats = getLevelScaledStats(defenderHero.stats, defender.level);
                        const damage = calculateHeroDamage(attacker, defender, atkStats, defStats, attackerHero, isBlue, settings, roleSettings, watcherBuffType);
                        
                        defender.currentHp -= damage;
                        attacker.totalDamageDealt += damage;

                        // [ì´í™íŠ¸ ì œê±°ë¨] í”¼ê²© íš¨ê³¼ ì‚­ì œ

                        if (defender.currentHp <= 0) {
                            attacker.kills++; defender.deaths++; attacker.gold += 300;
                            attacker.killStreak++;
                            defender.killStreak = 0; 
                            PersonalMemory.recordEvent(attacker, defender);
                            distributeAssist(match, attacker, defender, isBlue);
                            
                            if (isBlue) match.score.blue++; else match.score.red++;
                            
                            match.logs.push({ 
                                time: Math.floor(match.currentDuration), 
                                message: `ğŸ’€ [${attackerHero.name}]ê°€ [${defenderHero.name}] ì²˜ì¹˜!`, 
                                type: 'KILL', team: isBlue ? 'BLUE' : 'RED' 
                            });
                            
                            defender.currentHp = 0;
                            defender.respawnTimer = 10 + (defender.level * 2);
                        }
                    }
                  }
              }
          }
      }
  });
};



==========================================
FILE PATH: src/engine/match/phases/GrowthPhase.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/phases/GrowthPhase.ts
// ==========================================
import { LiveMatch, BattleSettings, Hero, BattlefieldSettings } from '../../../types';
import { updateLivePlayerStats } from '../systems/ItemManager';

const getRequiredExpForLevel = (level: number): number => {
  if (level >= 18) return 999999;
  return 250 + (level * 90) + (Math.pow(level, 2) * 5);
};

export const processGrowthPhase = (
  match: LiveMatch, 
  battleSettings: BattleSettings,
  fieldSettings: BattlefieldSettings,
  heroes: Hero[], 
  dt: number
) => {
  const allPlayers = [...match.blueTeam, ...match.redTeam];

  allPlayers.forEach(p => {
    // ì•ˆì „ì¥ì¹˜: totalGold ì´ˆê¸°í™”
    if (p.totalGold === undefined) p.totalGold = p.gold;

    // ë¶€í™œ ë¡œì§
    if (p.respawnTimer > 0) {
        p.respawnTimer -= dt;
        p.isRecalling = false;
        p.currentRecallTime = 0;
        
        if (p.respawnTimer <= 0) {
            p.respawnTimer = 0;
            const heroData = heroes.find(h => h.id === p.heroId);
            if (heroData) updateLivePlayerStats(p, heroData);
            p.currentHp = p.maxHp;
            p.currentMp = p.maxMp;
            
            // ë³¸ì§„ ì¢Œí‘œë¡œ ë³µê·€
            if (match.blueTeam.includes(p)) { p.x = 5; p.y = 95; } 
            else { p.x = 95; p.y = 5; }
            
            (p as any).pathIdx = 0;
            (p as any)._prevHp = p.maxHp;
        }
        return; 
    }

    const heroData = heroes.find(h => h.id === p.heroId);
    if (!heroData) return;

    const mpRegen = p.mpRegen || 5;
    const hpRegen = (p as any).hpRegen || heroData.stats.regen; 

    if (p.currentMp < p.maxMp) p.currentMp = Math.min(p.maxMp, p.currentMp + (mpRegen * dt));
    if (p.currentHp < p.maxHp) p.currentHp = Math.min(p.maxHp, p.currentHp + (hpRegen * dt));

    // [ìˆ˜ì •] ìì—° ê³¨ë“œ ì¦ê°€ (ì´ˆë‹¹ 2ì›) + ëˆ„ì  ê³¨ë“œì—ë„ ë°˜ì˜
    const passiveGold = 2.0 * dt;
    p.gold += passiveGold;
    p.totalGold += passiveGold;
    
    // [ìˆ˜ì •] ìì—° ê²½í—˜ì¹˜ ëŒ€í­ ìƒí–¥ (3.0 -> 6.0)
    // ì‹¸ì›€ë§Œ í•˜ëŠë¼ íŒŒë° ëª»í•´ë„ ë ˆë²¨ì€ ì˜¤ë¥´ê²Œ í•¨
    (p as any).exp = ((p as any).exp || 0) + (6.0 * dt);

    // ë ˆë²¨ì—… ë¡œì§
    let reqExp = getRequiredExpForLevel(p.level);
    while ((p as any).exp >= reqExp && p.level < 18) {
        (p as any).exp -= reqExp;
        p.level++;

        const oldMaxHp = p.maxHp;
        const oldMaxMp = p.maxMp;

        updateLivePlayerStats(p, heroData);

        // ë ˆë²¨ì—… ì‹œ ì²´ë ¥/ë§ˆë‚˜ íšŒë³µ
        p.currentHp += (p.maxHp - oldMaxHp) + 300; 
        p.currentMp += (p.maxMp - oldMaxMp) + 150;

        match.logs.push({
            time: Math.floor(match.currentDuration),
            message: `ğŸ†™ [${heroData.name}] ${p.level}ë ˆë²¨ ë‹¬ì„±!`,
            type: 'LEVELUP',
            team: match.blueTeam.includes(p) ? 'BLUE' : 'RED'
        });

        reqExp = getRequiredExpForLevel(p.level);
    }
  });
};



==========================================
FILE PATH: src/engine/match/phases/SiegePhase.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/phases/SiegePhase.ts
// ==========================================
import { LiveMatch, Hero, RoleSettings, BattlefieldSettings, BattleSettings } from '../../../types';
import { applyRoleBonus } from '../systems/RoleManager';
import { getDistance, BASES } from '../../data/MapData';
import { TOWER_COORDS } from '../constants/MapConstants';
import { TowerLogic } from '../logics/TowerLogic';
import { calcMitigatedDamage } from '../systems/DamageCalculator';

const getTowerPos = (lane: string, tier: number, isBlueSide: boolean) => {
  const coords = isBlueSide ? TOWER_COORDS.BLUE : TOWER_COORDS.RED;
  if (lane === 'MID') return coords.MID[tier - 1];
  if (lane === 'TOP') return coords.TOP[tier - 1];
  if (lane === 'BOT') return coords.BOT[tier - 1];
  return coords.NEXUS;
};

const LOGIC_TOWER_RANGE = 12; 
const LOGIC_NEXUS_RANGE = 15;

export const processSiegePhase = (
  match: LiveMatch, 
  heroes: Hero[], 
  fieldSettings: BattlefieldSettings,
  roleSettings: RoleSettings, 
  battleSettings: BattleSettings, 
  dt: number
) => {
  const allPlayers = [...match.blueTeam, ...match.redTeam];

  // 1. [ê³µê²©] ì±”í”¼ì–¸ -> íƒ€ì›Œ
  allPlayers.forEach(p => {
    if (p.currentHp <= 0 || p.respawnTimer > 0) return;

    const isBlue = match.blueTeam.includes(p);
    const enemyStats = isBlue ? match.stats.red : match.stats.blue;
    const enemyBase = isBlue ? BASES.RED : BASES.BLUE;
    
    const hero = heroes.find(h => h.id === p.heroId);
    if (!hero) return;

    // ì•„ì´í…œ ìŠ¤íƒ¯ ê³„ì‚° (ì‹¤ì‹œê°„)
    const itemAD = p.items.reduce((sum, i) => sum + (i.ad || 0), 0);
    const itemAP = p.items.reduce((sum, i) => sum + (i.ap || 0), 0);
    
    // [ìì—°ìŠ¤ëŸ¬ìš´ ì„±ì¥] 
    // ì´ ê³µê²©ë ¥ = (ê¸°ë³¸AD + ì•„ì´í…œAD) + (ì£¼ë¬¸ë ¥ì˜ 60% - ë§ˆë²•ì‚¬ë„ íƒ€ì›Œ ì² ê±° ê°€ëŠ¥)
    const totalAD = hero.stats.ad + itemAD;
    const structureDmg = totalAD + (itemAP * 0.6);

    // íƒ€ì›Œ ê³µê²© ë¡œì§ (ì •ê¸€ëŸ¬ë„ íƒ€ì›Œ ì¹  ìˆ˜ ìˆìŒ)
    const laneKey = p.lane.toLowerCase();
    
    // [ì¤‘ìš”] ë‚´ ë¼ì¸ì˜ íƒ€ì›Œë¥¼ ìš°ì„ ì ìœ¼ë¡œ ì°¾ìŒ
    if (p.lane !== 'JUNGLE') {
        const brokenCount = (enemyStats.towers as any)[laneKey];

        if (brokenCount < 3) {
            const targetTier = brokenCount + 1;
            const towerPos = getTowerPos(p.lane, targetTier, !isBlue);
            const dist = getDistance(p, towerPos);

            // ì‚¬ê±°ë¦¬ + 3.0 (íƒ€ì›Œ í¬ê¸° ê³ ë ¤)
            if (dist <= (hero.stats.range / 100) + 3.0) {
                const tStats = (fieldSettings.towers as any)[`t${targetTier}`];
                const { siegeMod } = applyRoleBonus(p, hero.role, true, [], roleSettings);
                
                // ê³µì„± ë²„í”„ (ê±°ì‹ ë³‘)
                const myStats = isBlue ? match.stats.blue : match.stats.red;
                const buffFactor = myStats.activeBuffs.siegeUnit ? 1.3 : 1.0; 

                // [ìˆœìˆ˜ ë¬¼ë¦¬ ì—”ì§„]
                // íƒ€ì›Œ ë°©ì–´ë ¥ ì ìš© (ì´ˆë°˜ì—” íƒ€ì›Œ ë°©ì–´ë ¥ì´ ë†’ì•„ì„œ ë°ë¯¸ì§€ê°€ ì ê²Œ ë“¤ì–´ê°)
                // í›„ë°˜ì— ì˜ì›… ê³µê²©ë ¥ì´ ë†’ì•„ì§€ë©´ ìì—°ìŠ¤ëŸ½ê²Œ ëš«ë¦¼
                let realDmg = calcMitigatedDamage(structureDmg * siegeMod * buffFactor, tStats.armor) * dt;
                
                // ê³µì† ë°˜ì˜ (1.0 ê¸°ì¤€)
                // (ì—¬ê¸°ì„œëŠ” dt ê¸°ë°˜ ì‹œë®¬ë ˆì´ì…˜ì´ë¼ ë‹¨ìˆœí™”)
                
                if (!(enemyStats as any).laneHealth) {
                    (enemyStats as any).laneHealth = { top: 10000, mid: 10000, bot: 10000 };
                }
                
                (enemyStats as any).laneHealth[laneKey] -= realDmg;

                if ((enemyStats as any).laneHealth[laneKey] <= 0) {
                    (enemyStats.towers as any)[laneKey]++;
                    (isBlue ? match.blueTeam : match.redTeam).forEach(m => m.gold += tStats.rewardGold);
                    
                    match.logs.push({ 
                        time: Math.floor(match.currentDuration), 
                        message: `ğŸ”¥ [${hero.name}] ${targetTier}ì°¨ í¬íƒ‘ ì² ê±°!`, 
                        type: 'TOWER', team: isBlue ? 'BLUE' : 'RED' 
                    });
                    
                    if (brokenCount + 1 < 3) {
                        const nextStats = (fieldSettings.towers as any)[`t${targetTier + 1}`];
                        (enemyStats as any).laneHealth[laneKey] = nextStats.hp;
                    }
                }
            }
        }
    }

    // ë„¥ì„œìŠ¤ ê³µê²©
    const inhibitorsDown = enemyStats.towers.top >= 3 || enemyStats.towers.mid >= 3 || enemyStats.towers.bot >= 3;
    if (inhibitorsDown) {
        const distToNexus = getDistance(p, enemyBase);
        if (distToNexus <= 14) { 
            const nStats = fieldSettings.towers.nexus;
            const { siegeMod } = applyRoleBonus(p, hero.role, true, [], roleSettings);
            
            const realDmg = calcMitigatedDamage(structureDmg * siegeMod, nStats.armor) * dt;
            enemyStats.nexusHp -= realDmg;
        }
    }
  });

  // 2. [ë°©ì–´] íƒ€ì›Œ -> ì  (ë°˜ê²©)
  const lanes = ['TOP', 'MID', 'BOT'];
  const teams = ['BLUE', 'RED'] as const;

  teams.forEach(defendingTeam => {
      const isBlueDef = defendingTeam === 'BLUE';
      const myStats = isBlueDef ? match.stats.blue : match.stats.red;
      const allies = isBlueDef ? match.blueTeam : match.redTeam; 
      const enemies = {
          heroes: isBlueDef ? match.redTeam : match.blueTeam,
          minions: (match.minions || []).filter(m => m.team !== defendingTeam)
      };

      lanes.forEach(lane => {
          const laneKey = lane.toLowerCase();
          const brokenCount = (myStats.towers as any)[laneKey];
          
          [1, 2, 3].forEach(tier => {
              if (tier > brokenCount) { 
                  const towerPos = getTowerPos(lane, tier, isBlueDef);
                  const towerStats = (fieldSettings.towers as any)[`t${tier}`];

                  const target = TowerLogic.selectTarget(towerPos, enemies, allies, LOGIC_TOWER_RANGE, match.currentDuration);
                  if (target) {
                      const hasMinions = enemies.minions.some(m => m.hp > 0 && getDistance(m, towerPos) <= LOGIC_TOWER_RANGE);
                      TowerLogic.applyDamage(match, target, towerStats, dt, false, hasMinions, defendingTeam);
                  }
              }
          });
      });

      const nexusPos = isBlueDef ? BASES.BLUE : BASES.RED;
      const nexusStats = fieldSettings.towers.nexus;
      
      const target = TowerLogic.selectTarget(nexusPos, enemies, allies, LOGIC_NEXUS_RANGE, match.currentDuration);
      if (target) {
          const hasMinions = enemies.minions.some(m => m.hp > 0 && getDistance(m, nexusPos) <= LOGIC_NEXUS_RANGE);
          TowerLogic.applyDamage(match, target, nexusStats, dt, true, hasMinions, defendingTeam);
      }
  });
};



==========================================
FILE PATH: src/engine/match/systems/BanPickEngine.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/systems/BanPickEngine.ts
// ==========================================

import { Hero, LiveMatch } from '../../../types';

// ì˜ì›… íƒœê·¸ ë¶„ì„ (ì¹´ìš´í„°/ì‹œë„ˆì§€ ê³„ì‚°ìš©)
const analyzeHeroTags = (h: Hero) => {
  if (!h || !h.skills) return { hasCC: false, hasDash: false, hasShield: false, hasExecute: false, isTank: false, isSquishy: false, isBurst: false };
  const skills = [h.skills.q, h.skills.w, h.skills.e, h.skills.r];
  return {
    hasCC: skills.some(s => s.mechanic === 'STUN' || s.mechanic === 'HOOK'),
    hasDash: skills.some(s => s.mechanic === 'DASH'),
    hasShield: skills.some(s => s.mechanic === 'SHIELD' || s.mechanic === 'HEAL'),
    hasExecute: skills.some(s => s.mechanic === 'EXECUTE'),
    isTank: h.stats.hp >= 2500 || h.stats.armor >= 50,
    isSquishy: h.stats.hp < 1800,
    isBurst: h.stats.ad > 80 || h.stats.ap > 80
  };
};

export const processDraftTurn = (match: LiveMatch, heroes: Hero[], userIq: number) => {
  if (!match.draft) return;
  const { turnIndex } = match.draft;

  // 1. ì´ë¯¸ ë°´/í”½ëœ ì˜ì›… ëª©ë¡ (ì¤‘ë³µ ë°©ì§€)
  const unavailableIds = new Set<string>();
  [...match.bans.blue, ...match.bans.red].forEach(id => unavailableIds.add(id));
  [...match.blueTeam, ...match.redTeam].forEach(p => { if(p.heroId) unavailableIds.add(p.heroId); });

  // ----------------------------------------------------
  // A. ë°´ í˜ì´ì¦ˆ (0~9í„´)
  // ----------------------------------------------------
  if (turnIndex < 10) {
    const candidates = heroes.filter(h => !unavailableIds.has(h.id));
    if (candidates.length === 0) return;

    // ìŠ¹ë¥  ë†’ì€ ì˜ì›…(OP) ìœ„ì£¼ë¡œ ë°´
    candidates.sort((a, b) => b.recentWinRate - a.recentWinRate);
    
    // [ê°œì„ ] ìƒìœ„ 15ê°œ ì¤‘ ëœë¤ ë°´ (ë„ˆë¬´ ê³ ì •ë˜ì§€ ì•Šê²Œ ë²”ìœ„ í™•ëŒ€)
    const banPoolSize = Math.min(candidates.length, 15);
    const banTarget = candidates[Math.floor(Math.random() * banPoolSize)];

    if (banTarget) {
      if (turnIndex % 2 === 0) {
          match.bans.blue.push(banTarget.id);
      } else {
          match.bans.red.push(banTarget.id);
      }
    }
    return;
  }

  // ----------------------------------------------------
  // B. í”½ í˜ì´ì¦ˆ (10~19í„´)
  // ----------------------------------------------------
  const pickOrderIndex = turnIndex - 10;
  // ìŠ¤ë„¤ì´í¬ í”½ ìˆœì„œ
  const SNAKE_ORDER = [0, 1, 1, 0, 0, 1, 1, 0, 0, 1]; 
  const TEAM_SLOT_MAP = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4]; 

  if (pickOrderIndex >= SNAKE_ORDER.length) return;

  const isBluePick = SNAKE_ORDER[pickOrderIndex] === 0;
  const teamIndex = TEAM_SLOT_MAP[pickOrderIndex];
  
  const targetTeam = isBluePick ? match.blueTeam : match.redTeam;
  const enemyTeam = isBluePick ? match.redTeam : match.blueTeam; 
  
  if (!targetTeam || !targetTeam[teamIndex]) return;
  const player = targetTeam[teamIndex]; 
  
  if (player.heroId) return;

  // ì—­í• êµ° í•„í„°
  const roleKey = (teamIndex === 4) ? 'SUP' : player.lane; 
  const preferredRoles: Record<string, string[]> = {
    'TOP': ['ì§‘í–‰ê´€', 'ìˆ˜í˜¸ê¸°ì‚¬'],
    'JUNGLE': ['ì¶”ì ì', 'ì§‘í–‰ê´€'],
    'MID': ['ì„ ì§€ì', 'ì¶”ì ì', 'ì‹ ì‚´ì'], 
    'BOT': ['ì‹ ì‚´ì'], 
    'SUP': ['ìˆ˜í˜¸ê¸°ì‚¬', 'ì„ ì§€ì']
  };
  const targetRoles = preferredRoles[roleKey] || ['ì§‘í–‰ê´€'];

  let candidates = heroes.filter(h => !unavailableIds.has(h.id) && targetRoles.includes(h.role));
  
  // í›„ë³´ ì—†ìœ¼ë©´ ì „ì²´ì—ì„œ ê²€ìƒ‰
  if (candidates.length === 0) candidates = heroes.filter(h => !unavailableIds.has(h.id));
  if (candidates.length === 0 && heroes.length > 0) candidates = [heroes[0]];

  // ----------------------------------------------------
  // [ê°œì„ ëœ] í”½ ë¡œì§
  // ----------------------------------------------------
  let pickedHeroId = candidates[0].id;

  // 1. [ì¥ì¸/ì¦ê²œ ëª¨ë“œ] (20% í™•ë¥ ): ì„±ëŠ¥ ë¬´ê´€í•˜ê²Œ ë¬´ì‘ìœ„ í”½
  // ìŠ¹ë¥ ì´ ë‚®ì•„ë„ ì• ì •ìœ¼ë¡œ í•˜ëŠ” ìœ ì €ë“¤ì„ ì‹œë®¬ë ˆì´ì…˜
  const isOneTrickPony = Math.random() < 0.2;

  if (isOneTrickPony) {
      const randomPick = candidates[Math.floor(Math.random() * candidates.length)];
      if (randomPick) pickedHeroId = randomPick.id;
  } 
  else if (userIq >= 70) {
    // 2. [ê³ ìˆ˜/ì²œìƒê³„] (IQ ë†’ìŒ): ì² ì €í•œ ìƒì„±/ì¡°í•© ê³„ì‚°
    const scored = candidates.map(hero => {
      let score = hero.recentWinRate * 10;
      const myTags = analyzeHeroTags(hero);

      // (1) ì  ì¹´ìš´í„° ì ìˆ˜
      enemyTeam.forEach(e => {
        if (!e.heroId) return;
        const eHero = heroes.find(h => h.id === e.heroId);
        if (!eHero) return;
        const eTags = analyzeHeroTags(eHero);

        if (eTags.isSquishy && myTags.hasDash && myTags.isBurst) score += 150; // ì•”ì‚´ ê°€ëŠ¥
        if (eTags.hasCC && (myTags.hasDash || myTags.hasShield)) score += 80; // ìƒì¡´ ìš©ì´
        if (eTags.isTank && myTags.hasExecute) score += 120; // íƒ±ì»¤ ì²˜ë¦¬
      });

      // (2) ì•„êµ° ì‹œë„ˆì§€ ì ìˆ˜
      targetTeam.forEach(a => {
        if (!a.heroId || a === player) return;
        const aHero = heroes.find(h => h.id === a.heroId);
        if (!aHero) return;
        const aTags = analyzeHeroTags(aHero);

        if (aTags.hasCC && myTags.isBurst) score += 100; // CCì—°ê³„
        if (aTags.isTank && myTags.isSquishy) score += 60; // ë³´í˜¸ ë°›ìŒ
      });

      return { hero, score };
    });

    // ì ìˆ˜ ë†’ì€ ìˆœ ì •ë ¬
    scored.sort((a, b) => b.score - a.score);
    
    // ìµœìƒìœ„ 1~2ê°œ ì¤‘ í•˜ë‚˜ ì„ íƒ (ê³ ìˆ˜ë„ ê°€ë” ì‹¤ìˆ˜í•˜ê±°ë‚˜ ì·¨í–¥ íƒ)
    const topPicks = scored.slice(0, 2);
    const chosen = topPicks[Math.floor(Math.random() * topPicks.length)];
    if (chosen) pickedHeroId = chosen.hero.id;

  } else {
    // 3. [ì¼ë°˜ ìœ ì €] (IQ ë‚®ìŒ): ìŠ¹ë¥  ìœ„ì£¼ì§€ë§Œ, í­ë„“ê²Œ ì„ íƒ
    candidates.sort((a, b) => b.recentWinRate - a.recentWinRate);
    
    // [ê°œì„ ] ìƒìœ„ 3ê°œê°€ ì•„ë‹ˆë¼ ìƒìœ„ 50% ì•ˆì—ì„œ ëœë¤ ì„ íƒ
    // ì˜ˆ: í›„ë³´ê°€ 10ëª…ì´ë©´ 1~5ë“± ì•ˆì—ì„œ ëœë¤ (4, 5ë“± ì±”í”¼ì–¸ë„ ì„ íƒë  ê¸°íšŒ ë¶€ì—¬)
    const pickPoolSize = Math.max(3, Math.ceil(candidates.length * 0.5));
    const chosen = candidates[Math.floor(Math.random() * pickPoolSize)];
    if (chosen) pickedHeroId = chosen.id;
  }

  player.heroId = pickedHeroId;
};


==========================================
FILE PATH: src/engine/match/systems/DamageCalculator.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/systems/DamageCalculator.ts
// ==========================================
import { BattleSettings, RoleSettings } from '../../../types';
import { applyRoleBonus } from './RoleManager';

export const calcMitigatedDamage = (rawDmg: number, armor: number) => {
  const reduction = 100 / (100 + armor);
  return rawDmg * reduction;
};

// [ì˜ì›… vs ì˜ì›…] ë°ë¯¸ì§€ ê³„ì‚°
export const calculateHeroDamage = (
    attacker: any, defender: any, atkStats: any, defStats: any, attackerHero: any, 
    isBlue: boolean, settings: BattleSettings, roleSettings: RoleSettings, buffType: string
) => {
    // 1. ê³µê²©ë ¥
    const god = isBlue ? settings.dante : settings.izman;
    const atkRatio = god?.atkRatio || 1.0;
    const itemAD = attacker.items.reduce((s:number, i:any) => s + (i.ad||0), 0);
    const totalAD = (atkStats.baseAtk + atkStats.ad + itemAD) * atkRatio;

    // 2. í¬ë¦¬í‹°ì»¬ (1.85ë°°ë¡œ ì†Œí­ ìƒí–¥)
    const itemCrit = attacker.items.reduce((s:number, i:any) => s + (i.crit||0), 0);
    let isCrit = Math.random() < (atkStats.crit + itemCrit) / 100;
    let rawDmg = totalAD * (isCrit ? 1.85 : 1.0);

    // 3. ë°©ì–´ë ¥
    const defGod = isBlue ? settings.izman : settings.dante; 
    const defRatio = defGod?.defRatio || 1.0;
    const itemArmor = defender.items.reduce((s:number, i:any) => s + (i.armor||0), 0);
    const totalArmor = (defStats.armor + itemArmor) * defRatio;
    
    // ê´€í†µ
    const itemPen = attacker.items.reduce((s:number, i:any) => s + (i.pen||0), 0);
    const effectiveArmor = Math.max(0, totalArmor - (atkStats.pen + itemPen));
    
    // 4. ìµœì¢… ë°ë¯¸ì§€
    const finalDamage = calcMitigatedDamage(rawDmg, effectiveArmor);
    
    // 5. ì—­í• êµ°/ë²„í”„ ë³´ì •
    const { damageMod } = applyRoleBonus(attacker, attackerHero.role, false, [], roleSettings);
    let result = finalDamage * damageMod;

    if (buffType === 'COMBAT') result *= 1.1; 

    // [í•µì‹¬ ìˆ˜ì •] ë°ë¯¸ì§€ ê³„ìˆ˜ 0.85ë¡œ ìƒí–¥ (ê¸°ì¡´ 0.7)
    return Math.floor(result * 0.85);
};

// [ì˜ì›… -> ë¯¸ë‹ˆì–¸] ë°ë¯¸ì§€ ê³„ì‚°
export const calculateUnitDamage = (
    attacker: any, atkStats: any, targetArmor: number, isBlue: boolean, settings: BattleSettings
) => {
    const god = isBlue ? settings.dante : settings.izman;
    const atkRatio = god?.atkRatio || 1.0;
    const itemAD = attacker.items.reduce((s:number, i:any) => s + (i.ad||0), 0);
    const totalAD = (atkStats.baseAtk + atkStats.ad + itemAD) * atkRatio;

    return Math.floor(calcMitigatedDamage(totalAD, targetArmor));
};



==========================================
FILE PATH: src/engine/match/systems/ItemManager.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/systems/ItemManager.ts
// ==========================================
import { Item, LivePlayer, Hero } from '../../../types';
import { getLevelScaledStats, calculateTotalStats } from '../utils/StatUtils';
import { ItemOptimizer } from '../ai/mechanics/ItemOptimizer';

export const updateLivePlayerStats = (player: LivePlayer, hero: Hero) => {
  const baseStats = getLevelScaledStats(hero.stats, player.level);
  const totalStats = calculateTotalStats({ ...hero, stats: baseStats }, player.items);

  const oldMaxHp = player.maxHp;
  const oldMaxMp = player.maxMp;

  player.maxHp = totalStats.hp;
  player.maxMp = totalStats.mp || 300;

  if (player.maxHp > oldMaxHp) player.currentHp += (player.maxHp - oldMaxHp);
  if (player.maxMp > oldMaxMp) player.currentMp += (player.maxMp - oldMaxMp);

  if (player.currentHp > player.maxHp) player.currentHp = player.maxHp;
  if (player.currentMp > player.maxMp) player.currentMp = player.maxMp;

  (player as any).moveSpeed = totalStats.speed;
  (player as any).hpRegen = totalStats.regen;
  player.mpRegen = totalStats.mpRegen || 5;
};

export const sellItem = (player: LivePlayer, index: number, hero: Hero) => {
  const itemToSell = player.items[index];
  if (!itemToSell) return 0;
  const refundGold = Math.floor(itemToSell.cost * 0.7);
  
  player.gold += refundGold;
  // [ì¤‘ìš”] íŒë§¤ë¡œ ì–»ì€ ê³¨ë“œëŠ” Total Goldì— í¬í•¨í•˜ì§€ ì•ŠìŒ (ìˆœìˆ˜ íšë“ ê³¨ë“œê°€ ì•„ë‹ˆë¯€ë¡œ)
  
  player.items.splice(index, 1);
  updateLivePlayerStats(player, hero);
  return refundGold;
};

export const attemptBuyItem = (
  player: LivePlayer, shopItems: Item[], heroes: Hero[], enemies: LivePlayer[], gameTime: number
) => {
  const hero = heroes.find(h => h.id === player.heroId);
  if (!hero) return;

  const weights = ItemOptimizer.getDynamicWeights(player, hero, enemies, heroes);
  const itemCount = player.items.length;
  const hasBoots = player.items.some(i => i.type === 'BOOTS');
  
  // ìµœì†Œ ë³´ìœ  ê³¨ë“œ (ë„ˆë¬´ ì‹¼ê±° ë§‰ ì‚¬ì§€ ì•Šê²Œ)
  let minPriceLimit = 350; 

  const candidates = shopItems.filter(item => {
      if (player.items.some(owned => owned.id === item.id)) return false; 
      if (item.type === 'BOOTS' && hasBoots) return false; 
      return item.cost <= player.gold && item.cost >= minPriceLimit;
  }).map(item => {
      let score = 0;
      score += (item.ad || 0) * weights.ad;
      score += (item.ap || 0) * weights.ap;
      score += (item.hp || 0) * weights.hp / 10;
      score += (item.armor || 0) * weights.armor;
      score += (item.speed || 0) * weights.speed * 5; // ì‹ ë°œ ì¤‘ìš”ë„
      if (item.type === 'POWER') score *= 3;
      return { item, score };
  });

  if (candidates.length === 0) return;
  
  candidates.sort((a, b) => b.score - a.score);
  const bestTarget = candidates[0].item;

  if (itemCount < 6) {
    if (player.gold >= bestTarget.cost) { 
        player.gold -= bestTarget.cost; 
        // [ì¤‘ìš”] totalGoldëŠ” ê±´ë“œë¦¬ì§€ ì•ŠìŒ!
        player.items.push(bestTarget); 
        updateLivePlayerStats(player, hero); 
    }
  }
};



==========================================
FILE PATH: src/engine/match/systems/JungleSystem.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/systems/JungleSystem.ts
// ==========================================
import { LiveMatch, JungleMob } from '../../../types';
import { Collision } from '../utils/Collision';
import { useGameStore } from '../../../store/useGameStore';
import { DEFAULT_JUNGLE_CONFIG } from '../../../data/jungle/jungleDefaults';
import { JungleCampType } from '../../../types/jungle';

export class JungleSystem {
  static update(match: LiveMatch, dt: number) {
    if (!match.jungleMobs || match.jungleMobs.length === 0) {
        match.jungleMobs = this.initJungle();
    }

    match.jungleMobs.forEach(mob => {
      if (!mob.isAlive) {
        mob.respawnTimer -= dt;
        if (mob.respawnTimer <= 0) {
          mob.isAlive = true;
          mob.hp = mob.maxHp;
        }
        return;
      }

      const nearbyHeroes = [...match.blueTeam, ...match.redTeam].filter(
        h => h.currentHp > 0 && Collision.inRange(h, mob, 10)
      );

      if (nearbyHeroes.length > 0) {
        const dps = nearbyHeroes.reduce((sum, h) => sum + (h.level * 30) + (h.items.length * 20), 0);
        mob.hp -= dps * dt;
        nearbyHeroes.forEach(h => { h.currentHp -= (mob.atk * dt) / nearbyHeroes.length; });

        if (mob.hp <= 0) {
          mob.isAlive = false;
          mob.respawnTimer = (mob as any).configRespawnTime || 60; 
          
          const killer = Collision.findNearest(mob, nearbyHeroes);
          if (killer) {
             const bonus = killer.lane === 'JUNGLE' ? 1.2 : 1.0;
             killer.gold += Math.floor(((mob as any).rewardGold || 50) * bonus);
             (killer as any).exp = ((killer as any).exp || 0) + Math.floor(((mob as any).rewardXp || 80) * bonus);
             
             killer.cs += (mob as any).isBuffMob ? 4 : 1;
             
             if ((mob as any).isBuffMob && (mob as any).buffs) {
                const buffs = (mob as any).buffs as { type: string, value: number }[];
                const buffMsg = buffs.map(b => `${b.type} +${b.value}`).join(', ');
                buffs.forEach(b => {
                    if(!killer.buffs) killer.buffs = [];
                    killer.buffs.push(`${b.type}:${b.value}`);
                });
                if (Math.random() < 0.3) {
                    match.logs.push({
                        time: Math.floor(match.currentDuration),
                        type: 'KILL',
                        message: `Buff: ${killer.name} -> [${buffMsg}] íšë“!`
                    });
                }
             }
          }
        }
      } else {
        if (mob.hp < mob.maxHp) mob.hp += mob.maxHp * 0.2 * dt;
      }
    });
  }

  private static initJungle(): JungleMob[] {
    const state = useGameStore.getState().gameState;
    const settings = state.fieldSettings.jungle as any;
    const camps = settings?.camps || DEFAULT_JUNGLE_CONFIG.camps;
    
    const mobs: JungleMob[] = [];

    (Object.keys(camps) as JungleCampType[]).forEach(campKey => {
        const campConfig = camps[campKey];

        campConfig.monsters.forEach((m: any, idx: number) => {
            // [í•µì‹¬ ìˆ˜ì •] ì¢Œí‘œ ì™œê³¡ ë¡œì§ ì‚­ì œ (basePos + offset... ì œê±°)
            // ì—ë””í„°ì—ì„œ ì„¤ì •í•œ ì¢Œí‘œ(m.x, m.y)ê°€ ê³§ ì›”ë“œ ì¢Œí‘œ(0~100)ì…ë‹ˆë‹¤.
            // ê·¸ëŒ€ë¡œ ëŒ€ì…í•˜ë©´ ìœ„ì¹˜ê°€ ì •í™•íˆ ì¼ì¹˜í•©ë‹ˆë‹¤.
            
            mobs.push({
                id: `j_${campKey}_${m.spotId}`,
                campId: idx,
                type: m.stats.isBuffMob ? 'GOLEM' : 'WOLF',
                x: m.x, // ìˆëŠ” ê·¸ëŒ€ë¡œ ì‚¬ìš©
                y: m.y, // ìˆëŠ” ê·¸ëŒ€ë¡œ ì‚¬ìš©
                hp: m.stats.hp,
                maxHp: m.stats.hp,
                atk: m.stats.atk,
                respawnTimer: 0,
                isAlive: true,
                // @ts-ignore
                rewardGold: m.stats.gold,
                // @ts-ignore
                rewardXp: m.stats.xp,
                // @ts-ignore
                configRespawnTime: m.stats.respawnTime,
                // @ts-ignore
                isBuffMob: m.stats.isBuffMob,
                // @ts-ignore
                buffs: m.stats.buffs, 
                // @ts-ignore
                name: m.stats.name
            });
        });
    });

    return mobs;
  }
}



==========================================
FILE PATH: src/engine/match/systems/MinionSpawner.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/systems/MinionSpawner.ts
// ==========================================
import { LiveMatch, Minion } from '../../../types';
import { BASES } from '../constants/MapConstants';

// íŒ€ë³„ ìµœëŒ€ ë¯¸ë‹ˆì–¸ ìˆ˜ (ìµœì í™” ë° ë ‰ ë°©ì§€)
const MAX_MINIONS_PER_TEAM = 60;

export class MinionSpawner {
  
  static spawnWave(match: LiveMatch, team: 'BLUE' | 'RED') {
    if (!match.minions) match.minions = [];

    // 1. [ê°œì„ ëœ ë¡œì§] ìº¡ ê´€ë¦¬ (ê³µê°„ í™•ë³´)
    // ê½‰ ì°¼ë‹¤ê³  ì•ˆ ë½‘ëŠ” ê²Œ ì•„ë‹ˆë¼, ì•½í•œ ê°œì²´ë¥¼ ë„íƒœì‹œí‚¤ê³  ìƒˆë¡œ ë½‘ìŒ
    this.cullExcessMinions(match, team);

    const lanes = ['TOP', 'MID', 'BOT'] as const;
    const startPos = team === 'BLUE' ? BASES.BLUE : BASES.RED;
    
    // ê²Œì„ ì‹œê°„ì— ë”°ë¥¸ ìŠ¤íƒ¯ ìŠ¤ì¼€ì¼ë§ (15ë¶„ ê¸°ì¤€ ì•½ 2ë°°)
    const rawScaling = 1 + (match.currentDuration / 900); 
    const timeScaling = Math.min(3.5, rawScaling); 

    // ëŒ€í¬ ë¯¸ë‹ˆì–¸ ìƒì„± ì£¼ê¸° (3ì›¨ì´ë¸Œë§ˆë‹¤)
    const isSiegeWave = Math.floor(match.currentDuration / 30) % 3 === 0;

    const newMinions: Minion[] = [];

    lanes.forEach(lane => {
      // ì „ì‚¬ ë¯¸ë‹ˆì–¸ 3ë§ˆë¦¬
      for (let i = 0; i < 3; i++) {
        newMinions.push(this.createMinion(team, lane, 'MELEE', startPos, timeScaling));
      }
      // ë§ˆë²•ì‚¬ ë¯¸ë‹ˆì–¸ 3ë§ˆë¦¬
      for (let i = 0; i < 3; i++) {
        newMinions.push(this.createMinion(team, lane, 'RANGED', startPos, timeScaling));
      }
      // ëŒ€í¬ ë¯¸ë‹ˆì–¸ 1ë§ˆë¦¬
      if (isSiegeWave) {
        newMinions.push(this.createMinion(team, lane, 'SIEGE', startPos, timeScaling));
      }
    });

    // ê¸°ì¡´ ë°°ì—´ì— ìƒˆ ë¯¸ë‹ˆì–¸ ì¶”ê°€
    match.minions.push(...newMinions);
  }

  /**
   * ë¯¸ë‹ˆì–¸ ìˆ˜ê°€ í•œê³„ë¥¼ ë„˜ìœ¼ë©´ ìš°ì„ ìˆœìœ„ê°€ ë‚®ì€(ì²´ë ¥ì´ ì ê±°ë‚˜ ì˜¤ë˜ëœ) ë¯¸ë‹ˆì–¸ì„ ê°•ì œë¡œ ì œê±°í•©ë‹ˆë‹¤.
   */
  private static cullExcessMinions(match: LiveMatch, team: 'BLUE' | 'RED') {
    const teamMinions = match.minions!.filter(m => m.team === team && m.hp > 0);
    const waveSize = 7; // í•œ ì›¨ì´ë¸Œë‹¹ ëŒ€ëµ 7ë§ˆë¦¬ ìƒì„±ë¨ (3+3+1)
    
    // ìƒˆë¡œ ìƒì„±ë  ê³µê°„(waveSize)ë§Œí¼ ì—¬ìœ ê°€ ì—†ìœ¼ë©´ ì •ë¦¬ ì‹œì‘
    if (teamMinions.length + waveSize > MAX_MINIONS_PER_TEAM) {
        const removeCount = (teamMinions.length + waveSize) - MAX_MINIONS_PER_TEAM;
        
        // [ìš°ì„ ìˆœìœ„ ì •ë ¬]
        // 1. ì²´ë ¥ ë¹„ìœ¨ì´ ë‚®ì€ ìˆœ (ì£½ê¸° ì§ì „ì¸ ë†ˆë¶€í„°)
        // 2. ID ê¸°ì¤€ (ì˜¤ë˜ëœ ë†ˆë¶€í„°)
        // ê±°ì‹ ë³‘(SUMMONED_COLOSSUS)ì€ ì ˆëŒ€ ì‚­ì œí•˜ì§€ ì•ŠìŒ
        const candidates = teamMinions
            .filter(m => m.type !== 'SUMMONED_COLOSSUS') 
            .sort((a, b) => {
                const hpRatioA = a.hp / a.maxHp;
                const hpRatioB = b.hp / b.maxHp;
                if (Math.abs(hpRatioA - hpRatioB) > 0.1) return hpRatioA - hpRatioB;
                return a.id.localeCompare(b.id); // ì˜¤ë˜ëœ ìˆœ
            });

        // ì‚­ì œ ëŒ€ìƒ ID ìˆ˜ì§‘
        const removeIds = new Set(candidates.slice(0, removeCount).map(m => m.id));

        // ì‹¤ì œ ë°°ì—´ì—ì„œ ì œê±° (ì§ì ‘ í• ë‹¹)
        match.minions = match.minions!.filter(m => !removeIds.has(m.id));
    }
  }

  private static createMinion(team: 'BLUE' | 'RED', lane: any, type: any, pos: {x:number, y:number}, scaling: number): Minion {
    // ê²¹ì¹¨ ë°©ì§€ë¥¼ ìœ„í•œ ì•½ê°„ì˜ ìœ„ì¹˜ ëœë¤ê°’ (Spawn Jitter)
    const offsetX = (Math.random() - 0.5) * 3; // 2 -> 3ìœ¼ë¡œ ì•½ê°„ ë„“í˜
    const offsetY = (Math.random() - 0.5) * 3;
    
    let hp = 550, atk = 25;
    // [ë°¸ëŸ°ìŠ¤ ë¯¸ì„¸ ì¡°ì •]
    if (type === 'RANGED') { hp = 350; atk = 45; }
    if (type === 'SIEGE') { hp = 950; atk = 70; } // ëŒ€í¬ ì²´ë ¥/ê³µê²©ë ¥ ìƒí–¥

    // IDì— íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ ë„£ì–´ ìƒì„± ìˆœì„œ ë³´ì¥
    return {
      id: `minion_${team}_${lane}_${Date.now()}_${Math.random().toString(36).substr(2,5)}`,
      team, lane, type,
      x: pos.x + offsetX, 
      y: pos.y + offsetY,
      hp: Math.floor(hp * scaling), 
      maxHp: Math.floor(hp * scaling), 
      atk: Math.floor(atk * scaling),
      pathIdx: 0
    };
  }
}



==========================================
FILE PATH: src/engine/match/systems/MinionSystem.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/systems/MinionSystem.ts
// ==========================================
import { LiveMatch, Minion, BattleSettings, Hero } from '../../../types';
import { MinionLogic } from '../logics/MinionLogic';
import { MinionSpawner } from './MinionSpawner';

const WAVE_INTERVAL = 30;

export class MinionSystem {
  static update(match: LiveMatch, settings: BattleSettings, dt: number, heroes: Hero[]) {
    if (!match.minions) match.minions = [];

    const currentWaveCycle = Math.floor(match.currentDuration / WAVE_INTERVAL);
    const prevWaveCycle = Math.floor((match.currentDuration - dt) / WAVE_INTERVAL);

    if (currentWaveCycle > prevWaveCycle) {
      MinionSpawner.spawnWave(match, 'BLUE');
      MinionSpawner.spawnWave(match, 'RED');
    }

    this.processMinions(match, settings, dt, heroes);
  }

  private static processMinions(match: LiveMatch, settings: BattleSettings, dt: number, heroes: Hero[]) {
    // 1. ì£½ì€ ë¯¸ë‹ˆì–¸ ì •ë¦¬
    match.minions = match.minions!.filter(m => m.hp > 0);

    // 2. [ìˆ˜ì •] Grid ëŒ€ì‹  ë‹¨ìˆœ ë¦¬ìŠ¤íŠ¸ ì‚¬ìš© (ì•ˆì •ì„± í™•ë³´)
    // Grid ì‹œìŠ¤í…œ ì˜¤ì‘ë™ìœ¼ë¡œ ì¸í•œ 0/0/0 ë²„ê·¸ í•´ê²°ì„ ìœ„í•´ ì›ë³µ
    const minionList = match.minions;
    const blueMinions = minionList.filter(m => m.team === 'BLUE');
    const redMinions = minionList.filter(m => m.team === 'RED');
    const blueHeroes = match.blueTeam.filter(h => h.currentHp > 0);
    const redHeroes = match.redTeam.filter(h => h.currentHp > 0);

    // 3. ë¯¸ë‹ˆì–¸ ë¡œì§ ì‹¤í–‰ (Mock Grid ê°ì²´ ì „ë‹¬)
    for (let i = 0; i < match.minions.length; i++) {
        const m = match.minions[i];
        
        // Grid ì¸í„°í˜ì´ìŠ¤ í‰ë‚´ë‚´ì§€ë§Œ ì‹¤ì œë¡œëŠ” ì „ì²´ ë°°ì—´ ë¦¬í„´ (í™•ì‹¤í•œ íƒìƒ‰)
        const enemyGrids = m.team === 'BLUE' ? {
            minions: { getNearbyUnits: () => redMinions } as any,
            heroes: { getNearbyUnits: () => redHeroes } as any
        } : {
            minions: { getNearbyUnits: () => blueMinions } as any,
            heroes: { getNearbyUnits: () => blueHeroes } as any
        };

        MinionLogic.processSingleMinion(
            m, match, settings, dt, enemyGrids, true, heroes
        );
    }
  }
}



==========================================
FILE PATH: src/engine/match/systems/ObjectiveSystem.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/systems/ObjectiveSystem.ts
// ==========================================
import { LiveMatch } from '../../../types';
import { useGameStore } from '../../../store/useGameStore';
import { POI, getDistance, BASES } from '../../data/MapData';

export function applyColossusReward(match: LiveMatch, isBlueTeam: boolean) {
  const teamName = isBlueTeam ? 'ë‹¨í…Œ' : 'ì´ì¦ˆë§ˆí•œ';
  const teamColor = isBlueTeam ? 'BLUE' : 'RED';
  const stats = isBlueTeam ? match.stats.blue : match.stats.red;
  const settings = useGameStore.getState().gameState.fieldSettings.colossus;
  const stackCount = stats.colossus; 
  const scaleFactor = 1.0 + Math.max(0, stackCount - 1) * 0.1;

  stats.activeBuffs.siegeUnit = true;

  if (!match.minions) match.minions = [];
  const startPos = isBlueTeam ? BASES.BLUE : BASES.RED;
  
  const baseHp = settings.hp || 15000;
  const baseAtk = settings.attack || 300;
  const baseArmor = settings.armor || 100;
  const finalHp = Math.floor(baseHp * scaleFactor);
  const finalAtk = Math.floor(baseAtk * scaleFactor);
  const finalArmor = Math.floor(baseArmor * scaleFactor);

  match.minions.push({
    id: `summoned_colossus_${Date.now()}`,
    type: 'SUMMONED_COLOSSUS',
    team: teamColor,
    lane: 'MID', 
    x: startPos.x, y: startPos.y,
    hp: finalHp, maxHp: finalHp, atk: finalAtk,
    // @ts-ignore
    armor: finalArmor,
    pathIdx: 0
  });

  const upgradeMsg = stackCount > 1 ? ` (Lv.${stackCount} ê°•í™”: +${Math.round((scaleFactor-1)*100)}%)` : '';
  match.logs.push({ time: match.currentDuration, message: `ğŸ¤– ${teamName} ì§„ì˜ì´ ê±°ì‹ ë³‘ì„ ì†Œí™˜í–ˆìŠµë‹ˆë‹¤!${upgradeMsg} ë¯¸ë“œ ë¼ì¸ìœ¼ë¡œ ì§„ê²©í•©ë‹ˆë‹¤!`, type: 'COLOSSUS', team: teamColor });
}

export function applyWatcherReward(match: LiveMatch, isBlueTeam: boolean) {
  const teamName = isBlueTeam ? 'ë‹¨í…Œ' : 'ì´ì¦ˆë§ˆí•œ';
  const teamColor = isBlueTeam ? 'BLUE' : 'RED';
  
  const allies = isBlueTeam ? match.blueTeam : match.redTeam;
  allies.forEach(p => {
    if (p.currentHp > 0 && p.respawnTimer <= 0) {
        if (!p.buffs.includes('WATCHER_BUFF')) {
            p.buffs.push('WATCHER_BUFF');
        }
    }
  });

  match.logs.push({
    time: match.currentDuration,
    message: `ğŸ‘ï¸ ${teamName} ì§„ì˜ì´ ê³µí—ˆì˜ í˜ì„ ì–»ì—ˆìŠµë‹ˆë‹¤! (ì‚¬ë§ ì‹œ ì†Œì‹¤)`,
    type: 'WATCHER',
    team: teamColor
  });
}

export const updateNeutralObjectives = (match: LiveMatch, fieldSettings: any, dt: number) => {
    (['colossus', 'watcher'] as const).forEach(type => {
        const obj = match.objectives[type];
        const setting = fieldSettings[type];
        if (!obj || !setting) return;

        // 1. ìŠ¤í° ë¡œì§
        if (obj.status === 'DEAD' && match.currentDuration >= obj.nextSpawnTime) {
            obj.status = 'ALIVE';
            obj.hp = setting.hp;
            obj.maxHp = setting.hp;
            // ë¶€í™œ ì‹œ ë§ˆì§€ë§‰ ê³µê²© ì‹œê°„ ì´ˆê¸°í™”
            (obj as any).lastAttackedTime = 0;
            match.logs.push({ time: match.currentDuration, message: `ğŸ“¢ ${type === 'colossus' ? 'ê±°ì‹ ë³‘' : 'ì£¼ì‹œì'}ê°€ ì „ì¥ì— ë“±ì¥í–ˆìŠµë‹ˆë‹¤!`, type: 'START' });
        }

        // 2. ì‚´ì•„ìˆì„ ë•Œ ë¡œì§ (í”¼ê²© ë° íšŒë³µ)
        if (obj.status === 'ALIVE') {
            const objectivePos = type === 'colossus' ? POI.BARON : POI.DRAGON;
            
            // ì£¼ë³€ 15ê±°ë¦¬ ë‚´ì— ì‚´ì•„ìˆëŠ” ì˜ì›…ì´ ìˆëŠ”ì§€ í™•ì¸ (ì–´ê·¸ë¡œ ë²”ìœ„)
            const nearbyHeroes = [...match.blueTeam, ...match.redTeam].filter(p => p.currentHp > 0 && p.respawnTimer <= 0 && getDistance(p, objectivePos) < 15);

            if (nearbyHeroes.length > 0) {
                // [ì „íˆ¬ ì¤‘] ë°ë¯¸ì§€ ì…ìŒ
                const dps = nearbyHeroes.reduce((sum, p) => sum + (p.level * 15) + (p.items.length * 10), 0);
                obj.hp -= dps * dt;
                
                // ë§ˆì§€ë§‰ ê³µê²© ì‹œê°„ ê¸°ë¡
                (obj as any).lastAttackedTime = match.currentDuration;

                if (obj.hp <= 0) {
                    obj.status = 'DEAD';
                    obj.nextSpawnTime = match.currentDuration + (setting.respawnTime || 300);

                    const blueCnt = nearbyHeroes.filter(p => match.blueTeam.includes(p)).length;
                    const redCnt = nearbyHeroes.length - blueCnt;
                    const isBlueWin = blueCnt >= redCnt;

                    if (type === 'colossus') {
                        match.stats[isBlueWin ? 'blue' : 'red'].colossus++;
                        applyColossusReward(match, isBlueWin);
                    } else {
                        match.stats[isBlueWin ? 'blue' : 'red'].watcher++;
                        applyWatcherReward(match, isBlueWin);
                    }
                }
            } else {
                // [ë¹„ì „íˆ¬ ìƒíƒœ] -> íšŒë³µ(Reset) ë¡œì§
                const lastAttacked = (obj as any).lastAttackedTime || 0;
                
                // ë§ˆì§€ë§‰ ê³µê²©ìœ¼ë¡œë¶€í„° 10ì´ˆê°€ ì§€ë‚¬ê³ , ì²´ë ¥ì´ ê¹ì—¬ìˆë‹¤ë©´
                if (match.currentDuration - lastAttacked > 10 && obj.hp < obj.maxHp) {
                    // ì´ˆë‹¹ ìµœëŒ€ ì²´ë ¥ì˜ 20%ì”© ê³ ì† íšŒë³µ
                    const regenAmount = obj.maxHp * 0.2 * dt;
                    obj.hp += regenAmount;
                    
                    if (obj.hp > obj.maxHp) obj.hp = obj.maxHp;
                }
            }
        }
    });
};



==========================================
FILE PATH: src/engine/match/systems/PathSystem.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/systems/PathSystem.ts
// ==========================================
import { Vector2 } from '../utils/Vector';
import { BASES, TOWER_COORDS, LANE_FRONTS } from '../constants/MapConstants';
import { LivePlayer, LiveMatch } from '../../../types';
import { JunglePathFinder } from '../ai/pathing/JunglePathFinder';
import { AIUtils } from '../ai/AIUtils';

export class PathSystem {
  
  static getNextWaypoint(player: LivePlayer, isBlue: boolean, match?: LiveMatch): Vector2 {
    
    // 1. ì •ê¸€ëŸ¬
    if (player.lane === 'JUNGLE' && match) {
        return JunglePathFinder.getNextCamp(player, match);
    }

    // 2. ë¼ì´ë„ˆ
    const defaultTarget = isBlue ? BASES.RED : BASES.BLUE;
    if (!match) return defaultTarget;

    // ë¯¸ë‹ˆì–¸ ì¶”ì 
    const myMinions = match.minions?.filter(m => 
        m.lane === player.lane && 
        m.team === (isBlue ? 'BLUE' : 'RED') && 
        m.hp > 0
    ) || [];

    if (myMinions.length > 0) {
        // ê°€ì¥ ì•ì— ìˆëŠ” ë¯¸ë‹ˆì–¸ ë”°ë¼ê°€ê¸°
        myMinions.sort((a, b) => AIUtils.dist(a, defaultTarget) - AIUtils.dist(b, defaultTarget));
        const frontMinion = myMinions[0];
        
        // ë¯¸ë‹ˆì–¸ê³¼ ê²¹ì¹˜ì§€ ì•Šê²Œ ì‚´ì§ ë¶„ì‚°
        const offsetX = (Math.random() - 0.5) * 4;
        const offsetY = (Math.random() - 0.5) * 4;
        return { x: frontMinion.x + offsetX, y: frontMinion.y + offsetY };
    }

    // [í•µì‹¬] ë¯¸ë‹ˆì–¸ì´ ì—†ìœ¼ë©´? -> íƒ€ì›Œê°€ ì•„ë‹ˆë¼ 'ë¼ì¸ ê²©ì „ì§€'ë¡œ ì§í–‰
    // íƒ€ì›Œê°€ ê¹¨ì¡ŒëŠ”ì§€ í™•ì¸
    const laneKey = player.lane.toLowerCase();
    const myStats = isBlue ? match.stats.blue : match.stats.red;
    const brokenCount = (myStats.towers as any)[laneKey];

    // 1ì°¨ íƒ€ì›Œê°€ ì•„ì§ ìˆìœ¼ë©´ -> ë¼ì¸ ì¤‘ì•™(ê²©ì „ì§€)ìœ¼ë¡œ ì´ë™
    if (brokenCount === 0) {
        // @ts-ignore
        return LANE_FRONTS[player.lane] || LANE_FRONTS.MID;
    }

    // 1ì°¨ê°€ ê¹¨ì¡Œìœ¼ë©´ -> ê·¸ ë‹¤ìŒ íƒ€ì›Œ ì•ì—ì„œ ìˆ˜ë¹„
    return this.getTowerPos(player.lane, brokenCount + 1, isBlue);
  }

  private static getTowerPos(lane: string, tier: number, isBlue: boolean) {
      if (tier > 3) return isBlue ? BASES.BLUE : BASES.RED; 
      const coords = isBlue ? TOWER_COORDS.BLUE : TOWER_COORDS.RED;
      // @ts-ignore
      return coords[lane][tier - 1] || coords.NEXUS;
  }
}



==========================================
FILE PATH: src/engine/match/systems/PlayerSystem.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/systems/PlayerSystem.ts
// ==========================================
import { LivePlayer, LiveMatch, Hero, RoleSettings } from '../../../types';
import { updateLivePlayerStats } from './ItemManager'; 
import { SteeringSystem } from './SteeringSystem';
import { PathSystem } from './PathSystem';
import { BASES, TOWER_COORDS } from '../constants/MapConstants';
import { MacroBrain } from '../ai/MacroBrain';
import { MicroBrain } from '../ai/MicroBrain';
import { getDistance } from '../../data/MapData';
import { RecallSystem } from './RecallSystem';
import { processSkillEffect } from './SkillProcessor';
import { AIUtils } from '../ai/AIUtils';
import { StatusManager } from './StatusManager';

const isSafeToRecall = (player: LivePlayer, match: LiveMatch, isBlue: boolean): boolean => {
  const enemyTowers = isBlue ? match.stats.red.towers : match.stats.blue.towers;
  const enemies = isBlue ? match.redTeam : match.blueTeam;

  for (const enemy of enemies) {
    if (enemy.currentHp > 0 && getDistance(player, enemy) < 15) return false;
  }
  if (match.minions) {
      const nearbyMinions = match.minions.find(m => m.team !== (isBlue ? 'BLUE' : 'RED') && m.hp > 0 && getDistance(player, m) < 10);
      if (nearbyMinions) return false;
  }
  const lanes = ['top', 'mid', 'bot'] as const;
  const towerCoords = isBlue ? TOWER_COORDS.RED : TOWER_COORDS.BLUE;
  for (const lane of lanes) {
      const broken = (enemyTowers as any)[lane];
      if (broken < 3) {
          [1, 2, 3].forEach(tier => {
              if (tier > broken) {
                  // @ts-ignore
                  const tPos = towerCoords[lane.toUpperCase()][tier - 1];
                  if (tPos && getDistance(player, tPos) < 16) return false;
              }
          });
      }
  }
  if (getDistance(player, towerCoords.NEXUS) < 18) return false;
  return true;
};

export const updatePlayerBehavior = (
  player: LivePlayer,
  match: LiveMatch,
  heroes: Hero[],
  shopItems: any[],
  roleSettings: RoleSettings,
  dt: number
) => {
  StatusManager.update(player, dt);
  
  if (StatusManager.isStunned(player)) {
      RecallSystem.cancelRecall(player);
      return; 
  }

  const prevHp = (player as any)._prevHp || player.currentHp;
  if (player.currentHp < prevHp - 0.1 && player.isRecalling) {
      RecallSystem.cancelRecall(player);
  }
  (player as any)._prevHp = player.currentHp;

  if (!player.cooldowns) player.cooldowns = { q:0, w:0, e:0, r:0 };
  Object.keys(player.cooldowns).forEach(k => {
    if ((player.cooldowns as any)[k] > 0) (player.cooldowns as any)[k] -= dt;
  });

  if (player.respawnTimer > 0) {
    player.respawnTimer -= dt;
    player.isRecalling = false;
    player.currentRecallTime = 0;
    if (player.respawnTimer <= 0) {
      player.respawnTimer = 0;
      const heroData = heroes.find(h => h.id === player.heroId);
      if (heroData) updateLivePlayerStats(player, heroData);
      player.currentHp = player.maxHp;
      player.currentMp = player.maxMp;
      const isBlueStart = match.blueTeam.includes(player);
      player.x = isBlueStart ? BASES.BLUE.x : BASES.RED.x;
      player.y = isBlueStart ? BASES.BLUE.y : BASES.RED.y;
      (player as any).pathIdx = 0;
      (player as any)._prevHp = player.maxHp;
      
      StatusManager.init(player);
    }
    return;
  }

  RecallSystem.update(player, match, heroes, shopItems, dt);
  if (player.isRecalling) return;

  const hero = heroes.find(h => h.id === player.heroId);
  if (!hero) return;

  const isBlue = match.blueTeam.includes(player);
  const allies = isBlue ? match.blueTeam : match.redTeam;

  const macroDecision = MacroBrain.decide(player, match, hero);
  let finalTargetPos = macroDecision.targetPos;
  let moveSpeed = (player as any).moveSpeed || hero.stats.speed;

  if (macroDecision.action === 'FIGHT' && macroDecision.targetUnit) {
      const enemy = macroDecision.targetUnit;
      if (AIUtils.hpPercent(enemy) < 0.3) {
          moveSpeed *= 1.25; 
      }
  }

  switch (macroDecision.action) {
    case 'RECALL':
      const myBase = isBlue ? BASES.BLUE : BASES.RED;
      if (getDistance(player, myBase) < 8) return; 

      if (!isSafeToRecall(player, match, isBlue)) {
          finalTargetPos = myBase;
          moveSpeed *= 1.1; 
      } else {
          RecallSystem.startRecall(player);
          return;
      }
      break;

    case 'FIGHT':
    case 'DEFEND': 
      if (macroDecision.targetUnit) {
        const micro = MicroBrain.control(player, macroDecision.targetUnit, hero, isBlue);
        
        if (micro.type === 'MOVE') {
          finalTargetPos = micro.targetPos;
        } else {
          finalTargetPos = { x: player.x, y: player.y }; 
          
          if (micro.skillKey) {
             const key = micro.skillKey as 'q'|'w'|'e'|'r';
             const skill = hero.skills[key];
             const cost = skill.cost || 0;
             if ((player.cooldowns as any)[key] <= 0 && player.currentMp >= cost) {
                 player.currentMp -= cost;
                 (player.cooldowns as any)[key] = skill.cd * (1 - (roleSettings.prophet.cdrPerLevel * 0.01 * player.level));
                 processSkillEffect(skill, player, macroDecision.targetUnit);
                 
                 // [ì´í™íŠ¸ ì œê±°, ë§í’ì„  ìœ ì§€]
                 player.activeSkill = { key, timestamp: match.currentDuration };

                 if (key === 'r') {
                     match.logs.push({
                         time: Math.floor(match.currentDuration),
                         type: 'KILL',
                         message: `ğŸ’¥ [${player.name}] ê¶ê·¹ê¸° ë°œë™! (${skill.name})`
                     });
                 }
             }
          }
        }
      }
      break;

    case 'FLEE':
    case 'SUPPORT':
    case 'GANK':
    case 'OBJECTIVE':
    case 'CHASE': 
      finalTargetPos = macroDecision.targetPos;
      break;

    case 'PUSH':
    case 'FARM':
    default:
      finalTargetPos = PathSystem.getNextWaypoint(player, isBlue, match);
      break;
  }

  const mapScaleSpeed = (moveSpeed / 100) * dt * 0.8; 
  const steering = SteeringSystem.calculateSteering(player, finalTargetPos, allies, mapScaleSpeed);

  player.x += steering.x;
  player.y += steering.y;

  player.x = Math.max(0, Math.min(100, player.x));
  player.y = Math.max(0, Math.min(100, player.y));
};



==========================================
FILE PATH: src/engine/match/systems/PowerCalculator.ts
==========================================
import { Hero, LivePlayer, RoleSettings, HeroStats } from '../../../types';
// [ìˆ˜ì •] ìˆœí™˜ ì°¸ì¡° ì œê±° (StatUtils ì‚¬ìš©)
import { getLevelScaledStats, calculateTotalStats } from '../utils/StatUtils';
import { applyRoleBonus } from './RoleManager';

// getLevelScaledStatsëŠ” StatUtilsë¡œ ì´ë™í–ˆìœ¼ë¯€ë¡œ exportë§Œ ë‹¤ì‹œ í•´ì¤ë‹ˆë‹¤ (í•˜ìœ„ í˜¸í™˜ì„±)
export { getLevelScaledStats } from '../utils/StatUtils';

export const calculateHeroPower = (
  heroId: string, 
  heroes: Hero[], 
  player: LivePlayer, 
  isSiege: boolean, 
  allies: LivePlayer[],
  roleSettings: RoleSettings
) => {
  const hero = heroes.find(h => h.id === heroId);
  if (!hero) return 1000;

  const scaledBaseStats = getLevelScaledStats(hero.stats, player.level);
  const { damageMod, defenseMod } = applyRoleBonus(player, hero.role, isSiege, allies, roleSettings);
  const currentTotalStats = calculateTotalStats({ ...hero, stats: scaledBaseStats }, player.items);

  const hpScore = currentTotalStats.hp / 12;
  const atkScore = (currentTotalStats.ad + currentTotalStats.ap) * 2.5;
  const utilScore = currentTotalStats.speed / 6;

  let basePower = (hpScore + atkScore + utilScore) * damageMod * defenseMod;
  const skillMultiplier = 0.85 + (player.mmr / 15000) + (player.stats.mechanics / 1000); 

  return basePower * skillMultiplier;
};



==========================================
FILE PATH: src/engine/match/systems/ProjectileSystem.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/systems/ProjectileSystem.ts
// ==========================================
import { LiveMatch, Projectile } from '../../../types';
import { Collision } from '../utils/Collision';

export class ProjectileSystem {
  static update(match: LiveMatch, dt: number) {
    if (!match.projectiles) match.projectiles = [];

    // [ìµœì í™”] ì‚­ì œ ì˜ˆì •ì¸ íˆ¬ì‚¬ì²´ ë¯¸ë¦¬ í•„í„°ë§ (ë©”ëª¨ë¦¬ ì ˆì•½)
    match.projectiles = match.projectiles.filter(p => !p.remove);

    match.projectiles.forEach(p => {
      // [ì‹ ê·œ] ìˆ˜ëª… ê´€ë¦¬: ìƒì„±ëœ ì§€ 3ì´ˆ ë„˜ìœ¼ë©´ ê°•ì œ ì‚­ì œ
      // Projectile íƒ€ì…ì— lifeTimeì´ ì—†ìœ¼ë¯€ë¡œ ì„ì‹œë¡œ í™•ì¥í•˜ê±°ë‚˜, ê±°ë¦¬ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì²´í¬
      // ì—¬ê¸°ì„œëŠ” ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ê±°ë‚˜ ëª©í‘œ ë„ë‹¬ ì‹¤íŒ¨ ì‹œ ì‚­ì œ ë¡œì§ ê°•í™”
      
      let targetPos = p.targetPos;

      if (p.targetId) {
        const target = [...match.blueTeam, ...match.redTeam].find(u => u.heroId === p.targetId);
        if (target && target.currentHp > 0) {
          targetPos = { x: target.x, y: target.y };
        } else {
          p.remove = true; 
          return;
        }
      }

      if (!targetPos) { p.remove = true; return; }

      const dx = targetPos.x - p.x;
      const dy = targetPos.y - p.y;
      const dist = Math.sqrt(dx*dx + dy*dy);

      // ì¶©ëŒ íŒì •
      if (dist < p.hitRadius || dist < (p.speed * dt * 0.1)) {
        this.onHit(match, p);
        p.remove = true;
      } else {
        // ì´ë™
        p.x += (dx / dist) * p.speed * dt * 0.1;
        p.y += (dy / dist) * p.speed * dt * 0.1;

        // [ì•ˆì „ì¥ì¹˜] ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì‚­ì œ
        if (p.x < -10 || p.x > 110 || p.y < -10 || p.y > 110) {
            p.remove = true;
        }
      }
    });
  }

  static spawn(match: LiveMatch, p: Projectile) {
    if (!match.projectiles) match.projectiles = [];
    // [ìµœì í™”] í™”ë©´ì— íˆ¬ì‚¬ì²´ê°€ ë„ˆë¬´ ë§ìœ¼ë©´(50ê°œ ì´ìƒ) ì´í™íŠ¸ ìƒëµ
    if (match.projectiles.length < 50) {
        match.projectiles.push(p);
    } else {
        // ì´í™íŠ¸ëŠ” ìƒëµí•˜ë˜ ë°ë¯¸ì§€ëŠ” ì¦‰ì‹œ ì ìš© (ì‹œë®¬ë ˆì´ì…˜ ì •í•©ì„± ìœ ì§€)
        this.onHit(match, p);
    }
  }

  private static onHit(match: LiveMatch, p: Projectile) {
    let targets = p.team === 'BLUE' ? match.redTeam : match.blueTeam;
    let victim = null;

    if (p.targetId) {
      victim = targets.find(t => t.heroId === p.targetId);
    } else {
      victim = Collision.findNearest(p, targets, p.hitRadius + 2);
    }

    if (victim) {
      victim.currentHp -= p.damage;
    }
  }
}



==========================================
FILE PATH: src/engine/match/systems/RecallSystem.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/systems/RecallSystem.ts
// ==========================================
import { LivePlayer, LiveMatch, Hero } from '../../../types';
import { BASES } from '../constants/MapConstants';
import { useGameStore } from '../../../store/useGameStore';
import { attemptBuyItem } from './ItemManager';

export class RecallSystem {
  
  static update(player: LivePlayer, match: LiveMatch, heroes: Hero[], shopItems: any[], dt: number) {
    const isBlue = match.blueTeam.includes(player);
    const basePos = isBlue ? BASES.BLUE : BASES.RED;
    
    // 1. ì¿¨íƒ€ì„ ê°ì†Œ
    if (player.recallCooldown > 0) {
        player.recallCooldown -= dt;
        if (player.recallCooldown < 0) player.recallCooldown = 0;
        player.isRecalling = false;
        player.currentRecallTime = 0;
        return;
    }

    // 2. [ìš°ë¬¼ ë„ì°© ìƒíƒœ] ì¦‰ì‹œ íšŒë³µ ë° íŒë‹¨ ì´ˆê¸°í™”
    const dist = Math.sqrt(Math.pow(player.x - basePos.x, 2) + Math.pow(player.y - basePos.y, 2));
    if (dist <= 5) {
        this.instantRestore(player, isBlue, dt, heroes, shopItems, match);
        
        // [í•µì‹¬] ê·€í™˜/ìš°ë¬¼ ë³µê·€ ì‹œ ìƒíƒœ ì™„ì „ ì´ˆê¸°í™” (ìƒˆë¡œìš´ íŒë‹¨ ìœ ë„)
        player.isRecalling = false;
        player.currentRecallTime = 0;
        (player as any).pathIdx = 0; // ì˜ˆì „ ê²½ë¡œ ê¸°ì–µ ì‚­ì œ
        
        return;
    }

    // 3. ê·€í™˜ ì±„ë„ë§ ì¤‘
    if (player.isRecalling) {
        const settings = useGameStore.getState().gameState.growthSettings;
        const RECALL_DURATION = settings?.recallTime || 8.0; // 10ì´ˆ -> 8ì´ˆë¡œ ì‚´ì§ ë‹¨ì¶• (ë‹µë‹µí•¨ í•´ì†Œ)

        player.currentRecallTime += dt;

        // ê·€í™˜ ì™„ë£Œ
        if (player.currentRecallTime >= RECALL_DURATION) {
            player.x = basePos.x;
            player.y = basePos.y;
            player.isRecalling = false;
            player.currentRecallTime = 0;
            
            // ë„ì°© ì¦‰ì‹œ ì²´ë ¥ 50% íšŒë³µ (ë¹ ë¥¸ ì „ì„  ë³µê·€ ì¤€ë¹„)
            player.currentHp = Math.min(player.maxHp, player.currentHp + player.maxHp * 0.5);
            
            // [í•µì‹¬] ê·€í™˜ ì™„ë£Œ ì‹œì—ë„ ê²½ë¡œ ì´ˆê¸°í™”
            (player as any).pathIdx = 0;
        }
    } else {
        player.currentRecallTime = 0;
    }
  }

  static startRecall(player: LivePlayer) {
    if (player.recallCooldown > 0) return; 
    if (player.isRecalling) return; 

    player.isRecalling = true;
    player.currentRecallTime = 0;
  }

  static cancelRecall(player: LivePlayer) {
    if (player.isRecalling) {
        player.isRecalling = false;
        player.currentRecallTime = 0;
        player.recallCooldown = 3.0; 
    }
  }

  private static instantRestore(
      p: LivePlayer, isBlue: boolean, dt: number, 
      heroes: Hero[], shopItems: any[], match: LiveMatch
  ) {
      // ìš°ë¬¼ íšŒë³µ ì†ë„: ì´ˆë‹¹ 40% (2.5ì´ˆë©´ í’€í”¼)
      p.currentHp = Math.min(p.maxHp, p.currentHp + p.maxHp * 0.4 * dt);
      p.currentMp = Math.min(p.maxMp, p.currentMp + p.maxMp * 0.4 * dt);
      
      // ì•„ì´í…œ êµ¬ë§¤ ì‹œë„
      const enemyTeam = isBlue ? match.redTeam : match.blueTeam;
      attemptBuyItem(p, shopItems, heroes, enemyTeam, match.currentDuration);
  }
}



==========================================
FILE PATH: src/engine/match/systems/RewardSystem.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/systems/RewardSystem.ts
// ==========================================
import { LiveMatch, LivePlayer, Hero } from '../../../types';
import { getDistance } from '../../data/MapData';

export const MINION_REWARD = {
    'MELEE': { gold: 21, xp: 60 },
    'RANGED': { gold: 14, xp: 30 },
    'SIEGE': { gold: 60, xp: 90 },
    'SUMMONED_COLOSSUS': { gold: 150, xp: 200 }
};

/**
 * í†µí•© ë³´ìƒ ë¶„ë°° ì‹œìŠ¤í…œ
 * - ë§‰íƒ€ ì¹œ ì˜ì›…: ê³¨ë“œ/XP íšë“
 * - ì£¼ë³€ ì•„êµ°: XP ê³µìœ 
 * - ìˆ˜í˜¸ê¸°ì‚¬(ì„œí¬í„°): íƒ€ê³¤ì‚° ê³¨ë“œ ê³µìœ 
 */
export const distributeRewards = (
    match: LiveMatch, 
    deadUnitPos: {x:number, y:number}, 
    killer: LivePlayer | null, 
    killerTeam: 'BLUE'|'RED', 
    reward: { gold: number, xp: number },
    heroes: Hero[] 
) => {
    // 1. í‚¬ëŸ¬ ë³´ìƒ
    if (killer) {
        killer.cs++;
        killer.gold += reward.gold;

        // [ì„œí¬í„° íƒ€ê³¤ì‚° ë¡œì§]
        const killerHero = heroes.find(h => h.id === killer.heroId);
        if (killerHero && killerHero.role === 'ìˆ˜í˜¸ê¸°ì‚¬') {
            const allies = killerTeam === 'BLUE' ? match.blueTeam : match.redTeam;
            let nearestAlly = null;
            let minDist = 15;
            
            for (const ally of allies) {
                if (ally !== killer && ally.currentHp > 0) {
                    const d = getDistance(killer, ally);
                    if (d < minDist) {
                        minDist = d;
                        nearestAlly = ally;
                    }
                }
            }

            if (nearestAlly) {
                nearestAlly.gold += reward.gold; // ê³¨ë“œ ê³µìœ 
                nearestAlly.cs++; // ê¸°ë¶„ ì¢‹ê²Œ CSë„ 1 ì˜¬ë ¤ì¤Œ
            }
        }
    }

    // 2. ê²½í—˜ì¹˜ ë¶„ë°° (Në¹µ)
    const allies = killerTeam === 'BLUE' ? match.blueTeam : match.redTeam;
    const beneficiaries = allies.filter(p => 
        p.currentHp > 0 && 
        p.respawnTimer <= 0 &&
        getDistance(p, deadUnitPos) < 18 
    );

    if (beneficiaries.length > 0) {
        const xpPerPerson = Math.floor(reward.xp / beneficiaries.length);
        beneficiaries.forEach(p => {
            (p as any).exp = ((p as any).exp || 0) + xpPerPerson;
        });
    }
};

// ì–´ì‹œìŠ¤íŠ¸ ë³´ìƒ
export const distributeAssist = (match: LiveMatch, killer: LivePlayer, victim: LivePlayer, isBlue: boolean) => {
    const allies = isBlue ? match.blueTeam : match.redTeam;
    const assists = allies.filter(p => p !== killer && p.currentHp > 0 && getDistance(p, victim) < 20);
    
    assists.forEach(p => {
        p.assists++;
        p.gold += 150; 
        (p as any).exp = ((p as any).exp || 0) + 100;
    });
};



==========================================
FILE PATH: src/engine/match/systems/RoleManager.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/RoleManager.ts
// ==========================================

import { Role, LivePlayer, RoleSettings } from '../../../types';

// ê¸°ë³¸ê°’ (ì„¤ì • ë¡œë“œ ì‹¤íŒ¨ ì‹œ ì•ˆì „ì¥ì¹˜)
const DEFAULT_SETTINGS: RoleSettings = {
  executor: { damage: 15, defense: 15 },
  tracker: { gold: 20, smiteChance: 1.5 },
  prophet: { cdrPerLevel: 2 },
  slayer: { structureDamage: 30 },
  guardian: { survivalRate: 20 }
};

export const applyRoleBonus = (
  player: LivePlayer, 
  role: Role, 
  isSiegeMode: boolean, 
  allies: LivePlayer[],
  settings: RoleSettings = DEFAULT_SETTINGS // [ì¤‘ìš”] ì„¤ì •ê°’ ì¸ì ì¶”ê°€
) => {
  let damageMod = 1.0;
  let defenseMod = 1.0;
  let siegeMod = 1.0;

  switch (role) {
    case 'ì§‘í–‰ê´€': 
      // ê³ ë¦½ ì‹œ ë³´ë„ˆìŠ¤ (ì„¤ì •ëœ %ë§Œí¼ ì¦ê°€)
      const nearbyAllies = allies.filter(a => a.lane === player.lane && a.heroId !== player.heroId).length;
      if (nearbyAllies === 0) {
        damageMod = 1 + (settings.executor.damage / 100); 
        defenseMod = 1 + (settings.executor.defense / 100);
      }
      break;

    case 'ì¶”ì ì': 
      // ì •ê¸€ëŸ¬ ê¸°ë³¸ ë³´ì •
      damageMod = 1.05; 
      break;

    case 'ì„ ì§€ì': 
      // ë ˆë²¨ë‹¹ ì„¤ì •ëœ %ë§Œí¼ ë°ë¯¸ì§€ ë³´ë„ˆìŠ¤ (ì¿¨ê°ì„ ë”œëŸ‰ìœ¼ë¡œ í™˜ì‚°)
      // ì˜ˆ: ë ˆë²¨ 10 * 2% = 20% ë°ë¯¸ì§€ ì¦ê°€
      damageMod = 1 + ((player.level * settings.prophet.cdrPerLevel) / 100);
      break;

    case 'ì‹ ì‚´ì': 
      if (isSiegeMode) {
        // êµ¬ì¡°ë¬¼ í”¼í•´ëŸ‰ ë³´ë„ˆìŠ¤
        siegeMod = 1 + (settings.slayer.structureDamage / 100);
      }
      if (player.items.length >= 3) {
        damageMod = 1.25;
      }
      break;

    case 'ìˆ˜í˜¸ê¸°ì‚¬': 
      // ë°©ì–´ë ¥ ë³´ë„ˆìŠ¤
      defenseMod = 1.3; 
      damageMod = 0.6;  
      break;
  }

  return { damageMod, defenseMod, siegeMod };
};

// ì •ê¸€ëŸ¬ ê°•íƒ€ í™•ë¥  ë³´ì •
export const getSmiteChance = (role: Role, settings: RoleSettings = DEFAULT_SETTINGS) => {
  return role === 'ì¶”ì ì' ? settings.tracker.smiteChance : 1.0; 
};


==========================================
FILE PATH: src/engine/match/systems/SkillProcessor.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/systems/SkillProcessor.ts
// ==========================================
import { SkillDetail } from '../../../types';
import { StatusManager } from './StatusManager';

export const processSkillEffect = (skill: SkillDetail, attacker: any, target: any) => {
  let power = skill.val + (attacker.stats.ad * skill.adRatio) + (attacker.stats.ap * skill.apRatio);

  switch (skill.mechanic) {
    case 'EXECUTE':
      if (target.currentHp / target.maxHp < 0.25) power *= 5; 
      break;
      
    case 'STUN':
    case 'HOOK':
      // [ìˆ˜ì •] StatusManagerë¥¼ í†µí•´ ì •í™•í•œ ì‹œê°„ ë™ì•ˆ ê¸°ì ˆì‹œí‚´
      // ìŠ¤í‚¬ ë°ì´í„°ì— durationì´ ì—†ìœ¼ë©´ ê¸°ë³¸ 1.5ì´ˆ
      const duration = skill.duration || 1.5;
      StatusManager.applyStun(target, duration);
      break;
      
    case 'HEAL':
      attacker.currentHp = Math.min(attacker.maxHp, attacker.currentHp + power);
      return 0;
      
    case 'SHIELD':
      // ì‰´ë“œ ë¡œì§ì€ ê°„ì†Œí™” (ì²´ë ¥ì„ ì„ì‹œë¡œ ëŠ˜ë¦¼ or ë³„ë„ ì²˜ë¦¬)
      // ì—¬ê¸°ì„œëŠ” ì¦‰ì‹œ íšŒë³µìœ¼ë¡œ ëŒ€ì²´ (êµ¬í˜„ ë³µì¡ë„ ì™„í™”)
      attacker.currentHp = Math.min(attacker.maxHp, attacker.currentHp + power * 0.5);
      return 0;
  }
  
  return Math.floor(power);
};



==========================================
FILE PATH: src/engine/match/systems/StatCalculator.ts
==========================================
// src/engine/battle/StatCalculator.ts
import { HeroStats, GodSettings } from '../../../types';

export const calculateDamage = (
  attackerStats: HeroStats,
  defenderStats: HeroStats,
  godBuff: GodSettings,
  isCritical: boolean
) => {
  // ê¸°ë³¸ ë°ë¯¸ì§€ = (ê¸°ë³¸ê³µê²©ë ¥ + AD) * ì§„ì˜ ê³µê²© ê°€ì¤‘ì¹˜
  let baseDmg = (attackerStats.baseAtk + attackerStats.ad) * godBuff.atkRatio;

  if (isCritical) baseDmg *= 1.75;

  // ë°©ì–´ë ¥ ê³„ì‚° (ê´€í†µë ¥ ì ìš©)
  const effectiveArmor = Math.max(0, defenderStats.armor - attackerStats.pen);
  const damageReduction = 100 / (100 + (effectiveArmor * godBuff.defRatio));

  return Math.floor(baseDmg * damageReduction);
};


==========================================
FILE PATH: src/engine/match/systems/StatusManager.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/systems/StatusManager.ts
// ==========================================
import { LivePlayer } from '../../../types';

interface StatusState {
  stunTimer: number;   // ê¸°ì ˆ ë‚¨ì€ ì‹œê°„
  slowTimer: number;   // ë‘”í™” ë‚¨ì€ ì‹œê°„
  silenceTimer: number; // ì¹¨ë¬µ ë‚¨ì€ ì‹œê°„
}

// ê°ì²´ì— ì§ì ‘ ì†ì„±ì„ ì¶”ê°€í•˜ì§€ ì•Šê³  ì™¸ë¶€ì—ì„œ ê´€ë¦¬ (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€)
const statusStore = new WeakMap<LivePlayer, StatusState>();

export class StatusManager {
  
  static init(player: LivePlayer) {
    if (!statusStore.has(player)) {
      statusStore.set(player, { stunTimer: 0, slowTimer: 0, silenceTimer: 0 });
    }
  }

  static applyStun(player: LivePlayer, duration: number) {
    this.init(player);
    const state = statusStore.get(player)!;
    // ê¸°ì¡´ ìŠ¤í„´ë³´ë‹¤ ê¸¸ë©´ ë®ì–´ì”Œì›€ (ê°•ì¸í•¨ ë¡œì§ ì¶”ê°€ ê°€ëŠ¥)
    if (duration > state.stunTimer) {
        state.stunTimer = duration;
    }
  }

  static update(player: LivePlayer, dt: number) {
    const state = statusStore.get(player);
    if (!state) return;

    if (state.stunTimer > 0) state.stunTimer -= dt;
    if (state.slowTimer > 0) state.slowTimer -= dt;
    if (state.silenceTimer > 0) state.silenceTimer -= dt;
  }

  static isStunned(player: LivePlayer): boolean {
    const state = statusStore.get(player);
    return state ? state.stunTimer > 0 : false;
  }

  static getRemainingStunTime(player: LivePlayer): number {
    const state = statusStore.get(player);
    return state ? Math.max(0, state.stunTimer) : 0;
  }
}



==========================================
FILE PATH: src/engine/match/systems/SteeringSystem.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/systems/SteeringSystem.ts
// ==========================================
import { Vector, Vector2 } from '../utils/Vector';
import { LivePlayer } from '../../../types';
import { MOVEMENT_SETTINGS } from '../constants/MapConstants';

export class SteeringSystem {
  static calculateSteering(
    me: LivePlayer, 
    target: Vector2, 
    neighbors: LivePlayer[], 
    maxSpeed: number
  ): Vector2 {
    const myPos = { x: me.x, y: me.y };
    
    // 1. Seek (ëª©ì ì§€ ì´ë™)
    const desired = Vector.sub(target, myPos);
    const dist = Vector.mag(desired);
    
    // [ìµœì í™”] ë„ì°© ì‹œ ì™„ì „ ì •ì§€ (ë–¨ë¦¼ ë°©ì§€)
    if (dist < 0.5) {
        return { x: 0, y: 0 };
    }

    let seekForce = Vector.normalize(desired);
    
    // Arrival (ê°ì†)
    if (dist < MOVEMENT_SETTINGS.ARRIVAL_TOLERANCE * 5) {
      const m = (dist / (MOVEMENT_SETTINGS.ARRIVAL_TOLERANCE * 5)) * maxSpeed;
      seekForce = Vector.mult(seekForce, m);
    } else {
      seekForce = Vector.mult(seekForce, maxSpeed);
    }

    // 2. Separation (ë°€ì–´ë‚´ê¸°) - [ìˆ˜ì •] í˜ ëŒ€í­ ì•½í™”
    let sepForce = { x: 0, y: 0 };
    let count = 0;
    
    for (const other of neighbors) {
      if (other === me || other.currentHp <= 0) continue;
      const d = Vector.dist(myPos, { x: other.x, y: other.y });
      
      if (d > 0 && d < MOVEMENT_SETTINGS.SEPARATION_DIST) {
        let diff = Vector.sub(myPos, { x: other.x, y: other.y });
        diff = Vector.normalize(diff);
        diff = Vector.div(diff, d); 
        sepForce = Vector.add(sepForce, diff);
        count++;
      }
    }
    
    if (count > 0) {
      sepForce = Vector.div(sepForce, count);
      sepForce = Vector.normalize(sepForce);
      // [ìˆ˜ì •] ë°€ì–´ë‚´ëŠ” í˜ì„ maxSpeedë§Œí¼ ì£¼ì§€ ì•Šê³  0.5ë°°ë¡œ ì¤„ì„ (ëœëœê±°ë¦¼ ë°©ì§€)
      sepForce = Vector.mult(sepForce, maxSpeed * 0.5); 
    }

    // [ìˆ˜ì •] í˜ì˜ í•©ì„± ë¹„ìœ¨ ì¡°ì • (ì´ë™ ìš°ì„ ìˆœìœ„ ë†’ì„)
    // ê¸°ì¡´: Seek 1.0 : Sep 1.5 -> ë³€ê²½: Seek 1.2 : Sep 0.6
    const totalForce = Vector.add(
      Vector.mult(seekForce, 1.2),
      Vector.mult(sepForce, 0.6) 
    );
    
    return totalForce; 
  }
}



==========================================
FILE PATH: src/engine/match/systems/VisualSystem.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/systems/VisualSystem.ts
// ==========================================
import { LiveMatch, VisualEffect } from '../../../types';

export class VisualSystem {
  // [ìµœì í™”] ì´í™íŠ¸ ì‹œìŠ¤í…œ ì™„ì „ ë¹„í™œì„±í™”
  // í‰íƒ€, ìŠ¤í‚¬ ì´í™íŠ¸ ë“±ì„ ìš”ì²­í•´ë„ ì•„ë¬´ ì¼ë„ ì¼ì–´ë‚˜ì§€ ì•ŠìŒ
  static addEffect(match: LiveMatch, effect: Omit<VisualEffect, 'id' | 'duration' | 'maxDuration'>, duration: number = 0.5) {
    return; 
  }

  static update(match: LiveMatch, dt: number) {
    // ê¸°ì¡´ì— ë‚¨ì•„ìˆì„ì§€ ëª¨ë¥¼ ì´í™íŠ¸ ë°°ì—´ë§Œ ì •ë¦¬ (ë©”ëª¨ë¦¬ í•´ì œ)
    if (match.visualEffects && match.visualEffects.length > 0) {
        match.visualEffects = [];
    }
  }
}



==========================================
FILE PATH: src/engine/match/utils/Collision.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/utils/Collision.ts
// ==========================================

export interface Point { x: number; y: number; }

export class Collision {
  // [ìµœì í™”] ê±°ë¦¬ ì œê³± ê³„ì‚° (ë£¨íŠ¸ ì—°ì‚° ì œê±°)
  static distSq(p1: Point, p2: Point): number {
    const dx = p1.x - p2.x;
    const dy = p1.y - p2.y;
    return dx * dx + dy * dy;
  }

  // [ìµœì í™”] ì›í˜• ì¶©ëŒ ì²´í¬
  static checkCircle(p1: Point, r1: number, p2: Point, r2: number): boolean {
    const d2 = this.distSq(p1, p2);
    const radSum = r1 + r2;
    return d2 <= radSum * radSum;
  }

  // [ìµœì í™”] ì‚¬ê±°ë¦¬ ì²´í¬ (ê±°ë¦¬ ì œê³± ë¹„êµ)
  static inRange(attacker: Point, target: Point, range: number): boolean {
    return this.distSq(attacker, target) <= (range * range);
  }

  // [ìµœì í™”] ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
  static findNearest<T extends Point>(me: Point, targets: T[], maxRange: number = 999): T | null {
    let nearest: T | null = null;
    let minDistSq = maxRange * maxRange;

    for (let i = 0; i < targets.length; i++) {
      const t = targets[i];
      const dSq = this.distSq(me, t);
      
      if (dSq < minDistSq) {
        minDistSq = dSq;
        nearest = t;
      }
    }
    return nearest;
  }
}



==========================================
FILE PATH: src/engine/match/utils/SpatialGrid.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/utils/SpatialGrid.ts
// ==========================================
import { Vector2 } from '../Vector';

// ë§µ í¬ê¸° 100x100 ê¸°ì¤€
const MAP_SIZE = 100;
// ì…€ í•˜ë‚˜ë‹¹ í¬ê¸° (ì‚¬ê±°ë¦¬ì™€ ë¹„ìŠ·í•œ 10~15 ì •ë„ê°€ ì ë‹¹)
const CELL_SIZE = 10;
// í–‰/ì—´ ê°œìˆ˜ (100 / 10 = 10ê°œ)
const COLS = Math.ceil(MAP_SIZE / CELL_SIZE);

export class SpatialGrid {
  private cells: Map<number, any[]> = new Map();

  constructor(units: any[]) {
    // ìƒì„±ê³¼ ë™ì‹œì— ê·¸ë¦¬ë“œ êµ¬ì¶• (O(N) - ë§¤ìš° ë¹ ë¦„)
    this.build(units);
  }

  private build(units: any[]) {
    this.cells.clear();
    for (const unit of units) {
      if (unit.currentHp <= 0) continue; // ì£½ì€ ìœ ë‹› ì œì™¸
      
      const index = this.getCellIndex(unit.x, unit.y);
      if (!this.cells.has(index)) {
        this.cells.set(index, []);
      }
      this.cells.get(index)!.push(unit);
    }
  }

  // ì¢Œí‘œë¥¼ ì…€ ì¸ë±ìŠ¤ë¡œ ë³€í™˜
  private getCellIndex(x: number, y: number): number {
    const col = Math.floor(Math.max(0, Math.min(MAP_SIZE - 1, x)) / CELL_SIZE);
    const row = Math.floor(Math.max(0, Math.min(MAP_SIZE - 1, y)) / CELL_SIZE);
    return row * COLS + col;
  }

  // ë‚´ ì£¼ë³€(ìì‹ ì´ ì†í•œ ì…€ + ì¸ì ‘ 8ê°œ ì…€)ì— ìˆëŠ” ìœ ë‹›ë“¤ë§Œ ë°˜í™˜
  public getNearbyUnits(me: Vector2): any[] {
    const centerIndex = this.getCellIndex(me.x, me.y);
    const result: any[] = [];

    const row = Math.floor(centerIndex / COLS);
    const col = centerIndex % COLS;

    // ì¸ì ‘ 3x3 ì…€ íƒìƒ‰
    for (let r = row - 1; r <= row + 1; r++) {
      for (let c = col - 1; c <= col + 1; c++) {
        if (r >= 0 && r < COLS && c >= 0 && c < COLS) {
          const idx = r * COLS + c;
          const unitsInCell = this.cells.get(idx);
          if (unitsInCell) {
            // for ë£¨í”„ê°€ concatë³´ë‹¤ ë¹ ë¦„
            for (let i = 0; i < unitsInCell.length; i++) {
                result.push(unitsInCell[i]);
            }
          }
        }
      }
    }
    return result;
  }
}



==========================================
FILE PATH: src/engine/match/utils/StatUtils.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/match/utils/StatUtils.ts
// ==========================================
import { HeroStats, Item, Hero, GrowthIntervals } from '../../../types';
import { useGameStore } from '../../../store/useGameStore';

export const getLevelScaledStats = (baseStats: HeroStats, level: number): HeroStats => {
  const state = useGameStore.getState().gameState;
  const g = state?.growthSettings || { 
      hp: {early:5,mid:10,late:15}, 
      ad: {early:3,mid:5,late:8}, 
      ap: {early:3,mid:5,late:8}, 
      armor: {early:2,mid:3,late:4}, 
      baseAtk: {early:2,mid:3,late:4}, 
      regen: {early:1,mid:2,late:3},
      respawnPerLevel: 3.0,
      recallTime: 10.0
  };

  const getMultiplier = (targetLevel: number, intervals: GrowthIntervals) => {
    if (targetLevel <= 1) return 0;
    let totalPercent = 0;
    for (let i = 2; i <= targetLevel; i++) {
        if (i <= 6) totalPercent += intervals.early;       
        else if (i <= 12) totalPercent += intervals.mid;   
        else totalPercent += intervals.late;               
    }
    return totalPercent / 100;
  };

  const scale = (val: number, intervals: GrowthIntervals) => {
    if (!intervals) return val;
    const multiplier = getMultiplier(level, intervals);
    return Math.floor(val * (1 + multiplier));
  };

  // [í•µì‹¬ ë°¸ëŸ°ìŠ¤ íŒ¨ì¹˜] 
  // 1ë ˆë²¨ ê¸°ë³¸ ë§·ì§‘ì„ ëŒ€í­ ìƒí–¥í•˜ì—¬ ì´ˆë°˜ 'ì˜ë¬¸ì‚¬' ë°©ì§€
  const FLAT_HP_BONUS = 500;
  const FLAT_ARMOR_BONUS = 20;

  return {
    ...baseStats,
    hp: scale(baseStats.hp, g.hp) + FLAT_HP_BONUS,        
    ad: scale(baseStats.ad, g.ad),        
    ap: scale(baseStats.ap, g.ap),        
    armor: scale(baseStats.armor, g.armor) + FLAT_ARMOR_BONUS,  
    baseAtk: scale(baseStats.baseAtk, g.baseAtk),
    regen: scale(baseStats.regen, g.regen),
    pen: baseStats.pen, 
  };
};

export const calculateTotalStats = (hero: Hero, items: Item[]): HeroStats => {
  let stats = { ...hero.stats };
  items.forEach(item => {
    stats.ad += (item.ad || 0);
    stats.ap += (item.ap || 0);
    stats.hp += (item.hp || 0);
    stats.mp += (item.mp || 0);
    stats.armor += (item.armor || 0);
    stats.crit += (item.crit || 0);
    stats.speed += (item.speed || 0);
    stats.regen += (item.regen || 0);
    stats.mpRegen += (item.mpRegen || 0);
    stats.pen += (item.pen || 0);
  });
  return stats;
};



==========================================
FILE PATH: src/engine/match/utils/Vector.ts
==========================================
export interface Vector2 { x: number; y: number; }

export class Vector {
  static add(v1: Vector2, v2: Vector2): Vector2 { return { x: v1.x + v2.x, y: v1.y + v2.y }; }
  static sub(v1: Vector2, v2: Vector2): Vector2 { return { x: v1.x - v2.x, y: v1.y - v2.y }; }
  static mult(v: Vector2, n: number): Vector2 { return { x: v.x * n, y: v.y * n }; }
  static div(v: Vector2, n: number): Vector2 { return n === 0 ? v : { x: v.x / n, y: v.y / n }; }
  
  static mag(v: Vector2): number { return Math.sqrt(v.x * v.x + v.y * v.y); }
  
  static normalize(v: Vector2): Vector2 {
    const m = Vector.mag(v);
    return m === 0 ? { x: 0, y: 0 } : Vector.div(v, m);
  }

  static dist(v1: Vector2, v2: Vector2): number {
    return Math.sqrt(Math.pow(v1.x - v2.x, 2) + Math.pow(v1.y - v2.y, 2));
  }

  static limit(v: Vector2, max: number): Vector2 {
    const m = Vector.mag(v);
    return m > max ? Vector.mult(Vector.normalize(v), max) : v;
  }
  
  // ì„ í˜• ë³´ê°„ (ë¶€ë“œëŸ¬ìš´ ì›€ì§ì„)
  static lerp(v1: Vector2, v2: Vector2, t: number): Vector2 {
    return {
      x: v1.x + (v2.x - v1.x) * t,
      y: v1.y + (v2.y - v1.y) * t
    };
  }
}



==========================================
FILE PATH: src/engine/SaveLoadSystem.ts
==========================================
import { userPool, replaceUserPool, initUserPool, getTopRankers } from './system/UserManager';
import { analyzeHeroMeta, calculateUserEcosystem } from './system/RankingSystem';
import { useGameStore } from '../store/useGameStore';
import { Hero, GameState, SaveMeta, UserProfile, LiveMatch, LivePlayer, Item } from '../types';
import { IDBStorage } from '../utils/IDBStorage';

const META_KEY = 'GW_SAVE_META';
const PENDING_LOAD_KEY = 'GW_PENDING_LOAD';

export const saveToSlot = async (slotId: string): Promise<boolean> => {
  const store = useGameStore.getState();
  const state = store.gameState;

  const optimizedMatches = state.liveMatches.map(m => ({
    ...m, 
    logs: [], timeline: [], minions: [], projectiles: [], jungleMobs: []    
  }));

  const saveData = {
    version: 24, // ë²„ì „ ì—…
    time: { season: state.season, day: state.day, hour: state.hour, minute: state.minute },
    config: {
      battle: state.battleSettings,
      field: state.fieldSettings,
      role: state.roleSettings,
      tier: state.tierConfig,
      ai: state.aiConfig,
      growth: state.growthSettings 
    },
    customImages: state.customImages,
    heroes: store.heroes.map(h => ({ id: h.id, record: h.record, concept: h.concept, name: h.name })),
    users: userPool, 
    itemStats: state.itemStats,
    shopItems: store.shopItems,
    godStats: state.godStats, 
    liveMatches: optimizedMatches,
    timestamp: Date.now()
  };

  try {
    await IDBStorage.setItem(slotId, saveData);
    const now = new Date();
    const meta: SaveMeta = {
      slotId, timestamp: Date.now(), realDateStr: now.toLocaleString(), 
      gameTimeDisplay: `S${state.season} D${state.day}`, totalUsers: userPool.length
    };
    const json = localStorage.getItem(META_KEY);
    const allMeta = json ? JSON.parse(json) : {};
    allMeta[slotId] = meta;
    localStorage.setItem(META_KEY, JSON.stringify(allMeta));
    return true;
  } catch (e: any) {
    alert(`ì €ì¥ ì‹¤íŒ¨: ${e.message}`);
    return false;
  }
};

export const loadFromSlot = async (slotId: string, defaultHeroes: Hero[]): Promise<boolean> => {
  try {
    let data = await IDBStorage.getItem(slotId);
    if (!data) {
        const legacyJson = localStorage.getItem(`GW_SAVE_DATA_${slotId}`);
        if(legacyJson) data = JSON.parse(legacyJson);
        else return false;
    }
    localStorage.setItem(PENDING_LOAD_KEY, slotId);
    window.location.reload();
    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
};

export const initializeGame = async (heroes: Hero[]) => {
  const pendingSlot = localStorage.getItem(PENDING_LOAD_KEY);
  if (pendingSlot) {
    console.log("ğŸ”„ [System] ë°ì´í„° ë¡œë“œ ë° ë¬´ê²°ì„± ê²€ì‚¬ ì‹œì‘:", pendingSlot);
    localStorage.removeItem(PENDING_LOAD_KEY); 
    try {
        let data = await IDBStorage.getItem(pendingSlot);
        if (data) {
            applyLoadedData(data, heroes);
            return;
        }
    } catch (e) {
        console.error("Critical Load Error:", e);
    }
  }
  if (userPool.length === 0) initUserPool(heroes, 3000);
};

const applyLoadedData = (data: any, defaultHeroes: Hero[]) => {
    const store = useGameStore.getState();
    
    const loadedHeroMap = new Map(data.heroes?.map((h: any) => [h.id, h]) || []);
    const restoredHeroes = defaultHeroes.map(def => {
        const saved = loadedHeroMap.get(def.id);
        return saved ? { ...def, ...saved } : def;
    });

    let restoredUsers: UserProfile[] = [];
    if (data.users && Array.isArray(data.users)) {
        restoredUsers = data.users.map((u: any) => ({
            ...u,
            heroStats: u.heroStats || {},
            history: u.history || [],
            status: 'OFFLINE' 
        }));
    } else {
        initUserPool(restoredHeroes, 3000);
        restoredUsers = [...userPool];
    }

    const validUserNames = new Set(restoredUsers.map(u => u.name));
    const validMatches: LiveMatch[] = [];
    const rawMatches = (data.liveMatches || []);
    
    rawMatches.forEach((m: any) => {
        const participants = [...(m.blueTeam || []), ...(m.redTeam || [])];
        const isValidMatch = participants.length === 10 && participants.every((p: any) => validUserNames.has(p.name));

        if (isValidMatch) {
            validMatches.push({
                ...m,
                minions: [], projectiles: [], jungleMobs: [], logs: [], timeline: [],
                blueTeam: m.blueTeam.map((p:any)=>({...p, items: p.items||[], cooldowns: {q:0,w:0,e:0,r:0}})),
                redTeam: m.redTeam.map((p:any)=>({...p, items: p.items||[], cooldowns: {q:0,w:0,e:0,r:0}})),
                stats: {
                    blue: { ...m.stats?.blue, nexusHp: Number(m.stats?.blue?.nexusHp||5000), towers: m.stats?.blue?.towers||{top:0,mid:0,bot:0}, activeBuffs: m.stats?.blue?.activeBuffs||{siegeUnit:false,voidPower:false} },
                    red: { ...m.stats?.red, nexusHp: Number(m.stats?.red?.nexusHp||5000), towers: m.stats?.red?.towers||{top:0,mid:0,bot:0}, activeBuffs: m.stats?.red?.activeBuffs||{siegeUnit:false,voidPower:false} }
                },
                objectives: {
                    colossus: { hp: 0, maxHp: 10000, status: 'DEAD', nextSpawnTime: m.currentDuration+60 },
                    watcher: { hp: 0, maxHp: 10000, status: 'DEAD', nextSpawnTime: m.currentDuration+120 }
                }
            });
            participants.forEach((p: any) => {
                const u = restoredUsers.find(user => user.name === p.name);
                if (u) u.status = 'INGAME';
            });
        }
    });

    replaceUserPool(restoredUsers);

    let loadedGrowth = data.config?.growth;
    if (loadedGrowth && typeof loadedGrowth.hp === 'number') {
        const convert = (val: number) => ({ early: Math.floor(val*0.6), mid: val, late: Math.floor(val*1.4) });
        loadedGrowth = {
            hp: convert(loadedGrowth.hp),
            ad: convert(loadedGrowth.ad),
            ap: convert(loadedGrowth.ap),
            armor: convert(loadedGrowth.armor),
            baseAtk: convert(loadedGrowth.baseAtk),
            regen: convert(loadedGrowth.regen),
            respawnPerLevel: 3.0,
            recallTime: 10.0
        };
    }
    if (!loadedGrowth) {
        loadedGrowth = { 
            hp: {early:3,mid:5,late:7}, ad: {early:5,mid:10,late:15}, ap: {early:5,mid:10,late:15},
            armor: {early:2,mid:3,late:4}, baseAtk: {early:2,mid:3,late:4}, regen: {early:1,mid:2,late:3},
            respawnPerLevel: 3.0, recallTime: 10.0
        };
    }
    // [í˜¸í™˜ì„±] ê·€í™˜ ì‹œê°„ 10ì´ˆ ê°•ì œ (ë°ì´í„°ê°€ ì—†ê±°ë‚˜ ë„ˆë¬´ ì§§ìœ¼ë©´)
    if (loadedGrowth.recallTime === undefined || loadedGrowth.recallTime < 4) loadedGrowth.recallTime = 10.0;
    if (loadedGrowth.respawnPerLevel === undefined) loadedGrowth.respawnPerLevel = 3.0;

    useGameStore.setState({ 
        gameState: {
            ...store.gameState,
            ...data.time,
            tierConfig: { ...store.gameState.tierConfig, ...data.config?.tier },
            battleSettings: { ...store.gameState.battleSettings, ...data.config?.battle },
            fieldSettings: { ...store.gameState.fieldSettings, ...data.config?.field },
            roleSettings: { ...store.gameState.roleSettings, ...data.config?.role },
            aiConfig: { ...store.gameState.aiConfig, ...data.config?.ai },
            growthSettings: loadedGrowth,
            
            itemStats: data.itemStats || {},
            godStats: data.godStats || store.gameState.godStats,
            customImages: { ...store.gameState.customImages, ...(data.customImages || {}) },
            liveMatches: validMatches,
            totalUsers: restoredUsers.length,
            topRankers: getTopRankers(restoredHeroes, data.config?.tier),
            userStatus: calculateUserEcosystem(validMatches.length * 10, restoredUsers.length, data.config?.tier),
            isPlaying: false 
        },
        heroes: analyzeHeroMeta(restoredHeroes),
        shopItems: data.shopItems || store.shopItems
    });
};

export const getSlotsMeta = (): Record<string, SaveMeta> => {
  try {
    const json = localStorage.getItem(META_KEY);
    return json ? JSON.parse(json) : {};
  } catch { return {}; }
};

export const deleteSlot = async (slotId: string) => {
  await IDBStorage.removeItem(slotId); 
  const meta = getSlotsMeta();
  delete meta[slotId];
  localStorage.setItem(META_KEY, JSON.stringify(meta));
};

export const exportSaveFile = async () => {};
export const importSaveFile = (file: File, heroes: Hero[]) => { return new Promise<boolean>((r)=>r(false)); };



==========================================
FILE PATH: src/engine/spectate/SpectateAI.ts
==========================================
// src/engine/SpectateAI.ts
import { LivePlayer } from '../types';

export interface VisualUnit extends LivePlayer {
  vx: number;
  vy: number;
  role: string;
}

const getDist = (x1: number, y1: number, x2: number, y2: number) => 
  Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));

export function updateUnitAI(
  u: VisualUnit, 
  allies: VisualUnit[], 
  enemies: VisualUnit[], 
  isBlue: boolean
): VisualUnit {

  // 1. ì‚¬ë§ ì‹œ ê¸°ì§€ ìœ„ì¹˜ ê³ ì •
  if (u.currentHp <= 0) {
    u.vx = isBlue ? 12 : 88;
    u.vy = isBlue ? 88 : 12;
    return u;
  }

  // 2. ì  íƒì§€
  let target: VisualUnit | null = null;
  let minDist = 20; // ì¸ì‹ ë²”ìœ„ 20%

  enemies.forEach(e => {
    if (e.currentHp > 0) {
      const d = getDist(u.vx, u.vy, e.vx, e.vy);
      if (d < minDist) { minDist = d; target = e; }
    }
  });

  const speed = 0.25; // ì´ë™ ì†ë„ (ì˜ìƒë³´ë‹¤ ë” ë¹ ë¥´ê²Œ ì„¤ì •)

  if (target) {
    const d = getDist(u.vx, u.vy, target.vx, target.vy);
    if (d > 4) { // ì‚¬ê±°ë¦¬ ë°–ì´ë©´ ì¶”ê²©
      u.vx += ((target.vx - u.vx) / d) * speed;
      u.vy += ((target.vy - u.vy) / d) * speed;
    } else {
      // êµì „ ì¤‘ (ë¯¸ì„¸í•œ ë–¨ë¦¼)
      u.vx += (Math.random() - 0.5) * 0.15;
      u.vy += (Math.random() - 0.5) * 0.15;
    }
  } else {
    // [ë¼ì¸ ì´ë™]
    const dest = getLanePath(u.lane, isBlue, u.vx, u.vy);
    const dDest = getDist(u.vx, u.vy, dest.x, dest.y);
    if (dDest > 1) {
      u.vx += ((dest.x - u.vx) / dDest) * speed;
      u.vy += ((dest.y - u.vy) / dDest) * speed;
    }
  }

  // ìœ ë‹›ë¼ë¦¬ ë„ˆë¬´ ê²¹ì¹˜ì§€ ì•Šê²Œ ë°€ì–´ë‚´ê¸°
  allies.forEach(mate => {
    if (mate.name === u.name) return;
    if (getDist(u.vx, u.vy, mate.vx, mate.vy) < 2) {
      u.vx += (Math.random() - 0.5) * 0.1;
      u.vy += (Math.random() - 0.5) * 0.1;
    }
  });

  return u;
}

function getLanePath(lane: string, isBlue: boolean, cx: number, cy: number) {
  const blueBase = { x: 12, y: 88 };
  const redBase = { x: 88, y: 12 };
  const target = isBlue ? redBase : blueBase;

  if (lane === 'MID') return target;
  if (lane === 'TOP') {
    if (isBlue) return cy > 15 ? { x: 12, y: 12 } : target;
    return cx > 15 ? { x: 12, y: 12 } : target;
  }
  if (lane === 'BOT') {
    if (isBlue) return cx < 85 ? { x: 88, y: 88 } : target;
    return cy < 85 ? { x: 88, y: 88 } : target;
  }
  return { x: 50, y: 50 };
}


==========================================
FILE PATH: src/engine/spectate/SpectateEngine.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/spectate/SpectateEngine.ts
// ==========================================

export const MAP = {
  BLUE_BASE: { x: 15, y: 85 },
  RED_BASE: { x: 85, y: 15 },
  CENTER: { x: 50, y: 50 }
};

// [ë³´ê°„ í•¨ìˆ˜] í˜„ì¬ UI ì¢Œí‘œ(current)ë¥¼ ëª©í‘œ ì‹œë®¬ë ˆì´ì…˜ ì¢Œí‘œ(target)ë¡œ ë¶€ë“œëŸ½ê²Œ ì´ë™
export const lerpPosition = (current: {x:number, y:number}, target: {x:number, y:number}, factor: number) => {
  const dx = target.x - current.x;
  const dy = target.y - current.y;
  
  // ê±°ë¦¬ê°€ ë„ˆë¬´ ë©€ë©´(í…”ë ˆí¬íŠ¸, ê·€í™˜ ë“±) ìˆœê°„ì´ë™ ì²˜ë¦¬ (ë¶€ë“œëŸ¬ìš´ ì´ë™ ìƒëµ)
  if (Math.abs(dx) > 20 || Math.abs(dy) > 20) return target;

  return {
    x: current.x + dx * factor,
    y: current.y + dy * factor
  };
};



==========================================
FILE PATH: src/engine/system/CommunityEngine.ts
==========================================
import { Hero, TierConfig, Post, Comment, AIConfig, BattleSettings, BattlefieldSettings } from '../../types';
import { fetchAIPost, fetchAIComment } from '../../utils/AIService';
// [ì¤‘ìš”] ìœ ì € ê°ì²´ ì•ˆì— í•¨ìˆ˜ê°€ ì—†ìœ¼ë¯€ë¡œ, ì™¸ë¶€ í•¨ìˆ˜ë¥¼ ê°€ì ¸ì™€ì„œ ì”ë‹ˆë‹¤.
import { getUserTierName } from './UserManager'; 

const pick = <T>(arr: T[]): T => arr[Math.floor(Math.random() * arr.length)];

const getTierWeight = (tier: string) => {
  if (tier.includes('ì²œìƒê³„') || tier.includes('ì±Œë¦°ì €')) return 50;
  if (tier.includes('ë§ˆìŠ¤í„°') || tier.includes('ì—ì´ìŠ¤')) return 30;
  if (tier.includes('ì¡°ì»¤') || tier.includes('ë‹¤ì´ì•„')) return 20;
  if (tier.includes('ê³¨ë“œ') || tier.includes('í”Œë˜í‹°ë„˜')) return 10;
  if (tier.includes('ì‹¤ë²„')) return 5;
  return 0; 
};

const getRichTopicContext = (heroes: Hero[], userPool: any[], battleSettings: BattleSettings) => {
  const rand = Math.random();

  if (rand < 0.05 && userPool.length > 0) {
    const targetUser = pick(userPool); 
    // ì—¬ê¸°ì„œëŠ” ë‹¨ìˆœíˆ ì´ë¦„ë§Œ ì“°ë¯€ë¡œ ìˆ˜ì • ë¶ˆí•„ìš”
    const isHighRank = targetUser.score > 3000;
    const isFeeder = targetUser.winRate < 45;

    let tone = "ë¹„ë‚œ";
    if (isHighRank) tone = "ì§ˆíˆ¬/ì˜ì‹¬";
    else if (isFeeder) tone = "ê·¹ë”œ";

    return {
      type: 'SNIPING',
      text: `ì£¼ì œ: ìœ ì € '${targetUser.name}' ì €ê²©. (ì ìˆ˜: ${targetUser.score}). ${tone}í•˜ëŠ” ë‚´ìš©.`
    };
  } 
  else if (rand < 0.40) {
    const h = pick(heroes);
    return { type: 'BALANCE', text: `ì£¼ì œ: ${h.name} ë°¸ëŸ°ìŠ¤ í† ë¡ .` };
  }
  else if (rand < 0.55) {
    return { type: 'SYSTEM', text: `ì£¼ì œ: ê²Œì„ ì‹œìŠ¤í…œ ë¶ˆë§Œ.` };
  }
  else if (rand < 0.75) {
    return { type: 'NONSENSE', text: `ì£¼ì œ: ì•„ë¬´ë§ ëŒ€ì”ì¹˜.` };
  }
  else {
    return { type: 'NORMAL', text: `ì£¼ì œ: ê²Œì„ ì¡ë‹´.` };
  }
};

export async function generatePostAsync(
  uniqueId: number, 
  heroes: Hero[], 
  tierConfig: TierConfig, 
  currentTick: number, 
  aiConfig: AIConfig,
  userPool: any[], 
  battleSettings: BattleSettings,
  fieldSettings: BattlefieldSettings
): Promise<Post | null> {

  if (!aiConfig.apiKey || !aiConfig.enabled) return null;
  if (!userPool || userPool.length === 0) return null;

  const author = pick(userPool);
  // [ìˆ˜ì •] author.getTierName() -> getUserTierName(author, tierConfig)
  const currentTierName = getUserTierName(author, tierConfig); 
  const mostChamp = heroes.find(h => h.id === author.mainHeroId)?.name || 'ëœë¤';

  const contextObj = getRichTopicContext(heroes, userPool, battleSettings);
  let category = "ì¡ë‹´";
  if (contextObj.type === 'SNIPING') category = 'ì§•ì§•';
  else if (contextObj.type === 'BALANCE') category = 'ë¶„ì„';
  else if (contextObj.type === 'NONSENSE') category = 'ìœ ë¨¸';
  else if (contextObj.type === 'SYSTEM') category = 'ì§•ì§•';

  if (Math.random() < 0.1) category = pick(['ê³µëµ', 'ì§ˆë¬¸', 'ìë‘']);

  const userContext = `[ì‘ì„±ì ì •ë³´] ë‹‰ë„¤ì„: ${author.name}, í‹°ì–´: ${currentTierName}, ì£¼ì±”: ${mostChamp}`;
  const fullContext = `${userContext}\n${contextObj.text}\n(ì¹´í…Œê³ ë¦¬: ${category} ê²Œì‹œíŒ)`;

  const aiResult = await fetchAIPost(aiConfig, fullContext, category);
  if (!aiResult) return null;

  let basePotential = 10;
  if (category === 'ê³µëµ' || category === 'ë¶„ì„') basePotential += 20;

  return {
    id: uniqueId,
    author: author.name, 
    authorTier: currentTierName,
    title: aiResult.title,
    content: aiResult.content,
    category: category as any,
    views: 1, upvotes: 0, downvotes: 0, 
    comments: 0, commentList: [],
    createdAt: currentTick,
    potential: Math.min(100, Math.max(10, basePotential)), 
    isBest: false,
    displayTime: "ë°©ê¸ˆ ì „"
  };
}

export async function generateCommentAsync(
  post: Post, 
  aiConfig: AIConfig, 
  userPool: any[], 
  tierConfig: TierConfig
): Promise<Comment | null> {
  if (!aiConfig.apiKey || !aiConfig.enabled) return null;
  if (!userPool || userPool.length === 0) return null;

  const commenter = pick(userPool);
  // [ìˆ˜ì •] ë©”ì„œë“œ í˜¸ì¶œ -> í•¨ìˆ˜ í˜¸ì¶œ
  const commenterTier = getUserTierName(commenter, tierConfig); 
  const commentText = await fetchAIComment(aiConfig, post.title, post.content);

  if (!commentText) return null;

  return {
    id: Date.now() + Math.random(), 
    author: commenter.name, 
    authorTier: commenterTier,
    content: commentText, 
    timestamp: "ë°©ê¸ˆ ì „"
  };
}

export function updatePostInteractions(posts: Post[], currentTick: number): Post[] {
  return posts.map(post => {
    const age = currentTick - post.createdAt;
    if (age > 1440) return post; 

    const updatedPost = { ...post };
    if (age < 1) updatedPost.displayTime = "ë°©ê¸ˆ ì „";
    else if (age < 60) updatedPost.displayTime = `${Math.floor(age)}ë¶„ ì „`;
    else updatedPost.displayTime = `${Math.floor(age / 60)}ì‹œê°„ ì „`;

    let exposure = (post.potential / (age * 1.5 + 20)); 
    if (post.isBest) exposure *= 3.0; 

    if (Math.random() < exposure) {
        updatedPost.views += Math.floor(Math.random() * 5) + 1;
        if (Math.random() < 0.1) updatedPost.upvotes++;
    }

    if (!updatedPost.isBest && updatedPost.upvotes >= 10) {
      updatedPost.isBest = true;
      updatedPost.potential += 50; 
      updatedPost.title = `[ë…ê¸€] ${updatedPost.title}`;
    }
    return updatedPost;
  });
}



==========================================
FILE PATH: src/engine/system/RankingSystem.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/system/RankingSystem.ts
// ==========================================
import { Hero, UserStatus, TierStat, TierConfig, Tier, UserProfile } from '../../types';
import { userPool } from './UserManager';

const safeDiv = (num: number, den: number) => (!den || den === 0 ? 0 : num / den);

export function analyzeHeroMeta(heroes: Hero[]): Hero[] {
  // [Safety] ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì¦‰ì‹œ ì¢…ë£Œ
  if (!heroes || !Array.isArray(heroes) || heroes.length === 0) return [];

  // ê¸€ë¡œë²Œ í”½ í†µê³„ ê³„ì‚°
  const totalGlobalPicks = heroes.reduce((sum, h) => sum + (h?.record?.totalPicks || 0), 0);
  const totalGlobalGames = Math.max(1, Math.floor(totalGlobalPicks / 10));

  const scoredHeroes = heroes.map(h => {
    if (!h) return null; 

    const r = h.record || { 
      totalMatches: 0, totalWins: 0, recentResults: [], totalBans: 0, 
      totalPicks: 0, totalKills: 0, totalDeaths: 0, totalAssists: 0, 
      totalDamage: 0, totalDamageTaken: 0, totalCs: 0, totalGold: 0 
    };
    
    const matches = Math.max(1, r.totalMatches);
    const totalWinRate = matches > 0 ? (r.totalWins / matches) * 100 : 50;
    
    // [ìµœê·¼ ì „ì  ê³„ì‚°]
    const recentResults = Array.isArray(r.recentResults) ? r.recentResults : [];
    const recentCount = recentResults.length;
    let recentWinRate = totalWinRate; // ê¸°ë³¸ê°’ì€ ì „ì²´ ìŠ¹ë¥ 

    if (recentCount > 0) {
        const recentWins = recentResults.filter(win => win).length;
        recentWinRate = (recentWins / recentCount) * 100;
    }

    // ---------------------------------------------------------------
    // [í•µì‹¬ ìˆ˜ì •] ë©”íƒ€ ë°˜ì‘ì„± ê°•í™”
    // ---------------------------------------------------------------
    
    // 1. ê°€ì¤‘ì¹˜ ë³€ê²½: ìµœê·¼ ìŠ¹ë¥  ë¹„ì¤‘ì„ 30% -> 70%ë¡œ ëŒ€í­ ìƒí–¥
    // (íŒ¨ì¹˜ë‚˜ ì—ë””í„° ìˆ˜ì • ì§í›„ì˜ ì„±ëŠ¥ì„ ë” ì¤‘ìš”í•˜ê²Œ ë´„)
    let weightedWinRate = (totalWinRate * 0.3) + (recentWinRate * 0.7);
    if (isNaN(weightedWinRate)) weightedWinRate = 50;

    // 2. ì‹ ë¢°ë„ ì„ê³„ê°’(Threshold) í•˜í–¥: 2000íŒ -> 100íŒ
    // 100íŒë§Œ ìŒ“ì—¬ë„ ë°ì´í„°ë¥¼ 100% ì‹ ë¢°í•¨ (ê¸°ì¡´ì—” 2000íŒ í•„ìš”í–ˆìŒ)
    const TRUST_THRESHOLD = 100;

    if (matches < TRUST_THRESHOLD) {
       // ì‹ ë¢°ë„ê°€ ë‚®ì•„ë„, ìµœì†Œ 30%ëŠ” ì‹¤ì œ ìŠ¹ë¥ ì„ ë°˜ì˜í•˜ì—¬ "ê°€ëŠ¥ì„±"ì„ ë³´ì—¬ì¤Œ
       // (ê¸°ì¡´ì—ëŠ” 0%ì—ì„œ ì‹œì‘í•´ì„œ 50%ì— ê³ ì •ë˜ì—ˆìŒ)
       const factor = Math.max(0.3, matches / TRUST_THRESHOLD);
       weightedWinRate = (weightedWinRate * factor) + (50 * (1 - factor));
    }

    // ---------------------------------------------------------------

    // [OP Score ì‚°ì¶œ]
    let winScore = (weightedWinRate - 50) * 4.0; // ìŠ¹ë¥  1% ì°¨ì´ë‹¹ 4ì 
    const banRate = (r.totalBans / totalGlobalGames) * 100;
    const banScore = isNaN(banRate) ? 0 : banRate * 1.0; // ë°´ë¥  ê°€ì¤‘ì¹˜ ìƒí–¥
    const pickRate = (r.totalPicks / totalGlobalGames) * 100;
    let pickScore = isNaN(pickRate) ? 0 : pickRate * 0.5;

    // ìŠ¹ë¥ ì´ ë‚®ìœ¼ë©´ í”½ë¥ /ë°´ë¥  ì ìˆ˜ ì‚­ê° (ê±°í’ˆ ì œê±°)
    if (weightedWinRate < 49) { pickScore *= 0.5; winScore -= 5; }
    if (weightedWinRate < 47) winScore -= 15;
    if (weightedWinRate < 45) winScore -= 30;

    const opScore = winScore + banScore + pickScore;

    // í†µê³„ ë¬¸ìì—´ í¬ë§·íŒ…
    const k = safeDiv(r.totalKills, matches);
    const d = safeDiv(r.totalDeaths, matches);
    const a = safeDiv(r.totalAssists, matches);
    const kdaVal = d < 1 ? (k + a) : (k + a) / d;

    // [ìˆ˜ì • ì™„ë£Œ] í…œí”Œë¦¿ ë¦¬í„°ëŸ´ ë¬¸ë²• ì •ìƒí™” (ì—­ìŠ¬ë˜ì‹œ ì œê±°ë¨)
    return {
      ...h,
      recentWinRate: weightedWinRate, 
      pickRate: pickRate || 0,
      banRate: banRate || 0,
      opScore: opScore || 0, 
      avgKda: `${k.toFixed(1)}/${d.toFixed(1)}/${a.toFixed(1)}`,
      kdaRatio: kdaVal.toFixed(2),
      avgDpm: Math.floor((r.totalDamage / matches) / 20).toLocaleString(), 
      avgDpg: Math.floor((r.totalDamageTaken / matches) / 20).toLocaleString(),
      avgCs: (r.totalCs / matches).toFixed(1),
      avgGold: Math.floor(r.totalGold / matches).toLocaleString(),
    };
  }).filter(h => h !== null) as Hero[];

  // ì ìˆ˜ ê¸°ë°˜ ì •ë ¬
  scoredHeroes.sort((a, b) => ((b as any).opScore || 0) - ((a as any).opScore || 0));

  // í‹°ì–´ í• ë‹¹
  return scoredHeroes.map((h, index) => {
    const rank = index + 1;
    const score = (h as any).opScore || 0;
    let tier: Tier = '3';

    // í‹°ì–´ ì»·ë¼ì¸ ì¡°ì •
    if (score >= 60 && rank <= 5) tier = 'OP';      // ê¸°ì¤€ ì™„í™” (80 -> 60)
    else if (score >= 30) tier = '1';               // ê¸°ì¤€ ì™„í™” (40 -> 30)
    else if (score >= 10) tier = '2';
    else if (score >= -10) tier = '3';
    else if (score >= -40) tier = '4';
    else tier = '5';

    // í•˜ìœ„ê¶Œ ê°•ì œ í• ë‹¹
    if (rank >= 46) tier = '5'; 
    else if (rank >= 41 && tier !== '5') tier = '4';

    return { ...h, rank, tier };
  });
}

// (ê¸°ì¡´ ìœ ì € ìƒíƒœê³„ ê³„ì‚° ë¡œì§ ìœ ì§€)
export function calculateUserEcosystem(ccu: number, totalUsers: number, config: TierConfig): UserStatus {
  if (!userPool || !Array.isArray(userPool)) {
      return { totalGames: 0, playingUsers: 0, queuingUsers: 0, avgWaitTime: 0, tierDistribution: [] };
  }

  const cfg = config || { master: 4800, ace: 3800, joker: 3200, gold: 2100, silver: 1300, bronze: 300 };

  const playingUsers = userPool.filter(u => u && u.status === 'INGAME').length;
  const queuingUsers = userPool.filter(u => u && (u.status === 'QUEUE' || u.status === 'IDLE')).length;
  
  const tiers: TierStat[] = [
    { name: 'ì²œìƒê³„', minScore: 9999, color: '#00bfff', count: 0, percent: 0 },
    { name: 'ë§ˆìŠ¤í„°', minScore: cfg.master || 4800, color: '#9b59b6', count: 0, percent: 0 },
    { name: 'ì—ì´ìŠ¤', minScore: cfg.ace || 3800, color: '#e74c3c', count: 0, percent: 0 },
    { name: 'ì¡°ì»¤', minScore: cfg.joker || 3200, color: '#2ecc71', count: 0, percent: 0 },
    { name: 'ê³¨ë“œ', minScore: cfg.gold || 2100, color: '#f1c40f', count: 0, percent: 0 },
    { name: 'ì‹¤ë²„', minScore: cfg.silver || 1300, color: '#95a5a6', count: 0, percent: 0 },
    { name: 'ë¸Œë¡ ì¦ˆ', minScore: cfg.bronze || 300, color: '#d35400', count: 0, percent: 0 },
    { name: 'ì•„ì´ì–¸', minScore: 0, color: '#7f8c8d', count: 0, percent: 0 },
  ];

  userPool.forEach(u => {
    if (!u) return;
    const score = typeof u.score === 'number' ? u.score : 0;
    
    let assigned = false;
    if (u.isChallenger) {
        tiers[0].count++;
        assigned = true;
    } else {
        for (let i = 1; i < tiers.length; i++) { 
            if (score >= tiers[i].minScore) { 
                tiers[i].count++; 
                assigned = true; 
                break; 
            } 
        }
    }
    
    if (!assigned) tiers[tiers.length - 1].count++;
  });

  const totalTracked = Math.max(1, userPool.length);
  tiers.forEach(t => { t.percent = parseFloat(((t.count / totalTracked) * 100).toFixed(1)); });

  return { 
    totalGames: Math.floor(playingUsers / 10), 
    playingUsers, 
    queuingUsers, 
    avgWaitTime: Math.max(5, Math.floor(120 / ((queuingUsers / 10) + 1))), 
    tierDistribution: tiers 
  };
}



==========================================
FILE PATH: src/engine/system/SentimentEngine.ts
==========================================
// ==========================================
// FILE PATH: /src/engine/system/SentimentEngine.ts
// ==========================================
// [ìˆ˜ì •] ../types -> ../../types
import { GameState, Hero, Post } from '../../types';

export function calculateTargetSentiment(
  gameState: GameState,
  heroes: Hero[],
  posts: Post[]
): number {
  let target = 65; 

  let brokenCount = 0;
  let goldenCount = 0; 

  heroes.forEach(h => {
    const wr = h.recentWinRate;
    if (wr >= 48 && wr <= 52) goldenCount++;
    if (wr > 58 || wr < 42) {
      brokenCount++;
      target -= (Math.abs(wr - 50) - 8) * 2; 
    }
  });

  if (brokenCount === 0) target += 10;
  if (goldenCount >= (heroes.length / 2)) target += 10;

  const izmanKills = parseFloat(gameState.godStats.izmanAvgKills);
  const danteKills = parseFloat(gameState.godStats.danteAvgKills);
  const totalAvgKills = izmanKills + danteKills;

  if (totalAvgKills >= 30) target += 5;
  if (totalAvgKills >= 50) target += 5;
  if (totalAvgKills < 15) target -= 5;

  let totalGold = 0;
  let heroCount = 0;
  heroes.forEach(h => {
    const goldVal = parseInt(h.avgGold.replace(/,/g, '')) || 0;
    if(goldVal > 0) {
        totalGold += goldVal;
        heroCount++;
    }
  });
  const globalAvgGold = heroCount > 0 ? totalGold / heroCount : 0;

  if (globalAvgGold >= 12000) target += 5;
  if (globalAvgGold >= 15000) target += 5;

  const waitTime = gameState.userStatus.avgWaitTime;
  if (waitTime <= 20) target += 5;
  else if (waitTime > 60) target -= 10;

  const recentPosts = posts.slice(0, 30);
  let communityScore = 0;

  recentPosts.forEach(p => {
    if (p.category === 'ì§•ì§•' && p.isBest) communityScore -= 2;
    if (p.category === 'ê³µëµ' || p.category === 'ë¶„ì„') communityScore += 0.5;
    if (p.category === 'ìë‘' && p.upvotes > 5) communityScore += 0.2;
  });

  target += Math.max(-20, Math.min(15, communityScore));

  return Math.max(0, Math.min(100, target));
}

export function smoothSentiment(current: number, target: number): number {
  const diff = target - current;
  if (Math.abs(diff) < 0.1) return target;
  let speed = 0.05; 
  if (diff > 0) speed = 0.08;
  else speed = 0.03;
  return current + diff * speed;
}


==========================================
FILE PATH: src/engine/system/UserActivitySystem.ts
==========================================
import { UserProfile, PlayStyle } from '../../types';

/**
 * [ì‹œê°„ëŒ€ë³„ ì ‘ì† ê°€ì¤‘ì¹˜ í…Œì´ë¸” (0ì‹œ ~ 23ì‹œ)]
 * ê° ì„±í–¥ë³„ë¡œ í•´ë‹¹ ì‹œê°„ì— ì ‘ì†í•  í™•ë¥  ê°€ì¤‘ì¹˜ (1.0 = ë³´í†µ)
 */
const SCHEDULE_WEIGHTS: Record<PlayStyle, number[]> = {
  // ì§ì¥ì¸: í‰ì¼ ë‚®(09~18)ì—” ì ‘ì† ë¶ˆê°€, ì €ë…(19~24)ì— í”¼í¬
  'WORKER': [
    0.3, 0.1, 0.0, 0.0, 0.0, 0.0, 0.1, 0.2, 0.1, 0.0, 0.0, 0.0, // 00~11
    0.1, 0.0, 0.0, 0.0, 0.1, 0.2, 0.8, 1.5, 2.5, 3.0, 2.5, 1.0  // 12~23
  ],
  // í•™ìƒ: í•™êµ ì‹œê°„(09~15) ë‚®ìŒ, ë°©ê³¼ í›„(16~22) í”¼í¬
  'STUDENT': [
    0.2, 0.1, 0.0, 0.0, 0.0, 0.0, 0.1, 0.5, 0.2, 0.1, 0.1, 0.1, // 00~11
    0.5, 0.2, 0.2, 1.0, 2.0, 2.5, 2.5, 2.0, 1.5, 1.0, 0.5, 0.3  // 12~23
  ],
  // ì˜¬ë¹¼ë¯¸: ì‹¬ì•¼(22~05)ì— í”¼í¬, ë‚®ì— ì 
  'NIGHT_OWL': [
    3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, // 00~11
    0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.8, 1.0, 1.5, 2.0, 2.5, 3.0  // 12~23
  ],
  // íì¸: ë°¥ ë¨¹ê³  ì ìëŠ” ì‹œê°„ ë¹¼ê³  í•­ìƒ ì ‘ì†
  'HARDCORE': Array(24).fill(1.5)
};

// ì‹œê°„ëŒ€ë³„ ì „ì²´ ëª©í‘œ ì ‘ì†ë¥  (0.0 ~ 1.0) -> ì „ì²´ ìœ ì €ì˜ ëª‡ %ê°€ ì ‘ì†í•´ ìˆì–´ì•¼ í•˜ëŠ”ê°€
const GLOBAL_CCU_CURVE = [
  0.15, 0.10, 0.06, 0.04, 0.03, 0.04, 0.07, 0.12, 0.10, 0.09, 0.10, 0.12, // 00~11
  0.15, 0.14, 0.15, 0.18, 0.22, 0.25, 0.28, 0.32, 0.35, 0.32, 0.28, 0.22  // 12~23 (20ì‹œ í”¼í¬ 35%)
];

export class UserActivitySystem {
  
  static updateTraffic(hour: number, userPool: UserProfile[]) {
    if (!userPool || userPool.length === 0) return;

    // 1. í˜„ì¬ ì‹œê°„ëŒ€ ëª©í‘œ ë™ì ‘ì ìˆ˜ ê³„ì‚°
    const currentHour = Math.floor(hour) % 24;
    const baseRatio = GLOBAL_CCU_CURVE[currentHour];
    // ì•½ê°„ì˜ ëœë¤ì„± (Â±5%) ë¶€ì—¬í•˜ì—¬ ê¸°ê³„ì ì¸ ëŠë‚Œ ì œê±°
    const targetCCU = Math.floor(userPool.length * (baseRatio * (0.95 + Math.random() * 0.1)));

    // 2. í˜„ì¬ ì ‘ì†ì ìˆ˜ (INGAME í¬í•¨)
    const onlineUsers = userPool.filter(u => u.status !== 'OFFLINE');
    const currentCCU = onlineUsers.length;
    const diff = targetCCU - currentCCU;

    // 3. íŠ¸ë˜í”½ ì¡°ì • (ì ‘ì† or ì¢…ë£Œ)
    if (diff > 0) {
      // [ì ‘ì† í•„ìš”] OFFLINE ìœ ì €ë¥¼ ê¹¨ì›€
      this.loginUsers(diff, currentHour, userPool);
    } else if (diff < 0) {
      // [ì¢…ë£Œ í•„ìš”] IDLE ìœ ì €ë¥¼ ì§‘ì— ë³´ëƒ„ (ê²Œì„ ì¤‘ì¸ ìœ ì €ëŠ” ê±´ë“œë¦¬ì§€ ì•ŠìŒ)
      this.logoutUsers(Math.abs(diff), currentHour, userPool);
    }

    // 4. íœ´ì‹ ìƒíƒœ ê´€ë¦¬
    this.handleRestingUsers(userPool);
  }

  private static loginUsers(count: number, hour: number, pool: UserProfile[]) {
    const offlineUsers = pool.filter(u => u.status === 'OFFLINE');
    if (offlineUsers.length === 0) return;

    // í‹±ë‹¹ ë„ˆë¬´ ë§ì´ ì ‘ì†í•˜ë©´ ë ‰ ê±¸ë¦¬ë¯€ë¡œ ì œí•œ (ìµœëŒ€ 30ëª…ì”©)
    const limit = Math.min(count, 30);
    let loggedIn = 0;

    // ëœë¤ìœ¼ë¡œ ìœ ì €ë¥¼ ë½‘ë˜, 'ì„±í–¥'ì´ ì‹œê°„ì— ë§ì§€ ì•Šìœ¼ë©´ ì ‘ì† ê±°ë¶€
    // ì˜ˆ: ìƒˆë²½ 4ì‹œì— ì§ì¥ì¸(WORKER)ì„ ë½‘ìœ¼ë©´ ì ‘ì† í™•ë¥  ë§¤ìš° ë‚®ìŒ
    for (let i = 0; i < limit * 3; i++) { // ì‹œë„ íšŸìˆ˜ë¥¼ ë„‰ë„‰íˆ
      if (loggedIn >= limit || offlineUsers.length === 0) break;
      
      const idx = Math.floor(Math.random() * offlineUsers.length);
      const user = offlineUsers[idx];
      
      const weight = SCHEDULE_WEIGHTS[user.playStyle][hour];
      // (ê¸°ë³¸ í™•ë¥  20% * ì‹œê°„ ê°€ì¤‘ì¹˜ * ê°œì¸ í™œë™ì„±)
      const prob = 0.2 * weight * (1 + user.activityBias);

      if (Math.random() < prob) {
        // ì ‘ì† ì„±ê³µ
        user.status = 'IDLE';
        user.tiredness = 0;
        // ì´ë²ˆ ì„¸ì…˜ ëª©í‘œ íŒìˆ˜ ì„¤ì • (2~5íŒ + ì„±í–¥ ë³´ì •)
        user.sessionTarget = 2 + Math.floor(Math.random() * 4);
        if (user.playStyle === 'HARDCORE') user.sessionTarget += 5;
        
        loggedIn++;
        // ì¤‘ë³µ ë°©ì§€ë¥¼ ìœ„í•´ ë°°ì—´ì—ì„œ ì œê±° (Swap & Pop)
        offlineUsers[idx] = offlineUsers[offlineUsers.length - 1];
        offlineUsers.pop();
      }
    }
  }

  private static logoutUsers(count: number, hour: number, pool: UserProfile[]) {
    // ê²Œì„ ëŒ€ê¸°ì¤‘(IDLE)ì¸ ì‚¬ëŒë§Œ ì§‘ì— ê°ˆ ìˆ˜ ìˆìŒ
    const idleUsers = pool.filter(u => u.status === 'IDLE');
    if (idleUsers.length === 0) return;

    const limit = Math.min(count, 30);
    let loggedOut = 0;

    for (let i = 0; i < limit * 3; i++) {
      if (loggedOut >= limit || idleUsers.length === 0) break;

      const idx = Math.floor(Math.random() * idleUsers.length);
      const user = idleUsers[idx];

      // ëª©í‘œ íŒìˆ˜ë¥¼ ë‹¤ ì±„ì› ê±°ë‚˜, ì§€ê¸ˆì´ í™œë™ ì‹œê°„ì´ ì•„ë‹ˆë©´ ì´íƒˆ í™•ë¥  ì¦ê°€
      const progress = user.tiredness / (user.sessionTarget || 3);
      const weight = SCHEDULE_WEIGHTS[user.playStyle][hour];
      
      // ì´íƒˆ í™•ë¥  = (ëª©í‘œë‹¬ì„±ë„ * 0.5) + (ì‹œê°„ëŒ€ê°€ ì•ˆë§ì„ìˆ˜ë¡ ì¦ê°€)
      let prob = (progress * 0.5);
      if (weight < 0.2) prob += 0.5; // ì˜ ì‹œê°„ì´ë‹¤ ì§‘ì— ê°€ë¼

      if (Math.random() < prob) {
        user.status = 'OFFLINE';
        loggedOut++;
        idleUsers[idx] = idleUsers[idleUsers.length - 1];
        idleUsers.pop();
      }
    }
  }

  private static handleRestingUsers(pool: UserProfile[]) {
    pool.forEach(u => {
      if (u.status === 'RESTING') {
        u.restTimer -= 1;
        if (u.restTimer <= 0) {
          // íœ´ì‹ ë. í•œ íŒ í–ˆìœ¼ë¯€ë¡œ í”¼ë¡œë„ ì¦ê°€
          u.tiredness++;
          
          // ëª©í‘œ ë‹¬ì„±í–ˆìœ¼ë©´ 50% í™•ë¥ ë¡œ ë¡œê·¸ì•„ì›ƒ, ì•„ë‹ˆë©´ ë‹¤ì‹œ í ëŒë¦¼
          if (u.tiredness >= u.sessionTarget) {
             u.status = Math.random() < 0.5 ? 'OFFLINE' : 'IDLE';
          } else {
             u.status = 'IDLE';
          }
        }
      }
    });
  }
}



==========================================
FILE PATH: src/engine/system/UserManager.ts
==========================================
import { Hero, UserProfile, TierConfig, PlayStyle } from '../../types';
import { generateUserName } from '../../utils/nameGenerator';

const registeredNames = new Set<string>();
export let userPool: UserProfile[] = [];

export function replaceUserPool(newUsers: UserProfile[]) {
  userPool = newUsers;
}

export function createUser(id: number, heroes: Hero[]): UserProfile {
  let tempName = generateUserName(id);
  if (!registeredNames.has(tempName)) registeredNames.add(tempName);
  else tempName = `${tempName}#${id}`;

  const hiddenMmr = 1000 + Math.floor(Math.random() * 2000);
  const mmrFactor = (hiddenMmr - 1000) / 2000;
  const baseStat = 20 + (mmrFactor * 40) + (Math.random() * 20); 

  let brain = 50, mechanics = 50;
  if (Math.random() < 0.5) { brain = baseStat * 1.2; mechanics = baseStat * 0.8; } 
  else { brain = baseStat * 0.8; mechanics = baseStat * 1.2; }
  brain = Math.min(100, Math.max(10, Math.floor(brain)));
  mechanics = Math.min(100, Math.max(10, Math.floor(mechanics)));

  const lanes = ['TOP', 'JUNGLE', 'MID', 'BOT'];
  const preferredLane = lanes[Math.floor(Math.random() * lanes.length)] as any;

  let preferredHeroes: string[] = [];
  if (heroes && heroes.length > 0) {
    const myRoleHeroes = heroes.filter(h => isHeroForLane(h, preferredLane));
    const poolSize = Math.min(myRoleHeroes.length, 3);
    preferredHeroes = myRoleHeroes.slice(0, poolSize).map(h => h.id);
    if (preferredHeroes.length === 0) preferredHeroes = [heroes[0].id];
  }

  // [í•µì‹¬] í˜„ì‹¤ì ì¸ ì„±í–¥ ë¹„ìœ¨ í• ë‹¹
  const rand = Math.random();
  let style: PlayStyle = 'WORKER'; // ê¸°ë³¸: ì§ì¥ì¸ (40%)
  if (rand < 0.4) style = 'WORKER';
  else if (rand < 0.7) style = 'STUDENT'; // í•™ìƒ (30%)
  else if (rand < 0.85) style = 'NIGHT_OWL'; // ì˜¬ë¹¼ë¯¸ (15%)
  else style = 'HARDCORE'; // íì¸ (15%)

  return {
    id, name: tempName, score: 0, hiddenMmr, tier: 'ì•„ì´ì–¸', rank: 0, isChallenger: false,
    winRate: 0, totalGames: 0, wins: 0, losses: 0,
    mainHeroId: preferredHeroes[0] || '', preferredLane, preferredHeroes,
    brain, mechanics,
    
    // ì‹ ê·œ ì†ì„± ì´ˆê¸°í™”
    playStyle: style, 
    activityBias: (Math.random() * 0.4) - 0.2, // -0.2 ~ +0.2 (í™œë™ì„± í¸ì°¨)
    tiredness: 0, 
    sessionTarget: 3,

    status: 'OFFLINE', restTimer: 0, history: [], heroStats: {}, promoStatus: null,
    mostChamps: [], laneStats: []
  };
}

function isHeroForLane(hero: Hero, lane: string) {
  if (lane === 'TOP') return hero.role === 'ìˆ˜í˜¸ê¸°ì‚¬' || hero.role === 'ì§‘í–‰ê´€';
  if (lane === 'MID') return hero.role === 'ì„ ì§€ì' || hero.role === 'ì¶”ì ì';
  if (lane === 'BOT') return hero.role === 'ì‹ ì‚´ì';
  if (lane === 'JUNGLE') return hero.role === 'ì¶”ì ì' || hero.role === 'ì§‘í–‰ê´€';
  return true;
}

export function getUserTierName(user: UserProfile, config: TierConfig) {
  const cfg = config || { challengerRank:50, master:4800, ace:3800, joker:3200, gold:2100, silver:1300, bronze:300 };
  if (user.isChallenger) return 'ì²œìƒê³„';
  if (user.score >= cfg.master) return 'ë§ˆìŠ¤í„°';
  if (user.score >= cfg.ace) return 'ì—ì´ìŠ¤';
  if (user.score >= cfg.joker) return 'ì¡°ì»¤';
  if (user.score >= cfg.gold) return 'ê³¨ë“œ';
  if (user.score >= cfg.silver) return 'ì‹¤ë²„';
  if (user.score >= cfg.bronze) return 'ë¸Œë¡ ì¦ˆ';
  return 'ì•„ì´ì–¸';
}

export function initUserPool(heroes: Hero[], count: number = 3000) {
  const startId = userPool.length;
  if (count > userPool.length) {
    const newUsersCount = count - userPool.length;
    for(let i=0; i<newUsersCount; i++) userPool.push(createUser(startId + i, heroes));
  }
}

// êµ¬ë²„ì „ í˜¸í™˜ìš© (ì‚¬ìš© ì•ˆí•¨)
export function updateUserActivity(hour: number, heroes: Hero[]) {}

export function getTopRankers(heroes: Hero[], config: TierConfig): UserProfile[] {
  const sorted = [...userPool].sort((a, b) => b.score - a.score || a.id - b.id);
  return sorted.slice(0, 50).map(u => ({ ...u, tier: getUserTierName(u, config) }));
}

export function getUsersInTier(tierName: string, config: TierConfig): UserProfile[] {
  return userPool
    .filter(u => getUserTierName(u, config) === tierName)
    .sort((a, b) => b.score - a.score);
}

export function findUserProfileByName(name: string, config: TierConfig): UserProfile | null {
  const user = userPool.find(u => u.name === name);
  if (!user) return null;
  return { ...user, tier: getUserTierName(user, config) };
}

export function getTierNameHelper(score: number, config: TierConfig) {
  return getUserTierName({ score, isChallenger: false } as UserProfile, config);
}



==========================================
FILE PATH: src/hooks/useGameEngine.ts
==========================================
import { useEffect, useRef, useState } from 'react';
import { useGameStore } from '../store/useGameStore';
import { saveToSlot, initializeGame } from '../engine/SaveLoadSystem';

export const useGameEngine = () => {
  const store = useGameStore();
  const { gameState, tick, heroes } = store;
  const { isPlaying, gameSpeed } = gameState;

  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
  const [isGameReady, setIsGameReady] = useState(false);
  const [runtimeError, setRuntimeError] = useState<Error | null>(null);

  const requestRef = useRef<number>(0);
  const previousTimeRef = useRef<number | undefined>(undefined);

  if (runtimeError) {
    throw runtimeError;
  }

  useEffect(() => {
    const init = async () => {
      try {
        await initializeGame(heroes);
      } catch (e: any) {
        console.error("Init Error:", e);
        setRuntimeError(e instanceof Error ? e : new Error(String(e)));
      } finally {
        setIsGameReady(true);
      }
    };
    init();
  }, []);

  useEffect(() => {
    const handleResize = () => setIsMobile(window.innerWidth <= 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  useEffect(() => {
    if (!isPlaying || !isGameReady || runtimeError) {
      if (requestRef.current) cancelAnimationFrame(requestRef.current);
      previousTimeRef.current = undefined; 
      return;
    }

    const loop = (time: number) => {
      if (previousTimeRef.current !== undefined) {
        // ë¸íƒ€ íƒ€ì„ ê³„ì‚° (ìµœëŒ€ 0.1ì´ˆ ì œí•œ)
        const realDelta = Math.min((time - previousTimeRef.current) / 1000, 0.1);
        const gameDelta = realDelta * (gameSpeed || 1);

        try {
          // [ì›ë³µ] ë§¤ í”„ë ˆì„ë§ˆë‹¤ ì¦‰ì‹œ tick í˜¸ì¶œ
          tick(gameDelta); 
        } catch (e: any) {
          console.error("CRITICAL TICK ERROR:", e);
          store.togglePlay(); 
          if (requestRef.current) cancelAnimationFrame(requestRef.current);
          setRuntimeError(e instanceof Error ? e : new Error("Game Loop Error: " + String(e)));
          return;
        }
      }
      
      previousTimeRef.current = time;
      requestRef.current = requestAnimationFrame(loop);
    };

    requestRef.current = requestAnimationFrame(loop);
    return () => { if (requestRef.current) cancelAnimationFrame(requestRef.current); };
  }, [isPlaying, isGameReady, runtimeError, gameSpeed]);

  useEffect(() => {
    const autoSaveInterval = setInterval(() => { 
      if (isPlaying && isGameReady && !runtimeError) saveToSlot('auto'); 
    }, 60000);
    return () => clearInterval(autoSaveInterval);
  }, [isPlaying, isGameReady, runtimeError]);

  return { isMobile, store, isGameReady };
};



==========================================
FILE PATH: src/hooks/useVisualInterpolation.ts
==========================================
// ==========================================
// FILE PATH: /src/hooks/useVisualInterpolation.ts
// ==========================================
import { useEffect, useRef } from 'react';
import { LiveMatch, LivePlayer, Minion } from '../types';

// ì„¤ì • ìƒìˆ˜
const CONFIG = {
  TELEPORT_THRESHOLD: 15, // ì´ ê±°ë¦¬ ì´ìƒ ë²Œì–´ì§€ë©´ ìˆœê°„ì´ë™ (ë§µ í¬ê¸° 100 ê¸°ì¤€ 15%)
  LERP_FACTOR_HERO: 0.15, // ì˜ì›… ë³´ê°„ ê³„ìˆ˜ (ë‚®ì„ìˆ˜ë¡ ë¶€ë“œëŸ½ì§€ë§Œ ë°˜ì‘ ëŠë¦¼)
  LERP_FACTOR_MINION: 0.2, // ë¯¸ë‹ˆì–¸ ë³´ê°„ ê³„ìˆ˜
  SNAP_DISTANCE: 0.05, // ì´ ê±°ë¦¬ ì´ë‚´ë©´ ëª©í‘œ ìœ„ì¹˜ë¡œ ì¦‰ì‹œ ê³ ì • (ë–¨ë¦¼ ë°©ì§€)
  Z_INDEX_BASE: 10
};

interface VisualState {
  x: number;
  y: number;
}

export const useVisualInterpolation = (match: LiveMatch | undefined) => {
  const requestRef = useRef<number>();
  const visualRef = useRef<Record<string, VisualState>>({});

  useEffect(() => {
    if (!match) return;

    const animate = () => {
      // 1. ì˜ì›… ì²˜ë¦¬
      const allPlayers = [...match.blueTeam, ...match.redTeam];
      allPlayers.forEach(p => {
        updateEntityPosition(`unit-${p.heroId}`, p.x, p.y, 'HERO');
      });

      // 2. ë¯¸ë‹ˆì–¸ ì²˜ë¦¬
      if (match.minions) {
        match.minions.forEach(m => {
          updateEntityPosition(`minion-${m.id}`, m.x, m.y, 'MINION');
        });
      }

      requestRef.current = requestAnimationFrame(animate);
    };

    requestRef.current = requestAnimationFrame(animate);
    return () => {
      if (requestRef.current) cancelAnimationFrame(requestRef.current);
    };
  }, [match]);

  // ê°œë³„ ì—”í‹°í‹° ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ë¡œì§
  const updateEntityPosition = (elementId: string, targetX: number, targetY: number, type: 'HERO' | 'MINION') => {
    const el = document.getElementById(elementId);
    if (!el) return;

    let current = visualRef.current[elementId];
    
    // ì´ˆê¸°í™”: ë°ì´í„°ê°€ ì—†ìœ¼ë©´ íƒ€ê²Ÿ ìœ„ì¹˜ë¡œ ì¦‰ì‹œ ì„¤ì •
    if (!current) {
      current = { x: targetX, y: targetY };
      visualRef.current[elementId] = current;
    }

    const dx = targetX - current.x;
    const dy = targetY - current.y;
    // ê±°ë¦¬ ì œê³± ëŒ€ì‹  ìœ í´ë¦¬ë“œ ê±°ë¦¬ ì‚¬ìš© (ì •í™•ë„)
    const dist = Math.sqrt(dx * dx + dy * dy);

    // [í•µì‹¬ ë¡œì§ 1] í…”ë ˆí¬íŠ¸ ê°ì§€ (ê±°ë¦¬ 15 ì´ìƒì´ë©´ ì¦‰ì‹œ ì´ë™)
    if (dist > CONFIG.TELEPORT_THRESHOLD) {
      current.x = targetX;
      current.y = targetY;
    } 
    // [í•µì‹¬ ë¡œì§ 2] ë¯¸ì„¸ ê±°ë¦¬ ìŠ¤ëƒ… (ë„ì°© ì‹œ ë–¨ë¦¼ ë°©ì§€)
    else if (dist < CONFIG.SNAP_DISTANCE) {
      current.x = targetX;
      current.y = targetY;
    } 
    // [í•µì‹¬ ë¡œì§ 3] ë¶€ë“œëŸ¬ìš´ ë³´ê°„ (Lerp)
    else {
      const factor = type === 'HERO' ? CONFIG.LERP_FACTOR_HERO : CONFIG.LERP_FACTOR_MINION;
      current.x += dx * factor;
      current.y += dy * factor;
    }

    // DOM ì§ì ‘ ì—…ë°ì´íŠ¸ (ë¦¬ì•¡íŠ¸ ë¦¬ë Œë”ë§ ë°©ì§€)
    el.style.left = `${current.x}%`;
    el.style.top = `${current.y}%`;
    
    // Yì¶•ì— ë”°ë¥¸ Z-Index ì •ë ¬ (ì•„ë˜ì— ìˆëŠ” ìœ ë‹›ì´ ìœ„ì— ê·¸ë ¤ì§ - ì›ê·¼ê°)
    el.style.zIndex = `${Math.floor(current.y) + CONFIG.Z_INDEX_BASE}`;
  };
};



==========================================
FILE PATH: src/index.css
==========================================
/* src/index.css */
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@700&family=Pretendard:wght@400;600;700;800&display=swap');

:root {
  --bg-main: #0f1115;
  --bg-panel: #161b22;
  --border: #30363d;
  --text-main: #f0f6fc;
  --text-sub: #8b949e;
  --primary: #58a6ff;
  --success: #238636;
  --danger: #da3633;
}

body {
  margin: 0;
  background-color: var(--bg-main);
  color: var(--text-main);
  font-family: 'Pretendard', sans-serif;
  -webkit-font-smoothing: antialiased;
}

/* ìŠ¤í¬ë¡¤ë°” ì»¤ìŠ¤í…€ */
::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: var(--bg-main); }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: #555; }

/* ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤ */
.panel {
  background: var(--bg-panel);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
}

.btn {
  padding: 10px 16px;
  border-radius: 6px;
  font-weight: 600;
  cursor: pointer;
  border: none;
  transition: 0.2s;
}
.btn-primary { background: var(--primary); color: #000; }
.btn-primary:hover { opacity: 0.9; }
.btn-danger { background: var(--danger); color: #fff; }

.text-mono { font-family: 'JetBrains Mono', monospace; }

@media (max-width: 768px) {
  /* í…Œì´ë¸” í—¤ë” ìˆ¨ê¹€ */
  thead { display: none; }

  /* í…Œì´ë¸” í–‰ì„ ë¸”ë¡ìœ¼ë¡œ, ì¹´ë“œì²˜ëŸ¼ ìŠ¤íƒ€ì¼ë§ */
  tr {
    display: flex;
    flex-direction: column;
    background: #1c1c1f;
    margin-bottom: 10px;
    border: 1px solid #333;
    border-radius: 8px;
    padding: 10px;
  }

  td {
    display: flex;
    justify-content: space-between;
    text-align: right;
    padding: 5px 0;
    border-bottom: 1px solid #222;
  }

  /* td ì•ì— ë¼ë²¨ ë¶™ì—¬ì£¼ê¸° (ê°€ìƒ ìš”ì†Œ í™œìš© ê°€ëŠ¥í•˜ì§€ë§Œ, ë¦¬ì•¡íŠ¸ ì»´í¬ë„ŒíŠ¸ ìˆ˜ì •ì´ ë” ì‰¬ì›€) */
}



==========================================
FILE PATH: src/index.tsx
==========================================
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

// [ë¹„ìƒìš©] React ì‹¤í–‰ ë¶ˆê°€ ì‹œ ë„ìš¸ í™”ë©´
function showPanicScreen(errorMsg: string, errorStack: string = '') {
  // DOM ê´€ë ¨ ì—ëŸ¬ëŠ” ì—¬ê¸°ì„œ ë„ìš°ì§€ ì•Šê³  React Error Boundaryì— ë§¡ê¹€
  if (
    errorMsg.includes("removeChild") || 
    errorMsg.includes("node to be removed") ||
    errorMsg.includes("Script error") // í¬ë¡œìŠ¤ ì˜¤ë¦¬ì§„ ì—ëŸ¬ ë¬´ì‹œ
  ) {
    return;
  }

  console.error("CRITICAL FAILURE:", errorMsg);

  const root = document.getElementById('root');
  if (!root) return;

  root.innerHTML = '';
  document.body.style.backgroundColor = '#0f1115';
  document.body.style.color = '#fff';
  document.body.style.margin = '0';
  document.body.style.overflow = 'hidden';

  const container = document.createElement('div');
  container.style.cssText = 'position:fixed; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; padding:20px; z-index:99999; font-family:sans-serif; text-align:center;';

  const icon = document.createElement('div');
  icon.innerHTML = 'âš ï¸';
  icon.style.fontSize = '48px';
  icon.style.marginBottom = '20px';

  const title = document.createElement('h1');
  title.innerText = 'ì‹œìŠ¤í…œ ì˜¤ë¥˜ (Panic Mode)';
  title.style.color = '#da3633';
  title.style.margin = '0 0 10px 0';

  const desc = document.createElement('p');
  desc.innerText = 'ì¹˜ëª…ì ì¸ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
  desc.style.color = '#8b949e';

  const errorBox = document.createElement('pre');
  errorBox.innerText = errorMsg;
  errorBox.style.cssText = 'background:#161b22; border:1px solid #da3633; padding:15px; border-radius:8px; color:#ff7b72; text-align:left; width:100%; max-width:600px; overflow:auto; max-height:200px; font-size:12px; margin-bottom:20px; white-space:pre-wrap;';

  const btnContainer = document.createElement('div');
  btnContainer.style.display = 'flex';
  btnContainer.style.gap = '10px';

  const reloadBtn = document.createElement('button');
  reloadBtn.innerText = 'ğŸ”„ ìƒˆë¡œê³ ì¹¨';
  reloadBtn.style.cssText = 'padding:10px 20px; background:#238636; border:none; color:white; border-radius:6px; cursor:pointer; font-weight:bold;';
  reloadBtn.onclick = () => window.location.reload();

  const resetBtn = document.createElement('button');
  resetBtn.innerText = 'ğŸ—‘ï¸ ë°ì´í„° ì´ˆê¸°í™”';
  resetBtn.style.cssText = 'padding:10px 20px; background:#3f1515; border:1px solid #da3633; color:#ff7b72; border-radius:6px; cursor:pointer; font-weight:bold;';
  resetBtn.onclick = () => {
    if (confirm('ì •ë§ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
        localStorage.clear();
        indexedDB.deleteDatabase('GodsWar_DB_V1');
        window.location.reload();
    }
  };

  btnContainer.appendChild(reloadBtn);
  btnContainer.appendChild(resetBtn);
  container.appendChild(icon);
  container.appendChild(title);
  container.appendChild(desc);
  container.appendChild(errorBox);
  container.appendChild(btnContainer);
  root.appendChild(container);
}

// 1. ì „ì—­ ì—ëŸ¬ í•¸ë“¤ëŸ¬
window.onerror = function(message, source, lineno, colno, error) {
  // DOM ì—ëŸ¬ëŠ” ë¬´ì‹œ (Reactê°€ ì²˜ë¦¬í•˜ê±°ë‚˜ ìë™ ë³µêµ¬)
  const msg = String(message);
  if (msg.includes("removeChild") || msg.includes("node to be removed")) {
    return true; // ì—ëŸ¬ ì „íŒŒ ë§‰ìŒ
  }
  showPanicScreen(msg, error?.stack);
  return true;
};

// 2. Promise ì—ëŸ¬ í•¸ë“¤ëŸ¬
window.onunhandledrejection = function(event) {
  showPanicScreen("Unhandled Promise Rejection", String(event.reason));
};

// 3. ì•± ì‹¤í–‰
try {
  const rootElement = document.getElementById('root');
  if (rootElement) {
    const root = ReactDOM.createRoot(rootElement);
    root.render(
      <React.StrictMode>
        <App />
      </React.StrictMode>
    );
  }
} catch (e: any) {
  showPanicScreen(e.message, e.stack);
}



==========================================
FILE PATH: src/store/slices/communitySlice.ts
==========================================
import { StateCreator } from 'zustand';
import { GameStore, CommunitySlice } from '../types';

export const createCommunitySlice: StateCreator<GameStore, [], [], CommunitySlice> = (set) => ({
  communityPosts: [],
  selectedPost: null,

  openPost: (post) => set({ selectedPost: post }),
  closePost: () => set({ selectedPost: null }),
  setCommunityPosts: (posts) => set({ communityPosts: posts }),
});


==========================================
FILE PATH: src/store/slices/gameSlice.ts
==========================================
// ==========================================
// FILE PATH: /src/store/slices/gameSlice.ts
// ==========================================
import { StateCreator } from 'zustand';
import { GameStore, GameSlice } from '../types';
import { INITIAL_CUSTOM_IMAGES } from '../../data/initialImages';
import { GameState } from '../../types';
import { CoreEngine } from '../../engine/CoreEngine';
import { userPool } from '../../engine/system/UserManager'; 
import { INITIAL_HEROES } from '../../data/heroes';
import { INITIAL_ITEMS } from '../../data/items';
import { TOWER_COORDS, POI } from '../../engine/match/constants/MapConstants';

const loadSavedAIConfig = () => {
  try {
    const saved = localStorage.getItem('GW_AI_CONFIG');
    return saved ? JSON.parse(saved) : null;
  } catch (e) { return null; }
};

const savedAI = loadSavedAIConfig();

const initialPositions = {
  colossus: POI.BARON, 
  watcher: POI.DRAGON,  
  jungle: POI.JUNGLE_SPOTS,
  towers: {
    blue: { top: TOWER_COORDS.BLUE.TOP, mid: TOWER_COORDS.BLUE.MID, bot: TOWER_COORDS.BLUE.BOT, nexus: TOWER_COORDS.BLUE.NEXUS },
    red: { top: TOWER_COORDS.RED.TOP, mid: TOWER_COORDS.RED.MID, bot: TOWER_COORDS.RED.BOT, nexus: TOWER_COORDS.RED.NEXUS }
  }
};

const initialGameState: GameState = {
  season: 1, day: 1, hour: 12, minute: 0, second: 0,
  isPlaying: false, gameSpeed: 1,
  userSentiment: 60, ccu: 0, totalUsers: 3000, 
  userStatus: { totalGames: 0, playingUsers: 0, queuingUsers: 0, avgWaitTime: 0, tierDistribution: [] },
  topRankers: [],
  godStats: { totalMatches: 0, izmanWins: 0, izmanAvgKills: '0.0', izmanAvgTime: '00:00', danteWins: 0, danteAvgKills: '0.0', danteAvgTime: '00:00', avgGameDuration: 0, guardianDeathRate: 0, godAwakenRate: 0 },
  itemStats: {},
  liveMatches: [],
  tierConfig: { challengerRank: 200, master: 4800, ace: 3800, joker: 3200, gold: 2100, silver: 1300, bronze: 300, promos: { master: 5, ace: 5, joker: 5, gold: 3, silver: 3, bronze: 3 } },
  battleSettings: {
    izman: { name: 'ì´ì¦ˆë§ˆí•œ', atkRatio: 1.5, defRatio: 1, hpRatio: 10000, guardianHp: 25000, towerAtk: 100, trait: 'ê´‘ë€', servantGold: 14, servantXp: 30, minions: { melee: { label: 'ê´‘ì‹ ë„', hp: 550, def: 10, atk: 25, gold: 21, xp: 60 }, ranged: { label: 'ì•”í‘ ì‚¬ì œ', hp: 350, def: 0, atk: 45, gold: 14, xp: 30 }, siege: { label: 'ì•”í‘ê¸°ì‚¬', hp: 950, def: 40, atk: 70, gold: 60, xp: 90 } } },
    dante: { name: 'ë‹¨í…Œ', atkRatio: 1.5, defRatio: 1, hpRatio: 10000, guardianHp: 25000, towerAtk: 100, trait: 'ê°€í˜¸', servantGold: 14, servantXp: 30, minions: { melee: { label: 'ìˆ˜ë„ì‚¬', hp: 550, def: 10, atk: 25, gold: 21, xp: 60 }, ranged: { label: 'êµ¬ë„ì', hp: 350, def: 0, atk: 45, gold: 14, xp: 30 }, siege: { label: 'ì„±ì „ì‚¬', hp: 950, def: 40, atk: 70, gold: 60, xp: 90 } } },
    economy: { minionGold: 18, minionXp: 30, killGold: 200, goldPerLevel: 20, bountyIncrement: 100, assistPool: 50, killXpBase: 40, killXpPerLevel: 20 },
    siege: { minionDmg: 1.0, cannonDmg: 1.0, superDmg: 1.0, dmgToHero: 1.0, dmgToT1: 0.3, dmgToT2: 0.25, dmgToT3: 0.2, dmgToNexus: 0.1, colossusToHero: 0.3, colossusToT1: 0.4, colossusToT2: 0.2, colossusToT3: 0.1, colossusToNexus: 0.05 }
  },
  fieldSettings: {
    towers: { t1: { hp: 5000, armor: 40, rewardGold: 300, atk: 350 }, t2: { hp: 7500, armor: 60, rewardGold: 450, atk: 450 }, t3: { hp: 10000, armor: 75, rewardGold: 600, atk: 550 }, nexus: { hp: 30000, armor: 60, rewardGold: 0, atk: 1000 } },
    colossus: { hp: 15000, armor: 100, rewardGold: 100, attack: 50, initialSpawnTime: 300, respawnTime: 300, dmgFromHero: 100, dmgFromMinion: 5, dmgFromTower: 30 },
    watcher: { hp: 20000, armor: 120, rewardGold: 150, buffType: 'COMBAT', buffAmount: 20, buffDuration: 180, initialSpawnTime: 420, respawnTime: 420 },
    jungle: { density: 50, yield: 50, attack: 30, defense: 20, threat: 0, xp: 160, gold: 80, initialSpawnTime: 90, respawnTime: 90 },
    positions: initialPositions
  },
  roleSettings: { executor: { damage: 10, defense: 10 }, tracker: { gold: 20, smiteChance: 1.5 }, prophet: { cdrPerLevel: 2 }, slayer: { structureDamage: 30 }, guardian: { survivalRate: 20 } },
  growthSettings: { hp: { early: 3, mid: 5, late: 7 }, ad: { early: 5, mid: 10, late: 15 }, ap: { early: 5, mid: 10, late: 15 }, armor: { early: 2, mid: 3, late: 4 }, baseAtk: { early: 2, mid: 3, late: 4 }, regen: { early: 1, mid: 2, late: 3 }, respawnPerLevel: 3.0, recallTime: 10.0 },
  aiConfig: savedAI || { provider: 'GEMINI', apiKey: '', model: 'gemini-2.5-flash', enabled: false },
  customImages: INITIAL_CUSTOM_IMAGES 
};

// [í•µì‹¬] ì‹œê°„ ì €ê¸ˆí†µ (Time Accumulator)
// í”„ë ˆì„ ì‚¬ì´ì— ë‚¨ëŠ” ì§œíˆ¬ë¦¬ ì‹œê°„ì„ ì €ì¥í•´ë‘¡ë‹ˆë‹¤.
let timeBuffer = 0;
let lastRenderTime = 0;

// [ìƒìˆ˜] ë¬¼ë¦¬ ì—”ì§„ í‹± ì£¼ê¸° (0.1ì´ˆ ê³ ì • = 10 TPS)
// ì´ ê°’ì„ ê³ ì •í•´ì•¼ íˆ¬ì‚¬ì²´ë‚˜ ì´ë™ ë¡œì§ì´ ì•ˆ ê¹¨ì§‘ë‹ˆë‹¤.
const FIXED_STEP = 0.1;

export const createGameSlice: StateCreator<GameStore, [], [], GameSlice> = (set, get) => ({
  gameState: initialGameState,

  setSpeed: (s) => set((state) => ({ gameState: { ...state.gameState, gameSpeed: s } })),
  togglePlay: () => set((state) => ({ gameState: { ...state.gameState, isPlaying: !state.gameState.isPlaying } })),
  
  setGameState: (updates) => set((state) => ({ gameState: { ...state.gameState, ...updates } })),

  tick: (deltaSeconds: number) => {
    const state = get();
    if (!state.gameState || !state.gameState.isPlaying) return;

    const speed = state.gameState.gameSpeed;
    
    // 1. íë¥¸ ì‹œê°„ì„ ë°°ì†ë§Œí¼ ê³±í•´ì„œ ì €ê¸ˆí†µì— ë„£ìŒ
    timeBuffer += deltaSeconds * speed;

    // ì•ˆì „ì¥ì¹˜: ë„ˆë¬´ ë§ì´ ìŒ“ì´ë©´(ë ‰ ê±¸ë ¤ì„œ ë©ˆì·„ë‹¤ê°€ í’€ë¦´ ë•Œ) 3ì´ˆì¹˜ê¹Œì§€ë§Œ ì²˜ë¦¬í•˜ê³  ë²„ë¦¼ (ë‚˜ì„ í™˜ ë°©ì§€)
    if (timeBuffer > 3.0) timeBuffer = 3.0;

    // 2. ì €ê¸ˆí†µì— 0.1ì´ˆ ì´ìƒ ëª¨ì˜€ìœ¼ë©´ ì—”ì§„ ê°€ë™
    // ëª¨ì¸ ë§Œí¼ ë°˜ë³µ ì‹¤í–‰ (ì˜ˆ: 60ë°°ì†ì´ë©´ í•œ ë²ˆì— ì—¬ëŸ¬ ë²ˆ ë”)
    if (timeBuffer >= FIXED_STEP) {
        
        CoreEngine.processTick(
          state.gameState,
          state.heroes,
          state.communityPosts,
          timeBuffer, // ëª¨ì¸ ì‹œê°„ì„ í†µì§¸ë¡œ ë„˜ê¹€
          FIXED_STEP, // ì²˜ë¦¬ ë‹¨ìœ„ ê³ ì •
          (updates, newHeroes, newPosts, remainingTime) => {
            
            // ì“°ê³  ë‚¨ì€ ì‹œê°„ì€ ë‹¤ì‹œ ì €ê¸ˆí†µì— ë„£ìŒ (ë‹¤ìŒ í”„ë ˆì„ì— ì”€)
            timeBuffer = remainingTime;

            const now = Date.now();
            let renderInterval = 33; 
            if (speed >= 60) renderInterval = 1000; 
            else if (speed >= 10) renderInterval = 200;

            // í™”ë©´ ê°±ì‹  (ìŠ¤ë¡œí‹€ë§ ì ìš©)
            if (now - lastRenderTime > renderInterval) {
              lastRenderTime = now;
              set((current) => ({
                gameState: { ...current.gameState, ...updates },
                heroes: newHeroes || current.heroes,
                communityPosts: newPosts || current.communityPosts
              }));
            } else {
              // í™”ë©´ ê°±ì‹  ì•ˆ í•  ë•Œë„ ë°ì´í„°ëŠ” ìµœì‹ í™”
              set((current) => ({
                gameState: { ...current.gameState, ...updates },
                heroes: newHeroes || current.heroes,
                communityPosts: newPosts || current.communityPosts
              }));
            }
          }
        );
    }
  },

  hardReset: () => {
    const currentAI = get().gameState.aiConfig;
    userPool.length = 0; 
    timeBuffer = 0; // ë¦¬ì…‹ ì‹œ ë²„í¼ë„ ë¹„ì›€
    set({
      gameState: { ...initialGameState, aiConfig: currentAI },
      heroes: INITIAL_HEROES,
      shopItems: INITIAL_ITEMS,
      communityPosts: [],     
      selectedPost: null
    });
  }
});



==========================================
FILE PATH: src/store/slices/heroSlice.ts
==========================================
// ==========================================
// FILE PATH: /src/store/slices/heroSlice.ts
// ==========================================
import { StateCreator } from 'zustand';
import { GameStore, HeroSlice } from '../types';
import { INITIAL_HEROES } from '../../data/heroes';
import { Hero } from '../../types';
import { updateLivePlayerStats } from '../../engine/match/systems/ItemManager';

export const createHeroSlice: StateCreator<GameStore, [], [], HeroSlice> = (set, get) => ({
  heroes: INITIAL_HEROES,

  addHero: (hero: Hero) => set((state) => ({ 
    heroes: [hero, ...state.heroes] 
  })),

  deleteHero: (heroId: string) => set((state) => ({
    heroes: state.heroes.filter((h) => h.id !== heroId)
  })),

  // [í•µì‹¬ ìˆ˜ì •] ì˜ì›… ì •ë³´ ì—…ë°ì´íŠ¸ ì‹œ ì‹¤ì‹œê°„ ê²Œì„ì—ë„ ë°˜ì˜
  updateHero: (id: string, updates: Partial<Hero>) => set((state) => {
    // 1. ê¸€ë¡œë²Œ ë°ì´í„° ì—…ë°ì´íŠ¸
    const newHeroes = state.heroes.map((h) => h.id === id ? { ...h, ...updates } : h);
    
    // ì—…ë°ì´íŠ¸ëœ ì˜ì›… ê°ì²´ í™•ë³´
    const updatedHero = newHeroes.find(h => h.id === id);

    // 2. ì§„í–‰ ì¤‘ì¸ ë§¤ì¹˜(LiveMatches) ê°•ì œ ë™ê¸°í™”
    if (updatedHero) {
        state.gameState.liveMatches.forEach(match => {
            const allPlayers = [...match.blueTeam, ...match.redTeam];
            
            allPlayers.forEach(player => {
                // í•´ë‹¹ ì˜ì›…ì„ ì‚¬ìš©í•˜ëŠ” í”Œë ˆì´ì–´ ì°¾ê¸°
                if (player.heroId === id) {
                    // ìŠ¤íƒ¯ ì¬ê³„ì‚° (ë ˆë²¨ ë¹„ë¡€ ìŠ¤íƒ¯ + ì•„ì´í…œ ìŠ¤íƒ¯ ë‹¤ì‹œ í•©ì‚°)
                    updateLivePlayerStats(player, updatedHero);
                }
            });
        });
    }

    return { 
        heroes: newHeroes,
        // liveMatchesëŠ” ë‚´ë¶€ ê°ì²´(player)ë¥¼ ì§ì ‘ ìˆ˜ì •í–ˆìœ¼ë¯€ë¡œ, 
        // ìƒíƒœ ê°±ì‹ ì„ íŠ¸ë¦¬ê±°í•˜ê¸° ìœ„í•´ gameStateë¥¼ ì–•ì€ ë³µì‚¬ë¡œ ê°±ì‹ 
        gameState: { ...state.gameState }
    };
  }),

  resetHeroStats: () => set((state) => {
    const resetHeroes = state.heroes.map((hero) => ({
      ...hero,
      record: { 
        totalMatches: 0, totalWins: 0, totalPicks: 0, totalBans: 0, 
        totalKills: 0, totalDeaths: 0, totalAssists: 0, 
        totalDamage: 0, totalDamageTaken: 0, totalCs: 0, totalGold: 0, 
        recentResults: [] 
      },
      tier: '3' as const, rank: 0, rankChange: 0, 
      recentWinRate: 0, pickRate: 0, banRate: 0, 
      avgKda: '0.0/0.0/0.0', kdaRatio: '0.00', 
      avgDpm: '0', avgDpg: '0', avgCs: '0', avgGold: '0'
    }));
    return { heroes: resetHeroes };
  }),
});



==========================================
FILE PATH: src/store/slices/itemSlice.ts
==========================================
// ==========================================
// FILE PATH: /src/store/slices/itemSlice.ts
// ==========================================
import { StateCreator } from 'zustand';
import { GameStore, ItemSlice } from '../types';
import { INITIAL_ITEMS } from '../../data/items';
import { Item } from '../../types';
import { updateLivePlayerStats } from '../../engine/match/systems/ItemManager';

export const createItemSlice: StateCreator<GameStore, [], [], ItemSlice> = (set, get) => ({
  shopItems: INITIAL_ITEMS,

  addItem: (item: Item) => set((state) => ({ shopItems: [...state.shopItems, item] })),
  
  deleteItem: (id: string) => set((state) => ({ shopItems: state.shopItems.filter((i) => i.id !== id) })),
  
  // [í•µì‹¬ ìˆ˜ì •] ì•„ì´í…œ ì—…ë°ì´íŠ¸ ì‹œ ë³´ìœ  ì¤‘ì¸ í”Œë ˆì´ì–´ ìŠ¤íƒ¯ ì¦‰ì‹œ ê°±ì‹ 
  updateItem: (id: string, updates: Partial<Item>) => set((state) => {
    // 1. ìƒì  ë°ì´í„° ì—…ë°ì´íŠ¸
    const newShopItems = state.shopItems.map((i) => i.id === id ? { ...i, ...updates } : i);
    
    // 2. ì‹¤ì‹œê°„ ë§¤ì¹˜ ë°˜ì˜
    state.gameState.liveMatches.forEach(match => {
        const allPlayers = [...match.blueTeam, ...match.redTeam];

        allPlayers.forEach(player => {
            let hasItem = false;

            // í”Œë ˆì´ì–´ ì¸ë²¤í† ë¦¬ì—ì„œ í•´ë‹¹ ì•„ì´í…œ ì°¾ì•„ì„œ ìŠ¤íƒ¯ ê°±ì‹ 
            player.items.forEach((item, idx) => {
                if (item.id === id) {
                    // ê¸°ì¡´ ì•„ì´í…œ ê°ì²´ì— ì—…ë°ì´íŠ¸ ë‚´ìš© ë®ì–´ì“°ê¸°
                    player.items[idx] = { ...item, ...updates };
                    hasItem = true;
                }
            });

            // ì•„ì´í…œì„ ê°€ì§€ê³  ìˆì—ˆë‹¤ë©´, í”Œë ˆì´ì–´ ì´í•© ìŠ¤íƒ¯ ì¬ê³„ì‚°
            if (hasItem) {
                const hero = state.heroes.find(h => h.id === player.heroId);
                if (hero) {
                    updateLivePlayerStats(player, hero);
                }
            }
        });
    });

    return { 
        shopItems: newShopItems,
        gameState: { ...state.gameState }
    };
  }),
});



==========================================
FILE PATH: src/store/slices/settingSlice.ts
==========================================
// ==========================================
// FILE PATH: /src/store/slices/settingSlice.ts
// ==========================================
import { StateCreator } from 'zustand';
import { GameStore, SettingSlice } from '../types';
import { Hero } from '../../types';

export const createSettingSlice: StateCreator<GameStore, [], [], SettingSlice> = (set) => ({

  updateBattleSettings: (s) => set((state) => ({ 
    gameState: { ...state.gameState, battleSettings: { ...state.gameState.battleSettings, ...s } } 
  })),

  updateFieldSettings: (s) => set((state) => ({ 
    gameState: { ...state.gameState, fieldSettings: { ...state.gameState.fieldSettings, ...s } } 
  })),

  updateTierConfig: (c) => set((state) => ({ 
    gameState: { ...state.gameState, tierConfig: c } 
  })),

  updateAIConfig: (c) => set((state) => {
    const newConfig = { ...state.gameState.aiConfig, ...c };
    localStorage.setItem('GW_AI_CONFIG', JSON.stringify(newConfig));
    return { gameState: { ...state.gameState, aiConfig: newConfig } };
  }),

  updateRoleSettings: (s) => set((state) => ({ 
    gameState: { ...state.gameState, roleSettings: { ...state.gameState.roleSettings, ...s } } 
  })),

  // [ì‹ ê·œ] ì„±ì¥ ì„¤ì • ì—…ë°ì´íŠ¸
  updateGrowthSettings: (s) => set((state) => ({ 
    gameState: { ...state.gameState, growthSettings: { ...state.gameState.growthSettings, ...s } } 
  })),

  setCustomImage: (id, imageData) => set((state) => ({
    gameState: { ...state.gameState, customImages: { ...state.gameState.customImages, [id]: imageData } }
  })),

  removeCustomImage: (id) => set((state) => {
    const newImages = { ...state.gameState.customImages };
    delete newImages[id];
    return { gameState: { ...state.gameState, customImages: newImages } };
  }),

  loadModData: (modData: any) => set((state) => {
    // (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
    return { ...state }; 
  }),

  updateObjectPosition: (key: string, x: number, y: number) => set((state) => {
    const positions = { ...state.gameState.fieldSettings.positions };
    const parts = key.split('.');
    
    if (parts.length === 1) {
        (positions as any)[parts[0]] = { x, y };
    } else if (parts[0] === 'jungle') {
        const idx = parseInt(parts[1]);
        if (positions.jungle[idx]) positions.jungle[idx] = { x, y };
    } else if (parts[0] === 'towers') {
        const side = parts[1] as 'blue'|'red';
        const lane = parts[2];
        if (lane === 'nexus') {
            positions.towers[side].nexus = { x, y };
        } else {
            const idx = parseInt(parts[3]);
            // @ts-ignore
            if (positions.towers[side][lane][idx]) {
                // @ts-ignore
                positions.towers[side][lane][idx] = { x, y };
            }
        }
    }

    return { 
        gameState: { 
            ...state.gameState, 
            fieldSettings: { ...state.gameState.fieldSettings, positions } 
        } 
    };
  }),
});



==========================================
FILE PATH: src/store/types.ts
==========================================
// ==========================================
// FILE PATH: /src/store/types.ts
// ==========================================

import { 
  Hero, Post, GameState, Item, 
  BattleSettings, BattlefieldSettings, TierConfig, AIConfig, RoleSettings, 
  ItemStatData 
} from '../types';

// 1. Hero Slice (ì˜ì›… ê´€ë¦¬)
export interface HeroSlice {
  heroes: Hero[];
  addHero: (hero: Hero) => void;
  deleteHero: (heroId: string) => void;
  updateHero: (id: string, updates: Partial<Hero>) => void;
  resetHeroStats: () => void;
}

// 2. Community Slice (ì»¤ë®¤ë‹ˆí‹°)
export interface CommunitySlice {
  communityPosts: Post[];
  selectedPost: Post | null;
  openPost: (post: Post) => void;
  closePost: () => void;
  setCommunityPosts: (posts: Post[]) => void;
}

// 3. Setting Slice (ì„¤ì • ê´€ë¦¬) - [ì‹ ê·œ ë¶„ë¦¬ë¨]
export interface SettingSlice {
  updateBattleSettings: (settings: Partial<BattleSettings['izman'] | BattleSettings['dante']>) => void;
  updateFieldSettings: (settings: Partial<BattlefieldSettings>) => void;
  updateTierConfig: (config: TierConfig) => void;
  updateAIConfig: (config: Partial<AIConfig>) => void;
  updateRoleSettings: (settings: Partial<RoleSettings>) => void;
  setCustomImage: (id: string, imageData: string) => void;
  removeCustomImage: (id: string) => void;
  loadModData: (modData: any) => void;
}

// 4. Game Slice (ê²Œì„ ì§„í–‰/ë©”ì¸ ë£¨í”„)
export interface GameSlice {
  gameState: GameState;
  setSpeed: (speed: number) => void;
  togglePlay: () => void;
  setGameState: (updates: Partial<GameState>) => void;
  tick: (deltaSeconds: number) => void; // í•µì‹¬ ë£¨í”„
  hardReset: () => void;
}

// 5. Item Slice (ì•„ì´í…œ ìƒì )
export interface ItemSlice {
  shopItems: Item[];
  addItem: (item: Item) => void;
  deleteItem: (id: string) => void;
  updateItem: (id: string, updates: Partial<Item>) => void;
}

// í†µí•© Store íƒ€ì…
export type GameStore = HeroSlice & CommunitySlice & SettingSlice & GameSlice & ItemSlice;


==========================================
FILE PATH: src/store/useGameStore.ts
==========================================
// ==========================================
// FILE PATH: /src/store/useGameStore.ts
// ==========================================

import { create } from 'zustand';
import { GameStore } from './types';

// ìŠ¬ë¼ì´ìŠ¤ë“¤ ë¶ˆëŸ¬ì˜¤ê¸°
import { createHeroSlice } from './slices/heroSlice';
import { createCommunitySlice } from './slices/communitySlice';
import { createGameSlice } from './slices/gameSlice';
import { createItemSlice } from './slices/itemSlice';
import { createSettingSlice } from './slices/settingSlice'; // [ì¶”ê°€ë¨]

export const useGameStore = create<GameStore>()((...a) => ({
  ...createHeroSlice(...a),
  ...createCommunitySlice(...a),
  ...createGameSlice(...a),
  ...createItemSlice(...a),
  ...createSettingSlice(...a), // [ì¶”ê°€ë¨]
}));


==========================================
FILE PATH: src/types/index.ts
==========================================
// ==========================================
// FILE PATH: /src/types/index.ts
// ==========================================
export * from './user';
export * from './hero';
export * from './match';

import { TierConfig, AIConfig } from './user';
export { TierConfig, AIConfig };

export interface Item {
  id: string; name: string; cost: number;
  ad: number; ap: number; hp: number; armor: number; crit: number; speed: number;
  mp?: number; regen?: number; mpRegen?: number; pen?: number;
  type: 'WEAPON' | 'ARMOR' | 'ACCESSORY' | 'POWER' | 'BOOTS' | 'ARTIFACT'; 
  description?: string;
}

export interface ItemStatData { itemId: string; totalPicks: number; totalWins: number; totalKills: number; totalDeaths: number; totalAssists: number; }

export interface ObjectStats { hp: number; armor: number; rewardGold: number; atk?: number; }

export interface ColossusSettings extends ObjectStats { 
  attack: number; 
  initialSpawnTime: number; 
  respawnTime: number;
  dmgFromHero: number;   
  dmgFromMinion: number; 
  dmgFromTower: number;  
}

export interface WatcherSettings extends ObjectStats { buffType: 'COMBAT' | 'GOLD'; buffAmount: number; buffDuration: number; initialSpawnTime: number; respawnTime: number; }
export interface JungleSettings { density: number; threat: number; yield: number; attack: number; defense: number; xp: number; gold: number; initialSpawnTime: number; respawnTime: number; }

export interface Vector2 { x: number; y: number; }
export interface MapPositions {
  colossus: Vector2;
  watcher: Vector2;
  jungle: Vector2[];
  towers: {
    blue: { top: Vector2[]; mid: Vector2[]; bot: Vector2[]; nexus: Vector2; };
    red: { top: Vector2[]; mid: Vector2[]; bot: Vector2[]; nexus: Vector2; };
  };
}

export interface BattlefieldSettings { 
  towers: { t1: ObjectStats; t2: ObjectStats; t3: ObjectStats; nexus: ObjectStats; };
  colossus: ColossusSettings; 
  watcher: WatcherSettings; 
  jungle: JungleSettings; 
  positions: MapPositions;
}

export interface RoleSettings { executor: { damage: number; defense: number }; tracker: { gold: number; smiteChance: number }; prophet: { cdrPerLevel: number }; slayer: { structureDamage: number }; guardian: { survivalRate: number }; }
export interface MinionStats { label: string; hp: number; def: number; atk: number; gold: number; xp: number; }
export interface GodSettings {
  name: string; atkRatio: number; defRatio: number; hpRatio: number;
  guardianHp: number; towerAtk: number; trait: string;
  minions: { melee: MinionStats; ranged: MinionStats; siege: MinionStats; };
  servantGold: number; servantXp: number; 
}

// [ìˆ˜ì •] ê²½ì œ ì„¤ì • í™•ì¥ (í˜„ìƒê¸ˆ ì‹œìŠ¤í…œ)
export interface EconomySettings { 
  minionGold: number; 
  minionXp: number;
  
  killGold: number;       // ê¸°ë³¸ í‚¬ ê³¨ë“œ
  goldPerLevel: number;   // [ì‹ ê·œ] ì  ë ˆë²¨ë‹¹ ì¶”ê°€ ê³¨ë“œ
  bountyIncrement: number;// [ì‹ ê·œ] ì—°ì† í‚¬ë‹¹ í˜„ìƒê¸ˆ ì¦ê°€ëŸ‰
  
  assistPool: number;     
  killXpBase: number;     
  killXpPerLevel: number; 
}

export interface SiegeSettings {
  minionDmg: number; cannonDmg: number; superDmg: number;
  dmgToHero: number; dmgToT1: number; dmgToT2: number; dmgToT3: number; dmgToNexus: number;
  colossusToHero: number; colossusToT1: number; colossusToT2: number; colossusToT3: number; colossusToNexus: number;
}

export interface GrowthIntervals {
  early: number; 
  mid: number;   
  late: number;  
}

export interface GrowthSettings {
  hp: GrowthIntervals;
  ad: GrowthIntervals;
  ap: GrowthIntervals;
  armor: GrowthIntervals;
  baseAtk: GrowthIntervals;
  regen: GrowthIntervals;
  respawnPerLevel: number; 
  recallTime: number;      
}

export interface BattleSettings { 
  izman: GodSettings; 
  dante: GodSettings; 
  economy: EconomySettings; 
  siege: SiegeSettings; 
}

export interface AIConfig { provider: 'GEMINI' | 'OPENAI'; apiKey: string; model: string; enabled: boolean; }
export interface GodStats { totalMatches: number; izmanWins: number; izmanAvgKills: string; izmanAvgTime: string; danteWins: number; danteAvgKills: string; danteAvgTime: string; avgGameDuration: number; guardianDeathRate: number; godAwakenRate: number; }
export interface Comment { id: number; author: string; authorTier: string; content: string; timestamp: string; }
export interface Post { id: number; author: string; authorTier: string; title: string; content: string; category: 'ê³µëµ' | 'ìœ ë¨¸' | 'ì§•ì§•' | 'ë¶„ì„' | 'ì¡ë‹´' | 'ì§ˆë¬¸' | 'ìë‘' | 'ê³µì§€'; views: number; upvotes: number; downvotes: number; comments: number; commentList: Comment[]; createdAt: number; potential: number; isBest: boolean; displayTime: string; }

import { UserProfile, UserStatus } from './user';
import { LiveMatch, LivePlayer } from './match';

export interface GameState { 
  season: number; day: number; hour: number; minute: number; second: number; 
  isPlaying: boolean; gameSpeed: number; userSentiment: number; 
  ccu: number; totalUsers: number; 
  userStatus: UserStatus; topRankers: UserProfile[]; godStats: GodStats; 
  liveMatches: LiveMatch[]; 
  tierConfig: TierConfig; battleSettings: BattleSettings; fieldSettings: BattlefieldSettings; 
  roleSettings: RoleSettings; growthSettings: GrowthSettings; 
  aiConfig: AIConfig; 
  itemStats: Record<string, ItemStatData>; customImages: Record<string, string>; 
}

export interface Minion {
  id: string;
  team: 'BLUE' | 'RED';
  lane: 'TOP' | 'MID' | 'BOT';
  type: 'MELEE' | 'RANGED' | 'SIEGE' | 'SUMMONED_COLOSSUS';
  x: number;
  y: number;
  hp: number;
  maxHp: number;
  atk: number;
  pathIdx: number;
  targetId?: string; 
  armor?: number; 
}

export interface HeroSlice { heroes: any[]; addHero: (hero: any) => void; deleteHero: (heroId: string) => void; updateHero: (id: string, updates: any) => void; resetHeroStats: () => void; }
export interface ItemSlice { shopItems: Item[]; addItem: (item: Item) => void; deleteItem: (id: string) => void; updateItem: (id: string, updates: Partial<Item>) => void; }
export interface CommunitySlice { communityPosts: Post[]; selectedPost: Post | null; openPost: (post: Post) => void; closePost: () => void; setCommunityPosts: (posts: Post[]) => void; }
export interface SettingSlice { 
  updateBattleSettings: (settings: any) => void; 
  updateFieldSettings: (settings: any) => void; 
  updateTierConfig: (config: TierConfig) => void; 
  updateAIConfig: (config: Partial<AIConfig>) => void; 
  updateRoleSettings: (settings: Partial<RoleSettings>) => void; 
  updateGrowthSettings: (settings: Partial<GrowthSettings>) => void; 
  setCustomImage: (id: string, imageData: string) => void; 
  removeCustomImage: (id: string) => void; 
  loadModData: (modData: any) => void; 
  updateObjectPosition: (key: string, x: number, y: number) => void;
}
export interface GameSlice { gameState: GameState; setSpeed: (speed: number) => void; togglePlay: () => void; setGameState: (updates: Partial<GameState>) => void; tick: (deltaSeconds: number) => void; hardReset: () => void; }
export type GameStore = HeroSlice & ItemSlice & CommunitySlice & GameSlice & SettingSlice;



==========================================
FILE PATH: src/types/jungle.ts
==========================================
// ==========================================
// FILE PATH: /src/types/jungle.ts
// ==========================================

export type JungleCampType = 'TOP_BLUE' | 'BOT_BLUE' | 'TOP_RED' | 'BOT_RED';

export type BuffType = 'ATK' | 'DEF' | 'SPEED' | 'REGEN' | 'HASSTE' | 'GOLD';

// [ì‹ ê·œ] ê°œë³„ ë²„í”„ ì •ì˜
export interface MonsterBuff {
  type: BuffType;
  value: number;
}

export interface JungleMonsterStats {
  name: string;
  hp: number;
  atk: number;
  def: number;
  gold: number;
  xp: number;
  respawnTime: number;
  isBuffMob: boolean;
  
  // [ìˆ˜ì •] ë‹¤ì¤‘ ë²„í”„ ì§€ì›ì„ ìœ„í•´ ë°°ì—´ë¡œ ë³€ê²½
  buffs: MonsterBuff[]; 
}

export interface JungleCampConfig {
  id: string;
  name: string;
  monsters: {
    spotId: string;
    x: number;
    y: number;
    stats: JungleMonsterStats;
  }[];
}

export interface JungleSettings {
  density: number;
  camps: Record<JungleCampType, JungleCampConfig>;
}



==========================================
FILE PATH: src/types/match.ts
==========================================
// ==========================================
// FILE PATH: /src/types/match.ts
// ==========================================

export type EventType = 'KILL' | 'TOWER' | 'COLOSSUS' | 'WATCHER' | 'START' | 'LEVELUP' | 'RECALL_CANCEL';

export interface GameLog {
  time: number;
  message: string;
  type: EventType;
  team?: 'BLUE' | 'RED';
}

export interface TimelineEvent {
  time: number; 
  type: EventType;
  killerId: string; 
  victimId: string; 
  message: string;
}

// [ì‹ ê·œ] ì‹œê° íš¨ê³¼ ì¸í„°í˜ì´ìŠ¤
export interface VisualEffect {
  id: string;
  type: 'PROJECTILE' | 'EXPLOSION' | 'AREA' | 'HIT';
  x: number;
  y: number;
  targetX?: number; // íˆ¬ì‚¬ì²´ ëª©í‘œ
  targetY?: number; // íˆ¬ì‚¬ì²´ ëª©í‘œ
  color: string;
  size: number;
  duration: number; // ë‚¨ì€ ì‹œê°„ (ì´ˆ)
  maxDuration: number; // ì „ì²´ ì‹œê°„ (ì• ë‹ˆë©”ì´ì…˜ìš©)
}

export interface LivePlayer {
  name: string; 
  heroId: string;
  kills: number; deaths: number; assists: number;
  gold: number; cs: number;
  currentHp: number; maxHp: number;
  currentMp: number; maxMp: number; mpRegen: number;
  level: number; items: any[]; 
  totalDamageDealt: number;
  x: number; y: number; lane: 'TOP' | 'MID' | 'BOT' | 'JUNGLE';
  buffs: string[]; mmr: number; respawnTimer: number;
  cooldowns?: { q:number, w:number, e:number, r:number };
  stats: { brain: number, mechanics: number };
  lastAttackTime?: number;       
  lastAttackedTargetId?: string;
  killStreak: number; bounty: number;
  isRecalling: boolean; currentRecallTime: number; recallCooldown: number;
  activeSkill?: { key: 'q' | 'w' | 'e' | 'r'; timestamp: number; };
}

export interface TowerStatus { top: number; mid: number; bot: number; }

export interface TeamStats {
  towers: TowerStatus; 
  laneHealth: { top: number; mid: number; bot: number };
  colossus: number; watcher: number; fury: number;
  nexusHp: number; maxNexusHp: number;
  activeBuffs: { siegeUnit: boolean; voidPower: boolean; voidBuffEndTime?: number; };
}

export interface LiveMatch {
  id: string;
  status: 'DRAFTING' | 'PLAYING' | 'ENDED';
  draft?: any;
  blueTeam: LivePlayer[]; redTeam: LivePlayer[];
  bans: { blue: string[]; red: string[]; };
  startTime: number; duration: number; currentDuration: number; avgTier: string;
  score: { blue: number, red: number };
  stats: { blue: TeamStats; red: TeamStats; };
  timeline: TimelineEvent[]; logs: GameLog[];
  
  nextColossusSpawnTime?: number;
  nextWatcherSpawnTime?: number;
  objectives: {
      colossus: { hp: number; maxHp: number; status: 'ALIVE'|'DEAD'; nextSpawnTime: number };
      watcher: { hp: number; maxHp: number; status: 'ALIVE'|'DEAD'; nextSpawnTime: number };
  };
  minions: any[];
  projectiles: any[];
  jungleMobs: any[];

  // [ì‹ ê·œ] ì‹œê° íš¨ê³¼ ë¦¬ìŠ¤íŠ¸ (ë¡œì§ì—” ì˜í–¥ ì•ˆ ì£¼ê³  ë Œë”ë§ì—ë§Œ ì”€)
  visualEffects: VisualEffect[];
}



==========================================
FILE PATH: src/types/user.ts
==========================================
export interface MatchHistory {
  season: number; result: 'WIN' | 'LOSE' | 'PROMO WIN' | 'PROMO LOSS'; 
  heroName: string; kda: string; lpChange: number; date: string;
}

export interface UserHeroStat {
  matches: number; wins: number; kills: number; deaths: number; assists: number;
}

// [ì‹ ê·œ] ìœ ì € ì„±í–¥ íƒ€ì… ì •ì˜
export type PlayStyle = 'WORKER' | 'STUDENT' | 'NIGHT_OWL' | 'HARDCORE';

export interface UserProfile {
  id: number; name: string; 
  score: number; tier: string; rank: number; isChallenger: boolean;
  promoStatus: { targetTier: string; wins: number; losses: number; targetWins: number; } | null;

  winRate: number; totalGames: number; wins: number; losses: number;
  
  mainHeroId: string; preferredLane: 'TOP' | 'JUNGLE' | 'MID' | 'BOT'; preferredHeroes: string[];
  brain: number; mechanics: number; hiddenMmr: number; 
  
  // [ì‹ ê·œ ì†ì„±: AI í–‰ë™ íŒ¨í„´ìš©]
  playStyle: PlayStyle;      // ìœ ì € ì„±í–¥ (ì ‘ì† ì‹œê°„ëŒ€ ê²°ì •)
  activityBias: number;      // ì ‘ì† ë¹ˆë„ ê°€ì¤‘ì¹˜ (ë†’ì„ìˆ˜ë¡ ìì£¼ ì ‘ì†)
  tiredness: number;         // í˜„ì¬ ì„¸ì…˜ì—ì„œ í”Œë ˆì´í•œ ê²Œì„ ìˆ˜
  sessionTarget: number;     // ì´ë²ˆ ì ‘ì†ì—ì„œ í”Œë ˆì´í•  ëª©í‘œ ê²Œì„ ìˆ˜

  status: 'IDLE' | 'QUEUE' | 'INGAME' | 'OFFLINE' | 'RESTING';
  restTimer: number;

  history: MatchHistory[]; heroStats: Record<string, UserHeroStat>;
  mostChamps?: any[]; laneStats?: any[];
}

export interface TierConfig {
  challengerRank: number; master: number; ace: number; joker: number;
  gold: number; silver: number; bronze: number;
  promos?: { master: number; ace: number; joker: number; gold: number; silver: number; bronze: number; };
}

export interface TierStat { name: string; minScore: number; count: number; percent: number; color: string; }
export interface UserStatus {
  totalGames: number; playingUsers: number; queuingUsers: number; avgWaitTime: number; tierDistribution: TierStat[];
}



==========================================
FILE PATH: src/utils/ai/AIClient.ts
==========================================
import { AIConfig } from '../../types';

// ê³µí†µ JSON ì‘ë‹µìš©
export async function callAI(config: AIConfig, prompt: string) {
  try {
    if (config.provider === 'GEMINI') {
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${config.model}:generateContent?key=${config.apiKey}`;
      const response = await fetch(url, {
        method: "POST", headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
      });
      const data = await response.json();
      if (data.error) throw new Error(data.error.message);
      const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
      const jsonStr = text.replace(/```json|```/g, "").trim();
      return JSON.parse(jsonStr);
    }

    if (config.provider === 'OPENAI') {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST", headers: { "Content-Type": "application/json", "Authorization": `Bearer ${config.apiKey}` },
        body: JSON.stringify({
          model: config.model,
          messages: [{ role: "system", content: "Reply in JSON only." }, { role: "user", content: prompt }],
          temperature: 0.9,
        })
      });
      const data = await response.json();
      return JSON.parse(data.choices[0].message.content);
    }
  } catch (e) {
    console.error("AI Error:", e);
    return null;
  }
  return null;
}

// ê³µí†µ í…ìŠ¤íŠ¸ ì‘ë‹µìš©
export async function callAIString(config: AIConfig, prompt: string) {
  try {
    if (config.provider === 'GEMINI') {
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${config.model}:generateContent?key=${config.apiKey}`;
      const response = await fetch(url, {
        method: "POST", headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
      });
      const data = await response.json();
      return data.candidates?.[0]?.content?.parts?.[0]?.text.trim();
    } 

    if (config.provider === 'OPENAI') {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST", headers: { "Content-Type": "application/json", "Authorization": `Bearer ${config.apiKey}` },
        body: JSON.stringify({
          model: config.model,
          messages: [
            { role: "system", content: "You are a user of a Korean gaming community." }, 
            { role: "user", content: prompt }
          ],
          temperature: 1.0,
          max_tokens: 100
        })
      });
      const data = await response.json();
      return data.choices[0].message.content.trim();
    }
  } catch (e) { return null; }
  return null;
}


==========================================
FILE PATH: src/utils/ai/CommentGenerator.ts
==========================================
import { AIConfig } from '../../types';
import { callAIString } from './AIClient';

const FALLBACK_COMMENTS = ["ã…‹ã…‹ã…‹ã…‹", "ã„¹ã…‡ã…‹ã…‹", "ê°œì›ƒê¸°ë„¤", "???", "ã„´ã„´ ì•„ë‹˜"];
const pickRandom = (arr: string[]) => arr[Math.floor(Math.random() * arr.length)];

export async function generateAIComment(config: AIConfig, postTitle: string, postContent: string): Promise<string | null> {
  if (!config.apiKey || !config.enabled) return pickRandom(FALLBACK_COMMENTS);

  const personas = [
    { type: "íŒ©íŠ¸í­ê²©ê¸°", desc: "ê¸€ ë‚´ìš©ì˜ ëª¨ìˆœì„ ì°¾ì•„ë‚´ì„œ ë…¼ë¦¬ì ìœ¼ë¡œ ë°˜ë°•í•¨. í‹°ì–´ ë¶€ì‹¬ì´ ì‹¬í•¨." },
    { type: "ê³µê°ëŸ¬", desc: "ê¸€ì“´ì´ì˜ ìƒí™©ì— ê¹Šì´ ê³µê°í•˜ë©° ê°™ì´ ìš•í•´ì¤Œ." },
    { type: "ë¹„ê¼¬ê¸° ì¥ì¸", desc: "ì§ì ‘ì ì¸ ìš•ì„¤ ì—†ì´ ëŒë ¤ì„œ ê¹Œê±°ë‚˜, 'ê·¸ë˜ì„œ í‹°ì–´ê°€?' ì‹œì „." },
    { type: "ë‹¨ë‹µí˜• ì¿¨ì°", desc: "ì•„ì£¼ ì§§ê²Œ í•œë§ˆë”” íˆ­ ë˜ì§. ì´ˆì„±ì²´(ã„¹ã…‡ã…‹ã…‹, ã„´ã„´, ã„·ã„·) ì• ìš©." },
    { type: "ë“œë¦½ì¶©", desc: "ìƒí™©ì— ë§ëŠ” ë“œë¦½ì„ ì¹¨." }
  ];

  const selected = personas[Math.floor(Math.random() * personas.length)];

  const systemPrompt = `
    ë„ˆëŠ” ê²Œì„ ì»¤ë®¤ë‹ˆí‹° ëŒ“ê¸€ ì‘ì„±ìì•¼. 
    [ê²Œì‹œê¸€]ì„ ë³´ê³  [ì»¨ì…‰]ì— ë§ì¶° **ì•„ì£¼ ì§§ì€ ëŒ“ê¸€ í•˜ë‚˜**ë¥¼ ì¨.

    [ê²Œì‹œê¸€ ì œëª©]: ${postTitle}
    [ê²Œì‹œê¸€ ë‚´ìš©]: ${postContent}
    [ë„ˆì˜ ì»¨ì…‰]: ${selected.type} (${selected.desc})

    [ê·œì¹™]:
    1. ë¬´ì¡°ê±´ ë°˜ë§/ìŒìŠ´ì²´.
    2. ê¸¸ì´ëŠ” 5~20ì ì´ë‚´. (ê¸¸ë©´ ì•ˆ ì½ìŒ)
    3. JSON ê¸ˆì§€. í…ìŠ¤íŠ¸ë§Œ ì¶œë ¥.
    4. "ë‹ˆê°€ ëª»í•´ì„œ ê·¸ë˜" ê¸ˆì§€. ì°½ì˜ì ìœ¼ë¡œ ì¨.
  `;

  try {
    const aiResponse = await callAIString(config, systemPrompt);
    return aiResponse || pickRandom(FALLBACK_COMMENTS);
  } catch (e) {
    return pickRandom(FALLBACK_COMMENTS);
  }
}


==========================================
FILE PATH: src/utils/ai/PostGenerator.ts
==========================================
// ==========================================
// FILE PATH: /src/utils/ai/PostGenerator.ts
// ==========================================

import { AIConfig } from '../../types';
import { callAI } from './AIClient';

export async function generateAIPost(config: AIConfig, context: string, category: string): Promise<{title: string, content: string} | null> {
  // AI ì„¤ì •ì´ ì—†ê±°ë‚˜ êº¼ì ¸ìˆìœ¼ë©´ ì¤‘ë‹¨
  if (!config.apiKey || !config.enabled) return null;

  // 1. ì¹´í…Œê³ ë¦¬ ë° ë¬¸ë§¥ì— ë”°ë¥¸ í˜ë¥´ì†Œë‚˜(ì„±ê²©) ì„¤ì •
  let persona = "ì¼ë°˜ì ì¸ ê²Œì„ ìœ ì €";
  let extraInstruction = "";

  // ë¬¸ë§¥ì— 'ì €ê²©'ì´ í¬í•¨ë˜ì–´ ìˆìœ¼ë©´ ì¹´í…Œê³ ë¦¬ë³´ë‹¤ ìš°ì„ í•˜ì—¬ ì €ê²©ëŸ¬ í˜ë¥´ì†Œë‚˜ ì ìš©
  if (context.includes('ì €ê²©') || context.includes('SNIPING')) {
    persona = "ì§‘ìš”í•œ ì €ê²©ëŸ¬. ì¦ê±°ë¥¼ ëŒ€ë¼ëŠ” ì‹ì˜ ë§íˆ¬ë‚˜ ë¹„ê¼¬ëŠ” ë§íˆ¬ ì‚¬ìš©.";
    extraInstruction = "ìƒëŒ€ ë‹‰ë„¤ì„ì„ ê±°ë¡ í•˜ë©° ê³µê°œì ìœ¼ë¡œ ë§ì‹ ì„ ì£¼ë ¤ëŠ” í†¤ìœ¼ë¡œ ì‘ì„±í•´. 'ëŒ€ë¦¬ëƒ?', 'ì‚¬ëŒì´ëƒ?' ê°™ì€ ê³µê²©ì ì¸ ì§ˆë¬¸ì„ ë˜ì ¸.";
  } 
  else if (category === 'ê³µëµ' || category === 'ë¶„ì„') {
    persona = "ë…¼ë¦¬ì ì´ê³  ë¶„ì„ì ì¸ ì²™í•˜ëŠ” 'ê²œì˜ì•Œ' ìœ ì €. ìˆ˜ì¹˜ì™€ ë°ì´í„°ë¥¼ ì–¸ê¸‰í•˜ê¸¸ ì¢‹ì•„í•¨.";
    extraInstruction = "ë§ˆì¹˜ ìì‹ ì´ í”„ë¡œê²Œì´ë¨¸ì¸ ê²ƒì²˜ëŸ¼ í›ˆìˆ˜ ë‘ëŠ” ë§íˆ¬ë¥¼ ì‚¬ìš©í•´. 'ì´ê±´ íŒ©íŠ¸ì„', 'ë°˜ë°•ì‹œ ë‹ˆë§ë§' ê°™ì€ í‘œí˜„ ì‚¬ìš©.";
  } 
  else if (category === 'ì§•ì§•') {
    persona = "í™”ê°€ ì”ëœ© ë‚œ ë‹¤í˜ˆì§ˆ ìœ ì €. ì–µìš¸í•¨ì„ í˜¸ì†Œí•˜ê±°ë‚˜ ìš´ì˜ì§„/íŒ€ì›ì„ íƒ“í•¨.";
    extraInstruction = "ê±°ì¹œ ì–´ì¡°ë¥¼ ì‚¬ìš©í•˜ê³ , 'ë§ê²œ', 'ì–µê¹Œ', 'ë°¸ëŸ°ìŠ¤ ê¼¬ë¼ì§€' ê°™ì€ ë‹¨ì–´ë¥¼ ì‚¬ìš©í•´ ë¶„ë…¸ë¥¼ í‘œì¶œí•´.";
  } 
  else if (category === 'ìœ ë¨¸') {
    persona = "ì»¤ë®¤ë‹ˆí‹° ë“œë¦½ ì¥ì¸. ì§§ê³  ê°•ë ¬í•œ 'ë»˜ê¸€'ì´ë‚˜ 'ë“œë¦½'ì„ ì˜ ì¹¨.";
    extraInstruction = "ì§„ì§€í•œ ë‚´ìš©ì€ ë¹¼ê³ , í”¼ì‹í•˜ê²Œ ë§Œë“œëŠ” ì§§ì€ ë¬¸ì¥ ìœ„ì£¼ë¡œ ì¨. ì´ˆì„±ì²´(ã…‹ã…‹ã…‹ã…‹, ã„¹ã…‡ã…‹ã…‹)ë¥¼ ì ê·¹ í™œìš©í•´.";
  } 
  else if (category === 'ì§ˆë¬¸') {
    persona = "ê²Œì„ì„ ê°“ ì‹œì‘í•œ ë‰´ë¹„ í˜¹ì€ ëª¨ë¥´ëŠ”ê²Œ ìƒê¸´ ìœ ì €.";
    extraInstruction = "ê²¸ì†í•˜ê²Œ ë¬¼ì–´ë³´ê±°ë‚˜, í˜¹ì€ í•‘í”„(ê²€ìƒ‰ ì•ˆí•˜ê³  ë¬¼ì–´ë³´ëŠ”) ì»¨ì…‰ìœ¼ë¡œ ì§ˆë¬¸í•´.";
  }
  else {
    persona = "ì‹¬ì‹¬í•œ ìœ ì €. ì˜ì‹ì˜ íë¦„ëŒ€ë¡œ ê¸€ì„ ì”€.";
    extraInstruction = "ì¼ìƒì ì¸ ë§íˆ¬ë¡œ ì‘ì„±í•´. ë³„ ë‚´ìš© ì—†ëŠ” ì¡ë‹´ì²˜ëŸ¼.";
  }

  // 2. AIì—ê²Œ ë³´ë‚¼ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ êµ¬ì„±
  const systemPrompt = `
    ë„ˆëŠ” 'ì‹ ë“¤ì˜ ì „ìŸ(Gods' War)'ì´ë¼ëŠ” ê°€ìƒì˜ AOS(MOBA) ê²Œì„ ì»¤ë®¤ë‹ˆí‹°(í•œêµ­ì˜ ë””ì‹œì¸ì‚¬ì´ë“œ ë¡¤ê°¤, í¨ì½”, ì•„ì¹´ë¼ì´ë¸Œ ëŠë‚Œ)ì˜ ìœ ì €ì•¼.
    ì£¼ì–´ì§„ [ìƒí™© ì •ë³´]ë¥¼ ë°”íƒ•ìœ¼ë¡œ, [ì¹´í…Œê³ ë¦¬]ì— ë§ëŠ” **ë‹¨ í•˜ë‚˜ì˜ ê²Œì‹œê¸€**ì„ ì‘ì„±í•´.

    [ì¹´í…Œê³ ë¦¬]: ${category}
    [ì‘ì„±ì ì»¨ì…‰]: ${persona}
    [ê¸€ê° ë° ìƒí™© ì •ë³´]: ${context}

    [ì‘ì„± ì§€ì¹¨]:
    1. **ë§íˆ¬**: í•œêµ­ ì¸í„°ë„· ì»¤ë®¤ë‹ˆí‹° ë§íˆ¬(ìŒìŠ´ì²´, ë°˜ë§, ì€ì–´, ì´ˆì„±ì²´ 'ã…‹ã…‹', 'ã„¹ã…‡', 'ã„·ã„·', 'ã„´ã„´')ë¥¼ ìì—°ìŠ¤ëŸ½ê²Œ ì‚¬ìš©í•´.
    2. **ë‚´ìš©**: 
       - ì œëª©ì€ í´ë¦­ì„ ìœ ë„í•˜ë„ë¡ ìê·¹ì ì´ê±°ë‚˜(ì–´ê·¸ë¡œ), ì•„ì£¼ ë¬´ì‹¬í•˜ê²Œ(ì¿¨ì°) ì§€ì–´.
       - ë³¸ë¬¸ì€ 1~4ë¬¸ì¥ ë‚´ì™¸ë¡œ ì§§ê²Œ. ë„ˆë¬´ ê¸¸ë©´ ì•ˆ ì½ìŒ.
       - ${extraInstruction}
    3. **í˜•ì‹**: ì˜¤ì§ JSONë§Œ ì¶œë ¥í•´. (ë§ˆí¬ë‹¤ìš´ ì½”ë“œë¸”ëŸ­ ì—†ì´).
    
    Example Input: ì§•ì§• / ì•¼ìŠ¤ì˜¤ Q ë„ˆí”„ì¢€
    Example Output: {"title": "ì•„ë‹ˆ ì•¼ìŠ¤ì˜¤ Q ë”œ ì‹¤í™”ëƒ?", "content": "ìŠ¤ì¹˜ë©´ ë°˜í”¼ ë‚˜ê°€ëŠ”ê²Œ ê²Œì„ì´ëƒ? ìš´ì˜ì ì¼ ì•ˆí•¨? ã…¡ã…¡"}
  `;

  // 3. AI í˜¸ì¶œ ë° ê²°ê³¼ ë°˜í™˜
  return await callAI(config, systemPrompt);
}


==========================================
FILE PATH: src/utils/AIService.ts
==========================================
// ==========================================
// FILE PATH: /src/utils/AIService.ts
// ==========================================

import { generateAIPost } from './ai/PostGenerator';
import { generateAIComment } from './ai/CommentGenerator';

// ê¸°ì¡´ ì½”ë“œì™€ì˜ í˜¸í™˜ì„±ì„ ìœ„í•´ í•¨ìˆ˜ ì´ë¦„ì„ ìœ ì§€í•˜ë©° ì—°ê²°í•©ë‹ˆë‹¤.
export const fetchAIPost = generateAIPost;
export const fetchAIComment = generateAIComment;


==========================================
FILE PATH: src/utils/GeminiService.ts
==========================================
// src/utils/GeminiService.ts

// [ì¤‘ìš”] Google AI Studio API Key í•„ìš”
const API_KEY = ""; 
const MODEL_VERSION = "gemini-2.5-flash"; // or gemini-2.0-flash-exp

export async function fetchGeminiPost(context: string, topic: string): Promise<{title: string, content: string} | null> {
  if (!API_KEY) {
    console.warn("Gemini API Key Missing");
    return null;
  }

  try {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_VERSION}:generateContent?key=${API_KEY}`;
    
    // [í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§]
    // AIì—ê²Œ êµ¬ì²´ì ì¸ í˜ë¥´ì†Œë‚˜ì™€ ìƒí™©ì„ ë¶€ì—¬í•˜ì—¬ ê¸€ì˜ í€„ë¦¬í‹°ë¥¼ ë†’ì„
    const prompt = `
      ë„ˆëŠ” 'ì‹ ë“¤ì˜ ì „ìŸ(Gods' War)'ì´ë¼ëŠ” AOS(MOBA) ê²Œì„ ì»¤ë®¤ë‹ˆí‹°ì˜ ìœ ì €ì•¼.
      ì§€ê¸ˆë¶€í„° ì•„ë˜ ì£¼ì–´ì§„ [ìƒí™©]ê³¼ [ì£¼ì œ]ì— ë§ì¶°ì„œ ì»¤ë®¤ë‹ˆí‹° ê²Œì‹œê¸€ì„ ì‘ì„±í•´.
      
      [ì£¼ì œ]: ${topic}
      [í˜„ì¬ ê²Œì„ ë©”íƒ€ ìƒí™©]:
      ${context}

      [ì‘ì„± ì§€ì¹¨]:
      1. ë§íˆ¬: ë””ì‹œì¸ì‚¬ì´ë“œ, í¨ì½”, ì•„ì¹´ë¼ì´ë¸Œ ë“± í•œêµ­ ê²Œì„ ì»¤ë®¤ë‹ˆí‹° ë§íˆ¬ë¥¼ ì‚¬ìš©í•´. (ë°˜ë§, ì€ì–´ ì‚¬ìš© ê°€ëŠ¥)
      2. ë‚´ìš©: ë¬´ì¡°ê±´ì ì¸ ìš•ì„¤ì´ë‚˜ ë¹„ë‚œë§Œ í•˜ì§€ ë§ˆ.
         - 'ë¶„ì„' ì£¼ì œë¼ë©´ ì§„ì§€í•˜ê²Œ ìŠ¤íƒ¯ì´ë‚˜ ì•„ì´í…œ íŠ¸ë¦¬ë¥¼ ë…¼í•´.
         - 'ì§ˆë¬¸' ì£¼ì œë¼ë©´ ë‰´ë¹„ì²˜ëŸ¼ ëª¨ë¥´ëŠ” ê±¸ ë¬¼ì–´ë´.
         - 'ìœ ë¨¸' ì£¼ì œë¼ë©´ ê²Œì„ ìƒí™©ì„ ë¹„ê¼¬ê±°ë‚˜ ë“œë¦½ì„ ì³.
      3. ê¸¸ì´: ì œëª©ì€ ì„íŒ©íŠ¸ ìˆê²Œ í•œ ì¤„, ë‚´ìš©ì€ 2~3ë¬¸ì¥ ì •ë„ë¡œ ì§§ê³  êµµê²Œ.
      
      [ì¶œë ¥ í˜•ì‹ (JSON)]:
      ë°˜ë“œì‹œ ë§ˆí¬ë‹¤ìš´ ì—†ì´ ìˆœìˆ˜ JSONë§Œ ì¶œë ¥í•´.
      {
        "title": "ê²Œì‹œê¸€ ì œëª©",
        "content": "ê²Œì‹œê¸€ ë³¸ë¬¸ ë‚´ìš©"
      }
    `;

    const response = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
    });

    const data = await response.json();
    if (data.error) throw new Error(data.error.message);

    const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
    if (!text) return null;
    
    const jsonStr = text.replace(/```json|```/g, "").trim();
    return JSON.parse(jsonStr);

  } catch (e) {
    console.error("Gemini Post Error:", e);
    return null;
  }
}

export async function fetchGeminiComment(postContent: string): Promise<string | null> {
  if (!API_KEY) return null;

  try {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_VERSION}:generateContent?key=${API_KEY}`;
    
    const prompt = `
      AOS ê²Œì„ ì»¤ë®¤ë‹ˆí‹° ê¸€ì— ë‹¬ë¦´ ëŒ“ê¸€ í•˜ë‚˜ë¥¼ ì‘ì„±í•´.
      ê¸€ ë‚´ìš©: "${postContent}"
      
      ì§€ì¹¨:
      - ê¸€ ë‚´ìš©ì— ë™ì¡°í•˜ê±°ë‚˜, ë°˜ë°•í•˜ê±°ë‚˜, ë¹„ê¼¬ëŠ” ë“± ë¦¬ì–¼í•œ ë°˜ì‘ì„ ë³´ì—¬ì¤˜.
      - "ã…‹ã…‹ã…‹ã…‹" ê°™ì€ ì´ˆì„±ì²´ë‚˜ ì€ì–´ë¥¼ ì ì ˆíˆ ì„ì–´.
      - ì„¤ëª… ì—†ì´ ëŒ“ê¸€ ë‚´ìš© í…ìŠ¤íŠ¸ë§Œ ì¶œë ¥í•´.
    `;

    const response = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
    });

    const data = await response.json();
    return data.candidates?.[0]?.content?.parts?.[0]?.text.trim();
  } catch (e) {
    return null;
  }
}


==========================================
FILE PATH: src/utils/GlobalErrorBoundary.tsx
==========================================
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { CrashScreen } from '../components/common/CrashScreen';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
  resetKey: number; // ì»´í¬ë„ŒíŠ¸ ê°•ì œ ë¦¬ë§ˆìš´íŠ¸ìš© í‚¤
}

export class GlobalErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null, resetKey: 0 };
  }

  static getDerivedStateFromError(error: Error): State {
    // DOM ê´€ë ¨ ì—ëŸ¬ë‚˜ ChunkLoad ì—ëŸ¬ëŠ” ì¹˜ëª…ì ì´ì§€ ì•Šë‹¤ê³  íŒë‹¨, ìë™ ë³µêµ¬ ì‹œë„
    const msg = error.message || "";
    if (
      msg.includes("removeChild") || 
      msg.includes("insertBefore") || 
      msg.includes("NotFound") || 
      msg.includes("Loading chunk")
    ) {
      // ì—ëŸ¬ ìƒíƒœë¥¼ trueë¡œ ë§Œë“¤ì§€ ì•Šê³ , ê·¸ëƒ¥ ë„˜ì–´ê°€ê±°ë‚˜
      // ë¦¬ë Œë”ë§ì„ ìœ ë„í•˜ê¸° ìœ„í•´ null ë°˜í™˜ (í•˜ì§€ë§Œ ë¼ì´í”„ì‚¬ì´í´ìƒ state ë°˜í™˜ í•„ìš”)
      return { hasError: true, error, resetKey: 0 };
    }
    return { hasError: true, error, resetKey: 0 };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    const msg = error.message || "";
    
    // [í•µì‹¬] DOM ë…¸ë“œ ë¶ˆì¼ì¹˜ ì—ëŸ¬ëŠ” ë¬´ì‹œí•˜ê³  ìë™ ë³µêµ¬
    if (
      msg.includes("removeChild") || 
      msg.includes("insertBefore") || 
      msg.includes("node to be removed")
    ) {
      console.warn("[Auto-Recovery] DOM Mismatch detected. Remounting app...");
      this.handleRecover();
      return;
    }
    
    console.error("React Error Boundary Caught:", error, errorInfo);
  }

  handleRecover = () => {
    // ì—ëŸ¬ ìƒíƒœ í•´ì œ ë° í‚¤ ë³€ê²½ìœ¼ë¡œ ë¦¬ë§ˆìš´íŠ¸ ìœ ë„
    setTimeout(() => {
      this.setState(prev => ({ hasError: false, error: null, resetKey: prev.resetKey + 1 }));
    }, 50);
  };

  resetErrorBoundary = () => {
    this.setState({ hasError: false, error: null });
    window.location.reload();
  };

  render() {
    if (this.state.hasError) {
      const msg = this.state.error?.message || "";
      
      // DOM ì—ëŸ¬ì¸ ê²½ìš° UIë¥¼ ê·¸ë¦¬ì§€ ì•Šê³  ë³µêµ¬ë¥¼ ê¸°ë‹¤ë¦¼ (ë¹ˆ í™”ë©´ 0.05ì´ˆ)
      if (
        msg.includes("removeChild") || 
        msg.includes("insertBefore") || 
        msg.includes("node to be removed")
      ) {
        return <div style={{ background:'#0f1115', width:'100vw', height:'100vh' }} />;
      }

      // ê·¸ ì™¸ ì§„ì§œ ì¹˜ëª…ì ì¸ ì—ëŸ¬ë§Œ ë¹¨ê°„ í™”ë©´ í‘œì‹œ
      return <CrashScreen error={this.state.error} resetErrorBoundary={this.resetErrorBoundary} />;
    }

    return (
      <React.Fragment key={this.state.resetKey}>
        {this.props.children}
      </React.Fragment>
    );
  }
}



==========================================
FILE PATH: src/utils/IDBStorage.ts
==========================================
// ==========================================
// FILE PATH: /src/utils/IDBStorage.ts
// ==========================================

const DB_NAME = 'GodsWar_DB_V1';
const STORE_NAME = 'SaveData';

export const IDBStorage = {
  // DB ì—´ê¸° (ì—†ìœ¼ë©´ ìƒì„±)
  openDB: (): Promise<IDBDatabase> => {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, 1);

      request.onupgradeneeded = (event: any) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          db.createObjectStore(STORE_NAME);
        }
      };

      request.onsuccess = (event: any) => resolve(event.target.result);
      request.onerror = (event: any) => reject(event.target.error);
    });
  },

  // ë°ì´í„° ì €ì¥ (Key-Value)
  setItem: async (key: string, value: any): Promise<void> => {
    const db = await IDBStorage.openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      const req = store.put(value, key);

      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  },

  // ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
  getItem: async (key: string): Promise<any> => {
    const db = await IDBStorage.openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readonly');
      const store = tx.objectStore(STORE_NAME);
      const req = store.get(key);

      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  },

  // ë°ì´í„° ì‚­ì œ
  removeItem: async (key: string): Promise<void> => {
    const db = await IDBStorage.openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      const req = store.delete(key);

      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }
};



==========================================
FILE PATH: src/utils/ImageLoader.ts
==========================================
// ==========================================
// FILE PATH: src/utils/ImageLoader.ts
// ==========================================
import { INITIAL_CUSTOM_IMAGES } from '../data/initialImages';

export const preloadGameImages = async (
  onProgress: (percent: number) => void
): Promise<void> => {
  // 1. ì‚¬ìš©ì ëŒ€ê¸° ì‹œê°„ 0ì´ˆ (ì¦‰ì‹œ ì‹œì‘)
  onProgress(100);

  // 2. ë°±ê·¸ë¼ìš´ë“œ ìºì‹± (ì†ë„ ì¡°ì ˆ)
  const imageUrls = Array.from(new Set(Object.values(INITIAL_CUSTOM_IMAGES))).filter(url => !!url);
  if (imageUrls.length === 0) return;

  let index = 0;
  
  const loadNext = () => {
    if (index >= imageUrls.length) return;

    // [í•µì‹¬] ë™ì‹œì— ì—¬ëŸ¬ ê°œë¥¼ ìš”ì²­í•˜ì§€ ì•Šê³ , í•˜ë‚˜ì”© ìˆœì°¨ì ìœ¼ë¡œ ìš”ì²­í•©ë‹ˆë‹¤.
    const img = new Image();
    img.src = imageUrls[index];
    
    index++;
    
    // [ìˆ˜ì •] 50ms -> 200msë¡œ í…€ì„ ëŠ˜ë ¤ì„œ
    // í™”ë©´ì— ìˆëŠ” 'ì§„ì§œ í•„ìš”í•œ ì´ë¯¸ì§€'ê°€ ë‹¤ìš´ë¡œë“œë  ëŒ€ì—­í­ì„ í™•ë³´í•´ì¤ë‹ˆë‹¤.
    setTimeout(loadNext, 200);
  };

  // ê²Œì„ ì‹œì‘ í›„ 2ì´ˆ ë’¤ë¶€í„° ì²œì²œíˆ ë°›ê¸° ì‹œì‘
  setTimeout(loadNext, 2000);
};



==========================================
FILE PATH: src/utils/nameGenerator.ts
==========================================
// src/utils/nameGenerator.ts

// 1. [í•œê¸€] í˜•ìš©ì‚¬ (ìˆ˜ì‹ì–´)
const KR_PREFIXES = [
  "ë§›ìˆëŠ”", "ì¦ê±°ìš´", "ìš°ìš¸í•œ", "ê°•ë ¥í•œ", "ë°°ê³ í”ˆ", "ì§€ë‚˜ê°€ë˜", "ì „ì„¤ì˜", "ìˆ˜ìƒí•œ", 
  "ê·€ì—¬ìš´", "ì‚¬ì•…í•œ", "íˆ¬ëª…í•œ", "ë„ë§ì¹œ", "ì ìëŠ”", "í™”ë‚œ", "í–‰ë³µí•œ", "ê°€ë‚œí•œ",
  "ë¶€ì", "ì²œì¬", "ë°”ë³´", "ë¯¸ì¹œ", "ì•¼ìƒì˜", "ì§‘ë‚˜ê°„", "ëŒì•„ì˜¨", "ë§ˆì§€ë§‰",
  "íƒ‘ì‹ ë³‘ì", "ì •ê¸€ì°¨ì´", "ë¯¸ë“œì˜¤í”ˆ", "ì„œí¿ìœ ì €", "ì›ë”œì™•", "ì¥ì¸", "ê³ ìˆ˜", "ì´ˆë³´",
  "í•‘í¬", "ë¸”ë™", "í™©ê¸ˆ", "ë¯¼íŠ¸ì´ˆì½”", "í•˜ì™€ì´ì•ˆ", "ë¶ˆíƒ€ëŠ”", "ì–¼ì–´ë¶™ì€", "ì‹ ì†í•œ",
  "ì¹˜ëª…ì ì¸", "ì—„ë§ˆëª°ë˜", "í•™êµì§¸ê³ ", "ë°¤ìƒ˜í•˜ëŠ”", "ë¼ë©´ë¨¹ëŠ”", "ì¹˜í‚¨ë¨¹ëŠ”", "ë‹¤ì´ì–´íŠ¸",
  "ë¬´ì ì˜", "íŒ¨ë°°ì˜", "ìŠ¹ë¦¬ì˜", "ê¸°ì ì˜", "ì¹¨ë¬µì˜", "ì˜ê´‘ì˜", "ì‹¬ì—°ì˜", "ê³µí—ˆì˜",
  "ì „ê´‘ì„í™”", "ë¹›ì˜", "ì–´ë‘ ì˜", "í­í’ì˜", "ëŒ€ì§€ì˜", "ê°•ì² ì˜", "ì‹ ì„±í•œ", "íƒ€ë½í•œ"
];

// 2. [í•œê¸€] ëª…ì‚¬ (ë³¸ì²´)
const KR_SUFFIXES = [
  "ë‹¤ëŒì¥", "í˜¸ë‘ì´", "ì‚¬ì", "ê³ ì–‘ì´", "ê°•ì•„ì§€", "í­ê·„", "ìŠ¬ë¼ì„", "ë“œë˜ê³¤",
  "ë–¡ë³¶ì´", "ì¹˜í‚¨", "í”¼ì", "í–„ë²„ê±°", "êµ­ë°¥", "ê¹€ì¹˜ì°Œê°œ", "ë¼ë©´", "ì½œë¼",
  "ê¸°ì‚¬", "ë§ˆë²•ì‚¬", "ì•”ì‚´ì", "ê¶ìˆ˜", "ì „ì‚¬", "ì‚¬ì œ", "ë„ì ", "ì„±ê¸°ì‚¬",
  "ì•¼ìŠ¤ì˜¤", "í‹°ëª¨", "ë¦¬ì‹ ", "ë² ì¸", "ì œë“œ", "ì´ì¦ˆë¦¬ì–¼", "ëŸ­ìŠ¤", "ì•„ë¦¬",
  "ì£¼ë¨¹", "ë°œì°¨ê¸°", "ê²€", "ë°©íŒ¨", "ì§€íŒ¡ì´", "í™œ", "ë„ë¼", "ë§ì¹˜",
  "ì»´í“¨í„°", "í‚¤ë³´ë“œ", "ë§ˆìš°ìŠ¤", "ëª¨ë‹ˆí„°", "ì™€ì´íŒŒì´", "ë°ì´í„°", "ë°°í„°ë¦¬",
  "í•™ìƒ", "ì•„ì €ì”¨", "í˜•", "ëˆ„ë‚˜", "ë™ìƒ", "ì‚¬ì¥ë‹˜", "ì•Œë°”ìƒ", "ë°±ìˆ˜",
  "ìœ ì €", "í”Œë ˆì´ì–´", "ì†Œí™˜ì‚¬", "ì±”í”¼ì–¸", "ë¯¸ë‹ˆì–¸", "ì •ê¸€ëŸ¬", "ë¼ì´ë„ˆ"
];

// 3. [ì˜ì–´] ë‹¨ì–´
const EN_WORDS = [
  "Shadow", "Light", "Dark", "Fire", "Ice", "Wind", "Storm", "Thunder",
  "Killer", "Slayer", "Hunter", "Sniper", "Assassin", "Knight", "Warrior",
  "God", "King", "Queen", "Prince", "Princess", "Lord", "Master", "Boss",
  "Faker", "Chovy", "ShowMaker", "Ruler", "Deft", "Viper", "Zeus", "Keria",
  "Alpha", "Beta", "Omega", "Zero", "One", "Infinite", "Eternal", "Final",
  "Crazy", "Mad", "Super", "Ultra", "Hyper", "Mega", "Giga", "Tera",
  "Ghost", "Phantom", "Spirit", "Soul", "Dragon", "Tiger", "Lion", "Wolf"
];

const CLAN_TAGS = ["T1", "GEN", "DK", "KT", "HLE", "DRX", "NS", "BRO", "LSB", "KDF", "SKT", "DWG", "GRF"];
const pick = (arr: string[]) => arr[Math.floor(Math.random() * arr.length)];
const chance = (percent: number) => Math.random() < (percent / 100);

export function generateUserName(seedId: number): string {
  const rand = Math.random();

  // [Fix] ëª¨ë“  íŒ¨í„´ì— ëœë¤ ìˆ«ì(2~4ìë¦¬)ë¥¼ ê°•ì œë¡œ ë¶™ì…ë‹ˆë‹¤.
  // 1000 ~ 9999 ì‚¬ì´ì˜ ë‚œìˆ˜ ìƒì„±
  const num = Math.floor(100 + Math.random() * 9900); 

  // íŒ¨í„´ 1: [í•œê¸€] í˜•ìš©ì‚¬ + ëª…ì‚¬ (50%)
  if (rand < 0.5) {
    const prefix = pick(KR_PREFIXES);
    const suffix = pick(KR_SUFFIXES);
    // ì˜ˆ: ê°€ë‚œí•œê²€392, ì¹¨ë¬µì˜ë–¡ë³¶ì´1024
    return `${prefix}${suffix}${num}`;
  }

  // íŒ¨í„´ 2: [ì˜ì–´] (30%)
  else if (rand < 0.8) {
    // í´ëœ íƒœê·¸í˜•: SKT Faker 01
    if (chance(30)) {
      return `${pick(CLAN_TAGS)} ${pick(EN_WORDS)} ${Math.floor(Math.random() * 99)}`;
    }

    // ì˜ë‹¨ì–´ ì¡°í•©í˜•: ShadowKiller9999
    if (chance(50)) {
      return `${pick(EN_WORDS)}${pick(EN_WORDS)}${num}`;
    } else {
      // ë‹¨ì¼ ë‹¨ì–´í˜•: Zeus1024
      return `${pick(EN_WORDS)}${num}`;
    }
  }

  // íŒ¨í„´ 3: [ì»¨ì…‰] ë¦¬ì–¼í•œ ë¬¸ì¥í˜• (10%)
  else if (rand < 0.9) {
    const sentences = [
      "ë˜ì§€ë©´ë°”ë¡œë‚˜ê°", "í•œíƒ€ë§Œí•¨", "ì±„íŒ…ì°¨ë‹¨í•¨", "ì¦ê²œìœ ì €", "ë¹¡ê²œëŸ¬",
      "ì—„ë§ˆê°€ë°¥ë¨¹ìœ¼ë˜", "ë‚´ê¿ˆì€ì±Œë¦°ì €", "ë¸Œë¡ ì¦ˆíƒˆì¶œê¸°", "ë²„ìŠ¤ì ìš”", "ì„œí¿ì°¨ì´",
      "ë¯¸ë“œë‹¬ë ¤", "ì •ê¸€íƒ“ì•ˆí•¨", "ì˜¤ë¹ ë‹¬ë ¤", "ëˆ„ë‚˜ë‚˜ì£½ì–´", "í˜•ë¯¿ì–´",
      "í‰ì 1ì ëŒ€", "ìŠ¹ë¥ 9í• ", "ë¶€ìºì…ë‹ˆë‹¤", "í˜„ì§€ì¸ì…ë‹ˆë‹¤"
    ];
    // ì˜ˆ: ì—„ë§ˆê°€ë°¥ë¨¹ìœ¼ë˜512
    return `${pick(sentences)}${num}`;
  }

  // íŒ¨í„´ 4: ë§‰ì¹œ ì•„ì´ë”” (10%)
  else {
    const keys = ["qwer", "asdf", "zxcv", "user", "player", "guest"];
    return `${pick(keys)}${Math.floor(Math.random() * 99999)}`;
  }
}


==========================================
FILE PATH: src/utils/OpenAIService.ts
==========================================
// src/utils/OpenAIService.ts

// 1. ì—¬ê¸°ì— OpenAI API í‚¤ë¥¼ ë„£ìœ¼ë©´ ì§„ì§œ AIê°€ ì‘ë™í•©ë‹ˆë‹¤. (ì—†ìœ¼ë©´ ê°€ì§œ AI ì‘ë™)
const API_KEY = ""; // ì˜ˆ: "sk-proj-..."

export async function fetchAIPost(context: string): Promise<{title: string, content: string} | null> {
  if (!API_KEY) return null; // í‚¤ ì—†ìœ¼ë©´ null ë°˜í™˜ -> í…œí”Œë¦¿ ì—”ì§„ ì‚¬ìš©

  try {
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${API_KEY}`
      },
      body: JSON.stringify({
        model: "gpt-3.5-turbo", // or gpt-4
        messages: [
          { role: "system", content: "ë„ˆëŠ” 'ì‹ ë“¤ì˜ ì „ìŸ'ì´ë¼ëŠ” AOS ê²Œì„ì˜ ì•…ì§ˆ ìœ ì €ì•¼. ë””ì‹œì¸ì‚¬ì´ë“œë‚˜ í¨ì½” ë§íˆ¬ë¡œ ì§§ê³  ê°„ê²°í•˜ê²Œ ê¸€ì„ ì¨. ë°˜ë§ì„ ì‚¬ìš©í•´." },
          { role: "user", content: `ë‹¤ìŒ ìƒí™©ì„ ë³´ê³  ê²Œì‹œê¸€ ì œëª©ê³¼ ë‚´ìš©ì„ JSON í˜•ì‹ìœ¼ë¡œ ë§Œë“¤ì–´ì¤˜: ${context}` }
        ],
        temperature: 0.8,
      })
    });

    const data = await response.json();
    const content = data.choices[0].message.content;
    // JSON íŒŒì‹± ì‹œë„ (AIê°€ í…ìŠ¤íŠ¸ë¡œ ì¤„ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ)
    try {
      return JSON.parse(content);
    } catch {
      return { title: "AI ê¸€ì‘ì„± ì˜¤ë¥˜", content: content };
    }
  } catch (e) {
    console.error("AI API Error:", e);
    return null;
  }
}

export async function fetchAIComment(postContent: string): Promise<string | null> {
  if (!API_KEY) return null;

  try {
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${API_KEY}`
      },
      body: JSON.stringify({
        model: "gpt-3.5-turbo",
        messages: [
          { role: "system", content: "ë„ˆëŠ” AOS ê²Œì„ ì»¤ë®¤ë‹ˆí‹° ìœ ì €ì•¼. ê±°ì¹ ê³  ì§§ì€ ë§íˆ¬ë¡œ ëŒ“ê¸€ì„ ë‹¬ì•„." },
          { role: "user", content: `ë‹¤ìŒ ê¸€ì— ë‹¬ë¦´ ëŒ“ê¸€ í•˜ë‚˜ë§Œ ì¨ì¤˜: "${postContent}"` }
        ],
        max_tokens: 50
      })
    });
    const data = await response.json();
    return data.choices[0].message.content;
  } catch (e) {
    return null;
  }
}


==========================================
FILE PATH: src/utils/ResourceDownloader.ts
==========================================
// ==========================================
// FILE PATH: /src/utils/ResourceDownloader.ts
// ==========================================
import { INITIAL_CUSTOM_IMAGES } from '../data/initialImages';

const CACHE_NAME = 'gods-war-assets-v1';

export const downloadAllResources = async (
  onProgress: (current: number, total: number) => void
): Promise<boolean> => {
  // 1. ë‹¤ìš´ë¡œë“œí•  ì´ë¯¸ì§€ ëª©ë¡ í™•ë³´
  const urls = Array.from(new Set(Object.values(INITIAL_CUSTOM_IMAGES))).filter(url => !!url);
  const total = urls.length;
  let count = 0;

  try {
    // 2. ë¸Œë¼ìš°ì € ìºì‹œ ì €ì¥ì†Œ ì—´ê¸°
    const cache = await caches.open(CACHE_NAME);

    // 3. ë³‘ë ¬ ì²˜ë¦¬ ëŒ€ì‹  ì•ˆì •ì„±ì„ ìœ„í•´ 5ê°œì”© ëŠì–´ì„œ ë‹¤ìš´ë¡œë“œ (ë°°ì¹˜ ì²˜ë¦¬)
    const BATCH_SIZE = 5;
    
    for (let i = 0; i < total; i += BATCH_SIZE) {
      const batch = urls.slice(i, i + BATCH_SIZE);
      
      await Promise.all(batch.map(async (url) => {
        try {
          // ì´ë¯¸ ìºì‹œì— ìˆëŠ”ì§€ í™•ì¸
          const match = await cache.match(url);
          if (!match) {
            // ì—†ìœ¼ë©´ ë„¤íŠ¸ì›Œí¬ ìš”ì²­í•´ì„œ ì €ì¥
            await cache.add(url);
          }
        } catch (e) {
          console.warn(`ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨ (${url}):`, e);
        } finally {
          count++;
          onProgress(count, total);
        }
      }));
    }
    
    return true;
  } catch (e) {
    console.error("ë¦¬ì†ŒìŠ¤ ë‹¤ìš´ë¡œë“œ ì‹œìŠ¤í…œ ì˜¤ë¥˜:", e);
    alert("ì´ ë¸Œë¼ìš°ì €ëŠ” ë¦¬ì†ŒìŠ¤ ì €ì¥ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
    return false;
  }
};

export const checkCachedStatus = async (): Promise<number> => {
  try {
    const cache = await caches.open(CACHE_NAME);
    const keys = await cache.keys();
    return keys.length;
  } catch {
    return 0;
  }
};



